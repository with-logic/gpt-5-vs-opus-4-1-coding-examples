<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Asteroid Run — GPT-5.1</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Space Grotesk", "Inter", system-ui, sans-serif;
        background: radial-gradient(circle at 20% 20%, #1d2753, #050509 70%);
        color: #f8f8ff;
        min-height: 100vh;
        overflow: hidden;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
        filter: drop-shadow(0 0 30px rgba(103, 204, 255, 0.25));
      }
      .hud {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 2rem;
        font-size: 1rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        z-index: 10;
      }
      .hud span strong {
        color: #7ff9ff;
      }
      .instructions {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.8);
        letter-spacing: 0.04em;
      }
      .modal {
        position: fixed;
        inset: 0;
        background: rgba(3, 3, 8, 0.86);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1.5rem;
        text-align: center;
        z-index: 20;
      }
      .modal.hidden {
        display: none;
      }
      .modal h1 {
        margin: 0;
        font-size: clamp(2rem, 4vw, 3rem);
        letter-spacing: 0.2em;
      }
      .modal p {
        max-width: 32rem;
        line-height: 1.5;
        color: rgba(255, 255, 255, 0.9);
      }
      button {
        background: linear-gradient(120deg, #4dc4ff, #c471f5);
        border: none;
        padding: 0.9rem 2.4rem;
        border-radius: 999px;
        color: #050509;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        letter-spacing: 0.1em;
      }
      button:hover {
        filter: brightness(1.08);
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div class="hud">
      <span>Score: <strong data-score>0</strong></span>
      <span>Shields: <strong data-shield>100</strong></span>
      <span>Wave: <strong data-wave>1</strong></span>
    </div>
    <div class="instructions">
      <div>W / ↑ — thrust · A/D or ←/→ — rotate · Space — fire · Shift — boost</div>
      <div>Survive incoming asteroid belts while dogfighting rogue AI interceptors.</div>
    </div>
    <section class="modal" id="modal">
      <h1>ASTEROID RUN</h1>
      <p>
        Pilot the Aurora interceptor through drifting asteroid fields and take down raider drones. Build combos by
        chaining asteroid pops and enemy kills without taking damage.
      </p>
      <button id="start-btn">Engage Thrusters</button>
      <p id="final-readout"></p>
    </section>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const hudScore = document.querySelector("[data-score]");
      const hudShield = document.querySelector("[data-shield]");
      const hudWave = document.querySelector("[data-wave]");
      const modal = document.getElementById("modal");
      const startBtn = document.getElementById("start-btn");
      const finalReadout = document.getElementById("final-readout");

      const keys = new Set();
      let animationId = null;
      let stars = [];
      let state = null;

      class Vector {
        constructor(x = 0, y = 0) {
          this.x = x;
          this.y = y;
        }
        add(v) {
          return new Vector(this.x + v.x, this.y + v.y);
        }
        subtract(v) {
          return new Vector(this.x - v.x, this.y - v.y);
        }
        scale(s) {
          return new Vector(this.x * s, this.y * s);
        }
        magnitude() {
          return Math.hypot(this.x, this.y);
        }
        normalized() {
          const mag = this.magnitude() || 1;
          return new Vector(this.x / mag, this.y / mag);
        }
      }

      class Player {
        constructor() {
          this.position = centerPoint();
          this.velocity = new Vector();
          this.angle = -Math.PI / 2;
          this.radius = 18;
          this.shield = 100;
          this.maxSpeed = 6;
          this.cooldown = 0;
          this.combo = 0;
        }
        update(dt) {
          if (keys.has("ArrowLeft") || keys.has("KeyA")) this.angle -= 0.06 * dt;
          if (keys.has("ArrowRight") || keys.has("KeyD")) this.angle += 0.06 * dt;
          const thrusting = keys.has("ArrowUp") || keys.has("KeyW");
          const braking = keys.has("ArrowDown") || keys.has("KeyS");
          const boosting = keys.has("ShiftLeft") || keys.has("ShiftRight");
          if (thrusting) {
            const thrust = new Vector(Math.cos(this.angle), Math.sin(this.angle)).scale((boosting ? 0.35 : 0.2) * dt);
            this.velocity = this.velocity.add(thrust);
          }
          if (braking) {
            this.velocity = this.velocity.scale(0.96);
          }
          const speed = this.velocity.magnitude();
          if (speed > this.maxSpeed) {
            this.velocity = this.velocity.normalized().scale(this.maxSpeed);
          }
          this.velocity = this.velocity.scale(0.995);
          this.position = wrapPosition(this.position.add(this.velocity));
          this.cooldown = Math.max(0, this.cooldown - dt * 16);
        }
        canShoot() {
          return this.cooldown === 0;
        }
        shoot() {
          if (!this.canShoot()) return;
          const dir = new Vector(Math.cos(this.angle), Math.sin(this.angle));
          const velocity = dir.scale(10).add(this.velocity);
          state.projectiles.push(new Projectile(this.position.add(dir.scale(this.radius + 4)), velocity, 12, "ally"));
          this.cooldown = 6;
        }
        draw() {
          ctx.save();
          ctx.translate(this.position.x, this.position.y);
          ctx.rotate(this.angle);
          ctx.strokeStyle = "#7ff9ff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.radius, 0);
          ctx.lineTo(-this.radius * 0.6, -this.radius * 0.7);
          ctx.lineTo(-this.radius * 0.2, 0);
          ctx.lineTo(-this.radius * 0.6, this.radius * 0.7);
          ctx.closePath();
          ctx.stroke();
          if (keys.has("ArrowUp") || keys.has("KeyW")) {
            ctx.strokeStyle = "#ff8f5c";
            ctx.beginPath();
            ctx.moveTo(-this.radius * 0.4, -6);
            ctx.lineTo(-this.radius - Math.random() * 6, 0);
            ctx.lineTo(-this.radius * 0.4, 6);
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      class Projectile {
        constructor(position, velocity, life, faction) {
          this.position = position;
          this.velocity = velocity;
          this.life = life;
          this.radius = 3;
          this.faction = faction;
        }
        update(dt) {
          this.position = wrapPosition(this.position.add(this.velocity.scale(dt * 0.6)));
          this.life -= dt;
          return this.life > 0;
        }
        draw() {
          ctx.fillStyle = this.faction === "ally" ? "#f8ff8f" : "#ff4b91";
          ctx.beginPath();
          ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      class Asteroid {
        constructor(position, velocity, size) {
          this.position = position;
          this.velocity = velocity;
          this.size = size;
          this.radius = size * 14;
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 0.01;
          this.shape = Array.from({ length: 10 }, () => 0.7 + Math.random() * 0.4);
        }
        update(dt) {
          this.position = wrapPosition(this.position.add(this.velocity.scale(dt * 0.4)));
          this.rotation += this.rotationSpeed * dt;
        }
        draw() {
          ctx.save();
          ctx.translate(this.position.x, this.position.y);
          ctx.rotate(this.rotation);
          ctx.strokeStyle = "#b0b4c4";
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < this.shape.length; i++) {
            const angle = (i / this.shape.length) * Math.PI * 2;
            const r = this.radius * this.shape[i];
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        split() {
          if (this.size <= 1) return [];
          return [1, 2].map(() => new Asteroid(this.position.add(randomVector(10)), randomVector(2), this.size - 1));
        }
      }

      class Enemy {
        constructor(position) {
          this.position = position;
          this.velocity = randomVector(1);
          this.radius = 16;
          this.health = 40;
          this.cooldown = 60;
        }
        update(dt) {
          const toPlayer = state.player.position.subtract(this.position);
          const desired = toPlayer.normalized().scale(0.8);
          this.velocity = this.velocity.add(desired).scale(0.96);
          this.position = wrapPosition(this.position.add(this.velocity.scale(dt)));
          this.cooldown -= dt;
          if (this.cooldown <= 0 && toPlayer.magnitude() < 320) {
            const dir = toPlayer.normalized();
            state.enemyProjectiles.push(new Projectile(this.position.add(dir.scale(this.radius)), dir.scale(6), 90, "enemy"));
            this.cooldown = 60 + Math.random() * 30;
          }
        }
        draw() {
          ctx.save();
          ctx.translate(this.position.x, this.position.y);
          ctx.rotate(Math.atan2(this.velocity.y, this.velocity.x));
          ctx.strokeStyle = "#ff4b91";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.radius, 0);
          ctx.lineTo(-this.radius * 0.6, -this.radius * 0.6);
          ctx.lineTo(-this.radius * 0.8, 0);
          ctx.lineTo(-this.radius * 0.6, this.radius * 0.6);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
      }

      class Particle {
        constructor(position, velocity, life, color) {
          this.position = position;
          this.velocity = velocity;
          this.life = life;
          this.color = color;
          this.maxLife = life;
        }
        update(dt) {
          this.position = this.position.add(this.velocity.scale(dt));
          this.life -= dt;
          return this.life > 0;
        }
        draw() {
          ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.position.x, this.position.y, 2 + Math.random() * 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function wrapPosition(pos) {
        const x = (pos.x + canvas.width) % canvas.width;
        const y = (pos.y + canvas.height) % canvas.height;
        return new Vector(x, y);
      }

      function randomVector(scale = 1) {
        const angle = Math.random() * Math.PI * 2;
        return new Vector(Math.cos(angle) * scale, Math.sin(angle) * scale);
      }

      function centerPoint() {
        return new Vector(canvas.width / 2, canvas.height / 2);
      }

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        stars = Array.from({ length: 140 }, () => ({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          speed: 0.2 + Math.random() * 0.8,
          size: Math.random() * 1.5,
        }));
      }

      function spawnWave() {
        const asteroidCount = 4 + state.wave;
        const enemyCount = Math.min(3, Math.floor(state.wave / 2) + 1);
        for (let i = 0; i < asteroidCount; i++) {
          const position = new Vector(Math.random() * canvas.width, Math.random() * canvas.height);
          if (position.subtract(state.player.position).magnitude() < 160) {
            i--;
            continue;
          }
          const velocity = randomVector(1.5 + Math.random() * 1.5);
          state.asteroids.push(new Asteroid(position, velocity, 2 + Math.floor(Math.random() * 2)));
        }
        for (let i = 0; i < enemyCount; i++) {
          const position = new Vector(Math.random() * canvas.width, Math.random() * canvas.height);
          if (position.subtract(state.player.position).magnitude() < 200) {
            i--;
            continue;
          }
          state.enemies.push(new Enemy(position));
        }
      }

      function explosion(position, color, sparks = 18) {
        for (let i = 0; i < sparks; i++) {
          state.particles.push(new Particle(position, randomVector(2 + Math.random() * 3), 30 + Math.random() * 20, color));
        }
      }

      function update(dt) {
        state.player.update(dt);
        if (keys.has("Space")) state.player.shoot();
        state.projectiles = state.projectiles.filter((proj) => proj.update(dt));
        state.enemyProjectiles = state.enemyProjectiles.filter((proj) => proj.update(dt));
        state.asteroids.forEach((asteroid) => asteroid.update(dt));
        state.enemies.forEach((enemy) => enemy.update(dt));
        state.particles = state.particles.filter((p) => p.update(dt));
        handleCollisions();
        if (state.asteroids.length === 0 && state.enemies.length === 0) {
          state.wave += 1;
          spawnWave();
        }
        hudScore.textContent = state.score.toString().padStart(5, "0");
        hudShield.textContent = Math.max(0, Math.round(state.player.shield)).toString();
        hudWave.textContent = state.wave;
      }

      function awardScore(base) {
        const multiplier = 1 + Math.min(0.75, state.player.combo * 0.12);
        state.score += Math.round(base * multiplier);
      }

      function handleCollisions() {
        for (let i = state.projectiles.length - 1; i >= 0; i--) {
          const proj = state.projectiles[i];
          if (proj.faction !== "ally") continue;
          let consumed = false;
          for (let j = state.asteroids.length - 1; j >= 0; j--) {
            const asteroid = state.asteroids[j];
            if (distance(proj.position, asteroid.position) < proj.radius + asteroid.radius) {
              state.projectiles.splice(i, 1);
              state.asteroids.splice(j, 1);
              state.player.combo += 1;
              awardScore(18);
              explosion(asteroid.position, "#f4f1de");
              state.asteroids.push(...asteroid.split());
              consumed = true;
              break;
            }
          }
          if (consumed) continue;
          for (let j = state.enemies.length - 1; j >= 0; j--) {
            const enemy = state.enemies[j];
            if (distance(proj.position, enemy.position) < proj.radius + enemy.radius) {
              enemy.health -= 20;
              state.projectiles.splice(i, 1);
              explosion(enemy.position, "#ff4b91", 14);
              if (enemy.health <= 0) {
                state.enemies.splice(j, 1);
                state.player.combo += 1;
                awardScore(150);
              }
              consumed = true;
              break;
            }
          }
        }

        for (let i = state.enemyProjectiles.length - 1; i >= 0; i--) {
          const proj = state.enemyProjectiles[i];
          if (distance(proj.position, state.player.position) < proj.radius + state.player.radius) {
            state.enemyProjectiles.splice(i, 1);
            state.player.shield -= 12;
            state.player.combo = 0;
            explosion(state.player.position, "#7ff9ff", 10);
          }
        }

        for (let i = state.asteroids.length - 1; i >= 0; i--) {
          const asteroid = state.asteroids[i];
          if (distance(asteroid.position, state.player.position) < asteroid.radius + state.player.radius - 6) {
            state.player.shield -= 20;
            state.player.combo = 0;
            explosion(state.player.position, "#7ff9ff", 20);
            state.asteroids.splice(i, 1);
            state.asteroids.push(...asteroid.split());
          }
        }

        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          if (distance(enemy.position, state.player.position) < enemy.radius + state.player.radius - 4) {
            state.player.shield -= 25;
            state.player.combo = 0;
            explosion(state.player.position, "#7ff9ff", 20);
            explosion(enemy.position, "#ff4b91", 20);
            state.enemies.splice(i, 1);
            awardScore(90);
          }
        }

        if (state.player.shield <= 0) {
          endGame();
        }
      }

      function distance(a, b) {
        return a.subtract(b).magnitude();
      }

      function draw() {
        ctx.fillStyle = "rgba(3, 3, 12, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawStars();
        state.particles.forEach((p) => p.draw());
        state.projectiles.forEach((proj) => proj.draw());
        state.enemyProjectiles.forEach((proj) => proj.draw());
        state.asteroids.forEach((asteroid) => asteroid.draw());
        state.enemies.forEach((enemy) => enemy.draw());
        state.player.draw();
      }

      function drawStars() {
        ctx.fillStyle = "white";
        stars.forEach((star) => {
          ctx.globalAlpha = 0.3 + star.speed * 0.5;
          ctx.fillRect(star.x, star.y, star.size, star.size);
          star.y += star.speed * 0.6;
          if (star.y > canvas.height) star.y = 0;
        });
        ctx.globalAlpha = 1;
      }

      function loop(timestamp) {
        if (!state.running) return;
        const dt = Math.min(5, (timestamp - state.lastTime) / 16.67 || 1);
        state.lastTime = timestamp;
        update(dt);
        draw();
        animationId = requestAnimationFrame(loop);
      }

      function startGame() {
        cancelAnimationFrame(animationId);
        state = {
          player: new Player(),
          projectiles: [],
          enemyProjectiles: [],
          asteroids: [],
          enemies: [],
          particles: [],
          score: 0,
          wave: 1,
          running: true,
          lastTime: performance.now(),
        };
        spawnWave();
        modal.classList.add("hidden");
        finalReadout.textContent = "";
        animationId = requestAnimationFrame(loop);
      }

      function endGame() {
        state.running = false;
        cancelAnimationFrame(animationId);
        finalReadout.textContent = `Final score: ${state.score.toString().padStart(5, "0")}`;
        startBtn.textContent = "Play Again";
        modal.classList.remove("hidden");
      }

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") e.preventDefault();
        keys.add(e.code);
      });
      window.addEventListener("keyup", (e) => keys.delete(e.code));
      startBtn.addEventListener("click", startGame);
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      draw();
    </script>
  </body>
</html>
