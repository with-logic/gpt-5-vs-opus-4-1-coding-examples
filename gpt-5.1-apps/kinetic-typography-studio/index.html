<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kinetic Typography Studio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&family=Playfair+Display:wght@400;600&family=Fira+Sans:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        --bg: #05060b;
        --panel: #131722;
        --accent: #6ee7ff;
        --text: #f9fafc;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Space Grotesk", system-ui, sans-serif;
        background: linear-gradient(135deg, #05060b, #101522);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 1.5rem 2rem;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      h1 {
        margin: 0;
        font-size: 1.5rem;
      }
      main {
        display: grid;
        grid-template-columns: 320px 1fr 320px;
        gap: 1rem;
        padding: 1rem;
        flex: 1;
      }
      .panel {
        background: var(--panel);
        border-radius: 1rem;
        padding: 1rem;
        overflow-y: auto;
      }
      .preview {
        background: #000;
        border-radius: 1rem;
        padding: 1rem;
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      canvas {
        width: 100%;
        border-radius: 1rem;
        background: #111;
      }
      label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        display: block;
        margin-bottom: 0.3rem;
      }
      input,
      select,
      textarea,
      button {
        width: 100%;
        border-radius: 0.5rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.04);
        color: inherit;
        font: inherit;
        padding: 0.5rem 0.75rem;
        margin-bottom: 0.75rem;
      }
      textarea {
        min-height: 90px;
        resize: vertical;
      }
      button {
        cursor: pointer;
        background: linear-gradient(120deg, #6ee7ff, #c084fc);
        border: none;
      }
      .timeline {
        margin-top: 1rem;
      }
      .timeline-row {
        display: grid;
        grid-template-columns: 80px 1fr 80px;
        gap: 0.4rem;
        margin-bottom: 0.4rem;
      }
      .timeline-row input {
        margin: 0;
      }
      .shortcuts {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.6);
      }
      .safe-guides {
        position: absolute;
        inset: 1rem;
        border: 1px dashed rgba(255, 255, 255, 0.2);
        pointer-events: none;
      }
      .grid-overlay {
        position: absolute;
        inset: 1rem;
        background-image: linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
        background-size: 40px 40px;
        pointer-events: none;
      }
      @media (max-width: 1200px) {
        main {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div>
        <h1>Kinetic Typography Studio</h1>
        <p>Design, sync, and export animated text.</p>
      </div>
      <div>
        <select id="preset" aria-label="Animation preset">
          <option value="typewriter">Typewriter</option>
          <option value="bounce">Bounce</option>
          <option value="liquid">Liquid</option>
          <option value="glitch">Glitch</option>
          <option value="fadeup">Fade up</option>
          <option value="cascade">Cascade</option>
        </select>
        <button id="applyPreset">Apply preset</button>
      </div>
    </header>
    <main>
      <aside class="panel" aria-label="Text controls">
        <label for="textInput">Text</label>
        <textarea id="textInput">Light dances on every syllable.</textarea>
        <label for="fontSelect">Font</label>
        <select id="fontSelect">
          <option value="Space Grotesk, sans-serif">Space Grotesk</option>
          <option value="'Playfair Display', serif">Playfair Display</option>
          <option value="'Fira Sans', sans-serif">Fira Sans</option>
          <option value="'Courier New', monospace">Monospace</option>
        </select>
        <label>Weight</label>
        <input type="range" id="weight" min="100" max="900" step="100" value="600" />
        <label>Tracking</label>
        <input type="range" id="tracking" min="-50" max="200" value="10" />
        <label>Per-letter stagger (ms)</label>
        <input type="range" id="stagger" min="0" max="200" value="40" />
        <label>Fill color</label>
        <input type="color" id="fillColor" value="#f8fafc" />
        <label>Outline color</label>
        <input type="color" id="strokeColor" value="#6ee7ff" />
        <label>Background</label>
        <input type="color" id="bgColor" value="#05060b" />
        <label>Background image URL</label>
        <input type="url" id="bgImage" placeholder="https://..." />
        <label><input type="checkbox" id="motionBlur" /> Motion blur</label>
        <label><input type="checkbox" id="safeArea" checked /> Safe guides</label>
        <label><input type="checkbox" id="gridToggle" /> Grid</label>
        <label for="aspect">Aspect</label>
        <select id="aspect">
          <option value="1">1:1</option>
          <option value="0.5625">9:16</option>
          <option value="1.777">16:9</option>
        </select>
      </aside>
      <section class="preview" aria-label="Preview area">
        <canvas id="preview" width="720" height="720"></canvas>
        <div class="safe-guides" id="guides"></div>
        <div class="grid-overlay" id="grid"></div>
        <input type="range" id="scrubber" min="0" max="4000" value="0" />
        <div class="shortcuts">Space: play/pause · ←/→ scrub · A: add keyframe</div>
        <div>
          <label>Audio reactive</label>
          <input type="file" id="audio" accept="audio/*" />
          <button id="snapBeats">Snap keyframes to beats</button>
        </div>
      </section>
      <aside class="panel" aria-label="Timeline and export">
        <h2>Timeline</h2>
        <div class="timeline" id="timeline"></div>
        <button id="addKeyframe">Add keyframe @ playhead</button>
        <h2>Export</h2>
        <label>Format</label>
        <select id="exportFormat">
          <option value="webm">WebM</option>
          <option value="png">PNG sequence</option>
        </select>
        <label>Frame rate</label>
        <input type="number" id="frameRate" value="30" min="1" max="60" />
        <label>Resolution</label>
        <select id="resolution">
          <option value="720">720</option>
          <option value="1080">1080</option>
        </select>
        <button id="export">Export</button>
      </aside>
    </main>

    <script>
      const canvas = document.getElementById("preview");
      const ctx = canvas.getContext("2d");
      const scrubber = document.getElementById("scrubber");
      const timelineEl = document.getElementById("timeline");
      const textInput = document.getElementById("textInput");
      const fontSelect = document.getElementById("fontSelect");
      const weight = document.getElementById("weight");
      const tracking = document.getElementById("tracking");
      const stagger = document.getElementById("stagger");
      const fillColor = document.getElementById("fillColor");
      const strokeColor = document.getElementById("strokeColor");
      const bgColor = document.getElementById("bgColor");
      const bgImage = document.getElementById("bgImage");
      const motionBlur = document.getElementById("motionBlur");
      const safeArea = document.getElementById("safeArea");
      const gridToggle = document.getElementById("gridToggle");
      const guides = document.getElementById("guides");
      const grid = document.getElementById("grid");
      const aspect = document.getElementById("aspect");
      const presetSelect = document.getElementById("preset");
      const applyPreset = document.getElementById("applyPreset");
      const audioInput = document.getElementById("audio");
      const snapBeats = document.getElementById("snapBeats");
      const addKeyframeBtn = document.getElementById("addKeyframe");
      const exportBtn = document.getElementById("export");
      const exportFormat = document.getElementById("exportFormat");
      const frameRate = document.getElementById("frameRate");
      const resolution = document.getElementById("resolution");

      const duration = 4000;
      let playing = false;
      let lastTime = 0;
      let playhead = 0;
      let audioBeats = [];

      const state = {
        keyframes: {
          positionY: [
            { time: 0, value: 0, easing: "ease" },
            { time: duration, value: -30, easing: "ease" },
          ],
          scale: [
            { time: 0, value: 1, easing: "ease" },
            { time: duration, value: 1, easing: "ease" },
          ],
          rotation: [
            { time: 0, value: 0, easing: "ease" },
            { time: duration, value: 0, easing: "ease" },
          ],
          opacity: [
            { time: 0, value: 0, easing: "ease" },
            { time: 500, value: 1, easing: "ease" },
          ],
        },
      };

      const easing = {
        ease: (t) => t,
        easeIn: (t) => t * t,
        easeOut: (t) => 1 - Math.pow(1 - t, 2),
        easeInOut: (t) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2),
      };

      function getValue(track, time) {
        const frames = state.keyframes[track];
        if (!frames || frames.length === 0) return 0;
        if (time <= frames[0].time) return frames[0].value;
        if (time >= frames[frames.length - 1].time) return frames[frames.length - 1].value;
        for (let i = 0; i < frames.length - 1; i++) {
          const a = frames[i];
          const b = frames[i + 1];
          if (time >= a.time && time <= b.time) {
            const t = (time - a.time) / (b.time - a.time);
            const easeFn = easing[a.easing] || easing.ease;
            return a.value + (b.value - a.value) * easeFn(t);
          }
        }
        return frames[0].value;
      }

      function render() {
        const prefersReduce = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);
        if (bgImage.value) {
          const img = new Image();
          img.src = bgImage.value;
          img.onload = () => {
            ctx.drawImage(img, 0, 0, width, height);
          };
        } else {
          ctx.fillStyle = bgColor.value;
          ctx.fillRect(0, 0, width, height);
        }
        ctx.save();
        const posY = prefersReduce ? 0 : getValue("positionY", playhead);
        const scale = motionBlur.checked && !prefersReduce ? getValue("scale", playhead) : 1;
        const rotation = getValue("rotation", playhead);
        const opacity = getValue("opacity", playhead);
        ctx.translate(width / 2, height / 2 + posY);
        ctx.rotate((rotation * Math.PI) / 180);
        ctx.scale(scale, scale);
        ctx.globalAlpha = opacity;
        ctx.font = `${weight.value} 72px ${fontSelect.value}`;
        ctx.textAlign = "center";
        const text = textInput.value;
        const characters = text.split("");
        const totalDelay = Number(stagger.value);
        let offsetX = 0;
        characters.forEach((char, index) => {
          const delay = prefersReduce ? 0 : (index * totalDelay) / duration;
          const progress = Math.min(1, Math.max(0, (playhead / duration) - delay));
          const letterOpacity = prefersReduce ? 1 : Math.pow(progress, 0.8);
          ctx.globalAlpha = letterOpacity * opacity;
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = strokeColor.value;
          ctx.fillStyle = fillColor.value;
          ctx.save();
          ctx.translate(offsetX, 0);
          ctx.strokeText(char, 0, 0);
          ctx.fillText(char, 0, 0);
          ctx.restore();
          offsetX += ctx.measureText(char).width + Number(tracking.value) * 0.5;
        });
        ctx.restore();
      }

      function update() {
        if (playing) {
          const now = performance.now();
          const delta = lastTime ? now - lastTime : 0;
          playhead = (playhead + delta) % duration;
          scrubber.value = playhead;
          lastTime = now;
        }
        render();
        requestAnimationFrame(update);
      }
      update();

      scrubber.addEventListener("input", () => {
        playhead = Number(scrubber.value);
        render();
      });

      document.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
          playing = !playing;
          lastTime = performance.now();
          event.preventDefault();
        } else if (event.code === "ArrowRight") {
          playhead = Math.min(duration, playhead + 50);
          scrubber.value = playhead;
          render();
        } else if (event.code === "ArrowLeft") {
          playhead = Math.max(0, playhead - 50);
          scrubber.value = playhead;
          render();
        } else if (event.key.toLowerCase() === "a") {
          addKeyframe();
        }
      });

      function addKeyframe() {
        Object.keys(state.keyframes).forEach((track) => {
          const value = getValue(track, playhead);
          state.keyframes[track].push({ time: playhead, value, easing: "ease" });
          state.keyframes[track].sort((a, b) => a.time - b.time);
        });
        renderTimeline();
      }
      addKeyframeBtn.addEventListener("click", addKeyframe);

      function renderTimeline() {
        timelineEl.innerHTML = "";
        Object.entries(state.keyframes).forEach(([track, frames]) => {
          frames.forEach((frame, index) => {
            const row = document.createElement("div");
            row.className = "timeline-row";
            row.innerHTML = `
              <span>${track}</span>
              <input type="range" min="0" max="${duration}" value="${frame.time}" data-track="${track}" data-index="${index}" />
              <select data-ease track="${track}" data-index="${index}">
                <option value="ease" ${frame.easing === "ease" ? "selected" : ""}>Ease</option>
                <option value="easeIn" ${frame.easing === "easeIn" ? "selected" : ""}>Ease in</option>
                <option value="easeOut" ${frame.easing === "easeOut" ? "selected" : ""}>Ease out</option>
                <option value="easeInOut" ${frame.easing === "easeInOut" ? "selected" : ""}>Ease in/out</option>
              </select>`;
            timelineEl.appendChild(row);
          });
        });
        timelineEl.querySelectorAll("input[type=range]").forEach((slider) => {
          slider.addEventListener("input", (event) => {
            const track = event.target.dataset.track;
            const index = event.target.dataset.index;
            state.keyframes[track][index].time = Number(event.target.value);
            state.keyframes[track].sort((a, b) => a.time - b.time);
          });
        });
        timelineEl.querySelectorAll("select").forEach((select) => {
          select.addEventListener("change", (event) => {
            const track = event.target.getAttribute("track");
            const index = event.target.dataset.index;
            state.keyframes[track][index].easing = event.target.value;
          });
        });
      }
      renderTimeline();

      [textInput, fontSelect, weight, tracking, stagger, fillColor, strokeColor, bgColor, bgImage, motionBlur].forEach((input) =>
        input.addEventListener("input", render)
      );
      [safeArea, gridToggle].forEach((toggle) =>
        toggle.addEventListener("change", () => {
          guides.style.display = safeArea.checked ? "block" : "none";
          grid.style.display = gridToggle.checked ? "block" : "none";
        })
      );
      guides.style.display = safeArea.checked ? "block" : "none";
      grid.style.display = gridToggle.checked ? "block" : "none";
      aspect.addEventListener("change", () => {
        const ratio = Number(aspect.value);
        canvas.height = canvas.width * ratio;
        render();
      });

      function applyPresetTimeline(type) {
        if (type === "typewriter") {
          state.keyframes.opacity = [
            { time: 0, value: 0, easing: "ease" },
            { time: 200, value: 1, easing: "ease" },
          ];
          stagger.value = 60;
        } else if (type === "bounce") {
          state.keyframes.positionY = [
            { time: 0, value: 60, easing: "easeOut" },
            { time: 400, value: -20, easing: "easeIn" },
            { time: 800, value: 0, easing: "easeOut" },
          ];
        } else if (type === "glitch") {
          state.keyframes.rotation = [
            { time: 0, value: -5, easing: "ease" },
            { time: 200, value: 5, easing: "ease" },
            { time: 400, value: -2, easing: "ease" },
          ];
        }
        renderTimeline();
      }
      applyPreset.addEventListener("click", () => applyPresetTimeline(presetSelect.value));

      let audioBuffer;
      audioInput.addEventListener("change", async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const arrayBuffer = await file.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        const raw = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;
        const windowSize = 1024;
        const threshold = 0.3;
        audioBeats = [];
        for (let i = 0; i < raw.length; i += windowSize) {
          const slice = raw.slice(i, i + windowSize);
          const energy = Math.sqrt(slice.reduce((sum, sample) => sum + sample * sample, 0) / slice.length);
          if (energy > threshold) {
            audioBeats.push((i / sampleRate) * 1000);
          }
        }
        audioCtx.close();
      });

      snapBeats.addEventListener("click", () => {
        if (audioBeats.length === 0) return;
        state.keyframes.positionY = audioBeats.slice(0, 6).map((time, index) => ({
          time: Math.min(duration, time),
          value: index % 2 === 0 ? -20 : 20,
          easing: "ease",
        }));
        renderTimeline();
      });

      async function exportAnimation() {
        const format = exportFormat.value;
        if (format === "webm") {
          await exportWebM();
        } else {
          await exportPNGs();
        }
      }
      exportBtn.addEventListener("click", exportAnimation);

      async function exportWebM() {
        const fps = Number(frameRate.value);
        const durationMs = duration;
        const stream = canvas.captureStream(fps);
        const recorder = new MediaRecorder(stream, { mimeType: "video/webm" });
        const chunks = [];
        recorder.ondataavailable = (e) => chunks.push(e.data);
        recorder.start();
        playing = true;
        playhead = 0;
        scrubber.value = 0;
        setTimeout(() => {
          recorder.stop();
          playing = false;
          const blob = new Blob(chunks, { type: "video/webm" });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = "kinetic.webm";
          link.click();
        }, durationMs + 100);
      }

      async function exportPNGs() {
        const fps = Number(frameRate.value);
        const totalFrames = Math.ceil((duration / 1000) * fps);
        playing = false;
        for (let i = 0; i < totalFrames; i++) {
          playhead = (i / totalFrames) * duration;
          render();
          await new Promise((resolve) => requestAnimationFrame(resolve));
          await new Promise((resolve) => canvas.toBlob((blob) => {
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `frame-${String(i).padStart(4, "0")}.png`;
            link.click();
            resolve();
          }));
        }
      }
    </script>
  </body>
</html>
