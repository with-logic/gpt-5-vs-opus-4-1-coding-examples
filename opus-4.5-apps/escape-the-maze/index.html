<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape the Maze</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }

        .stats {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }

        .stat {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
        }

        #mazeCanvas {
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .btn-primary {
            background: #4ecdc4;
            color: #1a1a2e;
            font-weight: 600;
        }

        .btn-primary:hover {
            background: #3dbdb5;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .difficulty {
            margin-top: 15px;
        }

        .difficulty select {
            padding: 10px 20px;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
        }

        .message {
            margin-top: 15px;
            font-size: 1.1rem;
            min-height: 30px;
        }

        .message.win {
            color: #f1c40f;
            font-weight: bold;
            animation: pulse 0.5s ease infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        .instructions {
            margin-top: 15px;
            color: #666;
            font-size: 0.9rem;
        }

        /* Touch controls for mobile */
        .touch-controls {
            display: none;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
            margin-top: 20px;
        }

        .touch-btn {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        @media (max-width: 600px) {
            .touch-controls {
                display: grid;
            }
        }
    </style>
</head>
<body>
    <h1>Escape the Maze</h1>

    <div class="stats">
        <div class="stat">
            <div class="stat-value" id="timer">0:00</div>
            <div class="stat-label">Time</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="moves">0</div>
            <div class="stat-label">Moves</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="best">-</div>
            <div class="stat-label">Best Path</div>
        </div>
    </div>

    <canvas id="mazeCanvas"></canvas>

    <div class="message" id="message">Find the exit! üö™</div>

    <div class="controls">
        <button class="btn btn-primary" onclick="newMaze()">New Maze</button>
        <button class="btn btn-secondary" onclick="showSolution()">Show Path</button>
        <button class="btn btn-secondary" onclick="resetMaze()">Reset</button>
    </div>

    <div class="difficulty">
        <select id="size" onchange="newMaze()">
            <option value="21">Easy (21√ó21)</option>
            <option value="31" selected>Medium (31√ó31)</option>
            <option value="41">Hard (41√ó41)</option>
            <option value="51">Expert (51√ó51)</option>
        </select>
    </div>

    <div class="touch-controls">
        <div></div>
        <button class="touch-btn" onclick="move(0,-1)">‚Üë</button>
        <div></div>
        <button class="touch-btn" onclick="move(-1,0)">‚Üê</button>
        <div></div>
        <button class="touch-btn" onclick="move(1,0)">‚Üí</button>
        <div></div>
        <button class="touch-btn" onclick="move(0,1)">‚Üì</button>
        <div></div>
    </div>

    <p class="instructions">Use arrow keys or WASD to move</p>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');

        const CELL_SIZE = 16;
        const WALL_COLOR = '#2c3e50';
        const PATH_COLOR = '#0f1419';
        const PLAYER_COLOR = '#4ecdc4';
        const EXIT_COLOR = '#e74c3c';
        const VISITED_COLOR = 'rgba(78, 205, 196, 0.15)';
        const SOLUTION_COLOR = 'rgba(241, 196, 15, 0.4)';

        let maze = [];
        let mazeSize = 31;
        let playerX = 1;
        let playerY = 1;
        let exitX, exitY;
        let moves = 0;
        let seconds = 0;
        let timerInterval = null;
        let gameWon = false;
        let visited = new Set();
        let solution = [];
        let showingSolution = false;

        // Generate complex maze using Prim's algorithm with added complexity
        function generateMaze(size) {
            // Initialize with all walls
            const grid = [];
            for (let y = 0; y < size; y++) {
                grid[y] = [];
                for (let x = 0; x < size; x++) {
                    grid[y][x] = 1; // 1 = wall
                }
            }

            // Use randomized Prim's algorithm for more branching paths
            const walls = [];
            const startX = 1;
            const startY = 1;
            grid[startY][startX] = 0;

            // Add initial walls
            const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
            for (const [dx, dy] of directions) {
                const nx = startX + dx;
                const ny = startY + dy;
                if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1) {
                    walls.push([startX + dx/2, startY + dy/2, nx, ny]);
                }
            }

            while (walls.length > 0) {
                // Pick random wall
                const idx = Math.floor(Math.random() * walls.length);
                const [wx, wy, cx, cy] = walls.splice(idx, 1)[0];

                if (grid[cy][cx] === 1) {
                    // Carve passage
                    grid[wy][wx] = 0;
                    grid[cy][cx] = 0;

                    // Add neighboring walls
                    for (const [dx, dy] of directions) {
                        const nx = cx + dx;
                        const ny = cy + dy;
                        if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && grid[ny][nx] === 1) {
                            walls.push([cx + dx/2, cy + dy/2, nx, ny]);
                        }
                    }
                }
            }

            // Add loops by removing some walls (makes maze more complex with multiple paths)
            const loopCount = Math.floor(size * size * 0.02);
            for (let i = 0; i < loopCount; i++) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;

                // Only remove walls that connect two path cells
                if (grid[y][x] === 1) {
                    const neighbors = [
                        [grid[y-1]?.[x], grid[y+1]?.[x]],
                        [grid[y]?.[x-1], grid[y]?.[x+1]]
                    ];
                    for (const [a, b] of neighbors) {
                        if (a === 0 && b === 0) {
                            grid[y][x] = 0;
                            break;
                        }
                    }
                }
            }

            // Ensure start and exit are accessible
            grid[1][1] = 0;
            grid[size - 2][size - 2] = 0;

            // Create clear path near exit if blocked
            if (grid[size - 3][size - 2] === 1 && grid[size - 2][size - 3] === 1) {
                grid[size - 3][size - 2] = 0;
            }

            return grid;
        }

        // Find shortest path using BFS
        function findSolution() {
            const queue = [[1, 1, [[1, 1]]]];
            const seen = new Set(['1,1']);

            while (queue.length > 0) {
                const [x, y, path] = queue.shift();

                if (x === exitX && y === exitY) {
                    return path;
                }

                for (const [dx, dy] of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {
                    const nx = x + dx;
                    const ny = y + dy;
                    const key = `${nx},${ny}`;

                    if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize &&
                        maze[ny][nx] === 0 && !seen.has(key)) {
                        seen.add(key);
                        queue.push([nx, ny, [...path, [nx, ny]]]);
                    }
                }
            }

            return [];
        }

        function draw() {
            canvas.width = mazeSize * CELL_SIZE;
            canvas.height = mazeSize * CELL_SIZE;

            // Draw maze
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    const isWall = maze[y][x] === 1;
                    ctx.fillStyle = isWall ? WALL_COLOR : PATH_COLOR;
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);

                    // Add subtle grid lines for paths
                    if (!isWall) {
                        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                        ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw visited cells
            visited.forEach(key => {
                const [x, y] = key.split(',').map(Number);
                ctx.fillStyle = VISITED_COLOR;
                ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            });

            // Draw solution if showing
            if (showingSolution && solution.length > 0) {
                ctx.fillStyle = SOLUTION_COLOR;
                solution.forEach(([x, y]) => {
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                });
            }

            // Draw exit
            ctx.fillStyle = EXIT_COLOR;
            ctx.beginPath();
            ctx.arc(
                exitX * CELL_SIZE + CELL_SIZE / 2,
                exitY * CELL_SIZE + CELL_SIZE / 2,
                CELL_SIZE / 3,
                0, Math.PI * 2
            );
            ctx.fill();

            // Draw exit glow
            ctx.shadowColor = EXIT_COLOR;
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw player
            ctx.fillStyle = PLAYER_COLOR;
            ctx.beginPath();
            ctx.arc(
                playerX * CELL_SIZE + CELL_SIZE / 2,
                playerY * CELL_SIZE + CELL_SIZE / 2,
                CELL_SIZE / 3,
                0, Math.PI * 2
            );
            ctx.fill();

            // Player glow
            ctx.shadowColor = PLAYER_COLOR;
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function move(dx, dy) {
            if (gameWon) return;

            const nx = playerX + dx;
            const ny = playerY + dy;

            // Check bounds and walls
            if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize && maze[ny][nx] === 0) {
                // Mark current position as visited
                visited.add(`${playerX},${playerY}`);

                playerX = nx;
                playerY = ny;
                moves++;
                document.getElementById('moves').textContent = moves;

                draw();

                // Check win
                if (playerX === exitX && playerY === exitY) {
                    win();
                }
            }
        }

        function win() {
            gameWon = true;
            clearInterval(timerInterval);

            const optimal = solution.length - 1;
            const efficiency = optimal > 0 ? Math.round((optimal / moves) * 100) : 100;

            let msg = `üéâ Escaped in ${moves} moves!`;
            if (moves === optimal) {
                msg += ' Perfect! ‚≠ê';
            } else {
                msg += ` (Optimal: ${optimal})`;
            }

            document.getElementById('message').textContent = msg;
            document.getElementById('message').className = 'message win';
        }

        function startTimer() {
            seconds = 0;
            clearInterval(timerInterval);
            updateTimerDisplay();

            timerInterval = setInterval(() => {
                seconds++;
                updateTimerDisplay();
            }, 1000);
        }

        function updateTimerDisplay() {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('timer').textContent =
                `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function newMaze() {
            mazeSize = parseInt(document.getElementById('size').value);
            maze = generateMaze(mazeSize);

            playerX = 1;
            playerY = 1;
            exitX = mazeSize - 2;
            exitY = mazeSize - 2;

            moves = 0;
            gameWon = false;
            visited = new Set();
            showingSolution = false;

            solution = findSolution();

            document.getElementById('moves').textContent = '0';
            document.getElementById('best').textContent = solution.length - 1;
            document.getElementById('message').textContent = 'Find the exit! üö™';
            document.getElementById('message').className = 'message';

            startTimer();
            draw();
        }

        function resetMaze() {
            playerX = 1;
            playerY = 1;
            moves = 0;
            gameWon = false;
            visited = new Set();
            showingSolution = false;

            document.getElementById('moves').textContent = '0';
            document.getElementById('message').textContent = 'Find the exit! üö™';
            document.getElementById('message').className = 'message';

            startTimer();
            draw();
        }

        function showSolution() {
            showingSolution = !showingSolution;
            draw();
        }

        // Keyboard controls
        document.addEventListener('keydown', e => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    move(0, -1);
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    move(0, 1);
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    move(-1, 0);
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    move(1, 0);
                    e.preventDefault();
                    break;
            }
        });

        // Initialize
        newMaze();
    </script>
</body>
</html>
