<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Rain</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            background: linear-gradient(to bottom, #0a0a1a 0%, #1a1a3a 50%, #2a2a4a 100%);
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        /* City Skyline */
        .city-background {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .building {
            position: absolute;
            bottom: 0;
            background: linear-gradient(to bottom, #1a1a2e, #0f0f1a);
            border-top-left-radius: 3px;
            border-top-right-radius: 3px;
        }

        .window {
            position: absolute;
            background: rgba(255, 220, 100, 0.8);
            width: 8px;
            height: 12px;
            border-radius: 1px;
        }

        .window.off {
            background: rgba(50, 50, 80, 0.5);
        }

        /* Rain drops background */
        .rain-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .raindrop {
            position: absolute;
            width: 2px;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(100, 150, 255, 0.6));
            animation: fall linear infinite;
        }

        @keyframes fall {
            0% { transform: translateY(-20px); }
            100% { transform: translateY(100vh); }
        }

        /* Word drops */
        .word-drop {
            position: absolute;
            z-index: 10;
            font-size: 1.4rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.8), 0 0 20px rgba(100, 200, 255, 0.5);
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.9), rgba(42, 82, 152, 0.8));
            border-radius: 8px;
            border: 2px solid rgba(100, 200, 255, 0.6);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transition: transform 0.1s, box-shadow 0.1s;
            white-space: nowrap;
        }

        .word-drop.active {
            border-color: #4ade80;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.6), 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .word-drop .typed {
            color: #4ade80;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.8);
        }

        .word-drop .remaining {
            color: #fff;
        }

        .word-drop.exploding {
            animation: explode 0.4s ease-out forwards;
        }

        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        .word-drop.missed {
            animation: missed 0.5s ease-out forwards;
        }

        @keyframes missed {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(50px); opacity: 0; color: #ef4444; }
        }

        /* UI Elements */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .stats-panel {
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(30, 30, 60, 0.9));
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid rgba(100, 150, 255, 0.4);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .stats-panel h2 {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            color: #ccc;
            font-size: 1rem;
        }

        .stat-value {
            color: #4ade80;
            font-weight: bold;
            font-size: 1.2rem;
            margin-left: 20px;
        }

        .stat-value.score {
            color: #fbbf24;
        }

        .input-area {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        #typing-input {
            width: 400px;
            padding: 15px 25px;
            font-size: 1.5rem;
            border: 3px solid rgba(100, 150, 255, 0.6);
            border-radius: 50px;
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(30, 30, 60, 0.9));
            color: #fff;
            text-align: center;
            outline: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        #typing-input:focus {
            border-color: #4ade80;
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.4), 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        #typing-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        /* Start Screen */
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 30, 0.95);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .screen-overlay.hidden {
            display: none;
        }

        .game-title {
            font-size: 4rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px rgba(100, 200, 255, 0.8), 0 0 60px rgba(100, 200, 255, 0.4);
            margin-bottom: 20px;
            letter-spacing: 5px;
        }

        .game-subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 50px;
        }

        .btn {
            padding: 18px 50px;
            font-size: 1.3rem;
            font-weight: bold;
            color: #fff;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 30px rgba(59, 130, 246, 0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(59, 130, 246, 0.7);
        }

        .btn:active {
            transform: translateY(0);
        }

        .final-stats {
            margin: 30px 0;
            text-align: center;
        }

        .final-stat {
            font-size: 1.3rem;
            color: rgba(255, 255, 255, 0.8);
            margin: 15px 0;
        }

        .final-stat span {
            color: #4ade80;
            font-weight: bold;
            font-size: 1.5rem;
        }

        .final-stat.score span {
            color: #fbbf24;
        }

        /* Difficulty indicator */
        .difficulty-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
        }

        .difficulty-label {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .difficulty-value {
            color: #fbbf24;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        /* Ground/danger zone */
        .danger-zone {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            background: linear-gradient(to top, rgba(239, 68, 68, 0.3), transparent);
            z-index: 5;
            pointer-events: none;
        }

        /* Particle effects */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            border-radius: 50%;
        }

        /* Instructions */
        .instructions {
            position: absolute;
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            text-align: center;
            z-index: 99;
        }

        /* Lives display */
        .lives-container {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .life {
            width: 20px;
            height: 20px;
            background: #ef4444;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
            transition: all 0.3s ease;
        }

        .life.lost {
            background: rgba(100, 100, 100, 0.3);
            box-shadow: none;
        }

        /* Combo display */
        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            font-size: 3rem;
            font-weight: bold;
            color: #fbbf24;
            text-shadow: 0 0 30px rgba(251, 191, 36, 0.8);
            opacity: 0;
            pointer-events: none;
        }

        .combo-display.show {
            animation: comboPopup 0.8s ease-out forwards;
        }

        @keyframes comboPopup {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -60%) scale(1); opacity: 0; }
        }

        /* Level up notification */
        .level-up {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            font-size: 2.5rem;
            font-weight: bold;
            color: #4ade80;
            text-shadow: 0 0 30px rgba(74, 222, 128, 0.8);
            opacity: 0;
            pointer-events: none;
        }

        .level-up.show {
            animation: levelUpAnim 1.5s ease-out forwards;
        }

        @keyframes levelUpAnim {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Stars -->
        <div class="stars" id="stars"></div>

        <!-- City Background -->
        <div class="city-background" id="city"></div>

        <!-- Rain Effect -->
        <div class="rain-container" id="rain"></div>

        <!-- Danger Zone -->
        <div class="danger-zone"></div>

        <!-- Word drops container -->
        <div id="words-container"></div>

        <!-- UI Overlay -->
        <div class="ui-overlay">
            <div class="stats-panel">
                <h2>⌨️ TYPING RAIN</h2>
                <div class="stat">
                    <span>Score</span>
                    <span class="stat-value score" id="score">0</span>
                </div>
                <div class="stat">
                    <span>Accuracy</span>
                    <span class="stat-value" id="accuracy">100%</span>
                </div>
                <div class="stat">
                    <span>WPM</span>
                    <span class="stat-value" id="wpm">0</span>
                </div>
                <div class="stat">
                    <span>Combo</span>
                    <span class="stat-value" id="combo">0x</span>
                </div>
                <div class="lives-container" id="lives"></div>
            </div>
        </div>

        <!-- Difficulty Indicator -->
        <div class="difficulty-indicator">
            <div class="difficulty-label">LEVEL</div>
            <div class="difficulty-value" id="level">1</div>
        </div>

        <!-- Combo Display -->
        <div class="combo-display" id="combo-display"></div>

        <!-- Level Up Display -->
        <div class="level-up" id="level-up">LEVEL UP!</div>

        <!-- Input Area -->
        <div class="input-area">
            <input type="text" id="typing-input" placeholder="Type the falling words..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
        </div>

        <div class="instructions">Type the words before they reach the ground!</div>

        <!-- Start Screen -->
        <div class="screen-overlay" id="start-screen">
            <h1 class="game-title">TYPING RAIN</h1>
            <p class="game-subtitle">Type the falling words before they hit the ground</p>
            <button class="btn" id="start-btn">START GAME</button>
        </div>

        <!-- Game Over Screen -->
        <div class="screen-overlay hidden" id="gameover-screen">
            <h1 class="game-title">GAME OVER</h1>
            <div class="final-stats">
                <div class="final-stat score">Final Score: <span id="final-score">0</span></div>
                <div class="final-stat">Words Typed: <span id="final-words">0</span></div>
                <div class="final-stat">Accuracy: <span id="final-accuracy">0%</span></div>
                <div class="final-stat">Max Combo: <span id="final-combo">0</span></div>
                <div class="final-stat">Peak WPM: <span id="final-wpm">0</span></div>
                <div class="final-stat">Level Reached: <span id="final-level">1</span></div>
            </div>
            <button class="btn" id="restart-btn">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // Word lists by difficulty
        const wordLists = {
            easy: ['cat', 'dog', 'run', 'sky', 'sun', 'moon', 'tree', 'book', 'fish', 'bird',
                   'red', 'blue', 'green', 'lake', 'rain', 'snow', 'wind', 'fire', 'leaf', 'rock',
                   'star', 'bear', 'wolf', 'ship', 'boat', 'hand', 'foot', 'head', 'door', 'wall'],
            medium: ['thunder', 'forest', 'garden', 'window', 'bridge', 'castle', 'planet', 'dragon',
                     'wizard', 'knight', 'sunset', 'winter', 'summer', 'spring', 'autumn', 'flower',
                     'stream', 'valley', 'mountain', 'island', 'ocean', 'desert', 'jungle', 'temple',
                     'ancient', 'crystal', 'shadow', 'golden', 'silver', 'bronze'],
            hard: ['beautiful', 'adventure', 'mysterious', 'wonderful', 'incredible', 'fantastic',
                   'legendary', 'powerful', 'dangerous', 'enchanted', 'lightning', 'hurricane',
                   'avalanche', 'earthquake', 'whirlwind', 'majestic', 'brilliant', 'spectacular',
                   'magnificent', 'phenomenal', 'extraordinary', 'remarkable', 'impossible', 'invisible'],
            expert: ['constellation', 'extraordinary', 'metamorphosis', 'kaleidoscope', 'philosophical',
                     'unprecedented', 'sophisticated', 'revolutionary', 'consciousness', 'hallucination',
                     'cryptocurrency', 'electromagnetic', 'transcendental', 'incomprehensible', 'supernatural']
        };

        // Game state
        let gameState = {
            isRunning: false,
            score: 0,
            lives: 5,
            level: 1,
            combo: 0,
            maxCombo: 0,
            wordsTyped: 0,
            totalKeystrokes: 0,
            correctKeystrokes: 0,
            startTime: null,
            peakWPM: 0,
            activeWords: [],
            currentWord: null,
            spawnInterval: null,
            gameLoop: null,
            lastSpawnTime: 0,
            spawnRate: 2500,
            baseSpeed: 0.5,
            wordSpeed: 0.5
        };

        // DOM elements
        const container = document.getElementById('game-container');
        const wordsContainer = document.getElementById('words-container');
        const input = document.getElementById('typing-input');
        const scoreEl = document.getElementById('score');
        const accuracyEl = document.getElementById('accuracy');
        const wpmEl = document.getElementById('wpm');
        const comboEl = document.getElementById('combo');
        const levelEl = document.getElementById('level');
        const livesEl = document.getElementById('lives');
        const startScreen = document.getElementById('start-screen');
        const gameoverScreen = document.getElementById('gameover-screen');
        const comboDisplay = document.getElementById('combo-display');
        const levelUpDisplay = document.getElementById('level-up');

        // Initialize city background
        function createCity() {
            const city = document.getElementById('city');
            const width = window.innerWidth;
            const buildings = [];

            let x = 0;
            while (x < width) {
                const buildingWidth = 40 + Math.random() * 80;
                const buildingHeight = 100 + Math.random() * 250;
                buildings.push({ x, width: buildingWidth, height: buildingHeight });
                x += buildingWidth + Math.random() * 20;
            }

            buildings.forEach(b => {
                const building = document.createElement('div');
                building.className = 'building';
                building.style.left = b.x + 'px';
                building.style.width = b.width + 'px';
                building.style.height = b.height + 'px';

                // Add windows
                const rows = Math.floor(b.height / 25);
                const cols = Math.floor(b.width / 18);
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const window = document.createElement('div');
                        window.className = 'window' + (Math.random() > 0.6 ? ' off' : '');
                        window.style.left = (5 + c * 18) + 'px';
                        window.style.bottom = (10 + r * 25) + 'px';
                        building.appendChild(window);
                    }
                }
                city.appendChild(building);
            });
        }

        // Initialize stars
        function createStars() {
            const starsContainer = document.getElementById('stars');
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = (1 + Math.random() * 2) + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 2 + 's';
                starsContainer.appendChild(star);
            }
        }

        // Initialize rain
        function createRain() {
            const rainContainer = document.getElementById('rain');
            for (let i = 0; i < 100; i++) {
                const drop = document.createElement('div');
                drop.className = 'raindrop';
                drop.style.left = Math.random() * 100 + '%';
                drop.style.animationDuration = (0.5 + Math.random() * 0.5) + 's';
                drop.style.animationDelay = Math.random() * 2 + 's';
                drop.style.opacity = 0.3 + Math.random() * 0.4;
                rainContainer.appendChild(drop);
            }
        }

        // Initialize lives display
        function updateLivesDisplay() {
            livesEl.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const life = document.createElement('div');
                life.className = 'life' + (i >= gameState.lives ? ' lost' : '');
                livesEl.appendChild(life);
            }
        }

        // Get word based on current level
        function getRandomWord() {
            let pool;
            if (gameState.level <= 2) {
                pool = wordLists.easy;
            } else if (gameState.level <= 4) {
                pool = [...wordLists.easy, ...wordLists.medium];
            } else if (gameState.level <= 6) {
                pool = [...wordLists.medium, ...wordLists.hard];
            } else if (gameState.level <= 8) {
                pool = [...wordLists.medium, ...wordLists.hard, ...wordLists.expert];
            } else {
                pool = [...wordLists.hard, ...wordLists.expert];
            }

            // Avoid duplicates
            let word;
            let attempts = 0;
            do {
                word = pool[Math.floor(Math.random() * pool.length)];
                attempts++;
            } while (gameState.activeWords.some(w => w.text === word) && attempts < 20);

            return word;
        }

        // Spawn a new word
        function spawnWord() {
            const text = getRandomWord();
            const wordEl = document.createElement('div');
            wordEl.className = 'word-drop';
            wordEl.innerHTML = `<span class="typed"></span><span class="remaining">${text}</span>`;

            const x = 50 + Math.random() * (window.innerWidth - 200);
            wordEl.style.left = x + 'px';
            wordEl.style.top = '-50px';

            wordsContainer.appendChild(wordEl);

            const word = {
                text: text,
                element: wordEl,
                x: x,
                y: -50,
                typedIndex: 0,
                speed: gameState.wordSpeed + (Math.random() * 0.2 - 0.1)
            };

            gameState.activeWords.push(word);
        }

        // Create particle effect
        function createParticles(x, y, color) {
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.width = (4 + Math.random() * 6) + 'px';
                particle.style.height = particle.style.width;
                particle.style.background = color;
                particle.style.boxShadow = `0 0 10px ${color}`;

                const angle = (Math.PI * 2 * i) / 12;
                const velocity = 3 + Math.random() * 4;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                container.appendChild(particle);

                let px = x, py = y, life = 1;
                const animateParticle = () => {
                    life -= 0.03;
                    if (life <= 0) {
                        particle.remove();
                        return;
                    }
                    px += vx;
                    py += vy + 1;
                    particle.style.left = px + 'px';
                    particle.style.top = py + 'px';
                    particle.style.opacity = life;
                    particle.style.transform = `scale(${life})`;
                    requestAnimationFrame(animateParticle);
                };
                requestAnimationFrame(animateParticle);
            }
        }

        // Show combo popup
        function showComboPopup(combo) {
            comboDisplay.textContent = `${combo}x COMBO!`;
            comboDisplay.classList.remove('show');
            void comboDisplay.offsetWidth;
            comboDisplay.classList.add('show');
        }

        // Show level up
        function showLevelUp() {
            levelUpDisplay.classList.remove('show');
            void levelUpDisplay.offsetWidth;
            levelUpDisplay.classList.add('show');
        }

        // Update difficulty based on score
        function updateDifficulty() {
            const newLevel = Math.floor(gameState.wordsTyped / 5) + 1;
            if (newLevel > gameState.level && newLevel <= 15) {
                gameState.level = newLevel;
                levelEl.textContent = newLevel;

                // Increase difficulty
                gameState.spawnRate = Math.max(800, 2500 - (newLevel * 150));
                gameState.wordSpeed = gameState.baseSpeed + (newLevel * 0.12);

                showLevelUp();
            }
        }

        // Complete a word
        function completeWord(word) {
            word.element.classList.add('exploding');

            const rect = word.element.getBoundingClientRect();
            createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, '#4ade80');

            // Calculate score with combo multiplier
            const basePoints = word.text.length * 10;
            const comboMultiplier = 1 + (gameState.combo * 0.1);
            const levelMultiplier = 1 + (gameState.level * 0.1);
            const points = Math.floor(basePoints * comboMultiplier * levelMultiplier);

            gameState.score += points;
            gameState.combo++;
            gameState.wordsTyped++;

            if (gameState.combo > gameState.maxCombo) {
                gameState.maxCombo = gameState.combo;
            }

            if (gameState.combo >= 3 && gameState.combo % 3 === 0) {
                showComboPopup(gameState.combo);
            }

            updateUI();
            updateDifficulty();

            setTimeout(() => {
                word.element.remove();
                gameState.activeWords = gameState.activeWords.filter(w => w !== word);
            }, 400);

            gameState.currentWord = null;
            input.value = '';

            // Find next word to type if partially matched
            findActiveWord();
        }

        // Miss a word
        function missWord(word) {
            word.element.classList.add('missed');

            const rect = word.element.getBoundingClientRect();
            createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, '#ef4444');

            gameState.lives--;
            gameState.combo = 0;
            updateLivesDisplay();
            updateUI();

            if (gameState.currentWord === word) {
                gameState.currentWord = null;
                input.value = '';
            }

            setTimeout(() => {
                word.element.remove();
                gameState.activeWords = gameState.activeWords.filter(w => w !== word);
            }, 500);

            if (gameState.lives <= 0) {
                endGame();
            }
        }

        // Find and highlight active word based on input
        function findActiveWord() {
            const typed = input.value.toLowerCase();

            if (!typed) {
                gameState.activeWords.forEach(w => w.element.classList.remove('active'));
                gameState.currentWord = null;
                return;
            }

            // If we have a current word, check if it still matches
            if (gameState.currentWord) {
                const remaining = gameState.currentWord.text.substring(gameState.currentWord.typedIndex);
                if (remaining.toLowerCase().startsWith(typed.toLowerCase())) {
                    return; // Still matching current word
                }
            }

            // Find a new matching word
            for (const word of gameState.activeWords) {
                const remaining = word.text.substring(word.typedIndex);
                if (remaining.toLowerCase().startsWith(typed.toLowerCase())) {
                    gameState.activeWords.forEach(w => w.element.classList.remove('active'));
                    word.element.classList.add('active');
                    gameState.currentWord = word;
                    return;
                }
            }

            // No match found - wrong keystroke
            gameState.activeWords.forEach(w => w.element.classList.remove('active'));
        }

        // Handle input
        function handleInput() {
            const typed = input.value.toLowerCase();
            gameState.totalKeystrokes++;

            findActiveWord();

            if (gameState.currentWord) {
                const word = gameState.currentWord;
                const fullWord = word.text.toLowerCase();
                const expectedPrefix = fullWord.substring(0, word.typedIndex + typed.length);
                const actualTyped = (fullWord.substring(0, word.typedIndex) + typed).toLowerCase();

                if (actualTyped === expectedPrefix) {
                    gameState.correctKeystrokes++;
                    word.typedIndex = actualTyped.length;

                    // Update display
                    const typedSpan = word.element.querySelector('.typed');
                    const remainingSpan = word.element.querySelector('.remaining');
                    typedSpan.textContent = word.text.substring(0, word.typedIndex);
                    remainingSpan.textContent = word.text.substring(word.typedIndex);

                    // Check if word is complete
                    if (word.typedIndex >= word.text.length) {
                        completeWord(word);
                    }
                } else {
                    // Wrong character - reset combo
                    if (gameState.combo > 0) {
                        gameState.combo = 0;
                        updateUI();
                    }
                }
            }

            updateUI();
        }

        // Update UI
        function updateUI() {
            scoreEl.textContent = gameState.score.toLocaleString();

            const accuracy = gameState.totalKeystrokes > 0
                ? Math.round((gameState.correctKeystrokes / gameState.totalKeystrokes) * 100)
                : 100;
            accuracyEl.textContent = accuracy + '%';

            const elapsed = (Date.now() - gameState.startTime) / 1000 / 60; // minutes
            const wpm = elapsed > 0 ? Math.round(gameState.wordsTyped / elapsed) : 0;
            wpmEl.textContent = wpm;
            if (wpm > gameState.peakWPM) gameState.peakWPM = wpm;

            comboEl.textContent = gameState.combo + 'x';
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!gameState.isRunning) return;

            // Spawn new words
            if (timestamp - gameState.lastSpawnTime > gameState.spawnRate) {
                if (gameState.activeWords.length < 5 + Math.floor(gameState.level / 2)) {
                    spawnWord();
                }
                gameState.lastSpawnTime = timestamp;
            }

            // Update word positions
            const bottomLimit = window.innerHeight - 150;
            gameState.activeWords.forEach(word => {
                word.y += word.speed;
                word.element.style.top = word.y + 'px';

                if (word.y > bottomLimit) {
                    missWord(word);
                }
            });

            if (gameState.isRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Start game
        function startGame() {
            gameState = {
                isRunning: true,
                score: 0,
                lives: 5,
                level: 1,
                combo: 0,
                maxCombo: 0,
                wordsTyped: 0,
                totalKeystrokes: 0,
                correctKeystrokes: 0,
                startTime: Date.now(),
                peakWPM: 0,
                activeWords: [],
                currentWord: null,
                spawnInterval: null,
                gameLoop: null,
                lastSpawnTime: 0,
                spawnRate: 2500,
                baseSpeed: 0.5,
                wordSpeed: 0.5
            };

            wordsContainer.innerHTML = '';
            updateLivesDisplay();
            updateUI();
            levelEl.textContent = '1';

            startScreen.classList.add('hidden');
            gameoverScreen.classList.add('hidden');

            input.value = '';
            input.focus();

            requestAnimationFrame(gameLoop);
        }

        // End game
        function endGame() {
            gameState.isRunning = false;

            document.getElementById('final-score').textContent = gameState.score.toLocaleString();
            document.getElementById('final-words').textContent = gameState.wordsTyped;
            document.getElementById('final-accuracy').textContent =
                gameState.totalKeystrokes > 0
                    ? Math.round((gameState.correctKeystrokes / gameState.totalKeystrokes) * 100) + '%'
                    : '100%';
            document.getElementById('final-combo').textContent = gameState.maxCombo;
            document.getElementById('final-wpm').textContent = gameState.peakWPM;
            document.getElementById('final-level').textContent = gameState.level;

            gameoverScreen.classList.remove('hidden');
        }

        // Event listeners
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);

        input.addEventListener('input', handleInput);

        // Keep focus on input
        document.addEventListener('click', () => {
            if (gameState.isRunning) {
                input.focus();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (gameState.isRunning && document.activeElement !== input) {
                input.focus();
            }

            if (e.key === 'Enter' && !gameState.isRunning) {
                if (!startScreen.classList.contains('hidden')) {
                    startGame();
                } else if (!gameoverScreen.classList.contains('hidden')) {
                    startGame();
                }
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            const city = document.getElementById('city');
            city.innerHTML = '';
            createCity();
        });

        // Initialize
        createStars();
        createCity();
        createRain();
        updateLivesDisplay();
    </script>
</body>
</html>
