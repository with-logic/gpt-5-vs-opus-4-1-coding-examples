<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Filter Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0 30px;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #e94560, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s linear infinite;
        }

        @keyframes shimmer {
            to { background-position: 200% center; }
        }

        .subtitle {
            color: #a0a0a0;
            margin-top: 8px;
            font-size: 1rem;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        .video-container {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(233, 69, 96, 0.2);
            background: #000;
        }

        #webcam {
            display: none;
        }

        #canvas {
            display: block;
            max-width: 100%;
            border-radius: 16px;
        }

        .overlay-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 40px;
        }

        .overlay-message.hidden {
            display: none;
        }

        .overlay-message i {
            font-size: 4rem;
            margin-bottom: 16px;
            display: block;
            opacity: 0.7;
        }

        .start-btn {
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            border: none;
            padding: 16px 32px;
            font-size: 1.1rem;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            margin-top: 16px;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            max-width: 800px;
        }

        .filter-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 12px 20px;
            font-size: 0.9rem;
            color: white;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .filter-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .filter-btn.active {
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            border-color: #e94560;
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        .action-buttons {
            display: flex;
            gap: 16px;
            margin-top: 8px;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 14px 28px;
            font-size: 1rem;
            color: white;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }

        .action-btn.capture {
            background: linear-gradient(135deg, #48dbfb, #0abde3);
            border-color: #48dbfb;
        }

        .action-btn.capture:hover {
            box-shadow: 0 10px 30px rgba(72, 219, 251, 0.4);
        }

        .action-btn.save {
            background: linear-gradient(135deg, #1dd1a1, #10ac84);
            border-color: #1dd1a1;
        }

        .action-btn.save:hover {
            box-shadow: 0 10px 30px rgba(29, 209, 161, 0.4);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .snapshots {
            margin-top: 24px;
            width: 100%;
            max-width: 800px;
        }

        .snapshots h3 {
            margin-bottom: 16px;
            font-size: 1.2rem;
            color: #a0a0a0;
        }

        .snapshot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
        }

        .snapshot-item {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            aspect-ratio: 4/3;
        }

        .snapshot-item:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .snapshot-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .snapshot-item .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(233, 69, 96, 0.9);
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 14px;
        }

        .snapshot-item:hover .delete-btn {
            opacity: 1;
        }

        .flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            pointer-events: none;
            opacity: 0;
            z-index: 1000;
        }

        .flash.active {
            animation: flashAnim 0.3s ease-out;
        }

        @keyframes flashAnim {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        .filter-intensity {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 20px;
            border-radius: 12px;
            margin-top: 8px;
        }

        .filter-intensity label {
            font-size: 0.9rem;
            color: #a0a0a0;
        }

        .filter-intensity input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        .filter-intensity input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            border-radius: 50%;
            cursor: pointer;
        }

        .current-filter {
            font-size: 0.9rem;
            color: #feca57;
            margin-bottom: 8px;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.8rem;
            }

            .filter-btn {
                padding: 10px 14px;
                font-size: 0.8rem;
            }

            .action-btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }

            .controls {
                gap: 8px;
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Webcam Filter Playground</h1>
            <p class="subtitle">Apply fun & surprising filters to your live webcam feed</p>
        </header>

        <main class="main-content">
            <div class="video-container">
                <video id="webcam" autoplay playsinline></video>
                <canvas id="canvas" width="640" height="480"></canvas>
                <div class="overlay-message" id="overlay">
                    <span style="font-size: 4rem;">ðŸ“·</span>
                    <p>Click below to start your webcam</p>
                    <button class="start-btn" id="startBtn">Start Camera</button>
                </div>
            </div>

            <div id="controlsSection" class="hidden">
                <p class="current-filter">Current Filter: <span id="filterName">None</span></p>

                <div class="controls">
                    <button class="filter-btn active" data-filter="none">None</button>
                    <button class="filter-btn" data-filter="grayscale">Grayscale</button>
                    <button class="filter-btn" data-filter="sepia">Sepia</button>
                    <button class="filter-btn" data-filter="invert">Invert</button>
                    <button class="filter-btn" data-filter="pixelate">Pixelate</button>
                    <button class="filter-btn" data-filter="blur">Blur</button>
                    <button class="filter-btn" data-filter="emboss">Emboss</button>
                    <button class="filter-btn" data-filter="edge">Edge Detect</button>
                    <button class="filter-btn" data-filter="thermal">Thermal</button>
                    <button class="filter-btn" data-filter="vhs">VHS</button>
                    <button class="filter-btn" data-filter="rainbow">Rainbow</button>
                    <button class="filter-btn" data-filter="mirror">Mirror</button>
                    <button class="filter-btn" data-filter="kaleidoscope">Kaleidoscope</button>
                    <button class="filter-btn" data-filter="comic">Comic</button>
                    <button class="filter-btn" data-filter="glitch">Glitch</button>
                </div>

                <div class="filter-intensity">
                    <label>Intensity:</label>
                    <input type="range" id="intensity" min="0" max="100" value="100">
                    <span id="intensityValue">100%</span>
                </div>

                <div class="action-buttons">
                    <button class="action-btn capture" id="captureBtn">
                        <span>ðŸ“¸</span> Capture
                    </button>
                    <button class="action-btn save" id="saveBtn" disabled>
                        <span>ðŸ’¾</span> Save Last
                    </button>
                </div>
            </div>

            <div class="snapshots" id="snapshotsSection">
                <h3>Captured Snapshots</h3>
                <div class="snapshot-grid" id="snapshotGrid"></div>
            </div>
        </main>
    </div>

    <div class="flash" id="flash"></div>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('startBtn');
        const controlsSection = document.getElementById('controlsSection');
        const captureBtn = document.getElementById('captureBtn');
        const saveBtn = document.getElementById('saveBtn');
        const filterName = document.getElementById('filterName');
        const intensitySlider = document.getElementById('intensity');
        const intensityValue = document.getElementById('intensityValue');
        const snapshotGrid = document.getElementById('snapshotGrid');
        const flash = document.getElementById('flash');

        let currentFilter = 'none';
        let intensity = 1;
        let isStreaming = false;
        let lastSnapshot = null;
        let snapshots = [];
        let animationId = null;
        let time = 0;

        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                filterName.textContent = btn.textContent;
            });
        });

        // Intensity slider
        intensitySlider.addEventListener('input', (e) => {
            intensity = e.target.value / 100;
            intensityValue.textContent = `${e.target.value}%`;
        });

        // Start camera
        startBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    overlay.classList.add('hidden');
                    controlsSection.classList.remove('hidden');
                    isStreaming = true;
                    render();
                };
            } catch (err) {
                alert('Unable to access webcam. Please ensure you have granted camera permissions.');
                console.error(err);
            }
        });

        // Capture snapshot
        captureBtn.addEventListener('click', () => {
            if (!isStreaming) return;

            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 300);

            lastSnapshot = canvas.toDataURL('image/png');
            snapshots.unshift(lastSnapshot);
            saveBtn.disabled = false;

            renderSnapshots();
        });

        // Save last snapshot
        saveBtn.addEventListener('click', () => {
            if (!lastSnapshot) return;

            const link = document.createElement('a');
            link.download = `webcam-filter-${Date.now()}.png`;
            link.href = lastSnapshot;
            link.click();
        });

        // Render snapshots
        function renderSnapshots() {
            snapshotGrid.innerHTML = snapshots.map((snap, index) => `
                <div class="snapshot-item" data-index="${index}">
                    <img src="${snap}" alt="Snapshot ${index + 1}">
                    <button class="delete-btn" onclick="deleteSnapshot(${index})">âœ•</button>
                </div>
            `).join('');

            document.querySelectorAll('.snapshot-item img').forEach((img, i) => {
                img.addEventListener('click', () => {
                    const link = document.createElement('a');
                    link.download = `webcam-filter-${Date.now()}.png`;
                    link.href = snapshots[i];
                    link.click();
                });
            });
        }

        window.deleteSnapshot = (index) => {
            snapshots.splice(index, 1);
            if (snapshots.length === 0) {
                lastSnapshot = null;
                saveBtn.disabled = true;
            } else {
                lastSnapshot = snapshots[0];
            }
            renderSnapshots();
        };

        // Main render loop
        function render() {
            if (!isStreaming) return;

            time += 0.016;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            if (currentFilter !== 'none') {
                applyFilter(currentFilter);
            }

            animationId = requestAnimationFrame(render);
        }

        // Apply filters
        function applyFilter(filter) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            switch (filter) {
                case 'grayscale':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = lerp(data[i], avg, intensity);
                        data[i + 1] = lerp(data[i + 1], avg, intensity);
                        data[i + 2] = lerp(data[i + 2], avg, intensity);
                    }
                    break;

                case 'sepia':
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        data[i] = lerp(r, Math.min(255, r * 0.393 + g * 0.769 + b * 0.189), intensity);
                        data[i + 1] = lerp(g, Math.min(255, r * 0.349 + g * 0.686 + b * 0.168), intensity);
                        data[i + 2] = lerp(b, Math.min(255, r * 0.272 + g * 0.534 + b * 0.131), intensity);
                    }
                    break;

                case 'invert':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = lerp(data[i], 255 - data[i], intensity);
                        data[i + 1] = lerp(data[i + 1], 255 - data[i + 1], intensity);
                        data[i + 2] = lerp(data[i + 2], 255 - data[i + 2], intensity);
                    }
                    break;

                case 'pixelate':
                    const pixelSize = Math.max(2, Math.floor(20 * intensity));
                    for (let y = 0; y < height; y += pixelSize) {
                        for (let x = 0; x < width; x += pixelSize) {
                            const i = (y * width + x) * 4;
                            const r = data[i], g = data[i + 1], b = data[i + 2];

                            for (let py = 0; py < pixelSize && y + py < height; py++) {
                                for (let px = 0; px < pixelSize && x + px < width; px++) {
                                    const pi = ((y + py) * width + (x + px)) * 4;
                                    data[pi] = r;
                                    data[pi + 1] = g;
                                    data[pi + 2] = b;
                                }
                            }
                        }
                    }
                    break;

                case 'blur':
                    const blurRadius = Math.max(1, Math.floor(5 * intensity));
                    const tempData = new Uint8ClampedArray(data);
                    for (let y = blurRadius; y < height - blurRadius; y++) {
                        for (let x = blurRadius; x < width - blurRadius; x++) {
                            let r = 0, g = 0, b = 0, count = 0;
                            for (let dy = -blurRadius; dy <= blurRadius; dy++) {
                                for (let dx = -blurRadius; dx <= blurRadius; dx++) {
                                    const i = ((y + dy) * width + (x + dx)) * 4;
                                    r += tempData[i];
                                    g += tempData[i + 1];
                                    b += tempData[i + 2];
                                    count++;
                                }
                            }
                            const i = (y * width + x) * 4;
                            data[i] = r / count;
                            data[i + 1] = g / count;
                            data[i + 2] = b / count;
                        }
                    }
                    break;

                case 'emboss':
                    const embossData = new Uint8ClampedArray(data);
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const i = (y * width + x) * 4;
                            const iPrev = ((y - 1) * width + (x - 1)) * 4;
                            const iNext = ((y + 1) * width + (x + 1)) * 4;

                            for (let c = 0; c < 3; c++) {
                                const val = 128 + (embossData[iNext + c] - embossData[iPrev + c]) * 2;
                                data[i + c] = lerp(embossData[i + c], Math.max(0, Math.min(255, val)), intensity);
                            }
                        }
                    }
                    break;

                case 'edge':
                    const edgeData = new Uint8ClampedArray(data);
                    const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
                    const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            let gx = 0, gy = 0;
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    const ki = (ky + 1) * 3 + (kx + 1);
                                    const pi = ((y + ky) * width + (x + kx)) * 4;
                                    const gray = (edgeData[pi] + edgeData[pi + 1] + edgeData[pi + 2]) / 3;
                                    gx += gray * sobelX[ki];
                                    gy += gray * sobelY[ki];
                                }
                            }
                            const magnitude = Math.sqrt(gx * gx + gy * gy);
                            const i = (y * width + x) * 4;
                            const edge = Math.min(255, magnitude);
                            data[i] = lerp(edgeData[i], edge, intensity);
                            data[i + 1] = lerp(edgeData[i + 1], edge, intensity);
                            data[i + 2] = lerp(edgeData[i + 2], edge, intensity);
                        }
                    }
                    break;

                case 'thermal':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const normalized = avg / 255;

                        let r, g, b;
                        if (normalized < 0.25) {
                            r = 0;
                            g = normalized * 4 * 255;
                            b = 255;
                        } else if (normalized < 0.5) {
                            r = 0;
                            g = 255;
                            b = (1 - (normalized - 0.25) * 4) * 255;
                        } else if (normalized < 0.75) {
                            r = (normalized - 0.5) * 4 * 255;
                            g = 255;
                            b = 0;
                        } else {
                            r = 255;
                            g = (1 - (normalized - 0.75) * 4) * 255;
                            b = 0;
                        }

                        data[i] = lerp(data[i], r, intensity);
                        data[i + 1] = lerp(data[i + 1], g, intensity);
                        data[i + 2] = lerp(data[i + 2], b, intensity);
                    }
                    break;

                case 'vhs':
                    // Add scanlines and color bleeding
                    for (let y = 0; y < height; y++) {
                        const scanline = Math.sin(y * 0.5 + time * 10) * 0.1 * intensity;
                        const offset = Math.floor(Math.sin(time * 5 + y * 0.1) * 3 * intensity);

                        for (let x = 0; x < width; x++) {
                            const i = (y * width + x) * 4;
                            const iOffset = (y * width + Math.max(0, Math.min(width - 1, x + offset))) * 4;

                            // Color bleeding
                            data[i] = Math.min(255, data[iOffset] + (Math.random() * 20 - 10) * intensity);
                            data[i + 1] = Math.min(255, data[i + 1] + (Math.random() * 20 - 10) * intensity);

                            // Scanlines
                            if (y % 2 === 0) {
                                data[i] *= (1 - 0.2 * intensity);
                                data[i + 1] *= (1 - 0.2 * intensity);
                                data[i + 2] *= (1 - 0.2 * intensity);
                            }

                            // Add noise
                            const noise = (Math.random() - 0.5) * 30 * intensity;
                            data[i] = Math.max(0, Math.min(255, data[i] + noise));
                            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
                        }
                    }
                    break;

                case 'rainbow':
                    for (let i = 0; i < data.length; i += 4) {
                        const x = (i / 4) % width;
                        const y = Math.floor((i / 4) / width);
                        const hue = ((x + y + time * 100) % 360) / 360;

                        const rgb = hslToRgb(hue, 0.7, 0.5);
                        data[i] = lerp(data[i], (data[i] + rgb[0]) / 2, intensity);
                        data[i + 1] = lerp(data[i + 1], (data[i + 1] + rgb[1]) / 2, intensity);
                        data[i + 2] = lerp(data[i + 2], (data[i + 2] + rgb[2]) / 2, intensity);
                    }
                    break;

                case 'mirror':
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width / 2; x++) {
                            const i = (y * width + x) * 4;
                            const mirrorI = (y * width + (width - 1 - x)) * 4;

                            data[mirrorI] = data[i];
                            data[mirrorI + 1] = data[i + 1];
                            data[mirrorI + 2] = data[i + 2];
                        }
                    }
                    break;

                case 'kaleidoscope':
                    const tempKaleid = new Uint8ClampedArray(data);
                    const segments = 8;
                    const cx = width / 2;
                    const cy = height / 2;

                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const dx = x - cx;
                            const dy = y - cy;
                            let angle = Math.atan2(dy, dx);
                            const radius = Math.sqrt(dx * dx + dy * dy);

                            const segmentAngle = (2 * Math.PI) / segments;
                            angle = Math.abs(((angle % segmentAngle) + segmentAngle) % segmentAngle);
                            if (Math.floor((Math.atan2(dy, dx) + Math.PI) / segmentAngle) % 2 === 1) {
                                angle = segmentAngle - angle;
                            }

                            const srcX = Math.floor(cx + radius * Math.cos(angle));
                            const srcY = Math.floor(cy + radius * Math.sin(angle));

                            if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                                const i = (y * width + x) * 4;
                                const srcI = (srcY * width + srcX) * 4;

                                data[i] = lerp(tempKaleid[i], tempKaleid[srcI], intensity);
                                data[i + 1] = lerp(tempKaleid[i + 1], tempKaleid[srcI + 1], intensity);
                                data[i + 2] = lerp(tempKaleid[i + 2], tempKaleid[srcI + 2], intensity);
                            }
                        }
                    }
                    break;

                case 'comic':
                    // Posterize and add outlines
                    const levels = 5;
                    const comicData = new Uint8ClampedArray(data);

                    for (let i = 0; i < data.length; i += 4) {
                        // Posterize
                        data[i] = Math.floor(data[i] / (256 / levels)) * (256 / levels);
                        data[i + 1] = Math.floor(data[i + 1] / (256 / levels)) * (256 / levels);
                        data[i + 2] = Math.floor(data[i + 2] / (256 / levels)) * (256 / levels);

                        // Increase saturation
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = lerp(avg, data[i], 1.5);
                        data[i + 1] = lerp(avg, data[i + 1], 1.5);
                        data[i + 2] = lerp(avg, data[i + 2], 1.5);
                    }

                    // Apply based on intensity
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = lerp(comicData[i], data[i], intensity);
                        data[i + 1] = lerp(comicData[i + 1], data[i + 1], intensity);
                        data[i + 2] = lerp(comicData[i + 2], data[i + 2], intensity);
                    }
                    break;

                case 'glitch':
                    const glitchData = new Uint8ClampedArray(data);
                    const numGlitches = Math.floor(5 * intensity);

                    for (let g = 0; g < numGlitches; g++) {
                        const glitchY = Math.floor(Math.random() * height);
                        const glitchH = Math.floor(Math.random() * 20 + 5);
                        const glitchOffset = Math.floor((Math.random() - 0.5) * 50 * intensity);

                        for (let y = glitchY; y < Math.min(height, glitchY + glitchH); y++) {
                            for (let x = 0; x < width; x++) {
                                const srcX = Math.max(0, Math.min(width - 1, x + glitchOffset));
                                const i = (y * width + x) * 4;
                                const srcI = (y * width + srcX) * 4;

                                // RGB shift
                                data[i] = glitchData[srcI];
                                data[i + 1] = glitchData[(y * width + Math.max(0, Math.min(width - 1, x - 3))) * 4 + 1];
                                data[i + 2] = glitchData[(y * width + Math.max(0, Math.min(width - 1, x + 3))) * 4 + 2];
                            }
                        }
                    }

                    // Random color blocks
                    if (Math.random() < 0.3 * intensity) {
                        const blockX = Math.floor(Math.random() * width);
                        const blockY = Math.floor(Math.random() * height);
                        const blockW = Math.floor(Math.random() * 100 + 20);
                        const blockH = Math.floor(Math.random() * 30 + 5);

                        for (let y = blockY; y < Math.min(height, blockY + blockH); y++) {
                            for (let x = blockX; x < Math.min(width, blockX + blockW); x++) {
                                const i = (y * width + x) * 4;
                                data[i] = Math.random() * 255;
                                data[i + 1] = Math.random() * 255;
                                data[i + 2] = Math.random() * 255;
                            }
                        }
                    }
                    break;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Helper functions
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
    </script>
</body>
</html>
