<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinetic Typography Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500;700;900&family=Playfair+Display:wght@400;700;900&family=Montserrat:wght@100;300;400;600;700;900&family=Dancing+Script:wght@400;700&family=Oswald:wght@300;400;700&family=Bebas+Neue&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f0f1a;
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --border: #2a2a4a;
            --success: #4ade80;
            --warning: #fbbf24;
            --panel-bg: rgba(22, 33, 62, 0.95);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Layout */
        .app-container {
            display: grid;
            grid-template-rows: 50px 1fr 200px;
            grid-template-columns: 280px 1fr 300px;
            height: 100vh;
            gap: 1px;
            background: var(--border);
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo svg {
            width: 24px;
            height: 24px;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-icon {
            padding: 8px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .btn-icon:hover {
            color: var(--text-primary);
            border-color: var(--accent);
        }

        .btn-icon.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        /* Panels */
        .panel {
            background: var(--bg-secondary);
            overflow-y: auto;
            padding: 15px;
        }

        .panel-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section-title {
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Left Panel - Tools */
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Canvas Area */
        .canvas-container {
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .canvas-wrapper {
            position: relative;
            background: #000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #mainCanvas {
            display: block;
        }

        .safe-area-guide {
            position: absolute;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.2;
        }

        /* Right Panel - Properties */
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .form-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .form-select {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .form-row {
            display: flex;
            gap: 10px;
        }

        .form-row .form-group {
            flex: 1;
        }

        /* Range Slider */
        .range-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            cursor: pointer;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .range-value {
            min-width: 40px;
            text-align: right;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Color Picker */
        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid var(--border);
            cursor: pointer;
        }

        .color-input {
            opacity: 0;
            position: absolute;
            width: 30px;
            height: 30px;
        }

        /* Timeline */
        .timeline {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            border-top: 1px solid var(--border);
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            gap: 15px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .playback-controls {
            display: flex;
            gap: 5px;
        }

        .time-display {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
            min-width: 120px;
        }

        .timeline-zoom {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: auto;
        }

        .timeline-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .timeline-labels {
            width: 150px;
            flex-shrink: 0;
            border-right: 1px solid var(--border);
            overflow-y: auto;
        }

        .timeline-track-label {
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border);
            cursor: pointer;
        }

        .timeline-track-label:hover {
            background: var(--bg-tertiary);
        }

        .timeline-track-label.active {
            color: var(--accent);
        }

        .timeline-tracks {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
        }

        .timeline-ruler {
            height: 25px;
            background: var(--bg-tertiary);
            position: sticky;
            top: 0;
            z-index: 10;
            border-bottom: 1px solid var(--border);
        }

        .timeline-track {
            height: 30px;
            position: relative;
            border-bottom: 1px solid var(--border);
        }

        .keyframe {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent);
            transform: rotate(45deg) translateY(-50%);
            top: 50%;
            margin-left: -6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }

        .keyframe:hover, .keyframe.selected {
            border-color: white;
            transform: rotate(45deg) translateY(-50%) scale(1.2);
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--accent);
            z-index: 20;
            pointer-events: none;
        }

        .playhead::before {
            content: '';
            position: absolute;
            top: 0;
            left: -5px;
            width: 12px;
            height: 12px;
            background: var(--accent);
            clip-path: polygon(50% 100%, 0 0, 100% 0);
        }

        /* Preset Cards */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .preset-card {
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .preset-card:hover {
            border-color: var(--accent);
            background: rgba(233, 69, 96, 0.1);
        }

        .preset-card.active {
            border-color: var(--accent);
            background: rgba(233, 69, 96, 0.2);
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 15px;
        }

        .tab {
            padding: 8px 15px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        /* Aspect Ratio Buttons */
        .aspect-buttons {
            display: flex;
            gap: 8px;
        }

        .aspect-btn {
            flex: 1;
            padding: 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .aspect-btn:hover {
            border-color: var(--accent);
        }

        .aspect-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 25px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border);
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        /* Audio Waveform */
        .waveform-container {
            height: 60px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            margin-bottom: 10px;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
        }

        .beat-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--warning);
            opacity: 0.7;
        }

        /* Easing Curve Editor */
        .easing-preview {
            width: 100%;
            height: 100px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 10px;
        }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toggle {
            position: relative;
            width: 40px;
            height: 22px;
            background: var(--border);
            border-radius: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .toggle.active::after {
            left: 21px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Export Progress */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s;
        }

        /* Text Editor */
        .text-editor {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1rem;
            resize: vertical;
            font-family: inherit;
        }

        .text-editor:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Keyboard Shortcuts Help */
        .shortcuts-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px 15px;
            font-size: 0.85rem;
        }

        .shortcut-key {
            background: var(--bg-tertiary);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8rem;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-columns: 250px 1fr 250px;
            }
        }

        @media (max-width: 900px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: 50px auto 1fr 180px;
            }

            .left-panel, .right-panel {
                display: none;
            }

            .left-panel.mobile-active, .right-panel.mobile-active {
                display: flex;
                position: fixed;
                top: 50px;
                bottom: 180px;
                width: 280px;
                z-index: 100;
            }

            .left-panel.mobile-active {
                left: 0;
            }

            .right-panel.mobile-active {
                right: 0;
            }
        }

        /* Animation Classes */
        .fade-in {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Tooltip */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.75rem;
            white-space: nowrap;
            border-radius: 4px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            pointer-events: none;
            z-index: 100;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Gradient Editor */
        .gradient-stops {
            position: relative;
            height: 30px;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .gradient-stop {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid var(--border);
            border-radius: 50%;
            top: 100%;
            transform: translate(-50%, -50%);
            cursor: grab;
        }

        .gradient-stop.active {
            border-color: var(--accent);
        }

        /* Loading Spinner */
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Notification */
        .notification {
            position: fixed;
            bottom: 220px;
            right: 20px;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.85rem;
            z-index: 1000;
            transform: translateX(120%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-color: var(--success);
        }

        .notification.error {
            border-color: var(--accent);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header" role="banner">
            <div class="logo">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M3 17h18v2H3v-2zm0-7h18v5H3v-5zm0-4h18v2H3V6z"/>
                </svg>
                Kinetic Typography Studio
            </div>
            <div class="header-controls">
                <button class="btn btn-secondary" id="newProjectBtn" aria-label="New Project" data-tooltip="New Project (Ctrl+N)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                    New
                </button>
                <button class="btn btn-secondary" id="loadAudioBtn" aria-label="Load Audio" data-tooltip="Load Audio File">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 18V5l12-2v13"/>
                        <circle cx="6" cy="18" r="3"/>
                        <circle cx="18" cy="16" r="3"/>
                    </svg>
                    Audio
                </button>
                <button class="btn btn-primary" id="exportBtn" aria-label="Export" data-tooltip="Export Video (Ctrl+E)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Export
                </button>
                <button class="btn btn-icon" id="helpBtn" aria-label="Help" data-tooltip="Keyboard Shortcuts (?)">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                        <line x1="12" y1="17" x2="12.01" y2="17"/>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Left Panel - Presets & Animation -->
        <aside class="panel left-panel" role="complementary" aria-label="Animation Presets">
            <div class="panel-section">
                <h2 class="panel-title">Text Input</h2>
                <textarea class="text-editor" id="textInput" placeholder="Enter your text here..." aria-label="Text content">KINETIC</textarea>
            </div>

            <div class="panel-section">
                <h2 class="panel-title">Animation Presets</h2>
                <div class="preset-grid" role="listbox" aria-label="Animation presets">
                    <div class="preset-card active" data-preset="typewriter" role="option" tabindex="0">Typewriter</div>
                    <div class="preset-card" data-preset="bounce" role="option" tabindex="0">Bounce</div>
                    <div class="preset-card" data-preset="liquid" role="option" tabindex="0">Liquid</div>
                    <div class="preset-card" data-preset="glitch" role="option" tabindex="0">Glitch</div>
                    <div class="preset-card" data-preset="fadeUp" role="option" tabindex="0">Fade Up</div>
                    <div class="preset-card" data-preset="cascade" role="option" tabindex="0">Cascade</div>
                    <div class="preset-card" data-preset="wave" role="option" tabindex="0">Wave</div>
                    <div class="preset-card" data-preset="elastic" role="option" tabindex="0">Elastic</div>
                </div>
            </div>

            <div class="panel-section">
                <h3 class="panel-section-title">Stagger Mode</h3>
                <select class="form-select" id="staggerMode" aria-label="Stagger mode">
                    <option value="letter">Per Letter</option>
                    <option value="word">Per Word</option>
                    <option value="line">Per Line</option>
                </select>
                <div class="form-group" style="margin-top: 10px;">
                    <label class="form-label">Stagger Delay (ms)</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="staggerDelay" min="0" max="200" value="50" aria-label="Stagger delay">
                        <span class="range-value" id="staggerDelayValue">50</span>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2 class="panel-title">Easing</h2>
                <select class="form-select" id="easingPreset" aria-label="Easing preset">
                    <option value="linear">Linear</option>
                    <option value="easeInOut" selected>Ease In Out</option>
                    <option value="easeIn">Ease In</option>
                    <option value="easeOut">Ease Out</option>
                    <option value="easeInBack">Ease In Back</option>
                    <option value="easeOutBack">Ease Out Back</option>
                    <option value="easeInElastic">Ease In Elastic</option>
                    <option value="easeOutElastic">Ease Out Elastic</option>
                    <option value="easeOutBounce">Ease Out Bounce</option>
                    <option value="custom">Custom Bézier</option>
                </select>
                <canvas id="easingCanvas" class="easing-preview" width="240" height="100" aria-label="Easing curve preview"></canvas>
                <div id="customBezier" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">X1</label>
                            <input type="number" class="form-input" id="bezierX1" value="0.42" step="0.01" min="0" max="1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Y1</label>
                            <input type="number" class="form-input" id="bezierY1" value="0" step="0.01">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">X2</label>
                            <input type="number" class="form-input" id="bezierX2" value="0.58" step="0.01" min="0" max="1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Y2</label>
                            <input type="number" class="form-input" id="bezierY2" value="1" step="0.01">
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2 class="panel-title">Audio Reactive</h2>
                <div class="waveform-container" id="waveformContainer">
                    <canvas id="waveformCanvas"></canvas>
                </div>
                <div class="toggle-container">
                    <span class="form-label">Snap to Beats</span>
                    <div class="toggle" id="snapToBeats" role="switch" aria-checked="false" tabindex="0"></div>
                </div>
                <div class="form-group" style="margin-top: 10px;">
                    <label class="form-label">Beat Sensitivity</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="beatSensitivity" min="0" max="100" value="50" aria-label="Beat sensitivity">
                        <span class="range-value">50</span>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Canvas Area -->
        <main class="canvas-container" role="main" aria-label="Canvas preview">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="mainCanvas" width="1920" height="1080"></canvas>
                <div class="safe-area-guide" id="safeArea" style="display: none;"></div>
                <canvas id="gridCanvas" class="grid-overlay" style="display: none;"></canvas>
            </div>
        </main>

        <!-- Right Panel - Style Controls -->
        <aside class="panel right-panel" role="complementary" aria-label="Style controls">
            <div class="panel-section">
                <h2 class="panel-title">Layout</h2>
                <div class="aspect-buttons">
                    <button class="aspect-btn" data-aspect="1:1" aria-label="1:1 aspect ratio">1:1</button>
                    <button class="aspect-btn active" data-aspect="16:9" aria-label="16:9 aspect ratio">16:9</button>
                    <button class="aspect-btn" data-aspect="9:16" aria-label="9:16 aspect ratio">9:16</button>
                </div>
                <div class="form-row" style="margin-top: 10px;">
                    <div class="toggle-container" style="flex: 1;">
                        <span class="form-label">Safe Area</span>
                        <div class="toggle" id="safeAreaToggle" role="switch" aria-checked="false" tabindex="0"></div>
                    </div>
                    <div class="toggle-container" style="flex: 1;">
                        <span class="form-label">Grid</span>
                        <div class="toggle" id="gridToggle" role="switch" aria-checked="false" tabindex="0"></div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2 class="panel-title">Typography</h2>
                <div class="form-group">
                    <label class="form-label">Font Family</label>
                    <select class="form-select" id="fontFamily" aria-label="Font family">
                        <option value="Roboto">Roboto</option>
                        <option value="Montserrat">Montserrat</option>
                        <option value="Playfair Display">Playfair Display</option>
                        <option value="Oswald">Oswald</option>
                        <option value="Bebas Neue">Bebas Neue</option>
                        <option value="Dancing Script">Dancing Script</option>
                        <option value="Arial">Arial (System)</option>
                        <option value="Georgia">Georgia (System)</option>
                        <option value="Times New Roman">Times New Roman (System)</option>
                    </select>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Weight</label>
                        <select class="form-select" id="fontWeight" aria-label="Font weight">
                            <option value="100">Thin</option>
                            <option value="300">Light</option>
                            <option value="400">Regular</option>
                            <option value="500">Medium</option>
                            <option value="600">Semi Bold</option>
                            <option value="700" selected>Bold</option>
                            <option value="900">Black</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Style</label>
                        <select class="form-select" id="fontStyle" aria-label="Font style">
                            <option value="normal">Normal</option>
                            <option value="italic">Italic</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Font Size</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="fontSize" min="12" max="400" value="120" aria-label="Font size">
                        <span class="range-value" id="fontSizeValue">120px</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Letter Spacing (Tracking)</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="letterSpacing" min="-20" max="50" value="0" aria-label="Letter spacing">
                        <span class="range-value" id="letterSpacingValue">0px</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Line Height</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="lineHeight" min="0.8" max="3" value="1.2" step="0.1" aria-label="Line height">
                        <span class="range-value" id="lineHeightValue">1.2</span>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2 class="panel-title">Colors</h2>
                <div class="form-group">
                    <label class="form-label">Fill Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" class="color-input" id="fillColor" value="#ffffff" aria-label="Fill color">
                        <div class="color-preview" id="fillColorPreview" style="background: #ffffff;"></div>
                        <input type="text" class="form-input" id="fillColorHex" value="#ffffff" style="flex: 1;">
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Stroke Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" class="color-input" id="strokeColor" value="#e94560" aria-label="Stroke color">
                        <div class="color-preview" id="strokeColorPreview" style="background: #e94560;"></div>
                        <input type="text" class="form-input" id="strokeColorHex" value="#e94560" style="flex: 1;">
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Stroke Width</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="strokeWidth" min="0" max="20" value="0" aria-label="Stroke width">
                        <span class="range-value" id="strokeWidthValue">0px</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Background Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" class="color-input" id="bgColor" value="#000000" aria-label="Background color">
                        <div class="color-preview" id="bgColorPreview" style="background: #000000;"></div>
                        <input type="text" class="form-input" id="bgColorHex" value="#000000" style="flex: 1;">
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2 class="panel-title">Effects</h2>
                <div class="form-group">
                    <label class="form-label">Shadow Blur</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="shadowBlur" min="0" max="50" value="0" aria-label="Shadow blur">
                        <span class="range-value" id="shadowBlurValue">0px</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Shadow Offset X</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="shadowX" min="-50" max="50" value="0" aria-label="Shadow X offset">
                        <span class="range-value" id="shadowXValue">0px</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Shadow Offset Y</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="shadowY" min="-50" max="50" value="0" aria-label="Shadow Y offset">
                        <span class="range-value" id="shadowYValue">0px</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Shadow Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" class="color-input" id="shadowColor" value="#000000" aria-label="Shadow color">
                        <div class="color-preview" id="shadowColorPreview" style="background: #000000;"></div>
                        <input type="text" class="form-input" id="shadowColorHex" value="#000000" style="flex: 1;">
                    </div>
                </div>
                <div class="toggle-container" style="margin-top: 10px;">
                    <span class="form-label">Motion Blur</span>
                    <div class="toggle" id="motionBlurToggle" role="switch" aria-checked="false" tabindex="0"></div>
                </div>
            </div>

            <div class="panel-section">
                <h2 class="panel-title">Transform</h2>
                <div class="form-group">
                    <label class="form-label">Position X</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="posX" min="-500" max="500" value="0" aria-label="Position X">
                        <span class="range-value" id="posXValue">0</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Position Y</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="posY" min="-500" max="500" value="0" aria-label="Position Y">
                        <span class="range-value" id="posYValue">0</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Scale</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="scale" min="0.1" max="3" value="1" step="0.01" aria-label="Scale">
                        <span class="range-value" id="scaleValue">100%</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Rotation</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="rotation" min="-180" max="180" value="0" aria-label="Rotation">
                        <span class="range-value" id="rotationValue">0°</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Opacity</label>
                    <div class="range-container">
                        <input type="range" class="range-slider" id="opacity" min="0" max="1" value="1" step="0.01" aria-label="Opacity">
                        <span class="range-value" id="opacityValue">100%</span>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Timeline -->
        <section class="timeline" role="region" aria-label="Timeline editor">
            <div class="timeline-controls">
                <div class="playback-controls">
                    <button class="btn btn-icon" id="skipStartBtn" aria-label="Skip to start" data-tooltip="Skip to Start (Home)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 6h2v12H6V6zm3.5 6l8.5 6V6l-8.5 6z"/>
                        </svg>
                    </button>
                    <button class="btn btn-icon" id="playBtn" aria-label="Play" data-tooltip="Play/Pause (Space)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" id="playIcon">
                            <path d="M8 5v14l11-7L8 5z"/>
                        </svg>
                    </button>
                    <button class="btn btn-icon" id="skipEndBtn" aria-label="Skip to end" data-tooltip="Skip to End (End)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 18l8.5-6L6 6v12zm10-12v12h2V6h-2z"/>
                        </svg>
                    </button>
                </div>
                <div class="time-display" id="timeDisplay" aria-live="polite">00:00.000 / 03:00.000</div>
                <button class="btn btn-secondary" id="addKeyframeBtn" aria-label="Add keyframe" data-tooltip="Add Keyframe (K)">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add Keyframe
                </button>
                <button class="btn btn-secondary" id="deleteKeyframeBtn" aria-label="Delete keyframe" data-tooltip="Delete Selected Keyframe (Del)">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                </button>
                <div class="timeline-zoom">
                    <span class="form-label" style="margin: 0;">Duration:</span>
                    <select class="form-select" id="durationSelect" style="width: auto;" aria-label="Animation duration">
                        <option value="1">1s</option>
                        <option value="2">2s</option>
                        <option value="3" selected>3s</option>
                        <option value="5">5s</option>
                        <option value="10">10s</option>
                        <option value="15">15s</option>
                        <option value="30">30s</option>
                        <option value="60">60s</option>
                    </select>
                </div>
            </div>
            <div class="timeline-content">
                <div class="timeline-labels">
                    <div class="timeline-track-label active" data-track="position">Position</div>
                    <div class="timeline-track-label" data-track="scale">Scale</div>
                    <div class="timeline-track-label" data-track="rotation">Rotation</div>
                    <div class="timeline-track-label" data-track="opacity">Opacity</div>
                    <div class="timeline-track-label" data-track="letterOffset">Letter Offset</div>
                    <div class="timeline-track-label" data-track="tracking">Tracking</div>
                </div>
                <div class="timeline-tracks" id="timelineTracks">
                    <canvas id="timelineCanvas" width="2000" height="200"></canvas>
                    <div class="playhead" id="playhead" style="left: 0;"></div>
                </div>
            </div>
        </section>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal" role="dialog" aria-labelledby="exportModalTitle" aria-modal="true">
        <div class="modal">
            <h2 class="modal-title" id="exportModalTitle">Export Settings</h2>
            <div class="form-group">
                <label class="form-label">Format</label>
                <select class="form-select" id="exportFormat" aria-label="Export format">
                    <option value="webm">WebM (Video)</option>
                    <option value="gif">GIF (Animated)</option>
                    <option value="png">PNG Sequence</option>
                </select>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Width</label>
                    <input type="number" class="form-input" id="exportWidth" value="1920" aria-label="Export width">
                </div>
                <div class="form-group">
                    <label class="form-label">Height</label>
                    <input type="number" class="form-input" id="exportHeight" value="1080" aria-label="Export height">
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Frame Rate</label>
                <select class="form-select" id="exportFps" aria-label="Export frame rate">
                    <option value="24">24 fps</option>
                    <option value="30" selected>30 fps</option>
                    <option value="60">60 fps</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Quality</label>
                <div class="range-container">
                    <input type="range" class="range-slider" id="exportQuality" min="0.1" max="1" value="0.9" step="0.1" aria-label="Export quality">
                    <span class="range-value" id="exportQualityValue">90%</span>
                </div>
            </div>
            <div class="progress-bar" id="exportProgress" style="display: none;">
                <div class="progress-fill" id="exportProgressFill"></div>
            </div>
            <div id="exportStatus" style="text-align: center; margin: 10px 0; font-size: 0.85rem; color: var(--text-secondary);"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="cancelExportBtn">Cancel</button>
                <button class="btn btn-primary" id="startExportBtn">Export</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal" role="dialog" aria-labelledby="helpModalTitle" aria-modal="true">
        <div class="modal">
            <h2 class="modal-title" id="helpModalTitle">Keyboard Shortcuts</h2>
            <div class="shortcuts-grid">
                <span class="shortcut-key">Space</span><span>Play / Pause</span>
                <span class="shortcut-key">K</span><span>Add Keyframe</span>
                <span class="shortcut-key">Del</span><span>Delete Selected Keyframe</span>
                <span class="shortcut-key">Home</span><span>Go to Start</span>
                <span class="shortcut-key">End</span><span>Go to End</span>
                <span class="shortcut-key">←</span><span>Previous Frame</span>
                <span class="shortcut-key">→</span><span>Next Frame</span>
                <span class="shortcut-key">Ctrl+N</span><span>New Project</span>
                <span class="shortcut-key">Ctrl+E</span><span>Export</span>
                <span class="shortcut-key">Ctrl+S</span><span>Save to Local Storage</span>
                <span class="shortcut-key">G</span><span>Toggle Grid</span>
                <span class="shortcut-key">S</span><span>Toggle Safe Area</span>
                <span class="shortcut-key">?</span><span>Show Help</span>
                <span class="shortcut-key">Esc</span><span>Close Modal</span>
            </div>
            <div class="modal-actions">
                <button class="btn btn-primary" id="closeHelpBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- Hidden Audio Input -->
    <input type="file" id="audioInput" accept="audio/*" style="display: none;">

    <!-- Notification -->
    <div class="notification" id="notification" aria-live="polite"></div>

    <script>
        // ==========================================
        // KINETIC TYPOGRAPHY STUDIO
        // ==========================================

        (function() {
            'use strict';

            // Check for reduced motion preference
            const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            // ==========================================
            // STATE MANAGEMENT
            // ==========================================
            const state = {
                text: 'KINETIC',
                currentPreset: 'typewriter',
                staggerMode: 'letter',
                staggerDelay: 50,
                easing: 'easeInOut',
                customBezier: [0.42, 0, 0.58, 1],

                // Typography
                fontFamily: 'Roboto',
                fontWeight: '700',
                fontStyle: 'normal',
                fontSize: 120,
                letterSpacing: 0,
                lineHeight: 1.2,

                // Colors
                fillColor: '#ffffff',
                strokeColor: '#e94560',
                strokeWidth: 0,
                bgColor: '#000000',

                // Effects
                shadowBlur: 0,
                shadowX: 0,
                shadowY: 0,
                shadowColor: '#000000',
                motionBlur: false,

                // Transform
                posX: 0,
                posY: 0,
                scale: 1,
                rotation: 0,
                opacity: 1,

                // Layout
                aspect: '16:9',
                showSafeArea: false,
                showGrid: false,
                canvasWidth: 1920,
                canvasHeight: 1080,

                // Timeline
                duration: 3,
                currentTime: 0,
                isPlaying: false,
                selectedTrack: 'position',
                selectedKeyframe: null,

                // Keyframes per track
                keyframes: {
                    position: [
                        { time: 0, x: 0, y: 0 },
                        { time: 3, x: 0, y: 0 }
                    ],
                    scale: [
                        { time: 0, value: 1 },
                        { time: 3, value: 1 }
                    ],
                    rotation: [
                        { time: 0, value: 0 },
                        { time: 3, value: 0 }
                    ],
                    opacity: [
                        { time: 0, value: 1 },
                        { time: 3, value: 1 }
                    ],
                    letterOffset: [
                        { time: 0, value: 0 },
                        { time: 3, value: 0 }
                    ],
                    tracking: [
                        { time: 0, value: 0 },
                        { time: 3, value: 0 }
                    ]
                },

                // Audio
                audioBuffer: null,
                audioContext: null,
                beats: [],
                snapToBeats: false,
                beatSensitivity: 50
            };

            // ==========================================
            // DOM ELEMENTS
            // ==========================================
            const elements = {
                mainCanvas: document.getElementById('mainCanvas'),
                canvasWrapper: document.getElementById('canvasWrapper'),
                timelineCanvas: document.getElementById('timelineCanvas'),
                easingCanvas: document.getElementById('easingCanvas'),
                waveformCanvas: document.getElementById('waveformCanvas'),
                gridCanvas: document.getElementById('gridCanvas'),
                playhead: document.getElementById('playhead'),
                timeDisplay: document.getElementById('timeDisplay'),
                playBtn: document.getElementById('playBtn'),
                playIcon: document.getElementById('playIcon'),
                textInput: document.getElementById('textInput'),
                notification: document.getElementById('notification'),
                exportModal: document.getElementById('exportModal'),
                helpModal: document.getElementById('helpModal'),
                safeArea: document.getElementById('safeArea'),
                timelineTracks: document.getElementById('timelineTracks'),
                exportProgress: document.getElementById('exportProgress'),
                exportProgressFill: document.getElementById('exportProgressFill'),
                exportStatus: document.getElementById('exportStatus')
            };

            const ctx = elements.mainCanvas.getContext('2d');
            const timelineCtx = elements.timelineCanvas.getContext('2d');
            const easingCtx = elements.easingCanvas.getContext('2d');
            const waveformCtx = elements.waveformCanvas.getContext('2d');

            // ==========================================
            // EASING FUNCTIONS
            // ==========================================
            const easingFunctions = {
                linear: t => t,
                easeInOut: t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
                easeIn: t => t * t * t,
                easeOut: t => 1 - Math.pow(1 - t, 3),
                easeInBack: t => {
                    const c1 = 1.70158;
                    const c3 = c1 + 1;
                    return c3 * t * t * t - c1 * t * t;
                },
                easeOutBack: t => {
                    const c1 = 1.70158;
                    const c3 = c1 + 1;
                    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
                },
                easeInElastic: t => {
                    const c4 = (2 * Math.PI) / 3;
                    return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
                },
                easeOutElastic: t => {
                    const c4 = (2 * Math.PI) / 3;
                    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
                },
                easeOutBounce: t => {
                    const n1 = 7.5625;
                    const d1 = 2.75;
                    if (t < 1 / d1) return n1 * t * t;
                    else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                    else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                    else return n1 * (t -= 2.625 / d1) * t + 0.984375;
                },
                custom: t => cubicBezier(state.customBezier[0], state.customBezier[1], state.customBezier[2], state.customBezier[3], t)
            };

            function cubicBezier(x1, y1, x2, y2, t) {
                // Newton-Raphson iteration for solving bezier
                const epsilon = 1e-6;
                let x = t;
                for (let i = 0; i < 8; i++) {
                    const currentX = ((1 - 3 * x2 + 3 * x1) * x + (3 * x2 - 6 * x1)) * x + 3 * x1;
                    const currentSlope = 3 * (1 - 3 * x2 + 3 * x1) * x * x + 2 * (3 * x2 - 6 * x1) * x + 3 * x1;
                    if (Math.abs(currentSlope) < epsilon) break;
                    x = x - (currentX * x - t) / currentSlope;
                }
                return ((1 - 3 * y2 + 3 * y1) * x + (3 * y2 - 6 * y1)) * x * x + 3 * y1 * x;
            }

            // ==========================================
            // ANIMATION PRESETS
            // ==========================================
            const presets = {
                typewriter: (chars, progress, index, total) => {
                    const charProgress = Math.max(0, Math.min(1, (progress * total - index) / 0.5));
                    return {
                        opacity: charProgress,
                        x: 0,
                        y: 0,
                        scale: 1,
                        rotation: 0
                    };
                },
                bounce: (chars, progress, index, total) => {
                    const delay = index / total * 0.5;
                    const p = Math.max(0, Math.min(1, (progress - delay) / (1 - 0.5)));
                    const bounce = Math.abs(Math.sin(p * Math.PI * 3)) * (1 - p);
                    return {
                        opacity: p > 0 ? 1 : 0,
                        x: 0,
                        y: -bounce * 50,
                        scale: 1,
                        rotation: 0
                    };
                },
                liquid: (chars, progress, index, total) => {
                    const delay = index / total * 0.3;
                    const p = Math.max(0, Math.min(1, (progress - delay) / (1 - 0.3)));
                    const wave = Math.sin(p * Math.PI * 2 + index) * (1 - p);
                    return {
                        opacity: p,
                        x: wave * 20,
                        y: Math.sin(p * Math.PI) * -30,
                        scale: 0.5 + p * 0.5 + wave * 0.1,
                        rotation: wave * 10
                    };
                },
                glitch: (chars, progress, index, total) => {
                    const delay = index / total * 0.2;
                    const p = Math.max(0, Math.min(1, (progress - delay) / (1 - 0.2)));
                    const glitchAmount = Math.random() * (1 - p) * 20;
                    const colorShift = Math.random() > 0.9 && p < 0.8;
                    return {
                        opacity: p > 0.1 ? 1 : 0,
                        x: (Math.random() - 0.5) * glitchAmount,
                        y: (Math.random() - 0.5) * glitchAmount,
                        scale: 1 + (Math.random() - 0.5) * (1 - p) * 0.2,
                        rotation: (Math.random() - 0.5) * glitchAmount,
                        colorShift: colorShift
                    };
                },
                fadeUp: (chars, progress, index, total) => {
                    const delay = index / total * 0.4;
                    const p = Math.max(0, Math.min(1, (progress - delay) / (1 - 0.4)));
                    const eased = easingFunctions.easeOutBack(p);
                    return {
                        opacity: p,
                        x: 0,
                        y: (1 - eased) * 50,
                        scale: 0.8 + eased * 0.2,
                        rotation: 0
                    };
                },
                cascade: (chars, progress, index, total) => {
                    const delay = index / total * 0.6;
                    const p = Math.max(0, Math.min(1, (progress - delay) / (1 - 0.6)));
                    const eased = easingFunctions.easeOutBounce(p);
                    return {
                        opacity: p,
                        x: 0,
                        y: (1 - eased) * -100,
                        scale: eased,
                        rotation: (1 - p) * 180
                    };
                },
                wave: (chars, progress, index, total) => {
                    const waveOffset = Math.sin(progress * Math.PI * 4 + index * 0.5) * 30;
                    const fadeIn = Math.min(1, progress * 3);
                    return {
                        opacity: fadeIn,
                        x: 0,
                        y: waveOffset * fadeIn,
                        scale: 1,
                        rotation: 0
                    };
                },
                elastic: (chars, progress, index, total) => {
                    const delay = index / total * 0.3;
                    const p = Math.max(0, Math.min(1, (progress - delay) / (1 - 0.3)));
                    const eased = easingFunctions.easeOutElastic(p);
                    return {
                        opacity: p > 0 ? 1 : 0,
                        x: 0,
                        y: 0,
                        scale: eased,
                        rotation: 0
                    };
                }
            };

            // ==========================================
            // INTERPOLATION
            // ==========================================
            function interpolateKeyframes(keyframes, time, property = 'value') {
                if (keyframes.length === 0) return property === 'value' ? 0 : { x: 0, y: 0 };
                if (keyframes.length === 1) {
                    return property === 'value' ? keyframes[0].value : { x: keyframes[0].x, y: keyframes[0].y };
                }

                // Find surrounding keyframes
                let prev = keyframes[0];
                let next = keyframes[keyframes.length - 1];

                for (let i = 0; i < keyframes.length - 1; i++) {
                    if (time >= keyframes[i].time && time <= keyframes[i + 1].time) {
                        prev = keyframes[i];
                        next = keyframes[i + 1];
                        break;
                    }
                }

                if (time <= prev.time) {
                    return property === 'value' ? prev.value : { x: prev.x, y: prev.y };
                }
                if (time >= next.time) {
                    return property === 'value' ? next.value : { x: next.x, y: next.y };
                }

                const t = (time - prev.time) / (next.time - prev.time);
                const eased = easingFunctions[state.easing](t);

                if (property === 'value') {
                    return prev.value + (next.value - prev.value) * eased;
                } else {
                    return {
                        x: prev.x + (next.x - prev.x) * eased,
                        y: prev.y + (next.y - prev.y) * eased
                    };
                }
            }

            // ==========================================
            // CANVAS RENDERING
            // ==========================================
            function resizeCanvas() {
                const container = elements.canvasWrapper.parentElement;
                const containerWidth = container.clientWidth - 40;
                const containerHeight = container.clientHeight - 40;

                const aspectRatio = state.canvasWidth / state.canvasHeight;
                let displayWidth, displayHeight;

                if (containerWidth / containerHeight > aspectRatio) {
                    displayHeight = containerHeight;
                    displayWidth = displayHeight * aspectRatio;
                } else {
                    displayWidth = containerWidth;
                    displayHeight = displayWidth / aspectRatio;
                }

                elements.canvasWrapper.style.width = displayWidth + 'px';
                elements.canvasWrapper.style.height = displayHeight + 'px';
                elements.mainCanvas.style.width = displayWidth + 'px';
                elements.mainCanvas.style.height = displayHeight + 'px';

                // Update safe area
                if (state.showSafeArea) {
                    const margin = 0.1;
                    elements.safeArea.style.left = (margin * 100) + '%';
                    elements.safeArea.style.top = (margin * 100) + '%';
                    elements.safeArea.style.width = ((1 - 2 * margin) * 100) + '%';
                    elements.safeArea.style.height = ((1 - 2 * margin) * 100) + '%';
                }

                // Update grid canvas
                elements.gridCanvas.width = state.canvasWidth;
                elements.gridCanvas.height = state.canvasHeight;
                elements.gridCanvas.style.width = displayWidth + 'px';
                elements.gridCanvas.style.height = displayHeight + 'px';
                drawGrid();
            }

            function drawGrid() {
                if (!state.showGrid) return;

                const gridCtx = elements.gridCanvas.getContext('2d');
                gridCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
                gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                gridCtx.lineWidth = 1;

                const cellSize = Math.min(state.canvasWidth, state.canvasHeight) / 12;

                for (let x = cellSize; x < state.canvasWidth; x += cellSize) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(x, 0);
                    gridCtx.lineTo(x, state.canvasHeight);
                    gridCtx.stroke();
                }

                for (let y = cellSize; y < state.canvasHeight; y += cellSize) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(0, y);
                    gridCtx.lineTo(state.canvasWidth, y);
                    gridCtx.stroke();
                }

                // Center lines
                gridCtx.strokeStyle = 'rgba(233, 69, 96, 0.5)';
                gridCtx.beginPath();
                gridCtx.moveTo(state.canvasWidth / 2, 0);
                gridCtx.lineTo(state.canvasWidth / 2, state.canvasHeight);
                gridCtx.stroke();
                gridCtx.beginPath();
                gridCtx.moveTo(0, state.canvasHeight / 2);
                gridCtx.lineTo(state.canvasWidth, state.canvasHeight / 2);
                gridCtx.stroke();
            }

            function render(forExport = false) {
                const width = state.canvasWidth;
                const height = state.canvasHeight;

                // Clear canvas
                ctx.fillStyle = state.bgColor;
                ctx.fillRect(0, 0, width, height);

                // Get interpolated values
                const position = interpolateKeyframes(state.keyframes.position, state.currentTime, 'position');
                const scale = interpolateKeyframes(state.keyframes.scale, state.currentTime);
                const rotation = interpolateKeyframes(state.keyframes.rotation, state.currentTime);
                const opacity = interpolateKeyframes(state.keyframes.opacity, state.currentTime);
                const letterOffset = interpolateKeyframes(state.keyframes.letterOffset, state.currentTime);
                const tracking = interpolateKeyframes(state.keyframes.tracking, state.currentTime);

                // Apply global transforms
                ctx.save();
                ctx.translate(width / 2 + position.x + state.posX, height / 2 + position.y + state.posY);
                ctx.rotate((rotation + state.rotation) * Math.PI / 180);
                ctx.scale(scale * state.scale, scale * state.scale);
                ctx.globalAlpha = opacity * state.opacity;

                // Setup font
                const font = `${state.fontStyle} ${state.fontWeight} ${state.fontSize}px "${state.fontFamily}"`;
                ctx.font = font;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Get characters based on stagger mode
                let elements_to_animate = [];
                const lines = state.text.split('\n');

                if (state.staggerMode === 'line') {
                    elements_to_animate = lines;
                } else if (state.staggerMode === 'word') {
                    lines.forEach(line => {
                        line.split(' ').forEach(word => {
                            elements_to_animate.push(word);
                        });
                    });
                } else {
                    state.text.split('').forEach(char => {
                        elements_to_animate.push(char);
                    });
                }

                // Calculate animation progress
                const animProgress = prefersReducedMotion ? 1 : state.currentTime / state.duration;
                const preset = presets[state.currentPreset];

                // Calculate total width for centering
                let totalWidth = 0;
                const charWidths = [];
                const effectiveTracking = state.letterSpacing + tracking;

                if (state.staggerMode === 'letter') {
                    elements_to_animate.forEach(char => {
                        const w = ctx.measureText(char).width;
                        charWidths.push(w);
                        totalWidth += w + effectiveTracking;
                    });
                } else if (state.staggerMode === 'word') {
                    elements_to_animate.forEach((word, i) => {
                        const w = ctx.measureText(word).width;
                        charWidths.push(w);
                        totalWidth += w + (i < elements_to_animate.length - 1 ? state.fontSize * 0.3 : 0);
                    });
                }

                // Draw text
                let currentX = -totalWidth / 2;
                let currentY = 0;

                if (state.staggerMode === 'line') {
                    const lineHeight = state.fontSize * state.lineHeight;
                    const totalHeight = lines.length * lineHeight;
                    currentY = -totalHeight / 2 + lineHeight / 2;

                    lines.forEach((line, index) => {
                        const anim = preset(elements_to_animate, animProgress, index, elements_to_animate.length);

                        ctx.save();
                        ctx.translate(anim.x, currentY + anim.y + letterOffset);
                        ctx.scale(anim.scale, anim.scale);
                        ctx.rotate(anim.rotation * Math.PI / 180);
                        ctx.globalAlpha *= anim.opacity;

                        // Shadow
                        if (state.shadowBlur > 0) {
                            ctx.shadowBlur = state.shadowBlur;
                            ctx.shadowColor = state.shadowColor;
                            ctx.shadowOffsetX = state.shadowX;
                            ctx.shadowOffsetY = state.shadowY;
                        }

                        // Stroke
                        if (state.strokeWidth > 0) {
                            ctx.strokeStyle = state.strokeColor;
                            ctx.lineWidth = state.strokeWidth;
                            ctx.strokeText(line, 0, 0);
                        }

                        // Fill
                        ctx.fillStyle = state.fillColor;
                        ctx.fillText(line, 0, 0);

                        ctx.restore();
                        currentY += lineHeight;
                    });
                } else {
                    elements_to_animate.forEach((element, index) => {
                        const anim = preset(elements_to_animate, animProgress, index, elements_to_animate.length);
                        const charWidth = charWidths[index];
                        const charX = currentX + charWidth / 2;

                        ctx.save();
                        ctx.translate(charX + anim.x, anim.y + letterOffset);
                        ctx.scale(anim.scale, anim.scale);
                        ctx.rotate(anim.rotation * Math.PI / 180);
                        ctx.globalAlpha *= anim.opacity;

                        // Shadow
                        if (state.shadowBlur > 0) {
                            ctx.shadowBlur = state.shadowBlur;
                            ctx.shadowColor = state.shadowColor;
                            ctx.shadowOffsetX = state.shadowX;
                            ctx.shadowOffsetY = state.shadowY;
                        }

                        // Glitch color shift effect
                        if (anim.colorShift && state.currentPreset === 'glitch') {
                            ctx.fillStyle = '#ff0000';
                            ctx.fillText(element, 2, 0);
                            ctx.fillStyle = '#00ffff';
                            ctx.fillText(element, -2, 0);
                        }

                        // Stroke
                        if (state.strokeWidth > 0) {
                            ctx.strokeStyle = state.strokeColor;
                            ctx.lineWidth = state.strokeWidth;
                            ctx.strokeText(element, 0, 0);
                        }

                        // Fill
                        ctx.fillStyle = state.fillColor;
                        ctx.fillText(element, 0, 0);

                        ctx.restore();

                        if (state.staggerMode === 'letter') {
                            currentX += charWidth + effectiveTracking;
                        } else {
                            currentX += charWidth + state.fontSize * 0.3;
                        }
                    });
                }

                ctx.restore();
            }

            // ==========================================
            // TIMELINE RENDERING
            // ==========================================
            function drawTimeline() {
                const width = elements.timelineCanvas.width;
                const height = 200;
                const rulerHeight = 25;
                const trackHeight = 30;
                const pixelsPerSecond = width / state.duration;

                timelineCtx.clearRect(0, 0, width, height);

                // Draw ruler
                timelineCtx.fillStyle = '#0f0f1a';
                timelineCtx.fillRect(0, 0, width, rulerHeight);

                timelineCtx.strokeStyle = '#2a2a4a';
                timelineCtx.fillStyle = '#a0a0a0';
                timelineCtx.font = '10px Roboto';

                // Draw time markers
                const interval = state.duration <= 5 ? 0.5 : state.duration <= 15 ? 1 : 5;
                for (let t = 0; t <= state.duration; t += interval) {
                    const x = t * pixelsPerSecond;
                    timelineCtx.beginPath();
                    timelineCtx.moveTo(x, rulerHeight - 10);
                    timelineCtx.lineTo(x, rulerHeight);
                    timelineCtx.stroke();
                    timelineCtx.fillText(t.toFixed(1) + 's', x + 3, rulerHeight - 12);
                }

                // Draw beat markers if audio loaded
                if (state.beats.length > 0) {
                    timelineCtx.fillStyle = 'rgba(251, 191, 36, 0.3)';
                    state.beats.forEach(beat => {
                        const x = beat * pixelsPerSecond;
                        timelineCtx.fillRect(x - 1, 0, 2, height);
                    });
                }

                // Draw tracks
                const tracks = ['position', 'scale', 'rotation', 'opacity', 'letterOffset', 'tracking'];
                tracks.forEach((track, index) => {
                    const y = rulerHeight + index * trackHeight;

                    // Track background
                    timelineCtx.fillStyle = index % 2 === 0 ? '#16213e' : '#1a1a2e';
                    timelineCtx.fillRect(0, y, width, trackHeight);

                    // Track line
                    timelineCtx.strokeStyle = track === state.selectedTrack ? '#e94560' : '#2a2a4a';
                    timelineCtx.beginPath();
                    timelineCtx.moveTo(0, y + trackHeight / 2);
                    timelineCtx.lineTo(width, y + trackHeight / 2);
                    timelineCtx.stroke();

                    // Keyframes
                    const keyframes = state.keyframes[track];
                    keyframes.forEach((kf, kfIndex) => {
                        const x = kf.time * pixelsPerSecond;
                        const isSelected = state.selectedKeyframe &&
                            state.selectedKeyframe.track === track &&
                            state.selectedKeyframe.index === kfIndex;

                        timelineCtx.save();
                        timelineCtx.translate(x, y + trackHeight / 2);
                        timelineCtx.rotate(Math.PI / 4);

                        timelineCtx.fillStyle = isSelected ? '#ff6b6b' : '#e94560';
                        timelineCtx.fillRect(-5, -5, 10, 10);

                        if (isSelected) {
                            timelineCtx.strokeStyle = '#ffffff';
                            timelineCtx.lineWidth = 2;
                            timelineCtx.strokeRect(-5, -5, 10, 10);
                        }

                        timelineCtx.restore();
                    });
                });

                // Update playhead position
                const playheadX = state.currentTime * pixelsPerSecond;
                elements.playhead.style.left = playheadX + 'px';
            }

            // ==========================================
            // EASING CURVE PREVIEW
            // ==========================================
            function drawEasingCurve() {
                const width = elements.easingCanvas.width;
                const height = elements.easingCanvas.height;
                const padding = 10;

                easingCtx.clearRect(0, 0, width, height);

                // Background
                easingCtx.fillStyle = '#0f0f1a';
                easingCtx.fillRect(0, 0, width, height);

                // Grid
                easingCtx.strokeStyle = '#2a2a4a';
                easingCtx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const x = padding + (width - 2 * padding) * i / 4;
                    const y = padding + (height - 2 * padding) * i / 4;
                    easingCtx.beginPath();
                    easingCtx.moveTo(x, padding);
                    easingCtx.lineTo(x, height - padding);
                    easingCtx.stroke();
                    easingCtx.beginPath();
                    easingCtx.moveTo(padding, y);
                    easingCtx.lineTo(width - padding, y);
                    easingCtx.stroke();
                }

                // Diagonal reference line
                easingCtx.strokeStyle = '#4a4a6a';
                easingCtx.setLineDash([5, 5]);
                easingCtx.beginPath();
                easingCtx.moveTo(padding, height - padding);
                easingCtx.lineTo(width - padding, padding);
                easingCtx.stroke();
                easingCtx.setLineDash([]);

                // Draw curve
                easingCtx.strokeStyle = '#e94560';
                easingCtx.lineWidth = 2;
                easingCtx.beginPath();

                const easingFn = easingFunctions[state.easing];
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100;
                    const value = easingFn(t);
                    const x = padding + t * (width - 2 * padding);
                    const y = height - padding - value * (height - 2 * padding);

                    if (i === 0) {
                        easingCtx.moveTo(x, y);
                    } else {
                        easingCtx.lineTo(x, y);
                    }
                }
                easingCtx.stroke();

                // Draw current position
                const currentT = state.currentTime / state.duration;
                const currentValue = easingFn(currentT);
                const dotX = padding + currentT * (width - 2 * padding);
                const dotY = height - padding - currentValue * (height - 2 * padding);

                easingCtx.fillStyle = '#ffffff';
                easingCtx.beginPath();
                easingCtx.arc(dotX, dotY, 5, 0, Math.PI * 2);
                easingCtx.fill();
            }

            // ==========================================
            // WAVEFORM RENDERING
            // ==========================================
            function drawWaveform() {
                const canvas = elements.waveformCanvas;
                const container = document.getElementById('waveformContainer');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;

                const width = canvas.width;
                const height = canvas.height;

                waveformCtx.clearRect(0, 0, width, height);
                waveformCtx.fillStyle = '#0f0f1a';
                waveformCtx.fillRect(0, 0, width, height);

                if (!state.audioBuffer) {
                    waveformCtx.fillStyle = '#4a4a6a';
                    waveformCtx.font = '12px Roboto';
                    waveformCtx.textAlign = 'center';
                    waveformCtx.fillText('No audio loaded', width / 2, height / 2);
                    return;
                }

                const data = state.audioBuffer.getChannelData(0);
                const step = Math.ceil(data.length / width);
                const amp = height / 2;

                waveformCtx.fillStyle = '#e94560';
                waveformCtx.beginPath();
                waveformCtx.moveTo(0, amp);

                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    waveformCtx.lineTo(i, (1 + min) * amp);
                }

                for (let i = width - 1; i >= 0; i--) {
                    let min = 1.0;
                    let max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    waveformCtx.lineTo(i, (1 + max) * amp);
                }

                waveformCtx.closePath();
                waveformCtx.fill();

                // Draw beat markers
                waveformCtx.strokeStyle = '#fbbf24';
                waveformCtx.lineWidth = 1;
                state.beats.forEach(beat => {
                    const x = (beat / state.audioBuffer.duration) * width;
                    waveformCtx.beginPath();
                    waveformCtx.moveTo(x, 0);
                    waveformCtx.lineTo(x, height);
                    waveformCtx.stroke();
                });

                // Draw playhead
                const playheadX = (state.currentTime / state.duration) * width;
                waveformCtx.strokeStyle = '#ffffff';
                waveformCtx.lineWidth = 2;
                waveformCtx.beginPath();
                waveformCtx.moveTo(playheadX, 0);
                waveformCtx.lineTo(playheadX, height);
                waveformCtx.stroke();
            }

            // ==========================================
            // BEAT DETECTION
            // ==========================================
            function detectBeats(audioBuffer) {
                const data = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;
                const beats = [];

                // Simple energy-based beat detection
                const windowSize = Math.floor(sampleRate * 0.05); // 50ms windows
                const threshold = state.beatSensitivity / 100;

                let prevEnergy = 0;
                for (let i = 0; i < data.length; i += windowSize) {
                    let energy = 0;
                    for (let j = 0; j < windowSize && i + j < data.length; j++) {
                        energy += data[i + j] * data[i + j];
                    }
                    energy /= windowSize;

                    if (energy > prevEnergy * (1 + threshold) && energy > 0.01) {
                        const time = i / sampleRate;
                        if (beats.length === 0 || time - beats[beats.length - 1] > 0.15) {
                            beats.push(time);
                        }
                    }
                    prevEnergy = energy;
                }

                return beats;
            }

            // ==========================================
            // PLAYBACK
            // ==========================================
            let animationFrame = null;
            let lastTimestamp = 0;

            function play() {
                state.isPlaying = true;
                elements.playIcon.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
                lastTimestamp = performance.now();
                animate();
            }

            function pause() {
                state.isPlaying = false;
                elements.playIcon.innerHTML = '<path d="M8 5v14l11-7L8 5z"/>';
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                }
            }

            function animate() {
                if (!state.isPlaying) return;

                const now = performance.now();
                const delta = (now - lastTimestamp) / 1000;
                lastTimestamp = now;

                state.currentTime += delta;
                if (state.currentTime >= state.duration) {
                    state.currentTime = 0;
                }

                updateTimeDisplay();
                render();
                drawTimeline();
                drawEasingCurve();
                drawWaveform();

                animationFrame = requestAnimationFrame(animate);
            }

            function updateTimeDisplay() {
                const current = formatTime(state.currentTime);
                const total = formatTime(state.duration);
                elements.timeDisplay.textContent = `${current} / ${total}`;
            }

            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }

            // ==========================================
            // EXPORT FUNCTIONALITY
            // ==========================================
            async function exportAnimation() {
                const format = document.getElementById('exportFormat').value;
                const width = parseInt(document.getElementById('exportWidth').value);
                const height = parseInt(document.getElementById('exportHeight').value);
                const fps = parseInt(document.getElementById('exportFps').value);
                const quality = parseFloat(document.getElementById('exportQuality').value);

                // Create offscreen canvas
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = width;
                offscreenCanvas.height = height;
                const offscreenCtx = offscreenCanvas.getContext('2d');

                // Store original values
                const originalWidth = state.canvasWidth;
                const originalHeight = state.canvasHeight;
                state.canvasWidth = width;
                state.canvasHeight = height;

                elements.exportProgress.style.display = 'block';
                elements.exportStatus.textContent = 'Preparing export...';

                const totalFrames = Math.ceil(state.duration * fps);
                const frames = [];

                // Render frames
                for (let i = 0; i < totalFrames; i++) {
                    state.currentTime = (i / fps);

                    // Swap context temporarily
                    const tempCtx = ctx;
                    window.ctx = offscreenCtx;
                    render(true);
                    window.ctx = tempCtx;

                    if (format === 'png') {
                        frames.push({
                            data: offscreenCanvas.toDataURL('image/png'),
                            frame: i
                        });
                    } else {
                        frames.push(offscreenCanvas.toDataURL('image/png'));
                    }

                    const progress = ((i + 1) / totalFrames) * 100;
                    elements.exportProgressFill.style.width = progress + '%';
                    elements.exportStatus.textContent = `Rendering frame ${i + 1} of ${totalFrames}...`;

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                // Restore original values
                state.canvasWidth = originalWidth;
                state.canvasHeight = originalHeight;
                state.currentTime = 0;

                elements.exportStatus.textContent = 'Encoding...';

                if (format === 'png') {
                    // Download as ZIP (simplified - just download first frame for demo)
                    elements.exportStatus.textContent = 'Downloading PNG sequence...';
                    for (let i = 0; i < Math.min(frames.length, 10); i++) {
                        const link = document.createElement('a');
                        link.download = `frame_${String(i).padStart(4, '0')}.png`;
                        link.href = frames[i].data;
                        link.click();
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    showNotification('PNG sequence exported (first 10 frames)', 'success');
                } else if (format === 'gif') {
                    // Create GIF using simple encoding
                    elements.exportStatus.textContent = 'Creating GIF...';
                    await createGif(frames, width, height, fps);
                } else {
                    // WebM export using MediaRecorder
                    elements.exportStatus.textContent = 'Creating WebM...';
                    await createWebM(offscreenCanvas, fps, quality);
                }

                elements.exportProgress.style.display = 'none';
                elements.exportProgressFill.style.width = '0%';
                elements.exportStatus.textContent = '';
                closeModal('exportModal');
            }

            async function createWebM(canvas, fps, quality) {
                return new Promise((resolve) => {
                    const stream = canvas.captureStream(fps);
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: quality * 10000000
                    });

                    const chunks = [];
                    mediaRecorder.ondataavailable = e => chunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = 'kinetic-typography.webm';
                        link.href = url;
                        link.click();
                        URL.revokeObjectURL(url);
                        showNotification('WebM exported successfully', 'success');
                        resolve();
                    };

                    // Re-render animation
                    mediaRecorder.start();

                    const startTime = performance.now();
                    const duration = state.duration * 1000;

                    function recordFrame() {
                        const elapsed = performance.now() - startTime;
                        state.currentTime = elapsed / 1000;
                        render(true);

                        if (elapsed < duration) {
                            requestAnimationFrame(recordFrame);
                        } else {
                            mediaRecorder.stop();
                        }
                    }

                    recordFrame();
                });
            }

            async function createGif(frames, width, height, fps) {
                // Simplified GIF creation - download frames
                showNotification('GIF export requires additional library. Downloading frames instead.', 'warning');
                for (let i = 0; i < Math.min(frames.length, 5); i++) {
                    const link = document.createElement('a');
                    link.download = `frame_${String(i).padStart(4, '0')}.png`;
                    link.href = frames[i];
                    link.click();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }

            // ==========================================
            // UI HELPERS
            // ==========================================
            function showNotification(message, type = 'info') {
                elements.notification.textContent = message;
                elements.notification.className = `notification show ${type}`;
                setTimeout(() => {
                    elements.notification.classList.remove('show');
                }, 3000);
            }

            function openModal(modalId) {
                document.getElementById(modalId).classList.add('active');
            }

            function closeModal(modalId) {
                document.getElementById(modalId).classList.remove('active');
            }

            // ==========================================
            // EVENT LISTENERS
            // ==========================================
            function setupEventListeners() {
                // Text input
                elements.textInput.addEventListener('input', (e) => {
                    state.text = e.target.value || 'TEXT';
                    render();
                });

                // Preset selection
                document.querySelectorAll('.preset-card').forEach(card => {
                    card.addEventListener('click', () => {
                        document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
                        card.classList.add('active');
                        state.currentPreset = card.dataset.preset;
                        render();
                    });

                    card.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            card.click();
                        }
                    });
                });

                // Stagger mode
                document.getElementById('staggerMode').addEventListener('change', (e) => {
                    state.staggerMode = e.target.value;
                    render();
                });

                // Stagger delay
                document.getElementById('staggerDelay').addEventListener('input', (e) => {
                    state.staggerDelay = parseInt(e.target.value);
                    document.getElementById('staggerDelayValue').textContent = e.target.value;
                    render();
                });

                // Easing preset
                document.getElementById('easingPreset').addEventListener('change', (e) => {
                    state.easing = e.target.value;
                    document.getElementById('customBezier').style.display = e.target.value === 'custom' ? 'block' : 'none';
                    drawEasingCurve();
                    render();
                });

                // Custom bezier inputs
                ['bezierX1', 'bezierY1', 'bezierX2', 'bezierY2'].forEach((id, index) => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        state.customBezier[index] = parseFloat(e.target.value);
                        drawEasingCurve();
                        render();
                    });
                });

                // Typography controls
                document.getElementById('fontFamily').addEventListener('change', (e) => {
                    state.fontFamily = e.target.value;
                    render();
                });

                document.getElementById('fontWeight').addEventListener('change', (e) => {
                    state.fontWeight = e.target.value;
                    render();
                });

                document.getElementById('fontStyle').addEventListener('change', (e) => {
                    state.fontStyle = e.target.value;
                    render();
                });

                // Range sliders with value display
                const rangeControls = [
                    { id: 'fontSize', state: 'fontSize', suffix: 'px', valueId: 'fontSizeValue' },
                    { id: 'letterSpacing', state: 'letterSpacing', suffix: 'px', valueId: 'letterSpacingValue' },
                    { id: 'lineHeight', state: 'lineHeight', suffix: '', valueId: 'lineHeightValue' },
                    { id: 'strokeWidth', state: 'strokeWidth', suffix: 'px', valueId: 'strokeWidthValue' },
                    { id: 'shadowBlur', state: 'shadowBlur', suffix: 'px', valueId: 'shadowBlurValue' },
                    { id: 'shadowX', state: 'shadowX', suffix: 'px', valueId: 'shadowXValue' },
                    { id: 'shadowY', state: 'shadowY', suffix: 'px', valueId: 'shadowYValue' },
                    { id: 'posX', state: 'posX', suffix: '', valueId: 'posXValue' },
                    { id: 'posY', state: 'posY', suffix: '', valueId: 'posYValue' },
                    { id: 'scale', state: 'scale', suffix: '%', valueId: 'scaleValue', multiplier: 100 },
                    { id: 'rotation', state: 'rotation', suffix: '°', valueId: 'rotationValue' },
                    { id: 'opacity', state: 'opacity', suffix: '%', valueId: 'opacityValue', multiplier: 100 }
                ];

                rangeControls.forEach(control => {
                    const element = document.getElementById(control.id);
                    element.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        state[control.state] = value;
                        const displayValue = control.multiplier ? Math.round(value * control.multiplier) : value;
                        document.getElementById(control.valueId).textContent = displayValue + control.suffix;
                        render();
                    });
                });

                // Color controls
                const colorControls = ['fill', 'stroke', 'bg', 'shadow'];
                colorControls.forEach(name => {
                    const colorInput = document.getElementById(`${name}Color`);
                    const hexInput = document.getElementById(`${name}ColorHex`);
                    const preview = document.getElementById(`${name}ColorPreview`);

                    colorInput.addEventListener('input', (e) => {
                        const color = e.target.value;
                        state[`${name}Color`] = color;
                        hexInput.value = color;
                        preview.style.background = color;
                        render();
                    });

                    hexInput.addEventListener('input', (e) => {
                        const color = e.target.value;
                        if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                            state[`${name}Color`] = color;
                            colorInput.value = color;
                            preview.style.background = color;
                            render();
                        }
                    });

                    preview.addEventListener('click', () => colorInput.click());
                });

                // Aspect ratio buttons
                document.querySelectorAll('.aspect-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        const aspect = btn.dataset.aspect;
                        state.aspect = aspect;

                        switch(aspect) {
                            case '1:1':
                                state.canvasWidth = 1080;
                                state.canvasHeight = 1080;
                                break;
                            case '16:9':
                                state.canvasWidth = 1920;
                                state.canvasHeight = 1080;
                                break;
                            case '9:16':
                                state.canvasWidth = 1080;
                                state.canvasHeight = 1920;
                                break;
                        }

                        elements.mainCanvas.width = state.canvasWidth;
                        elements.mainCanvas.height = state.canvasHeight;
                        document.getElementById('exportWidth').value = state.canvasWidth;
                        document.getElementById('exportHeight').value = state.canvasHeight;
                        resizeCanvas();
                        render();
                    });
                });

                // Toggles
                const toggles = [
                    { id: 'safeAreaToggle', state: 'showSafeArea', element: 'safeArea' },
                    { id: 'gridToggle', state: 'showGrid', element: 'gridCanvas' },
                    { id: 'motionBlurToggle', state: 'motionBlur' },
                    { id: 'snapToBeats', state: 'snapToBeats' }
                ];

                toggles.forEach(toggle => {
                    const el = document.getElementById(toggle.id);
                    el.addEventListener('click', () => {
                        state[toggle.state] = !state[toggle.state];
                        el.classList.toggle('active', state[toggle.state]);
                        el.setAttribute('aria-checked', state[toggle.state]);

                        if (toggle.element) {
                            document.getElementById(toggle.element).style.display = state[toggle.state] ? 'block' : 'none';
                        }

                        if (toggle.state === 'showGrid') {
                            drawGrid();
                        }
                        render();
                    });

                    el.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            el.click();
                        }
                    });
                });

                // Playback controls
                elements.playBtn.addEventListener('click', () => {
                    if (state.isPlaying) {
                        pause();
                    } else {
                        play();
                    }
                });

                document.getElementById('skipStartBtn').addEventListener('click', () => {
                    state.currentTime = 0;
                    updateTimeDisplay();
                    render();
                    drawTimeline();
                    drawEasingCurve();
                });

                document.getElementById('skipEndBtn').addEventListener('click', () => {
                    state.currentTime = state.duration;
                    updateTimeDisplay();
                    render();
                    drawTimeline();
                    drawEasingCurve();
                });

                // Duration select
                document.getElementById('durationSelect').addEventListener('change', (e) => {
                    state.duration = parseFloat(e.target.value);

                    // Update keyframes to match new duration
                    Object.keys(state.keyframes).forEach(track => {
                        const lastKf = state.keyframes[track][state.keyframes[track].length - 1];
                        if (lastKf) {
                            lastKf.time = state.duration;
                        }
                    });

                    updateTimeDisplay();
                    drawTimeline();
                });

                // Add keyframe
                document.getElementById('addKeyframeBtn').addEventListener('click', addKeyframe);

                // Delete keyframe
                document.getElementById('deleteKeyframeBtn').addEventListener('click', deleteSelectedKeyframe);

                // Timeline track labels
                document.querySelectorAll('.timeline-track-label').forEach(label => {
                    label.addEventListener('click', () => {
                        document.querySelectorAll('.timeline-track-label').forEach(l => l.classList.remove('active'));
                        label.classList.add('active');
                        state.selectedTrack = label.dataset.track;
                    });
                });

                // Timeline scrubbing
                elements.timelineTracks.addEventListener('mousedown', handleTimelineScrub);
                elements.timelineTracks.addEventListener('mousemove', (e) => {
                    if (e.buttons === 1) {
                        handleTimelineScrub(e);
                    }
                });

                // Timeline keyframe selection
                elements.timelineCanvas.addEventListener('click', (e) => {
                    const rect = elements.timelineCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const pixelsPerSecond = elements.timelineCanvas.width / state.duration;

                    const tracks = ['position', 'scale', 'rotation', 'opacity', 'letterOffset', 'tracking'];
                    const rulerHeight = 25;
                    const trackHeight = 30;

                    tracks.forEach((track, index) => {
                        const trackY = rulerHeight + index * trackHeight;
                        if (y >= trackY && y < trackY + trackHeight) {
                            state.keyframes[track].forEach((kf, kfIndex) => {
                                const kfX = kf.time * pixelsPerSecond;
                                if (Math.abs(x - kfX) < 10 && Math.abs(y - (trackY + trackHeight / 2)) < 10) {
                                    state.selectedKeyframe = { track, index: kfIndex };
                                    state.selectedTrack = track;
                                    document.querySelectorAll('.timeline-track-label').forEach(l => {
                                        l.classList.toggle('active', l.dataset.track === track);
                                    });
                                    drawTimeline();
                                }
                            });
                        }
                    });
                });

                // Audio input
                document.getElementById('loadAudioBtn').addEventListener('click', () => {
                    document.getElementById('audioInput').click();
                });

                document.getElementById('audioInput').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        state.audioContext = state.audioContext || new (window.AudioContext || window.webkitAudioContext)();
                        const arrayBuffer = await file.arrayBuffer();
                        state.audioBuffer = await state.audioContext.decodeAudioData(arrayBuffer);
                        state.beats = detectBeats(state.audioBuffer);

                        // Set duration to audio length
                        state.duration = Math.min(state.audioBuffer.duration, 60);
                        document.getElementById('durationSelect').value = Math.ceil(state.duration);

                        drawWaveform();
                        drawTimeline();
                        showNotification(`Audio loaded: ${state.beats.length} beats detected`, 'success');
                    } catch (error) {
                        showNotification('Error loading audio file', 'error');
                    }
                });

                // Beat sensitivity
                document.getElementById('beatSensitivity').addEventListener('input', (e) => {
                    state.beatSensitivity = parseInt(e.target.value);
                    e.target.nextElementSibling.textContent = e.target.value;
                    if (state.audioBuffer) {
                        state.beats = detectBeats(state.audioBuffer);
                        drawWaveform();
                        drawTimeline();
                    }
                });

                // Export
                document.getElementById('exportBtn').addEventListener('click', () => openModal('exportModal'));
                document.getElementById('cancelExportBtn').addEventListener('click', () => closeModal('exportModal'));
                document.getElementById('startExportBtn').addEventListener('click', exportAnimation);

                // Export quality display
                document.getElementById('exportQuality').addEventListener('input', (e) => {
                    document.getElementById('exportQualityValue').textContent = Math.round(e.target.value * 100) + '%';
                });

                // Help
                document.getElementById('helpBtn').addEventListener('click', () => openModal('helpModal'));
                document.getElementById('closeHelpBtn').addEventListener('click', () => closeModal('helpModal'));

                // New project
                document.getElementById('newProjectBtn').addEventListener('click', () => {
                    if (confirm('Start a new project? Unsaved changes will be lost.')) {
                        location.reload();
                    }
                });

                // Close modals on overlay click
                document.querySelectorAll('.modal-overlay').forEach(overlay => {
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            overlay.classList.remove('active');
                        }
                    });
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts when typing in inputs
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                        return;
                    }

                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            elements.playBtn.click();
                            break;
                        case 'k':
                        case 'K':
                            addKeyframe();
                            break;
                        case 'Delete':
                        case 'Backspace':
                            deleteSelectedKeyframe();
                            break;
                        case 'Home':
                            state.currentTime = 0;
                            updateTimeDisplay();
                            render();
                            drawTimeline();
                            break;
                        case 'End':
                            state.currentTime = state.duration;
                            updateTimeDisplay();
                            render();
                            drawTimeline();
                            break;
                        case 'ArrowLeft':
                            state.currentTime = Math.max(0, state.currentTime - 1/30);
                            updateTimeDisplay();
                            render();
                            drawTimeline();
                            break;
                        case 'ArrowRight':
                            state.currentTime = Math.min(state.duration, state.currentTime + 1/30);
                            updateTimeDisplay();
                            render();
                            drawTimeline();
                            break;
                        case 'g':
                        case 'G':
                            document.getElementById('gridToggle').click();
                            break;
                        case 's':
                        case 'S':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                localStorage.setItem('kineticTypographyState', JSON.stringify(state));
                                showNotification('Project saved to local storage', 'success');
                            } else {
                                document.getElementById('safeAreaToggle').click();
                            }
                            break;
                        case 'e':
                        case 'E':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                openModal('exportModal');
                            }
                            break;
                        case 'n':
                        case 'N':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                document.getElementById('newProjectBtn').click();
                            }
                            break;
                        case '?':
                            openModal('helpModal');
                            break;
                        case 'Escape':
                            document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('active'));
                            break;
                    }
                });

                // Window resize
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    drawWaveform();
                });

                // Touch support for timeline
                elements.timelineTracks.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleTimelineScrub(e.touches[0]);
                });

                elements.timelineTracks.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    handleTimelineScrub(e.touches[0]);
                });
            }

            function handleTimelineScrub(e) {
                const rect = elements.timelineTracks.getBoundingClientRect();
                const x = e.clientX - rect.left + elements.timelineTracks.scrollLeft;
                const pixelsPerSecond = elements.timelineCanvas.width / state.duration;

                let time = x / pixelsPerSecond;

                // Snap to beats if enabled
                if (state.snapToBeats && state.beats.length > 0) {
                    const snapThreshold = 0.1; // seconds
                    for (const beat of state.beats) {
                        if (Math.abs(time - beat) < snapThreshold) {
                            time = beat;
                            break;
                        }
                    }
                }

                state.currentTime = Math.max(0, Math.min(state.duration, time));
                updateTimeDisplay();
                render();
                drawTimeline();
                drawEasingCurve();
                drawWaveform();
            }

            function addKeyframe() {
                const track = state.selectedTrack;
                const keyframes = state.keyframes[track];

                // Check if keyframe already exists at this time
                const existingIndex = keyframes.findIndex(kf => Math.abs(kf.time - state.currentTime) < 0.01);
                if (existingIndex !== -1) {
                    showNotification('Keyframe already exists at this time', 'warning');
                    return;
                }

                // Get current interpolated value
                let newKeyframe;
                if (track === 'position') {
                    const pos = interpolateKeyframes(keyframes, state.currentTime, 'position');
                    newKeyframe = { time: state.currentTime, x: pos.x + state.posX, y: pos.y + state.posY };
                } else {
                    const value = interpolateKeyframes(keyframes, state.currentTime);
                    newKeyframe = { time: state.currentTime, value };
                }

                keyframes.push(newKeyframe);
                keyframes.sort((a, b) => a.time - b.time);

                state.selectedKeyframe = {
                    track,
                    index: keyframes.indexOf(newKeyframe)
                };

                drawTimeline();
                showNotification('Keyframe added', 'success');
            }

            function deleteSelectedKeyframe() {
                if (!state.selectedKeyframe) {
                    showNotification('No keyframe selected', 'warning');
                    return;
                }

                const { track, index } = state.selectedKeyframe;
                const keyframes = state.keyframes[track];

                // Don't delete first or last keyframe
                if (index === 0 || index === keyframes.length - 1) {
                    showNotification('Cannot delete first or last keyframe', 'warning');
                    return;
                }

                keyframes.splice(index, 1);
                state.selectedKeyframe = null;
                drawTimeline();
                showNotification('Keyframe deleted', 'success');
            }

            // ==========================================
            // INITIALIZATION
            // ==========================================
            function init() {
                // Load saved state if exists
                const savedState = localStorage.getItem('kineticTypographyState');
                if (savedState) {
                    try {
                        const parsed = JSON.parse(savedState);
                        Object.assign(state, parsed);
                        elements.textInput.value = state.text;
                    } catch (e) {
                        // Ignore parse errors
                    }
                }

                setupEventListeners();
                resizeCanvas();
                render();
                drawTimeline();
                drawEasingCurve();
                drawWaveform();
                updateTimeDisplay();

                // Apply reduced motion if preferred
                if (prefersReducedMotion) {
                    showNotification('Reduced motion mode active', 'info');
                }
            }

            // Start the app
            init();
        })();
    </script>
</body>
</html>
