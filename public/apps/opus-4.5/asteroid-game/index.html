<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroid Dogfight</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(ellipse at center, #0a0a2e 0%, #000000 100%);
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 16px;
            text-shadow: 0 0 10px #0ff;
            z-index: 100;
            pointer-events: none;
        }

        #ui div {
            margin-bottom: 8px;
        }

        #healthBar, #shieldBar, #boostBar {
            width: 200px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 4px;
        }

        #healthBar {
            border-color: #f44;
        }

        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #f44, #ff6b6b);
            transition: width 0.3s;
            box-shadow: 0 0 10px #f44;
        }

        #shieldBar {
            border-color: #4af;
        }

        #shieldFill {
            height: 100%;
            background: linear-gradient(90deg, #4af, #6bf);
            transition: width 0.3s;
            box-shadow: 0 0 10px #4af;
        }

        #boostBar {
            border-color: #fa0;
        }

        #boostFill {
            height: 100%;
            background: linear-gradient(90deg, #fa0, #fc6);
            transition: width 0.3s;
            box-shadow: 0 0 10px #fa0;
        }

        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0, 20, 40, 0.7);
            border: 2px solid #0ff;
            border-radius: 50%;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
        }

        #controls span {
            color: #0ff;
        }

        #gameOver, #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #gameOver h1, #startScreen h1 {
            color: #f44;
            font-size: 64px;
            text-shadow: 0 0 30px #f44;
            margin-bottom: 20px;
        }

        #startScreen h1 {
            color: #0ff;
            text-shadow: 0 0 30px #0ff;
        }

        #gameOver p, #startScreen p {
            color: #fff;
            font-size: 24px;
            margin-bottom: 30px;
        }

        #startScreen .subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 40px;
        }

        button {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(180deg, #0aa, #088);
            border: 2px solid #0ff;
            color: #fff;
            cursor: pointer;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        button:hover {
            background: linear-gradient(180deg, #0cc, #0aa);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transform: scale(1.05);
        }

        .hidden {
            display: none !important;
        }

        #crosshair {
            position: fixed;
            pointer-events: none;
            z-index: 50;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
        }

        #notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0;
            font-size: 24px;
            text-shadow: 0 0 20px #ff0;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #notification.show {
            opacity: 1;
        }

        #weaponIndicator {
            position: fixed;
            top: 20px;
            right: 220px;
            color: #0f0;
            font-size: 14px;
            text-shadow: 0 0 10px #0f0;
            z-index: 100;
            pointer-events: none;
            text-align: right;
        }

        #combo {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            color: #f80;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 20px #f80;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        }

        #combo.show {
            opacity: 1;
            transform: translateY(-50%) scale(1.2);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div>SCORE: <span id="score">0</span></div>
        <div>HEALTH
            <div id="healthBar"><div id="healthFill" style="width: 100%"></div></div>
        </div>
        <div>SHIELD
            <div id="shieldBar"><div id="shieldFill" style="width: 100%"></div></div>
        </div>
        <div>BOOST
            <div id="boostBar"><div id="boostFill" style="width: 100%"></div></div>
        </div>
        <div style="margin-top: 15px;">ENEMIES: <span id="enemyCount">0</span></div>
        <div>WAVE: <span id="wave">1</span></div>
    </div>

    <div id="weaponIndicator">
        <div>WEAPON: <span id="weaponName">LASER</span></div>
        <div>AMMO: <span id="ammo">∞</span></div>
    </div>

    <div id="minimap">
        <canvas id="minimapCanvas"></canvas>
    </div>

    <div id="controls">
        <span>WASD</span> - Move | <span>MOUSE</span> - Aim | <span>CLICK</span> - Fire | <span>SHIFT</span> - Boost | <span>1-3</span> - Weapons | <span>SPACE</span> - Dodge
    </div>

    <div id="notification"></div>
    <div id="combo"></div>

    <div id="crosshair">
        <svg viewBox="0 0 40 40">
            <circle cx="20" cy="20" r="15" fill="none" stroke="#0ff" stroke-width="1" opacity="0.5"/>
            <circle cx="20" cy="20" r="3" fill="#0ff"/>
            <line x1="20" y1="0" x2="20" y2="10" stroke="#0ff" stroke-width="2"/>
            <line x1="20" y1="30" x2="20" y2="40" stroke="#0ff" stroke-width="2"/>
            <line x1="0" y1="20" x2="10" y2="20" stroke="#0ff" stroke-width="2"/>
            <line x1="30" y1="20" x2="40" y2="20" stroke="#0ff" stroke-width="2"/>
        </svg>
    </div>

    <div id="startScreen">
        <h1>ASTEROID DOGFIGHT</h1>
        <p>Survive the asteroid field and defeat enemy fighters!</p>
        <div class="subtitle">Destroy asteroids for points • Defeat AI ships to advance waves</div>
        <button id="startBtn">START GAME</button>
    </div>

    <div id="gameOver" class="hidden">
        <h1>GAME OVER</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p style="font-size: 18px;">Wave Reached: <span id="finalWave">1</span></p>
        <button id="restartBtn">PLAY AGAIN</button>
    </div>

    <script>
        // Game Constants
        const WORLD_SIZE = 4000;
        const ASTEROID_COUNT = 60;
        const STAR_COUNT = 500;

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // UI Elements
        const scoreEl = document.getElementById('score');
        const healthFill = document.getElementById('healthFill');
        const shieldFill = document.getElementById('shieldFill');
        const boostFill = document.getElementById('boostFill');
        const enemyCountEl = document.getElementById('enemyCount');
        const waveEl = document.getElementById('wave');
        const weaponNameEl = document.getElementById('weaponName');
        const ammoEl = document.getElementById('ammo');
        const notification = document.getElementById('notification');
        const comboEl = document.getElementById('combo');
        const crosshair = document.getElementById('crosshair');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const finalWaveEl = document.getElementById('finalWave');

        // Game State
        let gameRunning = false;
        let score = 0;
        let wave = 1;
        let combo = 0;
        let comboTimer = 0;
        let screenShake = 0;
        let mouseX = 0, mouseY = 0;

        // Resize handler
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimapCanvas.width = 180;
            minimapCanvas.height = 180;
        }
        window.addEventListener('resize', resize);
        resize();

        // Input State
        const keys = {};
        let mouseDown = false;

        // Player Ship
        let player = null;

        // Game Objects
        let bullets = [];
        let asteroids = [];
        let enemies = [];
        let particles = [];
        let stars = [];
        let powerups = [];
        let explosions = [];

        // Weapons
        const WEAPONS = {
            LASER: { name: 'LASER', damage: 15, speed: 18, cooldown: 100, color: '#0f0', ammo: Infinity, spread: 0 },
            PLASMA: { name: 'PLASMA', damage: 40, speed: 12, cooldown: 300, color: '#f0f', ammo: 50, spread: 0, size: 8 },
            SCATTER: { name: 'SCATTER', damage: 8, speed: 15, cooldown: 250, color: '#ff0', ammo: 30, spread: 0.3, count: 5 }
        };

        // Ship Designs
        function drawPlayerShip(ctx, x, y, angle, boost) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // Engine glow
            if (boost) {
                const gradient = ctx.createRadialGradient(-25, 0, 0, -25, 0, 40);
                gradient.addColorStop(0, 'rgba(0, 200, 255, 0.8)');
                gradient.addColorStop(0.5, 'rgba(0, 100, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 50, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(-25, 0, 40, 15, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Main engine flame
            const flameSize = 15 + Math.random() * 5 + (boost ? 20 : 0);
            const flameGradient = ctx.createLinearGradient(-20, 0, -20 - flameSize, 0);
            flameGradient.addColorStop(0, '#fff');
            flameGradient.addColorStop(0.3, '#0af');
            flameGradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
            ctx.fillStyle = flameGradient;
            ctx.beginPath();
            ctx.moveTo(-18, -6);
            ctx.lineTo(-18 - flameSize, 0);
            ctx.lineTo(-18, 6);
            ctx.closePath();
            ctx.fill();

            // Ship body
            ctx.fillStyle = '#1a1a3a';
            ctx.strokeStyle = '#0af';
            ctx.lineWidth = 2;

            // Main hull
            ctx.beginPath();
            ctx.moveTo(25, 0);
            ctx.lineTo(10, -12);
            ctx.lineTo(-5, -14);
            ctx.lineTo(-18, -8);
            ctx.lineTo(-18, 8);
            ctx.lineTo(-5, 14);
            ctx.lineTo(10, 12);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Cockpit
            const cockpitGradient = ctx.createLinearGradient(5, -5, 15, 5);
            cockpitGradient.addColorStop(0, '#0af');
            cockpitGradient.addColorStop(1, '#058');
            ctx.fillStyle = cockpitGradient;
            ctx.beginPath();
            ctx.ellipse(8, 0, 8, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wing details
            ctx.strokeStyle = '#0cf';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-5, -12);
            ctx.lineTo(5, -8);
            ctx.moveTo(-5, 12);
            ctx.lineTo(5, 8);
            ctx.stroke();

            // Wing tips
            ctx.fillStyle = '#f44';
            ctx.beginPath();
            ctx.arc(-5, -14, 2, 0, Math.PI * 2);
            ctx.arc(-5, 14, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawEnemyShip(ctx, x, y, angle, type, health, maxHealth) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            const healthPercent = health / maxHealth;
            const damageColor = `rgb(${255 - healthPercent * 155}, ${50 + healthPercent * 50}, ${50})`;

            // Engine flame
            const flameSize = 10 + Math.random() * 5;
            ctx.fillStyle = type === 'fighter' ? '#f80' : '#f0f';
            ctx.beginPath();
            ctx.moveTo(-15, -4);
            ctx.lineTo(-15 - flameSize, 0);
            ctx.lineTo(-15, 4);
            ctx.closePath();
            ctx.fill();

            if (type === 'fighter') {
                // Fighter - aggressive angular design
                ctx.fillStyle = '#2a1a1a';
                ctx.strokeStyle = damageColor;
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(5, -15);
                ctx.lineTo(-15, -10);
                ctx.lineTo(-15, 10);
                ctx.lineTo(5, 15);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Cockpit
                ctx.fillStyle = '#f44';
                ctx.beginPath();
                ctx.ellipse(5, 0, 5, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wing cannons
                ctx.fillStyle = '#444';
                ctx.fillRect(-5, -16, 12, 3);
                ctx.fillRect(-5, 13, 12, 3);

            } else if (type === 'bomber') {
                // Bomber - heavy and bulky
                ctx.fillStyle = '#1a2a1a';
                ctx.strokeStyle = damageColor;
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(18, 0);
                ctx.lineTo(10, -18);
                ctx.lineTo(-10, -20);
                ctx.lineTo(-18, -12);
                ctx.lineTo(-18, 12);
                ctx.lineTo(-10, 20);
                ctx.lineTo(10, 18);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Heavy plating
                ctx.strokeStyle = '#4a4';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(0, 15);
                ctx.moveTo(-10, -18);
                ctx.lineTo(-10, 18);
                ctx.stroke();

                // Cockpit
                ctx.fillStyle = '#4f4';
                ctx.beginPath();
                ctx.ellipse(8, 0, 6, 4, 0, 0, Math.PI * 2);
                ctx.fill();

            } else if (type === 'ace') {
                // Ace - sleek and deadly
                ctx.fillStyle = '#2a1a2a';
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(25, 0);
                ctx.lineTo(15, -8);
                ctx.lineTo(0, -12);
                ctx.lineTo(-8, -18);
                ctx.lineTo(-18, -12);
                ctx.lineTo(-18, 12);
                ctx.lineTo(-8, 18);
                ctx.lineTo(0, 12);
                ctx.lineTo(15, 8);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Glowing core
                const coreGradient = ctx.createRadialGradient(5, 0, 0, 5, 0, 8);
                coreGradient.addColorStop(0, '#fff');
                coreGradient.addColorStop(0.5, '#f0f');
                coreGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(5, 0, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // Health bar above enemy
            const barWidth = 30;
            const barHeight = 4;
            ctx.fillStyle = '#300';
            ctx.fillRect(x - barWidth/2, y - 30, barWidth, barHeight);
            ctx.fillStyle = damageColor;
            ctx.fillRect(x - barWidth/2, y - 30, barWidth * healthPercent, barHeight);
        }

        // Asteroid generation
        function createAsteroid(x, y, size) {
            const vertices = [];
            const numVertices = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < numVertices; i++) {
                const angle = (i / numVertices) * Math.PI * 2;
                const radius = size * (0.7 + Math.random() * 0.3);
                vertices.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }

            return {
                x: x || Math.random() * WORLD_SIZE,
                y: y || Math.random() * WORLD_SIZE,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.03,
                size: size || 30 + Math.random() * 50,
                vertices: vertices,
                health: size ? size * 2 : 60 + Math.random() * 100,
                color: `hsl(${20 + Math.random() * 20}, ${30 + Math.random() * 20}%, ${20 + Math.random() * 15}%)`
            };
        }

        function drawAsteroid(ctx, asteroid) {
            ctx.save();
            ctx.translate(asteroid.x, asteroid.y);
            ctx.rotate(asteroid.rotation);

            ctx.fillStyle = asteroid.color;
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(asteroid.vertices[0].x, asteroid.vertices[0].y);
            for (let i = 1; i < asteroid.vertices.length; i++) {
                ctx.lineTo(asteroid.vertices[i].x, asteroid.vertices[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Crater details
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            for (let i = 0; i < 3; i++) {
                const cx = (Math.random() - 0.5) * asteroid.size * 0.8;
                const cy = (Math.random() - 0.5) * asteroid.size * 0.8;
                const cr = asteroid.size * 0.1 + Math.random() * asteroid.size * 0.1;
                ctx.beginPath();
                ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Star background
        function createStars() {
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random(),
                    twinkleSpeed: Math.random() * 0.05 + 0.01
                });
            }
        }

        function drawStars(ctx, camera) {
            stars.forEach(star => {
                const parallax = 0.3;
                let sx = (star.x - camera.x * parallax) % WORLD_SIZE;
                let sy = (star.y - camera.y * parallax) % WORLD_SIZE;
                if (sx < 0) sx += WORLD_SIZE;
                if (sy < 0) sy += WORLD_SIZE;

                const screenX = sx - camera.x * (1 - parallax);
                const screenY = sy - camera.y * (1 - parallax);

                if (screenX > -50 && screenX < canvas.width + 50 && screenY > -50 && screenY < canvas.height + 50) {
                    star.brightness += star.twinkleSpeed;
                    const alpha = 0.3 + Math.sin(star.brightness) * 0.3 + 0.4;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // Particle effects
        function createParticle(x, y, color, velocity, life, size) {
            particles.push({
                x, y,
                vx: velocity.x + (Math.random() - 0.5) * 2,
                vy: velocity.y + (Math.random() - 0.5) * 2,
                color,
                life,
                maxLife: life,
                size: size || 3
            });
        }

        function createExplosion(x, y, size, color) {
            explosions.push({
                x, y,
                radius: 0,
                maxRadius: size,
                color,
                life: 1
            });

            for (let i = 0; i < size; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                createParticle(x, y, color, {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                }, 30 + Math.random() * 30, 2 + Math.random() * 3);
            }
        }

        // Enemy AI
        function createEnemy(type) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 800 + Math.random() * 500;

            let health, speed, fireRate, damage;

            switch(type) {
                case 'fighter':
                    health = 60;
                    speed = 4;
                    fireRate = 800;
                    damage = 10;
                    break;
                case 'bomber':
                    health = 150;
                    speed = 2;
                    fireRate = 1500;
                    damage = 25;
                    break;
                case 'ace':
                    health = 100;
                    speed = 5;
                    fireRate = 400;
                    damage = 15;
                    break;
                default:
                    health = 60;
                    speed = 3;
                    fireRate = 1000;
                    damage = 10;
            }

            return {
                x: player.x + Math.cos(angle) * dist,
                y: player.y + Math.sin(angle) * dist,
                vx: 0,
                vy: 0,
                angle: 0,
                type,
                health,
                maxHealth: health,
                speed,
                fireRate,
                lastFire: 0,
                damage,
                state: 'chase',
                stateTimer: 0,
                dodgeDir: 1
            };
        }

        function updateEnemy(enemy, dt) {
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const targetAngle = Math.atan2(dy, dx);

            // Smooth rotation
            let angleDiff = targetAngle - enemy.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            enemy.angle += angleDiff * 0.05;

            // AI behavior based on type
            enemy.stateTimer -= dt;

            if (enemy.type === 'fighter') {
                if (dist > 400) {
                    // Chase
                    enemy.vx += Math.cos(enemy.angle) * 0.2;
                    enemy.vy += Math.sin(enemy.angle) * 0.2;
                } else if (dist < 200) {
                    // Retreat
                    enemy.vx -= Math.cos(enemy.angle) * 0.15;
                    enemy.vy -= Math.sin(enemy.angle) * 0.15;
                } else {
                    // Strafe
                    const strafeAngle = enemy.angle + Math.PI / 2 * enemy.dodgeDir;
                    enemy.vx += Math.cos(strafeAngle) * 0.1;
                    enemy.vy += Math.sin(strafeAngle) * 0.1;
                    if (enemy.stateTimer <= 0) {
                        enemy.dodgeDir *= -1;
                        enemy.stateTimer = 1000 + Math.random() * 1000;
                    }
                }
            } else if (enemy.type === 'bomber') {
                // Slow approach
                if (dist > 300) {
                    enemy.vx += Math.cos(enemy.angle) * 0.08;
                    enemy.vy += Math.sin(enemy.angle) * 0.08;
                }
            } else if (enemy.type === 'ace') {
                // Aggressive and evasive
                if (dist > 350) {
                    enemy.vx += Math.cos(enemy.angle) * 0.25;
                    enemy.vy += Math.sin(enemy.angle) * 0.25;
                } else {
                    // Circle strafe
                    const strafeAngle = enemy.angle + Math.PI / 2 * enemy.dodgeDir;
                    enemy.vx += Math.cos(strafeAngle) * 0.2;
                    enemy.vy += Math.sin(strafeAngle) * 0.2;
                    if (enemy.stateTimer <= 0) {
                        enemy.dodgeDir *= -1;
                        enemy.stateTimer = 500 + Math.random() * 500;
                    }
                }
            }

            // Apply velocity limits
            const speed = Math.sqrt(enemy.vx * enemy.vx + enemy.vy * enemy.vy);
            if (speed > enemy.speed) {
                enemy.vx = (enemy.vx / speed) * enemy.speed;
                enemy.vy = (enemy.vy / speed) * enemy.speed;
            }

            // Apply friction
            enemy.vx *= 0.98;
            enemy.vy *= 0.98;

            // Update position
            enemy.x += enemy.vx;
            enemy.y += enemy.vy;

            // Wrap around world
            if (enemy.x < 0) enemy.x += WORLD_SIZE;
            if (enemy.x > WORLD_SIZE) enemy.x -= WORLD_SIZE;
            if (enemy.y < 0) enemy.y += WORLD_SIZE;
            if (enemy.y > WORLD_SIZE) enemy.y -= WORLD_SIZE;

            // Fire at player
            if (Date.now() - enemy.lastFire > enemy.fireRate && dist < 600) {
                enemy.lastFire = Date.now();
                const bulletSpeed = enemy.type === 'bomber' ? 8 : 12;
                bullets.push({
                    x: enemy.x + Math.cos(enemy.angle) * 20,
                    y: enemy.y + Math.sin(enemy.angle) * 20,
                    vx: Math.cos(enemy.angle) * bulletSpeed + enemy.vx * 0.5,
                    vy: Math.sin(enemy.angle) * bulletSpeed + enemy.vy * 0.5,
                    damage: enemy.damage,
                    friendly: false,
                    color: enemy.type === 'ace' ? '#f0f' : '#f44',
                    size: enemy.type === 'bomber' ? 6 : 4,
                    life: 100
                });
            }
        }

        // Powerups
        function createPowerup(x, y) {
            const types = ['health', 'shield', 'plasma', 'scatter'];
            const type = types[Math.floor(Math.random() * types.length)];
            powerups.push({
                x, y,
                type,
                rotation: 0,
                pulse: 0
            });
        }

        function drawPowerup(ctx, powerup) {
            ctx.save();
            ctx.translate(powerup.x, powerup.y);
            ctx.rotate(powerup.rotation);

            const pulse = 1 + Math.sin(powerup.pulse) * 0.2;
            ctx.scale(pulse, pulse);

            let color;
            switch(powerup.type) {
                case 'health': color = '#f44'; break;
                case 'shield': color = '#44f'; break;
                case 'plasma': color = '#f0f'; break;
                case 'scatter': color = '#ff0'; break;
            }

            // Glow
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();

            // Icon
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            if (powerup.type === 'health') {
                ctx.fillRect(-8, -3, 16, 6);
                ctx.fillRect(-3, -8, 6, 16);
            } else if (powerup.type === 'shield') {
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(10, -5);
                ctx.lineTo(10, 5);
                ctx.lineTo(0, 12);
                ctx.lineTo(-10, 5);
                ctx.lineTo(-10, -5);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            ctx.restore();
        }

        // Player initialization
        function initPlayer() {
            return {
                x: WORLD_SIZE / 2,
                y: WORLD_SIZE / 2,
                vx: 0,
                vy: 0,
                angle: 0,
                health: 100,
                maxHealth: 100,
                shield: 100,
                maxShield: 100,
                boost: 100,
                maxBoost: 100,
                boosting: false,
                weapon: 'LASER',
                ammo: { PLASMA: 50, SCATTER: 30 },
                lastFire: 0,
                invulnerable: 0,
                dodgeCooldown: 0
            };
        }

        // Game initialization
        function initGame() {
            player = initPlayer();
            bullets = [];
            asteroids = [];
            enemies = [];
            particles = [];
            powerups = [];
            explosions = [];
            score = 0;
            wave = 1;
            combo = 0;

            createStars();

            // Create initial asteroids
            for (let i = 0; i < ASTEROID_COUNT; i++) {
                asteroids.push(createAsteroid());
            }

            // Spawn initial enemies
            spawnWaveEnemies();

            updateUI();
        }

        function spawnWaveEnemies() {
            const enemyCount = 2 + wave;
            for (let i = 0; i < enemyCount; i++) {
                let type = 'fighter';
                if (wave >= 3 && Math.random() < 0.3) type = 'bomber';
                if (wave >= 5 && Math.random() < 0.2) type = 'ace';
                enemies.push(createEnemy(type));
            }
            showNotification(`WAVE ${wave} - ${enemyCount} ENEMIES INCOMING!`);
        }

        // Notification system
        function showNotification(text) {
            notification.textContent = text;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 2000);
        }

        // UI Update
        function updateUI() {
            scoreEl.textContent = score;
            healthFill.style.width = (player.health / player.maxHealth * 100) + '%';
            shieldFill.style.width = (player.shield / player.maxShield * 100) + '%';
            boostFill.style.width = (player.boost / player.maxBoost * 100) + '%';
            enemyCountEl.textContent = enemies.length;
            waveEl.textContent = wave;
            weaponNameEl.textContent = player.weapon;
            ammoEl.textContent = player.weapon === 'LASER' ? '∞' : player.ammo[player.weapon];
        }

        // Input handlers
        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === '1') player.weapon = 'LASER';
            if (e.key === '2' && player.ammo.PLASMA > 0) player.weapon = 'PLASMA';
            if (e.key === '3' && player.ammo.SCATTER > 0) player.weapon = 'SCATTER';
            if (e.key === ' ' && player.dodgeCooldown <= 0 && player.boost >= 20) {
                // Dodge roll
                player.dodgeCooldown = 1000;
                player.boost -= 20;
                player.invulnerable = 300;
                const dodgeAngle = player.angle + (keys['a'] ? -Math.PI/2 : keys['d'] ? Math.PI/2 : 0);
                player.vx += Math.cos(dodgeAngle) * 15;
                player.vy += Math.sin(dodgeAngle) * 15;
                for (let i = 0; i < 10; i++) {
                    createParticle(player.x, player.y, '#0af', {x: -player.vx * 0.5, y: -player.vy * 0.5}, 20);
                }
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            crosshair.style.left = mouseX + 'px';
            crosshair.style.top = mouseY + 'px';
        });

        document.addEventListener('mousedown', () => mouseDown = true);
        document.addEventListener('mouseup', () => mouseDown = false);

        document.getElementById('startBtn').addEventListener('click', () => {
            startScreen.classList.add('hidden');
            initGame();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            initGame();
            gameRunning = true;
        });

        // Collision detection
        function circleCollision(a, b, r1, r2) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return dx * dx + dy * dy < (r1 + r2) * (r1 + r2);
        }

        // Main game loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameRunning) return;

            const dt = timestamp - lastTime;
            lastTime = timestamp;

            update(dt);
            render();

            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            if (!player) return;

            // Player rotation towards mouse
            const camera = {
                x: player.x - canvas.width / 2,
                y: player.y - canvas.height / 2
            };
            const worldMouseX = mouseX + camera.x;
            const worldMouseY = mouseY + camera.y;
            player.angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);

            // Player movement
            const accel = player.boosting && player.boost > 0 ? 0.4 : 0.2;
            if (keys['w']) {
                player.vx += Math.cos(player.angle) * accel;
                player.vy += Math.sin(player.angle) * accel;
            }
            if (keys['s']) {
                player.vx -= Math.cos(player.angle) * accel * 0.5;
                player.vy -= Math.sin(player.angle) * accel * 0.5;
            }
            if (keys['a']) {
                player.vx += Math.cos(player.angle - Math.PI/2) * accel * 0.7;
                player.vy += Math.sin(player.angle - Math.PI/2) * accel * 0.7;
            }
            if (keys['d']) {
                player.vx += Math.cos(player.angle + Math.PI/2) * accel * 0.7;
                player.vy += Math.sin(player.angle + Math.PI/2) * accel * 0.7;
            }

            // Boost
            player.boosting = keys['shift'] && player.boost > 0;
            if (player.boosting) {
                player.boost -= dt * 0.03;
                if (Math.random() < 0.3) {
                    createParticle(
                        player.x - Math.cos(player.angle) * 20,
                        player.y - Math.sin(player.angle) * 20,
                        '#0af',
                        { x: -player.vx, y: -player.vy },
                        20
                    );
                }
            } else {
                player.boost = Math.min(player.maxBoost, player.boost + dt * 0.015);
            }

            // Speed limit
            const maxSpeed = player.boosting ? 10 : 6;
            const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            if (speed > maxSpeed) {
                player.vx = (player.vx / speed) * maxSpeed;
                player.vy = (player.vy / speed) * maxSpeed;
            }

            // Friction
            player.vx *= 0.98;
            player.vy *= 0.98;

            // Update position
            player.x += player.vx;
            player.y += player.vy;

            // World wrap
            if (player.x < 0) player.x += WORLD_SIZE;
            if (player.x > WORLD_SIZE) player.x -= WORLD_SIZE;
            if (player.y < 0) player.y += WORLD_SIZE;
            if (player.y > WORLD_SIZE) player.y -= WORLD_SIZE;

            // Shooting
            const weapon = WEAPONS[player.weapon];
            if (mouseDown && Date.now() - player.lastFire > weapon.cooldown) {
                if (player.weapon === 'LASER' || player.ammo[player.weapon] > 0) {
                    player.lastFire = Date.now();
                    if (player.weapon !== 'LASER') player.ammo[player.weapon]--;

                    const count = weapon.count || 1;
                    for (let i = 0; i < count; i++) {
                        const spread = (i - (count - 1) / 2) * weapon.spread;
                        const angle = player.angle + spread + (Math.random() - 0.5) * 0.05;
                        bullets.push({
                            x: player.x + Math.cos(player.angle) * 25,
                            y: player.y + Math.sin(player.angle) * 25,
                            vx: Math.cos(angle) * weapon.speed + player.vx * 0.5,
                            vy: Math.sin(angle) * weapon.speed + player.vy * 0.5,
                            damage: weapon.damage,
                            friendly: true,
                            color: weapon.color,
                            size: weapon.size || 4,
                            life: 60
                        });
                    }

                    // Switch to laser if out of ammo
                    if (player.ammo[player.weapon] <= 0 && player.weapon !== 'LASER') {
                        player.weapon = 'LASER';
                    }
                }
            }

            // Update cooldowns
            if (player.invulnerable > 0) player.invulnerable -= dt;
            if (player.dodgeCooldown > 0) player.dodgeCooldown -= dt;

            // Shield regeneration
            if (player.shield < player.maxShield) {
                player.shield += dt * 0.005;
            }

            // Update bullets
            bullets = bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life--;

                // World wrap for bullets
                if (bullet.x < 0) bullet.x += WORLD_SIZE;
                if (bullet.x > WORLD_SIZE) bullet.x -= WORLD_SIZE;
                if (bullet.y < 0) bullet.y += WORLD_SIZE;
                if (bullet.y > WORLD_SIZE) bullet.y -= WORLD_SIZE;

                return bullet.life > 0;
            });

            // Update asteroids
            asteroids.forEach(asteroid => {
                asteroid.x += asteroid.vx;
                asteroid.y += asteroid.vy;
                asteroid.rotation += asteroid.rotationSpeed;

                // World wrap
                if (asteroid.x < 0) asteroid.x += WORLD_SIZE;
                if (asteroid.x > WORLD_SIZE) asteroid.x -= WORLD_SIZE;
                if (asteroid.y < 0) asteroid.y += WORLD_SIZE;
                if (asteroid.y > WORLD_SIZE) asteroid.y -= WORLD_SIZE;
            });

            // Update enemies
            enemies.forEach(enemy => updateEnemy(enemy, dt));

            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life--;
                return p.life > 0;
            });

            // Update explosions
            explosions = explosions.filter(e => {
                e.radius += (e.maxRadius - e.radius) * 0.2;
                e.life -= 0.05;
                return e.life > 0;
            });

            // Update powerups
            powerups.forEach(p => {
                p.rotation += 0.02;
                p.pulse += 0.1;
            });

            // Collision detection
            // Bullets vs Asteroids
            bullets.forEach((bullet, bi) => {
                if (!bullet.friendly) return;

                asteroids.forEach((asteroid, ai) => {
                    if (circleCollision(bullet, asteroid, bullet.size, asteroid.size)) {
                        asteroid.health -= bullet.damage;
                        bullets.splice(bi, 1);

                        // Hit effect
                        for (let i = 0; i < 5; i++) {
                            createParticle(bullet.x, bullet.y, '#fa0', {
                                x: (Math.random() - 0.5) * 5,
                                y: (Math.random() - 0.5) * 5
                            }, 15);
                        }

                        if (asteroid.health <= 0) {
                            // Destroy asteroid
                            createExplosion(asteroid.x, asteroid.y, asteroid.size, '#fa0');
                            screenShake = 5;

                            // Score and combo
                            combo++;
                            comboTimer = 120;
                            const points = Math.floor(asteroid.size * combo);
                            score += points;

                            // Split into smaller asteroids
                            if (asteroid.size > 25) {
                                for (let i = 0; i < 2; i++) {
                                    asteroids.push(createAsteroid(
                                        asteroid.x + (Math.random() - 0.5) * 20,
                                        asteroid.y + (Math.random() - 0.5) * 20,
                                        asteroid.size * 0.5
                                    ));
                                }
                            }

                            // Chance to spawn powerup
                            if (Math.random() < 0.1) {
                                createPowerup(asteroid.x, asteroid.y);
                            }

                            asteroids.splice(ai, 1);

                            // Respawn asteroid far from player
                            if (asteroids.length < ASTEROID_COUNT) {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = 1000 + Math.random() * 500;
                                asteroids.push(createAsteroid(
                                    player.x + Math.cos(angle) * dist,
                                    player.y + Math.sin(angle) * dist
                                ));
                            }
                        }
                    }
                });
            });

            // Bullets vs Enemies
            bullets.forEach((bullet, bi) => {
                if (!bullet.friendly) return;

                enemies.forEach((enemy, ei) => {
                    const size = enemy.type === 'bomber' ? 25 : 20;
                    if (circleCollision(bullet, enemy, bullet.size, size)) {
                        enemy.health -= bullet.damage;
                        bullets.splice(bi, 1);

                        for (let i = 0; i < 5; i++) {
                            createParticle(bullet.x, bullet.y, '#f44', {
                                x: (Math.random() - 0.5) * 5,
                                y: (Math.random() - 0.5) * 5
                            }, 15);
                        }

                        if (enemy.health <= 0) {
                            createExplosion(enemy.x, enemy.y, 40, '#f44');
                            screenShake = 10;

                            combo++;
                            comboTimer = 120;
                            const baseScore = enemy.type === 'ace' ? 500 : enemy.type === 'bomber' ? 300 : 200;
                            score += baseScore * combo;

                            if (Math.random() < 0.3) {
                                createPowerup(enemy.x, enemy.y);
                            }

                            enemies.splice(ei, 1);

                            // Check wave completion
                            if (enemies.length === 0) {
                                wave++;
                                setTimeout(spawnWaveEnemies, 2000);
                                showNotification(`WAVE ${wave - 1} COMPLETE! +${wave * 1000} BONUS`);
                                score += wave * 1000;
                            }
                        }
                    }
                });
            });

            // Enemy bullets vs Player
            if (player.invulnerable <= 0) {
                bullets.forEach((bullet, bi) => {
                    if (bullet.friendly) return;

                    if (circleCollision(bullet, player, bullet.size, 15)) {
                        bullets.splice(bi, 1);

                        let damage = bullet.damage;
                        if (player.shield > 0) {
                            const shieldDamage = Math.min(player.shield, damage * 0.7);
                            player.shield -= shieldDamage;
                            damage -= shieldDamage;
                        }
                        player.health -= damage;
                        screenShake = 8;

                        for (let i = 0; i < 10; i++) {
                            createParticle(player.x, player.y, '#f44', {
                                x: (Math.random() - 0.5) * 8,
                                y: (Math.random() - 0.5) * 8
                            }, 20);
                        }

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                });
            }

            // Player vs Asteroids
            if (player.invulnerable <= 0) {
                asteroids.forEach(asteroid => {
                    if (circleCollision(player, asteroid, 15, asteroid.size)) {
                        let damage = asteroid.size * 0.5;
                        if (player.shield > 0) {
                            const shieldDamage = Math.min(player.shield, damage * 0.7);
                            player.shield -= shieldDamage;
                            damage -= shieldDamage;
                        }
                        player.health -= damage;
                        player.invulnerable = 500;
                        screenShake = 10;

                        // Bounce off
                        const angle = Math.atan2(player.y - asteroid.y, player.x - asteroid.x);
                        player.vx = Math.cos(angle) * 8;
                        player.vy = Math.sin(angle) * 8;

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                });
            }

            // Player vs Powerups
            powerups = powerups.filter((powerup, pi) => {
                if (circleCollision(player, powerup, 15, 20)) {
                    switch(powerup.type) {
                        case 'health':
                            player.health = Math.min(player.maxHealth, player.health + 30);
                            showNotification('+30 HEALTH');
                            break;
                        case 'shield':
                            player.shield = Math.min(player.maxShield, player.shield + 50);
                            showNotification('+50 SHIELD');
                            break;
                        case 'plasma':
                            player.ammo.PLASMA += 25;
                            showNotification('+25 PLASMA AMMO');
                            break;
                        case 'scatter':
                            player.ammo.SCATTER += 15;
                            showNotification('+15 SCATTER AMMO');
                            break;
                    }
                    return false;
                }
                return true;
            });

            // Combo timer
            if (comboTimer > 0) {
                comboTimer--;
                comboEl.textContent = `${combo}x COMBO`;
                comboEl.classList.add('show');
            } else {
                combo = 0;
                comboEl.classList.remove('show');
            }

            // Screen shake decay
            if (screenShake > 0) screenShake *= 0.9;

            updateUI();
        }

        function render() {
            if (!player) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Camera with screen shake
            const shakeX = (Math.random() - 0.5) * screenShake;
            const shakeY = (Math.random() - 0.5) * screenShake;
            const camera = {
                x: player.x - canvas.width / 2 + shakeX,
                y: player.y - canvas.height / 2 + shakeY
            };

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw stars (parallax)
            ctx.restore();
            drawStars(ctx, camera);
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw explosions
            explosions.forEach(e => {
                const gradient = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${e.life})`);
                gradient.addColorStop(0.3, e.color + Math.floor(e.life * 255).toString(16).padStart(2, '0'));
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw particles
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw asteroids
            asteroids.forEach(asteroid => {
                // Only draw if on screen (with margin)
                const dx = asteroid.x - player.x;
                const dy = asteroid.y - player.y;
                if (Math.abs(dx) < canvas.width / 2 + 100 && Math.abs(dy) < canvas.height / 2 + 100) {
                    drawAsteroid(ctx, asteroid);
                }
            });

            // Draw powerups
            powerups.forEach(powerup => {
                const dx = powerup.x - player.x;
                const dy = powerup.y - player.y;
                if (Math.abs(dx) < canvas.width / 2 + 50 && Math.abs(dy) < canvas.height / 2 + 50) {
                    drawPowerup(ctx, powerup);
                }
            });

            // Draw bullets
            bullets.forEach(bullet => {
                const gradient = ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bullet.size * 2);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.3, bullet.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size * 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw enemies
            enemies.forEach(enemy => {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                if (Math.abs(dx) < canvas.width / 2 + 50 && Math.abs(dy) < canvas.height / 2 + 50) {
                    drawEnemyShip(ctx, enemy.x, enemy.y, enemy.angle, enemy.type, enemy.health, enemy.maxHealth);
                }
            });

            // Draw player
            const playerAlpha = player.invulnerable > 0 ? 0.5 + Math.sin(Date.now() * 0.02) * 0.5 : 1;
            ctx.globalAlpha = playerAlpha;
            drawPlayerShip(ctx, player.x, player.y, player.angle, player.boosting);
            ctx.globalAlpha = 1;

            ctx.restore();

            // Draw minimap
            drawMinimap();
        }

        function drawMinimap() {
            minimapCtx.clearRect(0, 0, 180, 180);

            // Background
            minimapCtx.fillStyle = 'rgba(0, 20, 40, 0.8)';
            minimapCtx.beginPath();
            minimapCtx.arc(90, 90, 85, 0, Math.PI * 2);
            minimapCtx.fill();

            const scale = 170 / WORLD_SIZE;
            const offsetX = 90;
            const offsetY = 90;

            // Draw asteroids as dots
            minimapCtx.fillStyle = '#666';
            asteroids.forEach(asteroid => {
                let x = (asteroid.x - player.x) * scale + offsetX;
                let y = (asteroid.y - player.y) * scale + offsetY;

                // Wrap
                while (x < 5) x += 170;
                while (x > 175) x -= 170;
                while (y < 5) y += 170;
                while (y > 175) y -= 170;

                const dist = Math.sqrt((x - 90) ** 2 + (y - 90) ** 2);
                if (dist < 85) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });

            // Draw enemies
            enemies.forEach(enemy => {
                let x = (enemy.x - player.x) * scale + offsetX;
                let y = (enemy.y - player.y) * scale + offsetY;

                while (x < 5) x += 170;
                while (x > 175) x -= 170;
                while (y < 5) y += 170;
                while (y > 175) y -= 170;

                const dist = Math.sqrt((x - 90) ** 2 + (y - 90) ** 2);
                if (dist < 85) {
                    minimapCtx.fillStyle = enemy.type === 'ace' ? '#f0f' : '#f44';
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 4, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });

            // Draw powerups
            minimapCtx.fillStyle = '#0f0';
            powerups.forEach(powerup => {
                let x = (powerup.x - player.x) * scale + offsetX;
                let y = (powerup.y - player.y) * scale + offsetY;

                while (x < 5) x += 170;
                while (x > 175) x -= 170;
                while (y < 5) y += 170;
                while (y > 175) y -= 170;

                const dist = Math.sqrt((x - 90) ** 2 + (y - 90) ** 2);
                if (dist < 85) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 3, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });

            // Draw player (center)
            minimapCtx.fillStyle = '#0ff';
            minimapCtx.beginPath();
            minimapCtx.arc(90, 90, 5, 0, Math.PI * 2);
            minimapCtx.fill();

            // Direction indicator
            minimapCtx.strokeStyle = '#0ff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(90, 90);
            minimapCtx.lineTo(90 + Math.cos(player.angle) * 15, 90 + Math.sin(player.angle) * 15);
            minimapCtx.stroke();
        }

        function gameOver() {
            gameRunning = false;
            createExplosion(player.x, player.y, 80, '#f44');
            finalScoreEl.textContent = score;
            finalWaveEl.textContent = wave;
            setTimeout(() => {
                gameOverScreen.classList.remove('hidden');
            }, 1000);
        }

        // Hide cursor over canvas
        canvas.style.cursor = 'none';
    </script>
</body>
</html>
