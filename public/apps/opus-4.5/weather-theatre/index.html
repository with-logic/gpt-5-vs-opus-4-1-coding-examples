<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Theatre</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Crimson+Text:ital@0;1&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', serif;
            background: #0a0a0a;
            min-height: 100vh;
            overflow-x: hidden;
            color: #f5f5f5;
        }

        .theatre-container {
            width: 100%;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .stage-frame {
            position: relative;
            width: 100%;
            max-width: 1200px;
            aspect-ratio: 16/9;
            border: 12px solid #2a1810;
            border-radius: 8px;
            overflow: hidden;
            box-shadow:
                0 0 60px rgba(0,0,0,0.8),
                inset 0 0 100px rgba(0,0,0,0.5),
                0 0 0 4px #1a0f08,
                0 0 0 8px #3d2518;
            background: #000;
        }

        .stage-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(139, 69, 19, 0.1) 0%,
                transparent 10%,
                transparent 90%,
                rgba(139, 69, 19, 0.1) 100%
            );
            pointer-events: none;
            z-index: 100;
        }

        .canvas-stage {
            width: 100%;
            height: 100%;
            display: block;
        }

        .curtain {
            position: absolute;
            top: 0;
            height: 100%;
            background: linear-gradient(
                90deg,
                #8B0000 0%,
                #B22222 10%,
                #8B0000 20%,
                #B22222 30%,
                #8B0000 40%,
                #B22222 50%,
                #8B0000 60%,
                #B22222 70%,
                #8B0000 80%,
                #B22222 90%,
                #8B0000 100%
            );
            z-index: 50;
            transition: transform 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .curtain-left {
            left: 0;
            width: 50%;
            transform-origin: left center;
        }

        .curtain-right {
            right: 0;
            width: 50%;
            transform-origin: right center;
        }

        .curtain-left.open {
            transform: translateX(-100%);
        }

        .curtain-right.open {
            transform: translateX(100%);
        }

        .curtain-valance {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(
                to bottom,
                #8B0000 0%,
                #6B0000 100%
            );
            z-index: 60;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 10px;
        }

        .curtain-valance::after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 0;
            right: 0;
            height: 20px;
            background:
                radial-gradient(ellipse 30px 20px at 30px 0, #8B0000 19px, transparent 20px),
                radial-gradient(ellipse 30px 20px at 90px 0, #8B0000 19px, transparent 20px);
            background-size: 60px 20px;
            background-repeat: repeat-x;
        }

        .subtitle-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 40;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 30px;
            border-radius: 4px;
            max-width: 80%;
            text-align: center;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .subtitle-text {
            font-family: 'Playfair Display', serif;
            font-size: 1.4rem;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            letter-spacing: 1px;
            min-height: 1.6em;
        }

        .controls-panel {
            width: 100%;
            max-width: 1200px;
            margin-top: 30px;
            padding: 30px;
            background: linear-gradient(
                135deg,
                rgba(42, 24, 16, 0.95) 0%,
                rgba(26, 15, 8, 0.95) 100%
            );
            border-radius: 12px;
            border: 2px solid #3d2518;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }

        .theatre-title {
            font-family: 'Playfair Display', serif;
            font-size: 2rem;
            color: #ffd700;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toggle-label {
            font-size: 1.1rem;
            color: #d4af37;
        }

        .toggle-switch {
            position: relative;
            width: 80px;
            height: 36px;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            border-radius: 18px;
            cursor: pointer;
            border: 2px solid #3d2518;
            transition: all 0.3s ease;
        }

        .toggle-switch.night {
            background: linear-gradient(to bottom, #0f0f1a, #1a1a2e);
        }

        .toggle-switch::before {
            content: '‚òÄÔ∏è';
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .toggle-switch::after {
            content: 'üåô';
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .toggle-knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #ffd700, #f4a460);
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .toggle-switch.night .toggle-knob {
            left: calc(100% - 30px);
            background: linear-gradient(135deg, #c0c0c0, #808080);
        }

        .sliders-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
        }

        @media (max-width: 768px) {
            .sliders-container {
                grid-template-columns: 1fr;
            }
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mood-name {
            font-family: 'Playfair Display', serif;
            font-size: 1.3rem;
            color: #ffd700;
        }

        .mood-value {
            font-size: 1.1rem;
            color: #d4af37;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 12px;
            border-radius: 4px;
        }

        .slider-track {
            position: relative;
            height: 12px;
            background: linear-gradient(to right, #1a0f08, #2a1810);
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid #3d2518;
        }

        .slider-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            border-radius: 6px;
            transition: width 0.1s ease;
        }

        .slider-fill.cosy {
            background: linear-gradient(to right, #ff6b35, #ffd700);
        }

        .slider-fill.eerie {
            background: linear-gradient(to right, #4a0080, #8b00ff);
        }

        .slider-fill.heroic {
            background: linear-gradient(to right, #00416a, #e4e5e6);
        }

        .slider-thumb {
            position: absolute;
            top: 50%;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #ffd700, #f4a460);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
            border: 2px solid #fff;
            transition: transform 0.1s ease;
        }

        .slider-thumb:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }

        .slider-thumb:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(0.95);
        }

        .forecast-display {
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            text-align: center;
        }

        .forecast-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.2rem;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .forecast-data {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .forecast-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .forecast-icon {
            font-size: 2rem;
        }

        .forecast-value {
            font-size: 1.1rem;
            color: #d4af37;
        }

        .forecast-label {
            font-size: 0.9rem;
            color: #a08060;
        }

        .curtain-button {
            margin-top: 20px;
            padding: 12px 30px;
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            background: linear-gradient(135deg, #8B0000, #B22222);
            color: #ffd700;
            border: 2px solid #ffd700;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .curtain-button:hover {
            background: linear-gradient(135deg, #B22222, #DC143C);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(139, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Mock forecast data
        const mockForecast = {
            temperature: 72,
            humidity: 65,
            windSpeed: 12,
            condition: 'Partly Cloudy',
            precipitation: 30
        };

        // Scene descriptions for typewriter effect
        const sceneDescriptions = {
            cosy: [
                "A warm hearth glows beneath gathering clouds...",
                "Rain patters softly on cottage windowpanes...",
                "Golden light spills through autumn leaves...",
                "The kettle whistles as thunder rolls distant..."
            ],
            eerie: [
                "Shadows dance in the flickering gaslight...",
                "The fog creeps closer with each heartbeat...",
                "Something stirs in the depths of the storm...",
                "The wind whispers secrets best left unheard..."
            ],
            heroic: [
                "Lightning heralds the coming of champions...",
                "Through tempest and trial, glory awaits...",
                "The storm breaks upon the mountain's peak...",
                "Destiny rides upon the thunder's wings..."
            ]
        };

        // Custom Slider Component
        const MoodSlider = ({ label, value, onChange, colorClass }) => {
            const trackRef = useRef(null);
            const [isDragging, setIsDragging] = useState(false);

            const updateValue = useCallback((clientX) => {
                if (!trackRef.current) return;
                const rect = trackRef.current.getBoundingClientRect();
                const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
                const newValue = Math.round((x / rect.width) * 100);
                onChange(newValue);
            }, [onChange]);

            const handleMouseDown = (e) => {
                setIsDragging(true);
                updateValue(e.clientX);
            };

            const handleMouseMove = useCallback((e) => {
                if (isDragging) {
                    updateValue(e.clientX);
                }
            }, [isDragging, updateValue]);

            const handleMouseUp = useCallback(() => {
                setIsDragging(false);
            }, []);

            useEffect(() => {
                if (isDragging) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleMouseMove);
                        window.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [isDragging, handleMouseMove, handleMouseUp]);

            return (
                <div className="slider-group">
                    <div className="slider-label">
                        <span className="mood-name">{label}</span>
                        <span className="mood-value">{value}%</span>
                    </div>
                    <div
                        className="slider-track"
                        ref={trackRef}
                        onMouseDown={handleMouseDown}
                    >
                        <div
                            className={`slider-fill ${colorClass}`}
                            style={{ width: `${value}%` }}
                        />
                        <div
                            className="slider-thumb"
                            style={{ left: `${value}%` }}
                        />
                    </div>
                </div>
            );
        };

        // Main Theatre Component
        const WeatherTheatre = () => {
            const canvasRef = useRef(null);
            const animationRef = useRef(null);
            const [cosy, setCosy] = useState(50);
            const [eerie, setEerie] = useState(30);
            const [heroic, setHeroic] = useState(40);
            const [isNight, setIsNight] = useState(false);
            const [curtainOpen, setCurtainOpen] = useState(false);
            const [subtitle, setSubtitle] = useState('');
            const [targetSubtitle, setTargetSubtitle] = useState('');
            const subtitleIndex = useRef(0);

            // Parallax layer positions
            const parallaxRef = useRef({
                far: 0,
                mid: 0,
                near: 0,
                spotlight: { x: 0, y: 0, angle: 0 }
            });

            // Determine dominant mood and select scene description
            useEffect(() => {
                const moods = { cosy, eerie, heroic };
                const dominant = Object.entries(moods).reduce((a, b) =>
                    a[1] > b[1] ? a : b
                )[0];

                const descriptions = sceneDescriptions[dominant];
                const index = Math.floor((cosy + eerie + heroic) / 100 * descriptions.length) % descriptions.length;
                setTargetSubtitle(descriptions[index]);
                subtitleIndex.current = 0;
            }, [cosy, eerie, heroic]);

            // Typewriter effect
            useEffect(() => {
                if (subtitleIndex.current < targetSubtitle.length) {
                    const timer = setTimeout(() => {
                        setSubtitle(targetSubtitle.slice(0, subtitleIndex.current + 1));
                        subtitleIndex.current++;
                    }, 50);
                    return () => clearTimeout(timer);
                }
            }, [subtitle, targetSubtitle]);

            // Canvas rendering
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;

                const resize = () => {
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width * dpr;
                    canvas.height = rect.height * dpr;
                    ctx.scale(dpr, dpr);
                };

                resize();
                window.addEventListener('resize', resize);

                let time = 0;
                const particles = [];

                // Initialize particles
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 3 + 1,
                        speedX: (Math.random() - 0.5) * 2,
                        speedY: Math.random() * 2 + 1,
                        opacity: Math.random()
                    });
                }

                const render = () => {
                    const width = canvas.width / dpr;
                    const height = canvas.height / dpr;
                    time += 0.016;

                    // Update parallax
                    parallaxRef.current.far += 0.1;
                    parallaxRef.current.mid += 0.2;
                    parallaxRef.current.near += 0.4;
                    parallaxRef.current.spotlight.angle += 0.02;

                    // Calculate color palette based on moods
                    const cosyInfluence = cosy / 100;
                    const eerieInfluence = eerie / 100;
                    const heroicInfluence = heroic / 100;
                    const nightMultiplier = isNight ? 0.4 : 1;

                    // Sky gradient
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, height);

                    if (isNight) {
                        const r = Math.round(10 + eerieInfluence * 30);
                        const g = Math.round(10 + heroicInfluence * 20);
                        const b = Math.round(30 + eerieInfluence * 40 + heroicInfluence * 30);
                        skyGradient.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
                        skyGradient.addColorStop(1, `rgb(${r/2}, ${g/2}, ${b/2})`);
                    } else {
                        const r = Math.round(135 + cosyInfluence * 80 - eerieInfluence * 50);
                        const g = Math.round(150 + cosyInfluence * 60 + heroicInfluence * 50 - eerieInfluence * 80);
                        const b = Math.round(180 + heroicInfluence * 75 + eerieInfluence * 30);
                        skyGradient.addColorStop(0, `rgb(${Math.min(255, r)}, ${Math.min(255, g)}, ${Math.min(255, b)})`);
                        skyGradient.addColorStop(1, `rgb(${Math.min(255, r - 40)}, ${Math.min(255, g - 30)}, ${Math.min(255, b - 20)})`);
                    }

                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, width, height);

                    // Stars (night only)
                    if (isNight) {
                        for (let i = 0; i < 50; i++) {
                            const starX = (i * 23.7 + time * 0.5) % width;
                            const starY = (i * 17.3) % (height * 0.5);
                            const twinkle = Math.sin(time * 3 + i) * 0.5 + 0.5;
                            ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.8})`;
                            ctx.beginPath();
                            ctx.arc(starX, starY, 1 + twinkle, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Moon/Sun
                    const celestialX = width * 0.8 + Math.sin(time * 0.1) * 20;
                    const celestialY = height * 0.15 + Math.cos(time * 0.1) * 10;

                    if (isNight) {
                        // Moon with eerie glow
                        const moonGlow = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, 80);
                        moonGlow.addColorStop(0, `rgba(200, 200, 255, ${0.3 + eerieInfluence * 0.4})`);
                        moonGlow.addColorStop(1, 'rgba(200, 200, 255, 0)');
                        ctx.fillStyle = moonGlow;
                        ctx.fillRect(celestialX - 80, celestialY - 80, 160, 160);

                        ctx.fillStyle = `rgb(${220 + eerieInfluence * 35}, ${220 + eerieInfluence * 20}, ${240})`;
                        ctx.beginPath();
                        ctx.arc(celestialX, celestialY, 25, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Sun with cosy/heroic glow
                        const sunGlow = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, 100);
                        sunGlow.addColorStop(0, `rgba(255, ${200 + cosyInfluence * 55}, ${100 + heroicInfluence * 100}, 0.6)`);
                        sunGlow.addColorStop(0.5, `rgba(255, ${180 + cosyInfluence * 40}, ${80}, 0.2)`);
                        sunGlow.addColorStop(1, 'rgba(255, 200, 100, 0)');
                        ctx.fillStyle = sunGlow;
                        ctx.fillRect(celestialX - 100, celestialY - 100, 200, 200);

                        ctx.fillStyle = `rgb(255, ${220 + cosyInfluence * 35}, ${150 + heroicInfluence * 50})`;
                        ctx.beginPath();
                        ctx.arc(celestialX, celestialY, 30, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Far mountains (parallax layer 1)
                    const farOffset = parallaxRef.current.far % 100;
                    ctx.fillStyle = isNight
                        ? `rgba(${30 + eerieInfluence * 40}, ${20 + heroicInfluence * 30}, ${50 + eerieInfluence * 30}, 0.8)`
                        : `rgba(${100 + cosyInfluence * 50}, ${80 + heroicInfluence * 40}, ${120 + eerieInfluence * 30}, 0.6)`;

                    ctx.beginPath();
                    ctx.moveTo(0, height);
                    for (let x = 0; x <= width + 100; x += 50) {
                        const y = height * 0.5 + Math.sin((x + farOffset) * 0.01) * 60 + Math.sin((x + farOffset) * 0.02) * 30;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(width, height);
                    ctx.closePath();
                    ctx.fill();

                    // Mid hills (parallax layer 2)
                    const midOffset = parallaxRef.current.mid % 150;
                    ctx.fillStyle = isNight
                        ? `rgba(${20 + eerieInfluence * 30}, ${15 + heroicInfluence * 20}, ${40 + eerieInfluence * 20}, 0.9)`
                        : `rgba(${80 + cosyInfluence * 40}, ${100 + heroicInfluence * 30}, ${60 + eerieInfluence * 40}, 0.7)`;

                    ctx.beginPath();
                    ctx.moveTo(0, height);
                    for (let x = 0; x <= width + 100; x += 30) {
                        const y = height * 0.65 + Math.sin((x + midOffset) * 0.015) * 40 + Math.sin((x + midOffset) * 0.03) * 20;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(width, height);
                    ctx.closePath();
                    ctx.fill();

                    // Clouds
                    const cloudCount = 5 + Math.floor(eerieInfluence * 5);
                    for (let i = 0; i < cloudCount; i++) {
                        const cloudX = ((i * 200 + time * (20 + i * 5)) % (width + 200)) - 100;
                        const cloudY = height * 0.2 + i * 30 + Math.sin(time + i) * 10;
                        const cloudOpacity = isNight
                            ? 0.3 + eerieInfluence * 0.3
                            : 0.4 + cosyInfluence * 0.2 + heroicInfluence * 0.2;

                        ctx.fillStyle = isNight
                            ? `rgba(${40 + eerieInfluence * 60}, ${30 + eerieInfluence * 40}, ${60 + eerieInfluence * 50}, ${cloudOpacity})`
                            : `rgba(255, 255, 255, ${cloudOpacity})`;

                        // Draw cloud puffs
                        for (let j = 0; j < 5; j++) {
                            ctx.beginPath();
                            ctx.arc(cloudX + j * 25, cloudY + Math.sin(j) * 10, 25 + j * 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Lightning for heroic mood
                    if (heroicInfluence > 0.5 && Math.random() < 0.01 * heroicInfluence) {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.8})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        let lx = Math.random() * width;
                        let ly = 0;
                        ctx.moveTo(lx, ly);
                        while (ly < height * 0.6) {
                            lx += (Math.random() - 0.5) * 50;
                            ly += Math.random() * 40 + 20;
                            ctx.lineTo(lx, ly);
                        }
                        ctx.stroke();

                        // Flash effect
                        ctx.fillStyle = `rgba(255, 255, 255, 0.1)`;
                        ctx.fillRect(0, 0, width, height);
                    }

                    // Near foreground (parallax layer 3)
                    const nearOffset = parallaxRef.current.near % 200;
                    ctx.fillStyle = isNight
                        ? `rgb(${10 + eerieInfluence * 15}, ${8 + heroicInfluence * 10}, ${20 + eerieInfluence * 15})`
                        : `rgb(${40 + cosyInfluence * 30}, ${50 + heroicInfluence * 20}, ${30 + eerieInfluence * 20})`;

                    ctx.beginPath();
                    ctx.moveTo(0, height);
                    for (let x = 0; x <= width + 100; x += 20) {
                        const y = height * 0.85 + Math.sin((x + nearOffset) * 0.02) * 15 + Math.sin((x + nearOffset) * 0.05) * 8;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(width, height);
                    ctx.closePath();
                    ctx.fill();

                    // Trees silhouettes
                    const treeColor = isNight
                        ? `rgb(${5 + eerieInfluence * 10}, ${5 + heroicInfluence * 8}, ${15 + eerieInfluence * 10})`
                        : `rgb(${20 + cosyInfluence * 15}, ${30 + heroicInfluence * 10}, ${15 + eerieInfluence * 10})`;

                    ctx.fillStyle = treeColor;
                    for (let i = 0; i < 8; i++) {
                        const treeX = ((i * 150 + nearOffset * 0.5) % (width + 100)) - 50;
                        const treeHeight = 80 + Math.sin(i * 2.5) * 30;
                        const baseY = height * 0.85;

                        // Tree trunk
                        ctx.fillRect(treeX - 5, baseY - treeHeight * 0.3, 10, treeHeight * 0.3);

                        // Tree canopy (triangular for conifers)
                        ctx.beginPath();
                        ctx.moveTo(treeX, baseY - treeHeight);
                        ctx.lineTo(treeX - 30 - i * 3, baseY - treeHeight * 0.3);
                        ctx.lineTo(treeX + 30 + i * 3, baseY - treeHeight * 0.3);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Weather particles (rain/snow based on mood)
                    const particleIntensity = (eerieInfluence + heroicInfluence) * 0.5;
                    particles.forEach((p, i) => {
                        p.x += p.speedX * (1 + heroicInfluence);
                        p.y += p.speedY * (1 + particleIntensity);

                        if (p.y > height) {
                            p.y = 0;
                            p.x = Math.random() * width;
                        }
                        if (p.x < 0) p.x = width;
                        if (p.x > width) p.x = 0;

                        // Rain for eerie/heroic, warm particles for cosy
                        if (cosyInfluence > 0.5 && particleIntensity < 0.4) {
                            // Warm floating particles
                            ctx.fillStyle = `rgba(255, ${200 + Math.random() * 55}, ${100 + Math.random() * 50}, ${p.opacity * cosyInfluence * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (particleIntensity > 0.3) {
                            // Rain drops
                            ctx.strokeStyle = `rgba(${150 + heroicInfluence * 100}, ${180 + heroicInfluence * 75}, 255, ${p.opacity * 0.6})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(p.x, p.y);
                            ctx.lineTo(p.x + p.speedX * 3, p.y + p.speedY * 3);
                            ctx.stroke();
                        }
                    });

                    // Fog for eerie mood
                    if (eerieInfluence > 0.3) {
                        const fogGradient = ctx.createLinearGradient(0, height * 0.6, 0, height);
                        fogGradient.addColorStop(0, 'rgba(100, 80, 120, 0)');
                        fogGradient.addColorStop(1, `rgba(${80 + eerieInfluence * 40}, ${60 + eerieInfluence * 30}, ${100 + eerieInfluence * 50}, ${eerieInfluence * 0.5})`);
                        ctx.fillStyle = fogGradient;
                        ctx.fillRect(0, height * 0.6, width, height * 0.4);

                        // Fog wisps
                        for (let i = 0; i < 5; i++) {
                            const wispX = (time * 10 + i * 200) % (width + 200) - 100;
                            const wispY = height * 0.75 + Math.sin(time + i * 2) * 20;
                            ctx.fillStyle = `rgba(${100 + eerieInfluence * 50}, ${80 + eerieInfluence * 40}, ${120 + eerieInfluence * 50}, ${eerieInfluence * 0.3})`;
                            ctx.beginPath();
                            ctx.ellipse(wispX, wispY, 100, 20, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Spotlight sweep
                    const spotlightAngle = parallaxRef.current.spotlight.angle;
                    const spotX = width * 0.5 + Math.sin(spotlightAngle) * width * 0.4;
                    const spotY = height * 0.3;

                    const spotlightGradient = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, 200);
                    const spotlightIntensity = isNight ? 0.15 : 0.08;
                    spotlightGradient.addColorStop(0, `rgba(255, ${240 + cosyInfluence * 15}, ${200 + heroicInfluence * 55}, ${spotlightIntensity})`);
                    spotlightGradient.addColorStop(0.5, `rgba(255, ${240 + cosyInfluence * 15}, ${200}, ${spotlightIntensity * 0.5})`);
                    spotlightGradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

                    ctx.fillStyle = spotlightGradient;
                    ctx.fillRect(0, 0, width, height);

                    // Warm glow for cosy mood
                    if (cosyInfluence > 0.4) {
                        const warmGlow = ctx.createRadialGradient(width * 0.5, height * 0.9, 0, width * 0.5, height * 0.9, height * 0.6);
                        warmGlow.addColorStop(0, `rgba(255, ${180 + cosyInfluence * 50}, ${100 + cosyInfluence * 50}, ${cosyInfluence * 0.2})`);
                        warmGlow.addColorStop(1, 'rgba(255, 150, 50, 0)');
                        ctx.fillStyle = warmGlow;
                        ctx.fillRect(0, 0, width, height);
                    }

                    // Vignette effect
                    const vignette = ctx.createRadialGradient(width / 2, height / 2, height * 0.3, width / 2, height / 2, height);
                    vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
                    vignette.addColorStop(1, `rgba(0, 0, 0, ${0.4 + eerieInfluence * 0.3})`);
                    ctx.fillStyle = vignette;
                    ctx.fillRect(0, 0, width, height);

                    animationRef.current = requestAnimationFrame(render);
                };

                render();

                return () => {
                    window.removeEventListener('resize', resize);
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                };
            }, [cosy, eerie, heroic, isNight]);

            // Auto-open curtain after mount
            useEffect(() => {
                const timer = setTimeout(() => setCurtainOpen(true), 500);
                return () => clearTimeout(timer);
            }, []);

            return (
                <div className="theatre-container">
                    <div className="stage-frame">
                        <canvas ref={canvasRef} className="canvas-stage" />

                        <div className={`curtain curtain-left ${curtainOpen ? 'open' : ''}`} />
                        <div className={`curtain curtain-right ${curtainOpen ? 'open' : ''}`} />
                        <div className="curtain-valance" />

                        {curtainOpen && (
                            <div className="subtitle-container">
                                <div className="subtitle-text">{subtitle}<span style={{opacity: Math.sin(Date.now() * 0.01) > 0 ? 1 : 0}}>|</span></div>
                            </div>
                        )}
                    </div>

                    <div className="controls-panel">
                        <div className="controls-header">
                            <h1 className="theatre-title">‚öú Weather Theatre ‚öú</h1>
                            <div className="toggle-container">
                                <span className="toggle-label">Matin√©e</span>
                                <div
                                    className={`toggle-switch ${isNight ? 'night' : ''}`}
                                    onClick={() => setIsNight(!isNight)}
                                >
                                    <div className="toggle-knob" />
                                </div>
                                <span className="toggle-label">Night</span>
                            </div>
                        </div>

                        <div className="sliders-container">
                            <MoodSlider
                                label="üî• Cosy"
                                value={cosy}
                                onChange={setCosy}
                                colorClass="cosy"
                            />
                            <MoodSlider
                                label="üëª Eerie"
                                value={eerie}
                                onChange={setEerie}
                                colorClass="eerie"
                            />
                            <MoodSlider
                                label="‚öîÔ∏è Heroic"
                                value={heroic}
                                onChange={setHeroic}
                                colorClass="heroic"
                            />
                        </div>

                        <div className="forecast-display">
                            <div className="forecast-title">Today's Forecast</div>
                            <div className="forecast-data">
                                <div className="forecast-item">
                                    <span className="forecast-icon">üå°Ô∏è</span>
                                    <span className="forecast-value">{mockForecast.temperature}¬∞F</span>
                                    <span className="forecast-label">Temperature</span>
                                </div>
                                <div className="forecast-item">
                                    <span className="forecast-icon">üíß</span>
                                    <span className="forecast-value">{mockForecast.humidity}%</span>
                                    <span className="forecast-label">Humidity</span>
                                </div>
                                <div className="forecast-item">
                                    <span className="forecast-icon">üí®</span>
                                    <span className="forecast-value">{mockForecast.windSpeed} mph</span>
                                    <span className="forecast-label">Wind</span>
                                </div>
                                <div className="forecast-item">
                                    <span className="forecast-icon">üåßÔ∏è</span>
                                    <span className="forecast-value">{mockForecast.precipitation}%</span>
                                    <span className="forecast-label">Precipitation</span>
                                </div>
                                <div className="forecast-item">
                                    <span className="forecast-icon">‚õÖ</span>
                                    <span className="forecast-value">{mockForecast.condition}</span>
                                    <span className="forecast-label">Condition</span>
                                </div>
                            </div>
                        </div>

                        <div style={{ textAlign: 'center' }}>
                            <button
                                className="curtain-button"
                                onClick={() => setCurtainOpen(!curtainOpen)}
                            >
                                {curtainOpen ? '‚óÄ Close Curtain ‚ñ∂' : '‚ñ∂ Open Curtain ‚óÄ'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Render the app
        ReactDOM.createRoot(document.getElementById('root')).render(<WeatherTheatre />);
    </script>
</body>
</html>