<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean Wave Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(15, 52, 96, 0.85);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 16px;
            z-index: 100;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls h2 {
            color: #e8f4f8;
            font-size: 1.4rem;
            margin-bottom: 20px;
            font-weight: 300;
            letter-spacing: 1px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            padding-bottom: 12px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #a8d8ea;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .control-group label span {
            color: #4db8d9;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a3a5c, #2a5a8c);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #4db8d9, #2a8ab0);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #4db8d9, #2a8ab0);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .time-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .time-btn {
            flex: 1;
            min-width: 60px;
            padding: 10px 8px;
            background: linear-gradient(135deg, #1a3a5c, #2a4a6c);
            border: 1px solid rgba(77, 184, 217, 0.3);
            color: #a8d8ea;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .time-btn:hover {
            background: linear-gradient(135deg, #2a5a8c, #3a6a9c);
            border-color: rgba(77, 184, 217, 0.6);
        }

        .time-btn.active {
            background: linear-gradient(135deg, #4db8d9, #2a8ab0);
            color: #fff;
            border-color: #4db8d9;
        }

        .info-text {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(168, 216, 234, 0.7);
            font-size: 0.75rem;
            text-align: center;
            line-height: 1.5;
        }

        @media (max-width: 600px) {
            .controls {
                top: 10px;
                right: 10px;
                left: 10px;
                min-width: unset;
                padding: 18px;
            }
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: #4db8d9;
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 3px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">Loading Ocean...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="controls">
        <h2>ðŸŒŠ Ocean Controls</h2>

        <div class="control-group">
            <label>
                Wind Speed
                <span id="windValue">5 m/s</span>
            </label>
            <input type="range" id="windSpeed" min="0" max="20" value="5" step="0.5">
        </div>

        <div class="control-group">
            <label>
                Wave Height
                <span id="heightValue">1.0x</span>
            </label>
            <input type="range" id="waveHeight" min="0.2" max="3" value="1" step="0.1">
        </div>

        <div class="control-group">
            <label>
                Wave Frequency
                <span id="freqValue">1.0x</span>
            </label>
            <input type="range" id="waveFrequency" min="0.3" max="2" value="1" step="0.1">
        </div>

        <div class="control-group">
            <label>Time of Day</label>
            <div class="time-buttons">
                <button class="time-btn" data-time="dawn">Dawn</button>
                <button class="time-btn active" data-time="day">Day</button>
                <button class="time-btn" data-time="sunset">Sunset</button>
                <button class="time-btn" data-time="night">Night</button>
            </div>
        </div>

        <div class="control-group">
            <label>
                Sun Position
                <span id="sunValue">45Â°</span>
            </label>
            <input type="range" id="sunPosition" min="0" max="180" value="45" step="1">
        </div>

        <div class="info-text">
            Drag to rotate view â€¢ Scroll to zoom<br>
            Relax and enjoy the waves
        </div>
    </div>

    <script>
        // Ocean Wave Simulation - Three.js Implementation
        let scene, camera, renderer, ocean, sky, sun, sunLight, ambientLight;
        let time = 0;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isDragging = false;
        let previousMouseX = 0, previousMouseY = 0;

        // Parameters
        const params = {
            windSpeed: 5,
            waveHeight: 1,
            waveFrequency: 1,
            timeOfDay: 'day',
            sunPosition: 45
        };

        // Color presets for different times of day
        const timePresets = {
            dawn: {
                skyTop: new THREE.Color(0x1a1a2e),
                skyBottom: new THREE.Color(0xff6b6b),
                sunColor: new THREE.Color(0xffaa77),
                ambientColor: new THREE.Color(0x443355),
                waterColor: new THREE.Color(0x001a33),
                waterDeep: new THREE.Color(0x000d1a),
                fogColor: new THREE.Color(0x2a1a3a),
                sunIntensity: 0.8
            },
            day: {
                skyTop: new THREE.Color(0x0077be),
                skyBottom: new THREE.Color(0x87ceeb),
                sunColor: new THREE.Color(0xfffaf0),
                ambientColor: new THREE.Color(0x6699cc),
                waterColor: new THREE.Color(0x006994),
                waterDeep: new THREE.Color(0x003366),
                fogColor: new THREE.Color(0x87ceeb),
                sunIntensity: 1.2
            },
            sunset: {
                skyTop: new THREE.Color(0x2c1654),
                skyBottom: new THREE.Color(0xff7b54),
                sunColor: new THREE.Color(0xff6347),
                ambientColor: new THREE.Color(0x553344),
                waterColor: new THREE.Color(0x1a3a4a),
                waterDeep: new THREE.Color(0x0d1f2a),
                fogColor: new THREE.Color(0x4a2a4a),
                sunIntensity: 0.9
            },
            night: {
                skyTop: new THREE.Color(0x0a0a1a),
                skyBottom: new THREE.Color(0x1a1a3a),
                sunColor: new THREE.Color(0xaaccff),
                ambientColor: new THREE.Color(0x112244),
                waterColor: new THREE.Color(0x001122),
                waterDeep: new THREE.Color(0x000811),
                fogColor: new THREE.Color(0x0a0a1a),
                sunIntensity: 0.3
            }
        };

        // Vertex shader for ocean waves
        const oceanVertexShader = `
            uniform float uTime;
            uniform float uWindSpeed;
            uniform float uWaveHeight;
            uniform float uWaveFrequency;

            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            varying float vElevation;

            // Simplex noise functions
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);

                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);

                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;

                i = mod289(i);
                vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));

                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;

                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);

                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);

                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);

                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));

                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);

                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;

                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            float getWaveHeight(vec2 pos, float t) {
                float windFactor = uWindSpeed * 0.1;
                float freq = uWaveFrequency;

                // Primary wave
                float wave1 = sin(pos.x * 0.05 * freq + t * (0.5 + windFactor * 0.3)) *
                             cos(pos.y * 0.03 * freq + t * 0.3) * 2.0;

                // Secondary wave
                float wave2 = sin(pos.x * 0.08 * freq - pos.y * 0.06 * freq + t * (0.7 + windFactor * 0.2)) * 1.5;

                // Tertiary wave for more detail
                float wave3 = sin(pos.x * 0.15 * freq + pos.y * 0.12 * freq + t * 1.2) * 0.8;

                // Noise-based waves for realism
                float noise1 = snoise(vec3(pos * 0.02 * freq, t * 0.3)) * 3.0;
                float noise2 = snoise(vec3(pos * 0.05 * freq, t * 0.5 + 100.0)) * 1.5;
                float noise3 = snoise(vec3(pos * 0.1 * freq, t * 0.8 + 200.0)) * 0.7;

                // Wind-driven choppy waves
                float chop = snoise(vec3(pos * 0.03 * freq + vec2(t * windFactor * 0.5, 0.0), t * 0.4)) * windFactor * 0.8;

                float total = (wave1 + wave2 + wave3 + noise1 + noise2 + noise3 + chop) * uWaveHeight;

                return total;
            }

            void main() {
                vUv = uv;

                vec3 pos = position;

                // Calculate wave height
                float elevation = getWaveHeight(pos.xz, uTime);
                pos.y += elevation;

                vElevation = elevation;

                // Calculate normal using finite differences
                float delta = 0.5;
                float hL = getWaveHeight(pos.xz - vec2(delta, 0.0), uTime);
                float hR = getWaveHeight(pos.xz + vec2(delta, 0.0), uTime);
                float hD = getWaveHeight(pos.xz - vec2(0.0, delta), uTime);
                float hU = getWaveHeight(pos.xz + vec2(0.0, delta), uTime);

                vec3 normal = normalize(vec3(hL - hR, 2.0 * delta, hD - hU));
                vNormal = normalMatrix * normal;

                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPosition.xyz;

                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `;

        // Fragment shader for ocean
        const oceanFragmentShader = `
            uniform vec3 uWaterColor;
            uniform vec3 uWaterDeep;
            uniform vec3 uSunColor;
            uniform vec3 uSunDirection;
            uniform float uSunIntensity;
            uniform float uTime;
            uniform vec3 uCameraPosition;

            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            varying float vElevation;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(uCameraPosition - vWorldPosition);
                vec3 sunDir = normalize(uSunDirection);

                // Fresnel effect
                float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);
                fresnel = mix(0.02, 1.0, fresnel);

                // Water color based on depth/elevation
                float depthFactor = smoothstep(-5.0, 5.0, vElevation);
                vec3 waterColor = mix(uWaterDeep, uWaterColor, depthFactor);

                // Diffuse lighting
                float diffuse = max(dot(normal, sunDir), 0.0);

                // Specular highlights (sun reflection)
                vec3 halfDir = normalize(sunDir + viewDir);
                float specular = pow(max(dot(normal, halfDir), 0.0), 256.0);
                specular *= uSunIntensity;

                // Subsurface scattering approximation
                float sss = pow(max(dot(viewDir, -sunDir + normal * 0.5), 0.0), 3.0) * 0.3;
                vec3 sssColor = vec3(0.0, 0.5, 0.5) * sss * uSunIntensity;

                // Foam on wave peaks
                float foam = smoothstep(2.5, 4.0, vElevation) * 0.5;
                foam += smoothstep(0.7, 0.9, abs(normal.x) + abs(normal.z)) * 0.3;
                vec3 foamColor = vec3(0.9, 0.95, 1.0);

                // Combine all lighting
                vec3 ambient = waterColor * 0.3;
                vec3 diffuseColor = waterColor * diffuse * uSunIntensity * 0.5;
                vec3 specularColor = uSunColor * specular;

                // Sky reflection
                vec3 skyColor = mix(uWaterColor * 1.5, vec3(0.6, 0.8, 1.0), fresnel * 0.5);

                vec3 finalColor = ambient + diffuseColor + specularColor + sssColor;
                finalColor = mix(finalColor, skyColor, fresnel * 0.4);
                finalColor = mix(finalColor, foamColor, foam);

                // Tone mapping
                finalColor = finalColor / (finalColor + vec3(1.0));
                finalColor = pow(finalColor, vec3(1.0 / 2.2));

                gl_FragColor = vec4(finalColor, 0.95);
            }
        `;

        // Sky shader
        const skyVertexShader = `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const skyFragmentShader = `
            uniform vec3 uSkyTop;
            uniform vec3 uSkyBottom;
            uniform vec3 uSunColor;
            uniform vec3 uSunDirection;
            uniform float uSunIntensity;

            varying vec3 vWorldPosition;

            void main() {
                vec3 direction = normalize(vWorldPosition);

                // Gradient sky
                float gradient = direction.y * 0.5 + 0.5;
                gradient = pow(gradient, 0.8);
                vec3 skyColor = mix(uSkyBottom, uSkyTop, gradient);

                // Sun
                vec3 sunDir = normalize(uSunDirection);
                float sunDot = dot(direction, sunDir);

                // Sun disk
                float sunDisk = smoothstep(0.995, 0.999, sunDot);

                // Sun glow
                float sunGlow = pow(max(sunDot, 0.0), 8.0) * 0.5;
                float sunHalo = pow(max(sunDot, 0.0), 64.0) * 2.0;

                vec3 sunEffect = uSunColor * (sunDisk + sunGlow + sunHalo) * uSunIntensity;

                // Atmospheric scattering near horizon
                float horizon = 1.0 - abs(direction.y);
                horizon = pow(horizon, 3.0);
                vec3 horizonColor = mix(uSkyBottom, uSunColor, 0.3) * horizon * 0.5;

                vec3 finalColor = skyColor + sunEffect + horizonColor;

                // Tone mapping
                finalColor = finalColor / (finalColor + vec3(1.0));
                finalColor = pow(finalColor, vec3(1.0 / 2.2));

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 30, 80);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create ocean
            createOcean();

            // Create sky
            createSky();

            // Lighting
            ambientLight = new THREE.AmbientLight(0x6699cc, 0.5);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xfffaf0, 1);
            sunLight.position.set(100, 100, 50);
            scene.add(sunLight);

            // Fog for depth
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.002);

            // Event listeners
            setupEventListeners();

            // Apply initial time of day
            updateTimeOfDay('day');

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);

            // Start animation
            animate();
        }

        function createOcean() {
            const geometry = new THREE.PlaneGeometry(800, 800, 256, 256);
            geometry.rotateX(-Math.PI / 2);

            const preset = timePresets.day;

            const material = new THREE.ShaderMaterial({
                vertexShader: oceanVertexShader,
                fragmentShader: oceanFragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uWindSpeed: { value: params.windSpeed },
                    uWaveHeight: { value: params.waveHeight },
                    uWaveFrequency: { value: params.waveFrequency },
                    uWaterColor: { value: preset.waterColor },
                    uWaterDeep: { value: preset.waterDeep },
                    uSunColor: { value: preset.sunColor },
                    uSunDirection: { value: new THREE.Vector3(1, 1, 0.5).normalize() },
                    uSunIntensity: { value: preset.sunIntensity },
                    uCameraPosition: { value: camera.position }
                },
                transparent: true,
                side: THREE.DoubleSide
            });

            ocean = new THREE.Mesh(geometry, material);
            scene.add(ocean);
        }

        function createSky() {
            const geometry = new THREE.SphereGeometry(2000, 32, 32);
            const preset = timePresets.day;

            const material = new THREE.ShaderMaterial({
                vertexShader: skyVertexShader,
                fragmentShader: skyFragmentShader,
                uniforms: {
                    uSkyTop: { value: preset.skyTop },
                    uSkyBottom: { value: preset.skyBottom },
                    uSunColor: { value: preset.sunColor },
                    uSunDirection: { value: new THREE.Vector3(1, 1, 0.5).normalize() },
                    uSunIntensity: { value: preset.sunIntensity }
                },
                side: THREE.BackSide
            });

            sky = new THREE.Mesh(geometry, material);
            scene.add(sky);
        }

        function updateSunPosition(angle) {
            const radians = (angle * Math.PI) / 180;
            const x = Math.cos(radians);
            const y = Math.sin(radians);
            const sunDir = new THREE.Vector3(x, y, 0.3).normalize();

            ocean.material.uniforms.uSunDirection.value = sunDir;
            sky.material.uniforms.uSunDirection.value = sunDir;
            sunLight.position.set(sunDir.x * 100, sunDir.y * 100, sunDir.z * 100);
        }

        function updateTimeOfDay(timeKey) {
            const preset = timePresets[timeKey];
            params.timeOfDay = timeKey;

            // Animate color transitions
            const duration = 1000;
            const startTime = Date.now();

            const startColors = {
                skyTop: sky.material.uniforms.uSkyTop.value.clone(),
                skyBottom: sky.material.uniforms.uSkyBottom.value.clone(),
                sunColor: ocean.material.uniforms.uSunColor.value.clone(),
                waterColor: ocean.material.uniforms.uWaterColor.value.clone(),
                waterDeep: ocean.material.uniforms.uWaterDeep.value.clone(),
                ambientColor: ambientLight.color.clone(),
                fogColor: scene.fog.color.clone()
            };

            function animateColors() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 3);

                sky.material.uniforms.uSkyTop.value.lerpColors(startColors.skyTop, preset.skyTop, ease);
                sky.material.uniforms.uSkyBottom.value.lerpColors(startColors.skyBottom, preset.skyBottom, ease);
                sky.material.uniforms.uSunColor.value.lerpColors(startColors.sunColor, preset.sunColor, ease);
                sky.material.uniforms.uSunIntensity.value = THREE.MathUtils.lerp(
                    sky.material.uniforms.uSunIntensity.value, preset.sunIntensity, ease
                );

                ocean.material.uniforms.uSunColor.value.lerpColors(startColors.sunColor, preset.sunColor, ease);
                ocean.material.uniforms.uWaterColor.value.lerpColors(startColors.waterColor, preset.waterColor, ease);
                ocean.material.uniforms.uWaterDeep.value.lerpColors(startColors.waterDeep, preset.waterDeep, ease);
                ocean.material.uniforms.uSunIntensity.value = THREE.MathUtils.lerp(
                    ocean.material.uniforms.uSunIntensity.value, preset.sunIntensity, ease
                );

                ambientLight.color.lerpColors(startColors.ambientColor, preset.ambientColor, ease);
                scene.fog.color.lerpColors(startColors.fogColor, preset.fogColor, ease);
                sunLight.color.copy(preset.sunColor);
                sunLight.intensity = preset.sunIntensity;

                if (progress < 1) {
                    requestAnimationFrame(animateColors);
                }
            }

            animateColors();

            // Update button states
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.time === timeKey);
            });
        }

        function setupEventListeners() {
            // Wind speed
            const windSlider = document.getElementById('windSpeed');
            windSlider.addEventListener('input', (e) => {
                params.windSpeed = parseFloat(e.target.value);
                ocean.material.uniforms.uWindSpeed.value = params.windSpeed;
                document.getElementById('windValue').textContent = `${params.windSpeed} m/s`;
            });

            // Wave height
            const heightSlider = document.getElementById('waveHeight');
            heightSlider.addEventListener('input', (e) => {
                params.waveHeight = parseFloat(e.target.value);
                ocean.material.uniforms.uWaveHeight.value = params.waveHeight;
                document.getElementById('heightValue').textContent = `${params.waveHeight.toFixed(1)}x`;
            });

            // Wave frequency
            const freqSlider = document.getElementById('waveFrequency');
            freqSlider.addEventListener('input', (e) => {
                params.waveFrequency = parseFloat(e.target.value);
                ocean.material.uniforms.uWaveFrequency.value = params.waveFrequency;
                document.getElementById('freqValue').textContent = `${params.waveFrequency.toFixed(1)}x`;
            });

            // Sun position
            const sunSlider = document.getElementById('sunPosition');
            sunSlider.addEventListener('input', (e) => {
                params.sunPosition = parseFloat(e.target.value);
                updateSunPosition(params.sunPosition);
                document.getElementById('sunValue').textContent = `${params.sunPosition}Â°`;
            });

            // Time of day buttons
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    updateTimeOfDay(btn.dataset.time);
                });
            });

            // Mouse/touch controls for camera
            const container = document.getElementById('canvas-container');

            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            });

            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMouseX;
                    const deltaY = e.clientY - previousMouseY;

                    targetRotationY += deltaX * 0.005;
                    targetRotationX += deltaY * 0.005;
                    targetRotationX = Math.max(-0.5, Math.min(0.8, targetRotationX));

                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                }
            });

            container.addEventListener('mouseup', () => isDragging = false);
            container.addEventListener('mouseleave', () => isDragging = false);

            // Touch events
            container.addEventListener('touchstart', (e) => {
                isDragging = true;
                previousMouseX = e.touches[0].clientX;
                previousMouseY = e.touches[0].clientY;
            });

            container.addEventListener('touchmove', (e) => {
                if (isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - previousMouseX;
                    const deltaY = e.touches[0].clientY - previousMouseY;

                    targetRotationY += deltaX * 0.005;
                    targetRotationX += deltaY * 0.005;
                    targetRotationX = Math.max(-0.5, Math.min(0.8, targetRotationX));

                    previousMouseX = e.touches[0].clientX;
                    previousMouseY = e.touches[0].clientY;
                }
            });

            container.addEventListener('touchend', () => isDragging = false);

            // Zoom with scroll
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const distance = camera.position.length();
                const newDistance = distance * (1 + e.deltaY * zoomSpeed * 0.01);
                const clampedDistance = Math.max(30, Math.min(200, newDistance));
                camera.position.normalize().multiplyScalar(clampedDistance);
            }, { passive: false });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            time += 0.016;
            ocean.material.uniforms.uTime.value = time;

            // Smooth camera rotation
            const radius = camera.position.length();
            const currentRotationX = Math.asin(camera.position.y / radius);
            const currentRotationY = Math.atan2(camera.position.x, camera.position.z);

            const newRotationX = currentRotationX + (targetRotationX - currentRotationX) * 0.05;
            const newRotationY = currentRotationY + (targetRotationY - currentRotationY) * 0.05;

            camera.position.x = radius * Math.cos(newRotationX) * Math.sin(newRotationY);
            camera.position.y = radius * Math.sin(newRotationX) + 20;
            camera.position.z = radius * Math.cos(newRotationX) * Math.cos(newRotationY);

            camera.lookAt(0, 0, 0);

            // Update camera position in shader
            ocean.material.uniforms.uCameraPosition.value.copy(camera.position);

            renderer.render(scene, camera);
        }

        // Initialize when DOM is ready
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
