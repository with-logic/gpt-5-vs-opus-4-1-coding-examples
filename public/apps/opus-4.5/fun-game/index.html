<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fun Game - Jump to Survive!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Chalkboard', 'Arial Rounded MT Bold', sans-serif;
            overflow: hidden;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 100%);
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        /* Parallax Background Layers */
        .parallax-layer {
            position: absolute;
            width: 200%;
            height: 100%;
            background-repeat: repeat-x;
            background-size: auto 100%;
        }

        #sky {
            background: linear-gradient(180deg,
                #FF9A56 0%,
                #FFB366 20%,
                #87CEEB 40%,
                #B0E0FF 100%);
            z-index: 0;
        }

        #clouds {
            z-index: 1;
        }

        #mountains {
            bottom: 0;
            height: 40%;
            z-index: 2;
        }

        #hills {
            bottom: 0;
            height: 25%;
            z-index: 3;
        }

        #ground {
            position: absolute;
            bottom: 0;
            width: 200%;
            height: 100px;
            z-index: 4;
        }

        /* Game Canvas */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        /* UI Overlay */
        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        #scoreBoard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #FF6B6B, #FF8E53);
            padding: 15px 25px;
            border-radius: 20px;
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4),
                        inset 0 -4px 0 rgba(0,0,0,0.2);
            border: 4px solid #FFF;
        }

        #scoreBoard h2 {
            color: #FFF;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
        }

        #scoreBoard .score {
            color: #FFF;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 3px 3px 0 rgba(0,0,0,0.2);
        }

        #highScoreBoard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #A855F7, #7C3AED);
            padding: 15px 25px;
            border-radius: 20px;
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.4),
                        inset 0 -4px 0 rgba(0,0,0,0.2);
            border: 4px solid #FFF;
        }

        #highScoreBoard h2 {
            color: #FFF;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
        }

        #highScoreBoard .score {
            color: #FFD700;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 3px 3px 0 rgba(0,0,0,0.2);
        }

        /* Start Screen */
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            z-index: 30;
            pointer-events: auto;
        }

        .game-title {
            font-size: 72px;
            color: #FFD700;
            text-shadow: 4px 4px 0 #FF6B6B,
                         8px 8px 0 rgba(0,0,0,0.3);
            margin-bottom: 20px;
            animation: bounce 1s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .subtitle {
            font-size: 24px;
            color: #FFF;
            margin-bottom: 40px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
        }

        .btn {
            padding: 20px 50px;
            font-size: 28px;
            font-family: inherit;
            font-weight: bold;
            color: #FFF;
            background: linear-gradient(180deg, #4ADE80, #22C55E);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 8px 0 #16A34A,
                        0 12px 25px rgba(0,0,0,0.3);
            transition: all 0.1s ease;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 0 #16A34A,
                        0 16px 30px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 4px 0 #16A34A,
                        0 8px 20px rgba(0,0,0,0.3);
        }

        .instructions {
            margin-top: 30px;
            color: #FFF;
            font-size: 18px;
            text-align: center;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
        }

        .instructions kbd {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 10px;
            margin: 0 5px;
        }

        /* Game Over Screen */
        #gameOverScreen {
            display: none;
        }

        .game-over-title {
            font-size: 64px;
            color: #FF6B6B;
            text-shadow: 4px 4px 0 #FFF,
                         8px 8px 0 rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .final-score {
            font-size: 48px;
            color: #FFD700;
            margin-bottom: 10px;
            text-shadow: 3px 3px 0 rgba(0,0,0,0.3);
        }

        .new-high-score {
            font-size: 32px;
            color: #4ADE80;
            margin-bottom: 30px;
            animation: pulse 0.5s ease-in-out infinite alternate;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        /* Speed indicator */
        #speedIndicator {
            position: absolute;
            bottom: 120px;
            left: 20px;
            background: linear-gradient(135deg, #3B82F6, #1D4ED8);
            padding: 10px 20px;
            border-radius: 15px;
            color: #FFF;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            border: 3px solid #FFF;
        }

        /* Combo display */
        #comboDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #FFD700;
            text-shadow: 3px 3px 0 #FF6B6B;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
        }

        /* Mobile touch button */
        #touchArea {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            z-index: 15;
            pointer-events: auto;
        }

        /* Decorative elements */
        .star {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #FFD700;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            animation: twinkle 1s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Parallax Backgrounds -->
        <div id="sky" class="parallax-layer"></div>
        <div id="clouds" class="parallax-layer"></div>
        <div id="mountains" class="parallax-layer"></div>
        <div id="hills" class="parallax-layer"></div>
        <div id="ground" class="parallax-layer"></div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Touch Area for Mobile -->
        <div id="touchArea"></div>

        <!-- UI Overlay -->
        <div id="uiOverlay">
            <div id="scoreBoard">
                <h2>Score</h2>
                <div class="score" id="currentScore">0</div>
            </div>
            <div id="highScoreBoard">
                <h2>Best</h2>
                <div class="score" id="highScore">0</div>
            </div>
            <div id="speedIndicator">Speed: <span id="speedValue">1.0</span>x</div>
            <div id="comboDisplay"></div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen">
            <h1 class="game-title">üéÆ Fun Game! üéÆ</h1>
            <p class="subtitle">Jump over obstacles to survive!</p>
            <button class="btn" id="startBtn">üöÄ Start Game!</button>
            <div class="instructions">
                Press <kbd>SPACE</kbd> or <kbd>‚Üë</kbd> or <kbd>TAP</kbd> to Jump!<br>
                Hold longer for higher jumps!
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen">
            <h1 class="game-over-title">üí• Game Over! üí•</h1>
            <div class="final-score">Score: <span id="finalScore">0</span></div>
            <div class="new-high-score hidden" id="newHighScore">üèÜ NEW HIGH SCORE! üèÜ</div>
            <button class="btn" id="retryBtn">üîÑ Try Again!</button>
            <div class="instructions">
                Don't give up! You can do it! üí™
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // AUDIO ENGINE - Funny Sound Effects
        // ============================================
        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.initialized = true;
            }

            // Generate a "boing" jump sound
            playJump() {
                if (!this.initialized) return;
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.frequency.setValueAtTime(300, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.1);
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.2);

                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

                osc.type = 'sine';
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.3);
            }

            // Generate a "splat" collision sound
            playCollision() {
                if (!this.initialized) return;
                const ctx = this.audioContext;

                // Create noise
                const bufferSize = ctx.sampleRate * 0.3;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
                }

                const noise = ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 500;

                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.5, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);

                noise.start();
            }

            // Score milestone sound
            playScoreMilestone() {
                if (!this.initialized) return;
                const ctx = this.audioContext;

                const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6

                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.connect(gain);
                    gain.connect(ctx.destination);

                    osc.frequency.value = freq;
                    osc.type = 'square';

                    const startTime = ctx.currentTime + i * 0.1;
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.15, startTime + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);

                    osc.start(startTime);
                    osc.stop(startTime + 0.2);
                });
            }

            // Successful dodge sound
            playDodge() {
                if (!this.initialized) return;
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.1);

                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);

                osc.type = 'sine';
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.15);
            }

            // Speed up sound
            playSpeedUp() {
                if (!this.initialized) return;
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.frequency.setValueAtTime(200, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.3);

                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

                osc.type = 'sawtooth';
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.3);
            }

            // Game start jingle
            playGameStart() {
                if (!this.initialized) return;
                const ctx = this.audioContext;

                const notes = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5

                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.connect(gain);
                    gain.connect(ctx.destination);

                    osc.frequency.value = freq;
                    osc.type = 'triangle';

                    const startTime = ctx.currentTime + i * 0.15;
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.2, startTime + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);

                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            }
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        class Particle {
            constructor(x, y, color, velocity, life, size) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = velocity.x;
                this.vy = velocity.y;
                this.life = life;
                this.maxLife = life;
                this.size = size;
                this.gravity = 0.3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life--;
                return this.life > 0;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            emit(x, y, count, colors, spread = 5) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                    const speed = spread + Math.random() * spread;
                    this.particles.push(new Particle(
                        x, y,
                        colors[Math.floor(Math.random() * colors.length)],
                        { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed - 5 },
                        30 + Math.random() * 20,
                        5 + Math.random() * 5
                    ));
                }
            }

            emitDust(x, y) {
                for (let i = 0; i < 5; i++) {
                    this.particles.push(new Particle(
                        x + Math.random() * 20, y,
                        '#8B7355',
                        { x: -2 - Math.random() * 2, y: -1 - Math.random() * 2 },
                        15 + Math.random() * 10,
                        3 + Math.random() * 3
                    ));
                }
            }

            update() {
                this.particles = this.particles.filter(p => p.update());
            }

            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
            }
        }

        // ============================================
        // GAME CHARACTER
        // ============================================
        class Character {
            constructor(x, y, groundY) {
                this.x = x;
                this.y = y;
                this.groundY = groundY;
                this.width = 60;
                this.height = 80;
                this.velocityY = 0;
                this.isJumping = false;
                this.jumpPower = 0;
                this.maxJumpPower = 22;
                this.minJumpPower = 14;
                this.gravity = 0.8;
                this.animFrame = 0;
                this.animTimer = 0;
                this.squash = 1;
                this.stretch = 1;
                this.eyeBlink = 0;
                this.expression = 'happy';
                this.legAngle = 0;
            }

            startJump() {
                if (!this.isJumping) {
                    this.jumpPower = this.minJumpPower;
                }
            }

            chargeJump() {
                if (!this.isJumping) {
                    this.jumpPower = Math.min(this.jumpPower + 0.8, this.maxJumpPower);
                    this.squash = 1.2;
                    this.stretch = 0.8;
                }
            }

            releaseJump() {
                if (!this.isJumping) {
                    this.velocityY = -this.jumpPower;
                    this.isJumping = true;
                    this.squash = 0.7;
                    this.stretch = 1.3;
                    return true;
                }
                return false;
            }

            update() {
                // Apply gravity
                this.velocityY += this.gravity;
                this.y += this.velocityY;

                // Ground collision
                if (this.y >= this.groundY) {
                    this.y = this.groundY;
                    this.velocityY = 0;
                    if (this.isJumping) {
                        this.squash = 1.3;
                        this.stretch = 0.7;
                    }
                    this.isJumping = false;
                }

                // Squash and stretch recovery
                this.squash += (1 - this.squash) * 0.2;
                this.stretch += (1 - this.stretch) * 0.2;

                // Animation
                this.animTimer++;
                if (this.animTimer > 5) {
                    this.animTimer = 0;
                    this.animFrame = (this.animFrame + 1) % 4;
                }

                // Eye blink
                if (Math.random() < 0.01) {
                    this.eyeBlink = 5;
                }
                if (this.eyeBlink > 0) this.eyeBlink--;

                // Leg animation
                if (!this.isJumping) {
                    this.legAngle = Math.sin(this.animTimer * 0.3) * 0.5;
                } else {
                    this.legAngle = -0.3;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height);
                ctx.scale(this.squash, this.stretch);

                // Body (blob shape)
                const bodyGradient = ctx.createRadialGradient(0, -40, 10, 0, -40, 50);
                bodyGradient.addColorStop(0, '#FF9F43');
                bodyGradient.addColorStop(1, '#EE5A24');

                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.ellipse(0, -40, 30, 40, 0, 0, Math.PI * 2);
                ctx.fill();

                // Belly
                ctx.fillStyle = '#FFEAA7';
                ctx.beginPath();
                ctx.ellipse(0, -30, 20, 25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                const eyeY = -55;
                const eyeSpacing = 12;

                // Eye whites
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.ellipse(-eyeSpacing, eyeY, 10, this.eyeBlink > 0 ? 2 : 12, 0, 0, Math.PI * 2);
                ctx.ellipse(eyeSpacing, eyeY, 10, this.eyeBlink > 0 ? 2 : 12, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                if (this.eyeBlink === 0) {
                    ctx.fillStyle = '#2C3E50';
                    const pupilOffset = this.isJumping ? -2 : 2;
                    ctx.beginPath();
                    ctx.arc(-eyeSpacing + pupilOffset, eyeY, 5, 0, Math.PI * 2);
                    ctx.arc(eyeSpacing + pupilOffset, eyeY, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Eye shine
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(-eyeSpacing + pupilOffset - 2, eyeY - 2, 2, 0, Math.PI * 2);
                    ctx.arc(eyeSpacing + pupilOffset - 2, eyeY - 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Mouth
                ctx.strokeStyle = '#C0392B';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                if (this.expression === 'happy') {
                    ctx.arc(0, -35, 12, 0.2, Math.PI - 0.2);
                } else if (this.expression === 'scared') {
                    ctx.ellipse(0, -32, 8, 10, 0, 0, Math.PI * 2);
                }
                ctx.stroke();

                // Cheeks (blush)
                ctx.fillStyle = 'rgba(255, 107, 107, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-25, -40, 8, 5, 0, 0, Math.PI * 2);
                ctx.ellipse(25, -40, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.fillStyle = '#EE5A24';
                ctx.save();
                ctx.translate(-15, 0);
                ctx.rotate(this.legAngle);
                ctx.fillRect(-8, -5, 16, 20);
                ctx.fillStyle = '#D35400';
                ctx.fillRect(-10, 12, 20, 8);
                ctx.restore();

                ctx.save();
                ctx.translate(15, 0);
                ctx.rotate(-this.legAngle);
                ctx.fillStyle = '#EE5A24';
                ctx.fillRect(-8, -5, 16, 20);
                ctx.fillStyle = '#D35400';
                ctx.fillRect(-10, 12, 20, 8);
                ctx.restore();

                // Arms
                ctx.fillStyle = '#EE5A24';
                const armWave = Math.sin(this.animTimer * 0.2) * 0.3;

                ctx.save();
                ctx.translate(-30, -45);
                ctx.rotate(-0.5 + (this.isJumping ? -0.5 : armWave));
                ctx.fillRect(0, 0, 25, 12);
                ctx.restore();

                ctx.save();
                ctx.translate(30, -45);
                ctx.rotate(0.5 + (this.isJumping ? 0.5 : -armWave));
                ctx.fillRect(-25, 0, 25, 12);
                ctx.restore();

                ctx.restore();
            }

            getBounds() {
                return {
                    x: this.x + 10,
                    y: this.y + 10,
                    width: this.width - 20,
                    height: this.height - 10
                };
            }
        }

        // ============================================
        // OBSTACLES
        // ============================================
        class Obstacle {
            constructor(x, groundY, type = 'cactus') {
                this.x = x;
                this.groundY = groundY;
                this.type = type;
                this.passed = false;

                if (type === 'cactus') {
                    this.width = 40;
                    this.height = 60 + Math.random() * 30;
                } else if (type === 'rock') {
                    this.width = 50;
                    this.height = 40;
                } else if (type === 'bird') {
                    this.width = 50;
                    this.height = 35;
                    this.y = groundY - 100 - Math.random() * 80;
                    this.wingAngle = 0;
                }
            }

            update(speed) {
                this.x -= speed;
                if (this.type === 'bird') {
                    this.wingAngle += 0.3;
                    this.y += Math.sin(this.wingAngle * 0.5) * 0.5;
                }
            }

            draw(ctx) {
                if (this.type === 'cactus') {
                    this.drawCactus(ctx);
                } else if (this.type === 'rock') {
                    this.drawRock(ctx);
                } else if (this.type === 'bird') {
                    this.drawBird(ctx);
                }
            }

            drawCactus(ctx) {
                const x = this.x;
                const y = this.groundY;

                // Main body
                const gradient = ctx.createLinearGradient(x, y, x + this.width, y);
                gradient.addColorStop(0, '#27AE60');
                gradient.addColorStop(0.5, '#2ECC71');
                gradient.addColorStop(1, '#27AE60');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.roundRect(x + 10, y - this.height, 20, this.height, 10);
                ctx.fill();

                // Arms
                if (this.height > 70) {
                    ctx.beginPath();
                    ctx.roundRect(x - 5, y - this.height + 20, 20, 15, 7);
                    ctx.roundRect(x - 5, y - this.height + 20, 15, 35, 7);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.roundRect(x + 25, y - this.height + 35, 20, 15, 7);
                    ctx.roundRect(x + 30, y - this.height + 35, 15, 30, 7);
                    ctx.fill();
                }

                // Face
                ctx.fillStyle = '#1E8449';
                ctx.beginPath();
                ctx.arc(x + 15, y - this.height + 15, 3, 0, Math.PI * 2);
                ctx.arc(x + 25, y - this.height + 15, 3, 0, Math.PI * 2);
                ctx.fill();

                // Angry eyebrows
                ctx.strokeStyle = '#1E8449';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + 12, y - this.height + 10);
                ctx.lineTo(x + 18, y - this.height + 12);
                ctx.moveTo(x + 28, y - this.height + 10);
                ctx.lineTo(x + 22, y - this.height + 12);
                ctx.stroke();

                // Mouth
                ctx.beginPath();
                ctx.arc(x + 20, y - this.height + 25, 5, 0.2, Math.PI - 0.2);
                ctx.stroke();
            }

            drawRock(ctx) {
                const x = this.x;
                const y = this.groundY;

                ctx.fillStyle = '#7F8C8D';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + 10, y - this.height);
                ctx.lineTo(x + 25, y - this.height - 10);
                ctx.lineTo(x + 40, y - this.height + 5);
                ctx.lineTo(x + this.width, y);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#95A5A6';
                ctx.beginPath();
                ctx.moveTo(x + 10, y - this.height);
                ctx.lineTo(x + 25, y - this.height - 10);
                ctx.lineTo(x + 25, y - 10);
                ctx.lineTo(x + 10, y - 5);
                ctx.closePath();
                ctx.fill();

                // Angry face
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.arc(x + 18, y - this.height + 15, 4, 0, Math.PI * 2);
                ctx.arc(x + 32, y - this.height + 15, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            drawBird(ctx) {
                const x = this.x;
                const y = this.y;

                ctx.save();
                ctx.translate(x + this.width / 2, y + this.height / 2);

                // Body
                ctx.fillStyle = '#9B59B6';
                ctx.beginPath();
                ctx.ellipse(0, 0, 25, 15, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wings
                ctx.fillStyle = '#8E44AD';
                const wingY = Math.sin(this.wingAngle) * 15;
                ctx.beginPath();
                ctx.ellipse(-5, wingY - 10, 20, 8, -0.3, 0, Math.PI * 2);
                ctx.fill();

                // Beak
                ctx.fillStyle = '#F39C12';
                ctx.beginPath();
                ctx.moveTo(25, 0);
                ctx.lineTo(35, 3);
                ctx.lineTo(25, 6);
                ctx.closePath();
                ctx.fill();

                // Eye
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(15, -3, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.arc(17, -3, 4, 0, Math.PI * 2);
                ctx.fill();

                // Angry eyebrow
                ctx.strokeStyle = '#2C3E50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(10, -10);
                ctx.lineTo(20, -8);
                ctx.stroke();

                ctx.restore();
            }

            getBounds() {
                if (this.type === 'bird') {
                    return {
                        x: this.x + 5,
                        y: this.y + 5,
                        width: this.width - 10,
                        height: this.height - 10
                    };
                }
                return {
                    x: this.x + 5,
                    y: this.groundY - this.height + 5,
                    width: this.width - 10,
                    height: this.height - 10
                };
            }
        }

        // ============================================
        // MAIN GAME CLASS
        // ============================================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.audio = new AudioEngine();
                this.particles = new ParticleSystem();

                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.groundY = this.canvas.height - 100;
                this.character = new Character(100, this.groundY, this.groundY);
                this.obstacles = [];

                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('funGameHighScore')) || 0;
                this.baseSpeed = 8;
                this.speed = this.baseSpeed;
                this.maxSpeed = 20;
                this.speedIncrement = 0.001;

                this.isRunning = false;
                this.isGameOver = false;
                this.lastObstacleX = this.canvas.width;
                this.minObstacleGap = 300;
                this.obstacleTimer = 0;

                this.parallaxOffsets = {
                    clouds: 0,
                    mountains: 0,
                    hills: 0,
                    ground: 0
                };

                this.jumpHeld = false;
                this.lastScoreMilestone = 0;

                this.setupEventListeners();
                this.updateUI();
                this.drawBackground();
                this.gameLoop();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.groundY = this.canvas.height - 100;
                if (this.character) {
                    this.character.groundY = this.groundY;
                    this.character.y = this.groundY;
                }
            }

            setupEventListeners() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.code === 'ArrowUp') {
                        e.preventDefault();
                        this.handleJumpStart();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space' || e.code === 'ArrowUp') {
                        e.preventDefault();
                        this.handleJumpRelease();
                    }
                });

                // Touch/Mouse
                const touchArea = document.getElementById('touchArea');
                touchArea.addEventListener('mousedown', (e) => this.handleJumpStart());
                touchArea.addEventListener('mouseup', (e) => this.handleJumpRelease());
                touchArea.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleJumpStart();
                });
                touchArea.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleJumpRelease();
                });

                // Buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('retryBtn').addEventListener('click', () => this.startGame());
            }

            handleJumpStart() {
                this.audio.init();
                if (!this.isRunning || this.isGameOver) return;
                this.jumpHeld = true;
                this.character.startJump();
            }

            handleJumpRelease() {
                if (!this.isRunning || this.isGameOver) return;
                this.jumpHeld = false;
                if (this.character.releaseJump()) {
                    this.audio.playJump();
                    this.particles.emitDust(this.character.x + 30, this.groundY);
                }
            }

            startGame() {
                this.audio.init();
                this.audio.playGameStart();

                this.score = 0;
                this.speed = this.baseSpeed;
                this.obstacles = [];
                this.character = new Character(100, this.groundY, this.groundY);
                this.isRunning = true;
                this.isGameOver = false;
                this.lastObstacleX = this.canvas.width;
                this.lastScoreMilestone = 0;
                this.particles = new ParticleSystem();

                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.add('hidden');

                this.updateUI();
            }

            gameOver() {
                this.isGameOver = true;
                this.isRunning = false;
                this.audio.playCollision();

                // Explosion particles
                this.particles.emit(
                    this.character.x + this.character.width / 2,
                    this.character.y + this.character.height / 2,
                    30,
                    ['#FF6B6B', '#FF9F43', '#FFEAA7', '#FFF']
                );

                this.character.expression = 'scared';

                // Update high score
                const isNewHighScore = this.score > this.highScore;
                if (isNewHighScore) {
                    this.highScore = this.score;
                    localStorage.setItem('funGameHighScore', this.highScore);
                }

                document.getElementById('finalScore').textContent = Math.floor(this.score);
                document.getElementById('newHighScore').classList.toggle('hidden', !isNewHighScore);

                setTimeout(() => {
                    document.getElementById('gameOverScreen').classList.remove('hidden');
                }, 500);

                this.updateUI();
            }

            spawnObstacle() {
                const types = ['cactus', 'cactus', 'cactus', 'rock', 'bird'];
                const type = types[Math.floor(Math.random() * types.length)];

                // Don't spawn birds until score is high enough
                const finalType = (type === 'bird' && this.score < 500) ? 'cactus' : type;

                this.obstacles.push(new Obstacle(this.canvas.width + 50, this.groundY, finalType));
                this.lastObstacleX = this.canvas.width + 50;
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            update() {
                if (!this.isRunning || this.isGameOver) return;

                // Charge jump while held
                if (this.jumpHeld) {
                    this.character.chargeJump();
                }

                // Update character
                this.character.update();

                // Generate dust when running
                if (!this.character.isJumping && Math.random() < 0.1) {
                    this.particles.emitDust(this.character.x + 30, this.groundY);
                }

                // Update particles
                this.particles.update();

                // Update speed
                this.speed = Math.min(this.speed + this.speedIncrement, this.maxSpeed);

                // Update score
                this.score += this.speed * 0.1;

                // Check score milestones
                const milestone = Math.floor(this.score / 500) * 500;
                if (milestone > this.lastScoreMilestone && milestone > 0) {
                    this.lastScoreMilestone = milestone;
                    this.audio.playScoreMilestone();
                    this.showCombo(`${milestone}!`);
                }

                // Speed up notification
                if (Math.floor(this.speed) > Math.floor(this.speed - this.speedIncrement) && this.speed > this.baseSpeed + 1) {
                    this.audio.playSpeedUp();
                }

                // Spawn obstacles
                const gap = this.minObstacleGap + Math.random() * 200 - (this.speed * 5);
                if (this.canvas.width - this.lastObstacleX > Math.max(gap, 200)) {
                    this.spawnObstacle();
                }

                // Update obstacles
                const characterBounds = this.character.getBounds();

                this.obstacles.forEach(obstacle => {
                    obstacle.update(this.speed);

                    // Check collision
                    if (this.checkCollision(characterBounds, obstacle.getBounds())) {
                        this.gameOver();
                    }

                    // Check if passed
                    if (!obstacle.passed && obstacle.x + obstacle.width < this.character.x) {
                        obstacle.passed = true;
                        this.audio.playDodge();
                    }
                });

                // Remove off-screen obstacles
                this.obstacles = this.obstacles.filter(o => o.x > -100);

                // Update parallax
                this.parallaxOffsets.clouds -= this.speed * 0.1;
                this.parallaxOffsets.mountains -= this.speed * 0.2;
                this.parallaxOffsets.hills -= this.speed * 0.4;
                this.parallaxOffsets.ground -= this.speed;

                // Loop parallax
                Object.keys(this.parallaxOffsets).forEach(key => {
                    if (this.parallaxOffsets[key] < -this.canvas.width) {
                        this.parallaxOffsets[key] += this.canvas.width;
                    }
                });

                this.updateUI();
            }

            showCombo(text) {
                const combo = document.getElementById('comboDisplay');
                combo.textContent = text;
                combo.style.opacity = '1';
                combo.style.transform = 'translate(-50%, -50%) scale(1.5)';
                setTimeout(() => {
                    combo.style.opacity = '0';
                    combo.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 1000);
            }

            updateUI() {
                document.getElementById('currentScore').textContent = Math.floor(this.score);
                document.getElementById('highScore').textContent = Math.floor(this.highScore);
                document.getElementById('speedValue').textContent = (this.speed / this.baseSpeed).toFixed(1);
            }

            drawBackground() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Sky gradient
                const skyGradient = ctx.createLinearGradient(0, 0, 0, h);
                skyGradient.addColorStop(0, '#FF9A56');
                skyGradient.addColorStop(0.2, '#FFB88C');
                skyGradient.addColorStop(0.4, '#87CEEB');
                skyGradient.addColorStop(1, '#B0E0FF');
                ctx.fillStyle = skyGradient;
                ctx.fillRect(0, 0, w, h);

                // Sun
                ctx.fillStyle = '#FFE66D';
                ctx.beginPath();
                ctx.arc(w - 150, 120, 60, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#FFF9C4';
                ctx.beginPath();
                ctx.arc(w - 150, 120, 50, 0, Math.PI * 2);
                ctx.fill();

                // Clouds
                this.drawClouds(ctx, this.parallaxOffsets.clouds);

                // Mountains
                this.drawMountains(ctx, this.parallaxOffsets.mountains);

                // Hills
                this.drawHills(ctx, this.parallaxOffsets.hills);

                // Ground
                this.drawGround(ctx, this.parallaxOffsets.ground);
            }

            drawClouds(ctx, offset) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                const cloudPositions = [
                    { x: 100, y: 80, scale: 1 },
                    { x: 400, y: 120, scale: 0.8 },
                    { x: 700, y: 60, scale: 1.2 },
                    { x: 1000, y: 140, scale: 0.9 },
                    { x: 1300, y: 90, scale: 1.1 }
                ];

                cloudPositions.forEach(cloud => {
                    let x = (cloud.x + offset) % (this.canvas.width + 200);
                    if (x < -200) x += this.canvas.width + 400;

                    ctx.save();
                    ctx.translate(x, cloud.y);
                    ctx.scale(cloud.scale, cloud.scale);

                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.arc(35, 0, 40, 0, Math.PI * 2);
                    ctx.arc(70, 0, 30, 0, Math.PI * 2);
                    ctx.arc(35, -20, 35, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }

            drawMountains(ctx, offset) {
                const h = this.canvas.height;
                const mountainY = h - 100;

                // Back mountains
                ctx.fillStyle = '#A78BFA';
                for (let i = -1; i < 4; i++) {
                    const x = (i * 400 + offset * 0.5) % (this.canvas.width + 400);
                    ctx.beginPath();
                    ctx.moveTo(x - 200, mountainY);
                    ctx.lineTo(x, mountainY - 200);
                    ctx.lineTo(x + 200, mountainY);
                    ctx.closePath();
                    ctx.fill();
                }

                // Front mountains
                ctx.fillStyle = '#8B5CF6';
                for (let i = -1; i < 4; i++) {
                    const x = (i * 350 + 150 + offset) % (this.canvas.width + 350);
                    ctx.beginPath();
                    ctx.moveTo(x - 175, mountainY);
                    ctx.lineTo(x, mountainY - 150);
                    ctx.lineTo(x + 175, mountainY);
                    ctx.closePath();
                    ctx.fill();
                }

                // Snow caps
                ctx.fillStyle = '#FFF';
                for (let i = -1; i < 4; i++) {
                    const x = (i * 350 + 150 + offset) % (this.canvas.width + 350);
                    ctx.beginPath();
                    ctx.moveTo(x - 30, mountainY - 120);
                    ctx.lineTo(x, mountainY - 150);
                    ctx.lineTo(x + 30, mountainY - 120);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            drawHills(ctx, offset) {
                const h = this.canvas.height;
                const hillY = h - 100;

                ctx.fillStyle = '#86EFAC';
                for (let i = -1; i < 6; i++) {
                    const x = (i * 300 + offset) % (this.canvas.width + 300);
                    ctx.beginPath();
                    ctx.arc(x, hillY + 50, 150, Math.PI, 0);
                    ctx.fill();
                }

                // Trees on hills
                ctx.fillStyle = '#22C55E';
                for (let i = -1; i < 10; i++) {
                    const x = (i * 180 + 50 + offset * 1.1) % (this.canvas.width + 200);
                    const treeH = 40 + Math.sin(i * 2) * 15;

                    ctx.beginPath();
                    ctx.moveTo(x, hillY - treeH);
                    ctx.lineTo(x - 20, hillY);
                    ctx.lineTo(x + 20, hillY);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            drawGround(ctx, offset) {
                const h = this.canvas.height;
                const groundY = h - 100;

                // Main ground
                const groundGradient = ctx.createLinearGradient(0, groundY, 0, h);
                groundGradient.addColorStop(0, '#8B7355');
                groundGradient.addColorStop(0.3, '#A0826D');
                groundGradient.addColorStop(1, '#6B5344');
                ctx.fillStyle = groundGradient;
                ctx.fillRect(0, groundY, this.canvas.width, 100);

                // Grass
                ctx.fillStyle = '#4ADE80';
                ctx.fillRect(0, groundY - 5, this.canvas.width, 15);

                // Grass details
                ctx.strokeStyle = '#22C55E';
                ctx.lineWidth = 2;
                for (let i = 0; i < this.canvas.width; i += 15) {
                    const grassOffset = (i + offset * 2) % 30;
                    const grassH = 8 + Math.sin(i * 0.5) * 4;
                    ctx.beginPath();
                    ctx.moveTo(i, groundY);
                    ctx.quadraticCurveTo(i + grassOffset * 0.2, groundY - grassH, i + 5, groundY);
                    ctx.stroke();
                }

                // Ground details (pebbles)
                ctx.fillStyle = '#7A6555';
                for (let i = 0; i < 20; i++) {
                    const x = ((i * 97 + offset * 0.5) % this.canvas.width);
                    const y = groundY + 20 + (i % 3) * 25;
                    const size = 3 + (i % 4);
                    ctx.beginPath();
                    ctx.ellipse(x, y, size, size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw background
                this.drawBackground();

                // Draw obstacles
                this.obstacles.forEach(obstacle => obstacle.draw(this.ctx));

                // Draw character
                this.character.draw(this.ctx);

                // Draw particles
                this.particles.draw(this.ctx);
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game when the page loads
        window.addEventListener('load', () => {
            new Game();
        });
    </script>
</body>
</html>