<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Void: Dogfight</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent mobile scrolling */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .score-container {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #0ff;
            color: #0ff;
        }
        .health-bar-container {
            width: 200px;
            height: 20px;
            border: 2px solid #f00;
            border-radius: 4px;
            overflow: hidden;
            background: rgba(50, 0, 0, 0.5);
            box-shadow: 0 0 10px #f00;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #f00;
            transition: width 0.2s ease-out;
            box-shadow: 0 0 10px #f00 inset;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            z-index: 10;
        }
        h1 {
            font-size: 60px;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            letter-spacing: 5px;
            color: #fff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #00f;
            text-align: center;
        }
        p {
            font-size: 18px;
            color: #ccc;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.5;
        }
        .btn {
            padding: 15px 40px;
            font-size: 24px;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 30px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            font-weight: bold;
        }
        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }
        .hidden {
            display: none !important;
        }
        .controls-hint {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
        .key {
            display: inline-block;
            border: 1px solid #666;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            background: #222;
            color: #fff;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-container">SCORE: <span id="score">0</span></div>
            <div class="health-bar-container">
                <div id="health-fill"></div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Neon Void</h1>
        <p>Pilot your ship through the asteroid field.<br>Neutralize enemy interceptors.</p>
        <button class="btn" id="start-btn">Initialize System</button>
        <div class="controls-hint">
            <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> to Move &nbsp;|&nbsp; 
            <span class="key">MOUSE</span> to Aim &nbsp;|&nbsp; 
            <span class="key">L-CLICK</span> to Shoot
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #f00; text-shadow: 0 0 20px #f00;">CRITICAL FAILURE</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button class="btn" id="restart-btn" style="border-color: #f00; color: #f00; box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);">Reboot</button>
    </div>

    <canvas id="game-canvas"></canvas>

<script>
/**
 * Game Configuration & State
 */
const CONFIG = {
    friction: 0.98,
    shipSpeed: 0.5,
    maxSpeed: 8,
    bulletSpeed: 12,
    bulletLifetime: 60,
    fireRate: 8, // Frames between shots
    enemySpawnRate: 300, // Frames
    asteroidSpawnRate: 120, // Frames
    screenShakeDecay: 0.9,
    colors: {
        player: '#0ff',
        enemy: '#f0f',
        asteroid: '#fa0',
        bullet: '#ff0',
        particle: '#fff'
    }
};

const STATE = {
    width: window.innerWidth,
    height: window.innerHeight,
    player: null,
    entities: [],
    particles: [],
    keys: {},
    mouse: { x: 0, y: 0, down: false },
    score: 0,
    gameOver: false,
    frame: 0,
    camera: { x: 0, y: 0, shake: 0 },
    lastTime: 0
};

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const finalScoreEl = document.getElementById('final-score');
const healthFillEl = document.getElementById('health-fill');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');

/**
 * Audio System (Procedural)
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const Sound = {
    shoot: () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(440, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    },
    explode: (size = 1) => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const bufferSize = audioCtx.sampleRate * 0.5; // 0.5 seconds
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, audioCtx.currentTime);
        filter.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.5);
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.2 * size, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    },
    hit: () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }
};

/**
 * Utility Functions
 */
function randomRange(min, max) { return Math.random() * (max - min) + min; }
function distance(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
function angleTo(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }

/**
 * Classes
 */
class Entity {
    constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.radius = radius;
        this.color = color;
        this.rotation = 0;
        this.dead = false;
        this.id = Math.random().toString(36).substr(2, 9);
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        this.drawShape(ctx);
        ctx.stroke();
        ctx.restore();
    }

    drawShape(ctx) {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
    }
}

class Particle extends Entity {
    constructor(x, y, color, speed, life) {
        super(x, y, 1, color);
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = life;
        this.maxLife = life;
    }

    update() {
        super.update();
        this.life--;
        if (this.life <= 0) this.dead = true;
    }

    draw(ctx) {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, randomRange(1, 3), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, angle, owner) {
        super(x, y, 2, CONFIG.colors.bullet);
        this.vx = Math.cos(angle) * CONFIG.bulletSpeed;
        this.vy = Math.sin(angle) * CONFIG.bulletSpeed;
        this.owner = owner; // 'player' or 'enemy'
        this.life = CONFIG.bulletLifetime;
    }

    update() {
        super.update();
        this.life--;
        if (this.life <= 0) this.dead = true;

        // Create trail
        if (STATE.frame % 2 === 0) {
            STATE.particles.push(new Particle(this.x, this.y, this.color, 0.5, 10));
        }
    }

    drawShape(ctx) {
        ctx.beginPath();
        ctx.moveTo(-5, 0);
        ctx.lineTo(5, 0);
    }
}

class Ship extends Entity {
    constructor(x, y, radius, color) {
        super(x, y, radius, color);
        this.health = 100;
        this.maxHealth = 100;
        this.cooldown = 0;
    }

    takeDamage(amount) {
        this.health -= amount;
        Sound.hit();
        STATE.camera.shake = 5;
        // Spawn particles
        for (let i = 0; i < 5; i++) {
            STATE.particles.push(new Particle(this.x, this.y, this.color, randomRange(1, 4), 20));
        }
        if (this.health <= 0) {
            this.dead = true;
            this.explode();
        }
    }

    explode() {
        Sound.explode(2);
        STATE.camera.shake = 15;
        for (let i = 0; i < 30; i++) {
            STATE.particles.push(new Particle(this.x, this.y, this.color, randomRange(2, 8), 40));
        }
        for (let i = 0; i < 5; i++) {
             STATE.particles.push(new Particle(this.x, this.y, '#fff', randomRange(5, 12), 20));
        }
    }
}

class Player extends Ship {
    constructor() {
        super(STATE.width / 2, STATE.height / 2, 15, CONFIG.colors.player);
    }

    update() {
        // Controls
        if (STATE.keys['w']) this.vy -= CONFIG.shipSpeed;
        if (STATE.keys['s']) this.vy += CONFIG.shipSpeed;
        if (STATE.keys['a']) this.vx -= CONFIG.shipSpeed;
        if (STATE.keys['d']) this.vx += CONFIG.shipSpeed;

        // Physics
        this.vx *= CONFIG.friction;
        this.vy *= CONFIG.friction;

        // Cap speed
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > CONFIG.maxSpeed) {
            this.vx = (this.vx / speed) * CONFIG.maxSpeed;
            this.vy = (this.vy / speed) * CONFIG.maxSpeed;
        }

        super.update();

        // Screen wrap
        if (this.x < 0) this.x = STATE.width;
        if (this.x > STATE.width) this.x = 0;
        if (this.y < 0) this.y = STATE.height;
        if (this.y > STATE.height) this.y = 0;

        // Rotation towards mouse
        this.rotation = angleTo(this, STATE.mouse);

        // Shooting
        if (this.cooldown > 0) this.cooldown--;
        if (STATE.mouse.down && this.cooldown <= 0) {
            STATE.entities.push(new Bullet(this.x, this.y, this.rotation, 'player'));
            this.cooldown = CONFIG.fireRate;
            Sound.shoot();
            
            // Recoil
            this.vx -= Math.cos(this.rotation) * 1;
            this.vy -= Math.sin(this.rotation) * 1;
        }

        // Engine Trail
        if (STATE.keys['w'] || STATE.keys['a'] || STATE.keys['s'] || STATE.keys['d']) {
            if (STATE.frame % 3 === 0) {
                const angle = this.rotation + Math.PI + randomRange(-0.5, 0.5);
                const px = this.x + Math.cos(angle) * 10;
                const py = this.y + Math.sin(angle) * 10;
                STATE.particles.push(new Particle(px, py, '#0aa', 2, 15));
            }
        }
    }

    drawShape(ctx) {
        ctx.beginPath();
        ctx.moveTo(15, 0); // Nose
        ctx.lineTo(-10, 10); // Back Right
        ctx.lineTo(-5, 0); // Engine center
        ctx.lineTo(-10, -10); // Back Left
        ctx.closePath();
        
        // Cockpit
        ctx.moveTo(0, 0);
        ctx.lineTo(-3, 0);
    }
}

class Enemy extends Ship {
    constructor() {
        // Spawn near edge
        let x, y;
        if (Math.random() < 0.5) {
            x = Math.random() < 0.5 ? -50 : STATE.width + 50;
            y = Math.random() * STATE.height;
        } else {
            x = Math.random() * STATE.width;
            y = Math.random() < 0.5 ? -50 : STATE.height + 50;
        }
        
        super(x, y, 15, CONFIG.colors.enemy);
        this.health = 30;
        this.state = 'chase'; // chase, evade
        this.targetAngle = 0;
    }

    update() {
        if (!STATE.player || STATE.player.dead) return;

        const dist = distance(this, STATE.player);
        const angle = angleTo(this, STATE.player);

        // AI Logic
        if (dist > 300) {
            // Chase
            this.vx += Math.cos(angle) * 0.2;
            this.vy += Math.sin(angle) * 0.2;
        } else if (dist < 150) {
            // Evade (too close)
            this.vx -= Math.cos(angle) * 0.2;
            this.vy -= Math.sin(angle) * 0.2;
        } else {
            // Strafe
            this.vx += Math.cos(angle + Math.PI/2) * 0.2;
            this.vy += Math.sin(angle + Math.PI/2) * 0.2;
        }

        this.vx *= 0.95;
        this.vy *= 0.95;

        super.update();
        
        // Smooth rotation
        this.rotation = angle; // Immediate aim for difficulty

        // Shoot
        if (this.cooldown > 0) this.cooldown--;
        if (dist < 500 && Math.abs(angle - this.rotation) < 0.5 && this.cooldown <= 0) {
            STATE.entities.push(new Bullet(this.x, this.y, this.rotation + randomRange(-0.1, 0.1), 'enemy'));
            this.cooldown = CONFIG.fireRate * 3;
            Sound.shoot();
        }
    }

    drawShape(ctx) {
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-5, 8);
        ctx.lineTo(-10, 0);
        ctx.lineTo(-5, -8);
        ctx.closePath();
        
        ctx.moveTo(-5, 8);
        ctx.lineTo(-15, 12);
        
        ctx.moveTo(-5, -8);
        ctx.lineTo(-15, -12);
    }
}

class Asteroid extends Entity {
    constructor(x, y, radius, generation = 1) {
        super(x || (Math.random() * STATE.width), y || (Math.random() * STATE.height), radius, CONFIG.colors.asteroid);
        if (!x && !y) {
            // Randomize start pos if not provided (not splitting)
             if (Math.random() < 0.5) {
                this.x = Math.random() < 0.5 ? -radius : STATE.width + radius;
                this.y = Math.random() * STATE.height;
            } else {
                this.x = Math.random() * STATE.width;
                this.y = Math.random() < 0.5 ? -radius : STATE.height + radius;
            }
        }
        
        const angle = Math.random() * Math.PI * 2;
        const speed = randomRange(0.5, 2);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.rotSpeed = randomRange(-0.05, 0.05);
        this.generation = generation;
        
        // Generate Jagged Shape
        this.points = [];
        const segments = 8 + this.radius / 2;
        for (let i = 0; i < segments; i++) {
            const a = (i / segments) * Math.PI * 2;
            const r = this.radius * randomRange(0.8, 1.2);
            this.points.push({x: Math.cos(a) * r, y: Math.sin(a) * r});
        }
    }

    update() {
        super.update();
        this.rotation += this.rotSpeed;

        // Wrap around
        const buffer = this.radius + 10;
        if (this.x < -buffer) this.x = STATE.width + buffer;
        if (this.x > STATE.width + buffer) this.x = -buffer;
        if (this.y < -buffer) this.y = STATE.height + buffer;
        if (this.y > STATE.height + buffer) this.y = -buffer;
    }

    takeDamage() {
        Sound.explode(1);
        this.dead = true;
        
        // Score
        STATE.score += 100 / this.generation;
        
        // Particles
        for (let i = 0; i < 10; i++) {
            STATE.particles.push(new Particle(this.x, this.y, this.color, randomRange(1, 3), 20));
        }

        // Split
        if (this.generation < 3) {
            for (let i = 0; i < 2; i++) {
                const newR = this.radius / 1.8;
                const asteroid = new Asteroid(this.x, this.y, newR, this.generation + 1);
                asteroid.vx = this.vx + randomRange(-1, 1);
                asteroid.vy = this.vy + randomRange(-1, 1);
                STATE.entities.push(asteroid);
            }
        }
    }

    drawShape(ctx) {
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].x, this.points[i].y);
        }
        ctx.closePath();
    }
}

/**
 * Game Engine
 */
function init() {
    window.addEventListener('resize', resize);
    window.addEventListener('keydown', e => STATE.keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => STATE.keys[e.key.toLowerCase()] = false);
    window.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        STATE.mouse.x = e.clientX - rect.left;
        STATE.mouse.y = e.clientY - rect.top;
    });
    window.addEventListener('mousedown', () => STATE.mouse.down = true);
    window.addEventListener('mouseup', () => STATE.mouse.down = false);
    
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    resize();
    requestAnimationFrame(loop);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    STATE.width = canvas.width;
    STATE.height = canvas.height;
}

function startGame() {
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    
    STATE.player = new Player();
    STATE.entities = [];
    STATE.particles = [];
    STATE.score = 0;
    STATE.gameOver = false;
    STATE.frame = 0;
    
    // Initial Asteroids
    for(let i=0; i<5; i++) {
        STATE.entities.push(new Asteroid(null, null, 40));
    }
}

function update() {
    if (STATE.gameOver || !STATE.player) return;

    STATE.frame++;

    // Spawning
    if (STATE.frame % CONFIG.enemySpawnRate === 0) {
        STATE.entities.push(new Enemy());
    }
    if (STATE.frame % CONFIG.asteroidSpawnRate === 0) {
        STATE.entities.push(new Asteroid(null, null, 40));
    }

    // Update Player
    STATE.player.update();
    if (STATE.player.dead) {
        gameOver();
    }

    // Update Entities
    STATE.entities = STATE.entities.filter(e => !e.dead);
    STATE.entities.forEach(e => e.update());

    // Update Particles
    STATE.particles = STATE.particles.filter(p => !p.dead);
    STATE.particles.forEach(p => p.update());

    // Collision Detection
    checkCollisions();

    // Camera Shake Decay
    STATE.camera.shake *= CONFIG.screenShakeDecay;
    if (STATE.camera.shake < 0.5) STATE.camera.shake = 0;

    // Update UI
    scoreEl.innerText = Math.floor(STATE.score);
    const healthPct = Math.max(0, (STATE.player.health / STATE.player.maxHealth) * 100);
    healthFillEl.style.width = `${healthPct}%`;
}

function checkCollisions() {
    const bullets = STATE.entities.filter(e => e instanceof Bullet);
    const enemies = STATE.entities.filter(e => e instanceof Enemy);
    const asteroids = STATE.entities.filter(e => e instanceof Asteroid);

    // Bullets hitting things
    for (const b of bullets) {
        if (b.owner === 'player') {
            // Hit Enemy
            for (const e of enemies) {
                if (distance(b, e) < e.radius + b.radius) {
                    b.dead = true;
                    e.takeDamage(10);
                    STATE.score += 50;
                    if (e.dead) {
                         STATE.score += 200;
                         e.explode();
                    }
                }
            }
            // Hit Asteroid
            for (const a of asteroids) {
                if (distance(b, a) < a.radius + b.radius) {
                    b.dead = true;
                    a.takeDamage();
                }
            }
        } else if (b.owner === 'enemy') {
            // Hit Player
            if (distance(b, STATE.player) < STATE.player.radius + b.radius) {
                b.dead = true;
                STATE.player.takeDamage(10);
            }
        }
    }

    // Player collision
    for (const e of STATE.entities) {
        if (e instanceof Enemy || e instanceof Asteroid) {
             if (distance(STATE.player, e) < STATE.player.radius + e.radius) {
                 STATE.player.takeDamage(20);
                 if (e instanceof Asteroid) e.takeDamage();
                 if (e instanceof Enemy) {
                     e.takeDamage(100); // Crash kills enemy
                 }
             }
        }
    }
}

function gameOver() {
    STATE.gameOver = true;
    finalScoreEl.innerText = Math.floor(STATE.score);
    gameOverScreen.classList.remove('hidden');
}

function draw() {
    // Clear & Background
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, STATE.width, STATE.height);

    // Starfield (Simple)
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 50; i++) {
        // Deterministic stars based on index + drift? 
        // Just random for now, but to avoid "noise" effect, we should probably store them.
        // For this single-file simplicity, we'll store stars or just draw random ones?
        // Random every frame flickers. Let's make a static background canvas or just store array.
    }
    // Better: Draw stored stars. We'll add them to state lazily.
    if (!STATE.stars) {
        STATE.stars = [];
        for(let i=0; i<100; i++) STATE.stars.push({
            x: Math.random() * STATE.width, 
            y: Math.random() * STATE.height, 
            size: Math.random() * 2
        });
    }
    ctx.save();
    STATE.stars.forEach(star => {
        ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.001 + star.x) * 0.2;
        ctx.fillRect(star.x, star.y, star.size, star.size);
    });
    ctx.restore();


    // Camera Shake Transform
    ctx.save();
    if (STATE.camera.shake > 0) {
        const dx = (Math.random() - 0.5) * STATE.camera.shake;
        const dy = (Math.random() - 0.5) * STATE.camera.shake;
        ctx.translate(dx, dy);
    }

    // Draw Entities
    STATE.particles.forEach(p => p.draw(ctx));
    STATE.entities.forEach(e => e.draw(ctx));
    if (STATE.player && !STATE.player.dead) STATE.player.draw(ctx);

    ctx.restore();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// Start
init();

</script>
</body>
</html>
