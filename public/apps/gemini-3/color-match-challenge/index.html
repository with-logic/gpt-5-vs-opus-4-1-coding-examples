<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Match Challenge</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Framer Motion -->
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=JetBrains+Mono:wght@700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #1a1a2e;
            color: #fff;
            overflow: hidden; /* Prevent scrolling on mobile tap */
            touch-action: manipulation; /* Improve touch response */
        }
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }
        /* Custom scrollbar hide */
        ::-webkit-scrollbar {
            display: none;
        }
        .btn-shadow {
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }
        .btn-shadow:active {
            box-shadow: 0 0 0 rgba(0,0,0,0.2);
            transform: translateY(4px);
        }
    </style>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        bg: '#1a1a2e',
                        card: '#16213e',
                        accent: '#e94560',
                    },
                    animation: {
                        'pulse-fast': 'pulse 0.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;
        const { motion, AnimatePresence } = window.Motion;

        // Game Configuration
        const GAME_DURATION = 30; // seconds
        
        const COLORS = [
            { name: 'RED', hex: '#FF4757', border: '#C41E3A' },
            { name: 'BLUE', hex: '#2E86DE', border: '#1B4F93' },
            { name: 'GREEN', hex: '#2ED573', border: '#26AF61' },
            { name: 'YELLOW', hex: '#FFA502', border: '#CC8E35' }, // Slightly orange-yellow for visibility
            { name: 'PURPLE', hex: '#5352ED', border: '#3742FA' },
            { name: 'ORANGE', hex: '#FF7F50', border: '#E55039' }
        ];

        // Utility to get random item
        const randomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];

        // --- Components ---

        const Button = ({ color, onClick, disabled }) => {
            return (
                <motion.button
                    whileHover={{ scale: 1.05 }}
                    whileTap={{ scale: 0.95 }}
                    onClick={onClick}
                    disabled={disabled}
                    className="w-full aspect-square rounded-2xl flex items-center justify-center text-xl font-bold transition-colors relative group"
                    style={{ 
                        backgroundColor: color.hex,
                        boxShadow: `0 6px 0 ${color.border}`
                    }}
                >
                    <span className="sr-only">{color.name}</span>
                    <div className="absolute inset-0 bg-white opacity-0 group-hover:opacity-10 rounded-2xl transition-opacity" />
                    {/* Optional: Show color name icon or just color block? 
                        The prompt implies "click the correct color button". 
                        Usually these buttons are just colored blocks to reduce cognitive load on the input side 
                        while increasing it on the processing side. 
                        Let's keep them as clean colored blocks.
                    */}
                </motion.button>
            );
        };

        const Timer = ({ timeLeft, totalTime }) => {
            const progress = (timeLeft / totalTime) * 100;
            let colorClass = "bg-green-500";
            if (progress < 60) colorClass = "bg-yellow-400";
            if (progress < 30) colorClass = "bg-red-500";

            return (
                <div className="w-full max-w-md h-4 bg-gray-700 rounded-full overflow-hidden mb-6 relative border-2 border-gray-600">
                    <motion.div 
                        className={`h-full ${colorClass}`}
                        initial={{ width: "100%" }}
                        animate={{ width: `${progress}%` }}
                        transition={{ duration: 0.5, ease: "linear" }}
                    />
                </div>
            );
        };

        const FloatingParticles = () => {
            // Background decoration
            return (
                <div className="fixed inset-0 pointer-events-none overflow-hidden z-0">
                    {[...Array(15)].map((_, i) => (
                        <motion.div
                            key={i}
                            className="absolute rounded-full opacity-10"
                            style={{
                                backgroundColor: randomItem(COLORS).hex,
                                width: Math.random() * 100 + 50,
                                height: Math.random() * 100 + 50,
                                left: `${Math.random() * 100}%`,
                                top: `${Math.random() * 100}%`,
                            }}
                            animate={{
                                y: [0, Math.random() * 100 - 50],
                                x: [0, Math.random() * 100 - 50],
                                scale: [1, 1.2, 1],
                            }}
                            transition={{
                                duration: Math.random() * 10 + 10,
                                repeat: Infinity,
                                repeatType: "reverse",
                            }}
                        />
                    ))}
                </div>
            );
        };

        const App = () => {
            const [gameState, setGameState] = useState('menu'); // menu, playing, gameover
            const [score, setScore] = useState(0);
            const [timeLeft, setTimeLeft] = useState(GAME_DURATION);
            const [challenge, setChallenge] = useState({ word: '', colorObj: COLORS[0] });
            const [feedback, setFeedback] = useState(null); // 'correct' | 'wrong'
            
            const timerRef = useRef(null);

            const generateChallenge = useCallback(() => {
                const wordObj = randomItem(COLORS);
                let colorObj = randomItem(COLORS);
                
                // Ensure high entropy - usually we want word != color for Stroop, 
                // but random is also fine. To make it harder, let's just do pure random.
                // Actually, forcing mismatch often makes it slightly harder, 
                // but pure random includes matches which are confusing in a different way ("Easy" trap).
                // Let's stick to pure random for true chaos.
                
                setChallenge({
                    word: wordObj.name,
                    colorObj: colorObj
                });
            }, []);

            const startGame = () => {
                setScore(0);
                setTimeLeft(GAME_DURATION);
                setGameState('playing');
                generateChallenge();
                setFeedback(null);
                
                if (timerRef.current) clearInterval(timerRef.current);
                timerRef.current = setInterval(() => {
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            endGame();
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
            };

            const endGame = () => {
                clearInterval(timerRef.current);
                setGameState('gameover');
            };

            const handleAnswer = (selectedColorHex) => {
                if (gameState !== 'playing') return;

                // The rule: "Show a word... in a random font color â€” player must click the correct color button (not the word meaning)."
                // Correct answer matches the challenge.colorObj.hex
                
                const isCorrect = selectedColorHex === challenge.colorObj.hex;

                if (isCorrect) {
                    setScore(s => s + 1);
                    setFeedback('correct');
                    setTimeout(() => setFeedback(null), 200);
                    generateChallenge();
                } else {
                    // Penalty? Or just ignore? 
                    // Let's do a slight time penalty or screen shake to discourage spamming
                    // Penalty: -2 seconds
                    setTimeLeft(prev => Math.max(0, prev - 2));
                    setFeedback('wrong');
                    setTimeout(() => setFeedback(null), 200);
                    // Do we generate new challenge on wrong? 
                    // Usually yes to prevent getting stuck, or no to force correction.
                    // Fast paced: yes, generate new one to keep flow.
                    generateChallenge();
                }
            };

            // Cleanup
            useEffect(() => {
                return () => {
                    if (timerRef.current) clearInterval(timerRef.current);
                };
            }, []);

            // Animations variants
            const containerVariants = {
                hidden: { opacity: 0, scale: 0.9 },
                visible: { opacity: 1, scale: 1, transition: { duration: 0.3 } },
                exit: { opacity: 0, scale: 1.1, transition: { duration: 0.2 } }
            };

            return (
                <div className="min-h-screen w-full flex flex-col items-center justify-center p-4 relative z-10 selection:bg-pink-500 selection:text-white">
                    <FloatingParticles />
                    
                    <AnimatePresence mode="wait">
                        {/* --- MENU SCREEN --- */}
                        {gameState === 'menu' && (
                            <motion.div
                                key="menu"
                                variants={containerVariants}
                                initial="hidden"
                                animate="visible"
                                exit="exit"
                                className="text-center z-10 bg-card/80 backdrop-blur-md p-8 md:p-12 rounded-3xl border border-white/10 shadow-2xl max-w-lg w-full"
                            >
                                <motion.div 
                                    initial={{ y: -20, opacity: 0 }}
                                    animate={{ y: 0, opacity: 1 }}
                                    transition={{ delay: 0.2 }}
                                >
                                    <h1 className="text-6xl md:text-7xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 leading-tight">
                                        COLOR<br/>MATCH
                                    </h1>
                                    <p className="text-gray-300 text-lg mb-8 font-light">
                                        Tap the <strong className="text-white">INK COLOR</strong>,<br/>not the word!
                                    </p>
                                </motion.div>
                                
                                <motion.button
                                    whileHover={{ scale: 1.05 }}
                                    whileTap={{ scale: 0.95 }}
                                    onClick={startGame}
                                    className="bg-accent hover:bg-red-500 text-white text-2xl font-bold py-4 px-12 rounded-full shadow-lg shadow-red-500/30 transition-all border-b-4 border-red-800 active:border-b-0 active:translate-y-1"
                                >
                                    PLAY NOW
                                </motion.button>
                                
                                <div className="mt-8 flex justify-center gap-2 text-sm text-gray-500">
                                    <span className="bg-white/5 px-3 py-1 rounded-lg border border-white/5">30 Seconds</span>
                                    <span className="bg-white/5 px-3 py-1 rounded-lg border border-white/5">Fast Paced</span>
                                </div>
                            </motion.div>
                        )}

                        {/* --- GAME SCREEN --- */}
                        {gameState === 'playing' && (
                            <motion.div
                                key="game"
                                variants={containerVariants}
                                initial="hidden"
                                animate="visible"
                                exit="exit"
                                className="w-full max-w-md flex flex-col items-center z-10"
                            >
                                <div className="w-full flex justify-between items-end mb-4 px-2">
                                    <div className="text-left">
                                        <p className="text-xs text-gray-400 uppercase tracking-widest mb-1">Score</p>
                                        <p className="text-4xl font-bold mono text-white">{score}</p>
                                    </div>
                                    <div className="text-right">
                                        <p className="text-xs text-gray-400 uppercase tracking-widest mb-1">Time</p>
                                        <p className={`text-4xl font-bold mono ${timeLeft < 10 ? 'text-red-500 animate-pulse' : 'text-white'}`}>
                                            {timeLeft}
                                        </p>
                                    </div>
                                </div>

                                <Timer timeLeft={timeLeft} totalTime={GAME_DURATION} />

                                {/* The Challenge Card */}
                                <motion.div 
                                    className="relative w-full aspect-video bg-card rounded-3xl border border-white/10 shadow-2xl flex items-center justify-center mb-8 overflow-hidden"
                                    animate={
                                        feedback === 'wrong' ? { x: [-10, 10, -10, 10, 0] } : {}
                                    }
                                    transition={{ type: 'spring', stiffness: 300, damping: 20 }}
                                >
                                    {/* Flash Effect on Correct/Wrong */}
                                    <AnimatePresence>
                                        {feedback === 'correct' && (
                                            <motion.div 
                                                initial={{ opacity: 0 }} 
                                                animate={{ opacity: 0.3 }} 
                                                exit={{ opacity: 0 }}
                                                className="absolute inset-0 bg-green-500 pointer-events-none"
                                            />
                                        )}
                                        {feedback === 'wrong' && (
                                            <motion.div 
                                                initial={{ opacity: 0 }} 
                                                animate={{ opacity: 0.3 }} 
                                                exit={{ opacity: 0 }}
                                                className="absolute inset-0 bg-red-500 pointer-events-none"
                                            />
                                        )}
                                    </AnimatePresence>

                                    <motion.h2 
                                        key={score + challenge.word} // Re-render animation on change
                                        initial={{ scale: 0.5, opacity: 0 }}
                                        animate={{ scale: 1, opacity: 1 }}
                                        transition={{ type: "spring", stiffness: 300, damping: 15 }}
                                        className="text-7xl md:text-8xl font-black tracking-tight"
                                        style={{ color: challenge.colorObj.hex, textShadow: '0 4px 20px rgba(0,0,0,0.5)' }}
                                    >
                                        {challenge.word}
                                    </motion.h2>
                                </motion.div>

                                {/* Controls */}
                                <div className="grid grid-cols-3 gap-4 w-full">
                                    {COLORS.map((color) => (
                                        <Button 
                                            key={color.name} 
                                            color={color} 
                                            onClick={() => handleAnswer(color.hex)}
                                        />
                                    ))}
                                </div>
                            </motion.div>
                        )}

                        {/* --- GAME OVER SCREEN --- */}
                        {gameState === 'gameover' && (
                            <motion.div
                                key="gameover"
                                variants={containerVariants}
                                initial="hidden"
                                animate="visible"
                                exit="exit"
                                className="text-center z-10 bg-card/90 backdrop-blur-md p-8 rounded-3xl border border-white/10 shadow-2xl max-w-md w-full"
                            >
                                <p className="text-gray-400 uppercase tracking-widest text-sm mb-4">Time's Up!</p>
                                <h2 className="text-5xl font-bold text-white mb-2">Final Score</h2>
                                <div className="text-8xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-yellow-600 mb-8 mono">
                                    {score}
                                </div>
                                
                                <div className="space-y-4">
                                    <motion.button
                                        whileHover={{ scale: 1.05 }}
                                        whileTap={{ scale: 0.95 }}
                                        onClick={startGame}
                                        className="w-full bg-white text-indigo-900 text-xl font-bold py-4 rounded-xl shadow-lg transition-colors hover:bg-gray-100"
                                    >
                                        Play Again
                                    </motion.button>
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>