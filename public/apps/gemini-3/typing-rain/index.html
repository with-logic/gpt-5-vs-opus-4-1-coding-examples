<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Rain</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --bg-dark: #050510;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'JetBrains Mono', monospace;
            color: white;
            user-select: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }
        .interactive {
            pointer-events: auto;
        }
        .neon-text {
            text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue);
        }
        .neon-text-pink {
            text-shadow: 0 0 5px var(--neon-pink), 0 0 10px var(--neon-pink);
        }
        .glass-panel {
            background: rgba(10, 10, 25, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        /* Pulse animation for the cursor/target */
        @keyframes pulse-target {
            0% { text-shadow: 0 0 5px var(--neon-pink); }
            50% { text-shadow: 0 0 15px var(--neon-pink), 0 0 25px var(--neon-pink); }
            100% { text-shadow: 0 0 5px var(--neon-pink); }
        }
        .target-active {
            color: var(--neon-pink);
            animation: pulse-target 1s infinite;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <!-- Background Music / Sound Placeholder (Optional, staying silent for auto-play policy safety) -->

    <!-- Canvas Layer -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-between p-6">
        
        <!-- HUD: Score & Stats -->
        <div id="hud" class="flex justify-between items-start opacity-0 transition-opacity duration-500">
            <div class="glass-panel p-4 rounded-lg text-neon-blue">
                <div class="text-xs uppercase tracking-widest opacity-70">Score</div>
                <div class="text-3xl font-bold" id="score-display">0</div>
            </div>
            
            <div class="flex space-x-4">
                <div class="glass-panel p-4 rounded-lg text-white">
                    <div class="text-xs uppercase tracking-widest opacity-70">Accuracy</div>
                    <div class="text-xl font-bold text-center"><span id="accuracy-display">100</span>%</div>
                </div>
                <div class="glass-panel p-4 rounded-lg text-white">
                    <div class="text-xs uppercase tracking-widest opacity-70">Streak</div>
                    <div class="text-xl font-bold text-center" id="streak-display">0</div>
                </div>
                <div class="glass-panel p-4 rounded-lg text-red-400">
                    <div class="text-xs uppercase tracking-widest opacity-70">Danger</div>
                    <div class="w-32 h-6 bg-gray-900 rounded-full mt-1 overflow-hidden border border-red-900 relative">
                        <div id="danger-bar" class="h-full bg-red-600 w-0 transition-all duration-200"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="absolute inset-0 flex items-center justify-center interactive bg-black/60 backdrop-blur-sm z-50">
            <div class="text-center glass-panel p-12 rounded-2xl border-t-4 border-t-cyan-400 max-w-lg w-full transform transition-all hover:scale-105 duration-300">
                <h1 class="text-6xl font-bold mb-2 font-['Rajdhani'] neon-text tracking-wider">TYPING RAIN</h1>
                <p class="text-cyan-200 mb-8 tracking-widest uppercase text-sm">Cyberpunk Wordfall Defense</p>
                
                <div class="space-y-2 mb-8 text-left bg-black/40 p-4 rounded border-l-2 border-cyan-500 text-sm text-gray-300">
                    <p>⚡ Type words to neutralize them before they hit the city.</p>
                    <p>⚡ Don't make typos to maintain your streak.</p>
                    <p>⚡ Difficulty increases as you survive.</p>
                </div>

                <button id="start-btn" class="px-8 py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded text-xl shadow-[0_0_15px_rgba(0,243,255,0.5)] transition-all uppercase tracking-widest">
                    Initialize System
                </button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="absolute inset-0 flex items-center justify-center interactive bg-red-900/20 backdrop-blur-md z-50 hidden">
            <div class="text-center glass-panel p-10 rounded-2xl border-t-4 border-t-red-500 shadow-[0_0_50px_rgba(255,0,0,0.2)]">
                <h2 class="text-5xl font-bold mb-2 font-['Rajdhani'] text-red-500 neon-text-pink">SYSTEM FAILURE</h2>
                <p class="text-red-200 mb-6 uppercase tracking-widest">City Defenses Breached</p>
                
                <div class="grid grid-cols-2 gap-4 mb-8">
                    <div class="bg-black/50 p-3 rounded">
                        <div class="text-xs text-gray-400 uppercase">Final Score</div>
                        <div class="text-2xl font-bold text-white" id="final-score">0</div>
                    </div>
                    <div class="bg-black/50 p-3 rounded">
                        <div class="text-xs text-gray-400 uppercase">Best Streak</div>
                        <div class="text-2xl font-bold text-white" id="final-streak">0</div>
                    </div>
                    <div class="bg-black/50 p-3 rounded col-span-2">
                        <div class="text-xs text-gray-400 uppercase">Accuracy</div>
                        <div class="text-2xl font-bold text-white" id="final-accuracy">0%</div>
                    </div>
                </div>

                <button id="restart-btn" class="px-8 py-3 bg-red-600 hover:bg-red-500 text-white font-bold rounded text-lg shadow-[0_0_15px_rgba(255,0,0,0.5)] transition-all uppercase tracking-widest">
                    Reboot System
                </button>
            </div>
        </div>
    </div>

<script>
/**
 * TYPING RAIN
 * A cyberpunk aesthetic typing game.
 */

// --- Constants & Config ---
const WORDS_EASY = ["run", "sky", "cat", "dog", "net", "bit", "cpu", "ram", "red", "neo", "car", "bus", "top", "pop", "zap", "fix", "box", "key", "log", "map"];
const WORDS_MEDIUM = ["cyber", "neon", "rain", "data", "code", "hack", "laser", "pulse", "drive", "power", "robot", "sound", "light", "night", "storm", "watch", "track", "frame", "pixel", "virus", "logic", "cloud", "stack", "queue"];
const WORDS_HARD = ["interface", "protocol", "algorithm", "bandwidth", "encryption", "mainframe", "cyberpunk", "synthetic", "processor", "backdoor", "firewall", "terminal", "override", "sequence", "download", "gigabyte", "network", "database", "security"];
const WORDS_EXPERT = ["singularity", "artificial", "intelligence", "architecture", "cryptography", "decentralized", "infrastructure", "biometric", "authentication", "virtualization", "microprocessor", "transmission", "countermeasure"];

const COLORS = {
    text: '#ffffff',
    matched: '#ff00ff', // Pink for matched letters
    active: '#00f3ff',  // Cyan for active word highlight
    rain: 'rgba(0, 243, 255, 0.3)',
    cityDark: '#020205',
    cityLight: '#101020',
    bg: '#050510'
};

// --- Game State ---
const state = {
    screen: 'start', // start, playing, gameover
    words: [], // Array of Word objects
    particles: [], // Rain/Explosion particles
    targetWordIndex: -1, // Index of word currently being typed
    score: 0,
    startTime: 0,
    keystrokesTotal: 0,
    keystrokesCorrect: 0,
    streak: 0,
    maxStreak: 0,
    difficultyMultiplier: 1,
    spawnTimer: 0,
    spawnInterval: 120, // Frames between spawns
    dangerLevel: 0, // 0 to 100
    lastFrameTime: 0
};

// --- Canvas Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let w, h;

function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- Procedural City Background ---
let citySilhouette = [];

function generateCity() {
    citySilhouette = [];
    let x = 0;
    while (x < w) {
        const width = 30 + Math.random() * 80;
        const height = 50 + Math.random() * 150;
        citySilhouette.push({ x, w: width, h: height });
        x += width;
    }
}

// --- Classes ---

class Word {
    constructor() {
        // Difficulty scaling pick
        let pool = WORDS_EASY;
        if (state.score > 500) pool = pool.concat(WORDS_MEDIUM);
        if (state.score > 1500) pool = pool.concat(WORDS_HARD);
        if (state.score > 3000) pool = pool.concat(WORDS_EXPERT);
        
        this.text = pool[Math.floor(Math.random() * pool.length)];
        this.matchedIndex = 0; // How many chars matched so far
        
        // Measure text for width/height
        ctx.font = '24px "JetBrains Mono"';
        const metrics = ctx.measureText(this.text);
        this.width = metrics.width;
        this.height = 24;
        
        // Random position, avoiding edges
        this.x = Math.random() * (w - this.width - 40) + 20;
        this.y = -40; // Start above screen
        
        // Speed increases with difficulty
        const baseSpeed = 0.5 + (state.difficultyMultiplier * 0.2);
        this.speed = baseSpeed + Math.random() * 0.5;
        
        this.isActive = false; // Is this the word currently being typed?
    }

    update() {
        this.y += this.speed;
        
        // Check collision with "city" (bottom of screen area)
        if (this.y > h - 50) {
            return 'hit';
        }
        return 'active';
    }

    draw() {
        ctx.font = 'bold 24px "JetBrains Mono"';
        
        // Draw trailing line (rain effect)
        ctx.beginPath();
        ctx.moveTo(this.x + this.width / 2, this.y);
        ctx.lineTo(this.x + this.width / 2, this.y - 100);
        ctx.strokeStyle = `rgba(0, 243, 255, ${Math.max(0, 0.1 - (this.y/h)*0.1)})`;
        ctx.lineWidth = 1;
        ctx.stroke();

        // Draw text
        const matchedStr = this.text.substring(0, this.matchedIndex);
        const remainingStr = this.text.substring(this.matchedIndex);

        // Draw background pill if active
        if (this.isActive) {
            ctx.fillStyle = 'rgba(0, 243, 255, 0.1)';
            ctx.fillRect(this.x - 5, this.y - this.height, this.width + 10, this.height + 5);
            
            // Draw Target Reticle
            ctx.strokeStyle = COLORS.active;
            ctx.lineWidth = 1;
            const pad = 8;
            const rx = this.x - pad;
            const ry = this.y - this.height;
            const rw = this.width + pad*2;
            const rh = this.height + pad;
            
            // Corner brackets
            const bl = 5; // bracket length
            ctx.beginPath();
            // Top Left
            ctx.moveTo(rx, ry + bl); ctx.lineTo(rx, ry); ctx.lineTo(rx + bl, ry);
            // Top Right
            ctx.moveTo(rx + rw - bl, ry); ctx.lineTo(rx + rw, ry); ctx.lineTo(rx + rw, ry + bl);
            // Bottom Right
            ctx.moveTo(rx + rw, ry + rh - bl); ctx.lineTo(rx + rw, ry + rh); ctx.lineTo(rx + rw - bl, ry + rh);
            // Bottom Left
            ctx.moveTo(rx + bl, ry + rh); ctx.lineTo(rx, ry + rh); ctx.lineTo(rx, ry + rh - bl);
            ctx.stroke();
        }

        // Draw Matched Part
        let currentX = this.x;
        if (matchedStr.length > 0) {
            ctx.fillStyle = COLORS.matched;
            ctx.shadowColor = COLORS.matched;
            ctx.shadowBlur = 10;
            ctx.fillText(matchedStr, currentX, this.y);
            currentX += ctx.measureText(matchedStr).width;
            ctx.shadowBlur = 0;
        }

        // Draw Remaining Part
        ctx.fillStyle = COLORS.text;
        // Optional: First letter of remaining highlighted if not active yet but reachable?
        // For now just white.
        if (this.isActive && remainingStr.length > 0) {
             // Highlight next character to type
             const nextChar = remainingStr[0];
             const rest = remainingStr.substring(1);
             
             ctx.fillStyle = '#ffffff'; // Next char bright white
             ctx.fillText(nextChar, currentX, this.y);
             currentX += ctx.measureText(nextChar).width;
             
             ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; // Rest dimmed
             ctx.fillText(rest, currentX, this.y);
        } else {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillText(remainingStr, currentX, this.y);
        }
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 1.0;
        this.color = color || COLORS.active;
        this.size = Math.random() * 2 + 1;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.02;
        this.vy += 0.1; // gravity
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class RainDrop {
    constructor() {
        this.x = Math.random() * w;
        this.y = Math.random() * h;
        this.len = Math.random() * 20 + 10;
        this.speed = Math.random() * 5 + 10;
        this.opacity = Math.random() * 0.3 + 0.1;
    }
    update() {
        this.y += this.speed;
        if (this.y > h) {
            this.y = -20;
            this.x = Math.random() * w;
        }
    }
    draw() {
        ctx.strokeStyle = `rgba(0, 243, 255, ${this.opacity})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y + this.len);
        ctx.stroke();
    }
}

// --- Engine ---

// Ambient Rain
const ambientRain = Array.from({ length: 100 }, () => new RainDrop());

function createExplosion(x, y, color) {
    for (let i = 0; i < 15; i++) {
        state.particles.push(new Particle(x, y, color));
    }
}

function updateGame() {
    // Spawning Logic
    state.spawnTimer++;
    // Difficulty curve: spawn faster as score increases
    const currentInterval = Math.max(30, 120 - Math.floor(state.score / 100) * 5);
    
    if (state.spawnTimer > currentInterval) {
        state.words.push(new Word());
        state.spawnTimer = 0;
    }

    // Update Ambient Rain
    ambientRain.forEach(r => r.update());

    // Update Particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.update();
        if (p.life <= 0) state.particles.splice(i, 1);
    }

    // Update Words
    for (let i = state.words.length - 1; i >= 0; i--) {
        const word = state.words[i];
        const status = word.update();
        
        if (status === 'hit') {
            // Word hit the city
            state.dangerLevel += 20; // 20% danger per hit
            createExplosion(word.x + word.width/2, h - 20, '#ff0000');
            state.words.splice(i, 1);
            
            // Check index shift
            if (state.targetWordIndex === i) state.targetWordIndex = -1;
            else if (state.targetWordIndex > i) state.targetWordIndex--;
            
            // Break streak
            state.streak = 0;
            updateUI();
            
            // Check Game Over
            if (state.dangerLevel >= 100) {
                endGame();
            }
        }
    }

    // Difficulty Multiplier
    state.difficultyMultiplier = 1 + (state.score / 1000);
}

function drawGame() {
    // Clear
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, w, h);

    // Draw City Silhouette (Background)
    ctx.fillStyle = COLORS.cityLight;
    citySilhouette.forEach(b => {
        // Simple parallax feel or just static
        ctx.fillRect(b.x, h - b.h, b.w, b.h);
    });
    
    // Draw Glow from city
    const gradient = ctx.createLinearGradient(0, h-100, 0, h);
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(1, 'rgba(0, 243, 255, 0.1)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, h-150, w, 150);

    // Draw Rain
    ambientRain.forEach(r => r.draw());

    // Draw Words
    state.words.forEach(word => word.draw());

    // Draw Particles
    state.particles.forEach(p => p.draw());
    
    // Danger Overlay (Red Vignette if danger is high)
    if (state.dangerLevel > 0) {
        const opacity = state.dangerLevel / 200; // max 0.5 opacity
        const radGrad = ctx.createRadialGradient(w/2, h/2, h/3, w/2, h/2, h);
        radGrad.addColorStop(0, 'rgba(255, 0, 0, 0)');
        radGrad.addColorStop(1, `rgba(255, 0, 0, ${opacity})`);
        ctx.fillStyle = radGrad;
        ctx.fillRect(0, 0, w, h);
    }
}

function loop() {
    if (state.screen === 'playing') {
        updateGame();
        drawGame();
        requestAnimationFrame(loop);
    }
}

// --- Input Handling ---

window.addEventListener('keydown', (e) => {
    if (state.screen !== 'playing') return;

    // Ignore modifiers
    if (e.ctrlKey || e.altKey || e.metaKey) return;
    if (e.key.length !== 1) return; // Only printable chars

    const char = e.key.toLowerCase();
    state.keystrokesTotal++;

    // 1. If we have a target word
    if (state.targetWordIndex !== -1) {
        const word = state.words[state.targetWordIndex];
        const neededChar = word.text[word.matchedIndex];

        if (char === neededChar) {
            // Correct hit
            word.matchedIndex++;
            state.keystrokesCorrect++;
            
            // Check completion
            if (word.matchedIndex >= word.text.length) {
                // Word Done
                state.score += word.text.length * 10 + (state.streak * 2);
                state.streak++;
                if (state.streak > state.maxStreak) state.maxStreak = state.streak;
                
                // Heal Danger slightly
                if (state.dangerLevel > 0) state.dangerLevel = Math.max(0, state.dangerLevel - 5);
                
                createExplosion(word.x + word.width/2, word.y, COLORS.matched);
                
                // Remove word
                state.words.splice(state.targetWordIndex, 1);
                state.targetWordIndex = -1;
            }
        } else {
            // Typo on active word
            state.streak = 0;
            // Screen shake or visual feedback?
        }
    } 
    // 2. No target selected, look for starts
    else {
        // Find words starting with char
        const candidates = [];
        state.words.forEach((word, index) => {
            if (word.text.startsWith(char)) {
                candidates.push({ index, word });
            }
        });

        if (candidates.length > 0) {
            // Pick the one closest to bottom (highest Y)
            candidates.sort((a, b) => b.word.y - a.word.y);
            
            const selected = candidates[0];
            state.targetWordIndex = selected.index;
            state.words[selected.index].isActive = true;
            state.words[selected.index].matchedIndex = 1; // First char matched
            state.keystrokesCorrect++;
        } else {
            // Miss (no word starts with this)
            state.streak = 0;
        }
    }
    updateUI();
});

// --- UI Management ---

const uiStart = document.getElementById('start-screen');
const uiGameOver = document.getElementById('game-over-screen');
const uiHud = document.getElementById('hud');
const scoreDisplay = document.getElementById('score-display');
const accDisplay = document.getElementById('accuracy-display');
const streakDisplay = document.getElementById('streak-display');
const dangerBar = document.getElementById('danger-bar');

function updateUI() {
    scoreDisplay.innerText = state.score;
    streakDisplay.innerText = state.streak;
    
    let acc = 100;
    if (state.keystrokesTotal > 0) {
        acc = Math.floor((state.keystrokesCorrect / state.keystrokesTotal) * 100);
    }
    accDisplay.innerText = acc;

    dangerBar.style.width = `${state.dangerLevel}%`;
    
    // Danger Bar Color Shift
    if (state.dangerLevel > 80) dangerBar.className = "h-full bg-red-600 w-0 transition-all duration-200 animate-pulse";
    else dangerBar.className = "h-full bg-red-600 w-0 transition-all duration-200";
}

function startGame() {
    // Reset State
    state.screen = 'playing';
    state.score = 0;
    state.words = [];
    state.particles = [];
    state.targetWordIndex = -1;
    state.spawnTimer = 0;
    state.keystrokesTotal = 0;
    state.keystrokesCorrect = 0;
    state.streak = 0;
    state.dangerLevel = 0;
    state.startTime = Date.now();
    
    // UI
    uiStart.classList.add('hidden');
    uiGameOver.classList.add('hidden');
    uiHud.classList.remove('opacity-0');
    
    generateCity();
    updateUI();
    loop();
}

function endGame() {
    state.screen = 'gameover';
    
    document.getElementById('final-score').innerText = state.score;
    document.getElementById('final-streak').innerText = state.maxStreak;
    let acc = 100;
    if (state.keystrokesTotal > 0) acc = Math.floor((state.keystrokesCorrect / state.keystrokesTotal) * 100);
    document.getElementById('final-accuracy').innerText = acc + "%";

    uiGameOver.classList.remove('hidden');
    uiHud.classList.add('opacity-0');
}

// --- Init ---
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);

// Initial Render for background effect on start screen
generateCity();
function attractionLoop() {
    if (state.screen === 'start') {
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, w, h);
        
        ctx.fillStyle = COLORS.cityLight;
        citySilhouette.forEach(b => ctx.fillRect(b.x, h - b.h, b.w, b.h));
        
        ambientRain.forEach(r => { r.update(); r.draw(); });
        requestAnimationFrame(attractionLoop);
    }
}
attractionLoop();

</script>
</body>
</html>
