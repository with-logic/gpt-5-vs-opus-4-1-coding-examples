<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Festival Lights Show</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body {
            background-color: #050505;
            color: white;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* Glassmorphism for UI */
        .glass-panel {
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05); 
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2); 
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4); 
        }

        /* Neon Glow Text */
        .neon-text {
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8), 0 0 10px currentColor;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">

    const { useState, useEffect, useRef, useMemo } = React;

    /**
     * AUDIO ENGINE
     * Generates a synthesized beat using Web Audio API so no external files are needed.
     */
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.analyser = null;
            this.isPlaying = false;
            this.bpm = 128;
            this.nextNoteTime = 0;
            this.timerID = null;
            this.lookahead = 25.0; // ms
            this.scheduleAheadTime = 0.1; // s
            this.beatCount = 0;
            this.dataArray = null;
            
            // Callbacks
            this.onBeat = null; 
        }

        init() {
            if (!this.ctx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 256;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                
                // Master compressor to prevent clipping
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.connect(this.ctx.destination);
                this.analyser.connect(compressor);
            }
        }

        toggle() {
            if (this.isPlaying) {
                this.stop();
            } else {
                this.start();
            }
            return this.isPlaying;
        }

        start() {
            if (!this.ctx) this.init();
            if (this.ctx.state === 'suspended') this.ctx.resume();
            
            this.isPlaying = true;
            this.nextNoteTime = this.ctx.currentTime;
            this.scheduler();
        }

        stop() {
            this.isPlaying = false;
            window.clearTimeout(this.timerID);
        }

        scheduler() {
            while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                this.scheduleNote(this.beatCount, this.nextNoteTime);
                this.nextNote();
            }
            if (this.isPlaying) {
                this.timerID = window.setTimeout(() => this.scheduler(), this.lookahead);
            }
        }

        nextNote() {
            const secondsPerBeat = 60.0 / this.bpm;
            this.nextNoteTime += 0.25 * secondsPerBeat; // 16th notes
            this.beatCount++;
            if (this.beatCount === 16) {
                this.beatCount = 0;
            }
        }

        scheduleNote(beatNumber, time) {
            // Visualize trigger
            if (beatNumber % 4 === 0 && this.onBeat) {
                // Main beat
                setTimeout(() => this.onBeat('kick'), (time - this.ctx.currentTime) * 1000);
            } else if (beatNumber % 4 === 2 && this.onBeat) {
                 setTimeout(() => this.onBeat('snare'), (time - this.ctx.currentTime) * 1000);
            }

            // Audio Synthesis
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.connect(gain);
            gain.connect(this.analyser);

            // Kick
            if (beatNumber % 4 === 0) {
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.start(time);
                osc.stop(time + 0.5);
            }
            // Hi-hat
            else if (beatNumber % 2 !== 0) {
                // White noise buffer for hi-hat would be better, but simple osc for now
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, time);
                osc.frequency.exponentialRampToValueAtTime(12000, time + 0.05);
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                osc.start(time);
                osc.stop(time + 0.05);
            }
            // Snare-ish
            else if (beatNumber % 4 === 2) {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, time);
                gain.gain.setValueAtTime(0.7, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                osc.start(time);
                osc.stop(time + 0.2);
            }
            
            // Bassline (simple arpeggio)
            if (beatNumber % 2 === 0) {
                const bassOsc = this.ctx.createOscillator();
                const bassGain = this.ctx.createGain();
                bassOsc.type = 'sawtooth';
                bassOsc.connect(bassGain);
                bassGain.connect(this.analyser);
                
                // Simple progression
                const freqs = [55, 55, 65, 49]; // A, A, C, G
                const noteIdx = Math.floor(beatNumber / 4) % 4;
                
                bassOsc.frequency.setValueAtTime(freqs[noteIdx], time);
                bassGain.gain.setValueAtTime(0.4, time);
                bassGain.gain.linearRampToValueAtTime(0, time + 0.2);
                
                bassOsc.start(time);
                bassOsc.stop(time + 0.2);
            }
        }
        
        getAudioData() {
            if (!this.analyser) return 0;
            this.analyser.getByteFrequencyData(this.dataArray);
            // Return average volume of low end
            let sum = 0;
            for(let i = 0; i < 10; i++) {
                sum += this.dataArray[i];
            }
            return sum / 10;
        }
    }

    /**
     * LIGHT SHOW RENDERER
     * Handles Canvas API drawing
     */
    class LightShow {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.width = canvas.width;
            this.height = canvas.height;
            this.lights = [];
            this.particles = []; // For explosion effects
            this.cols = 20;
            this.rows = 15;
            this.time = 0;
            
            // Config
            this.pattern = 'matrix';
            this.baseColor = { h: 280, s: 100, l: 60 };
            this.speed = 1;
            this.intensity = 1;
            this.beatImpulse = 0;
            
            this.resize();
            this.initLights();
        }

        resize() {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            this.initLights();
        }

        initLights() {
            this.lights = [];
            const xStep = this.width / (this.cols + 1);
            const yStep = this.height / (this.rows + 1);

            for(let y = 0; y < this.rows; y++) {
                for(let x = 0; x < this.cols; x++) {
                    this.lights.push({
                        gx: x, gy: y, // Grid coordinates
                        x: (x + 1) * xStep,
                        y: (y + 1) * yStep,
                        baseX: (x + 1) * xStep,
                        baseY: (y + 1) * yStep,
                        hue: 0,
                        sat: 0,
                        lum: 0,
                        alpha: 0,
                        size: 0
                    });
                }
            }
        }

        triggerBeat(type) {
            this.beatImpulse = 1.0;
            // Spawn particles on kick
            if (type === 'kick') {
                const cx = this.width / 2;
                const cy = this.height / 2;
                for(let i=0; i<20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 5;
                    this.particles.push({
                        x: cx, y: cy,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        hue: this.baseColor.h + Math.random() * 40 - 20
                    });
                }
            }
        }

        update(dt, audioLevel) {
            this.time += dt * this.speed;
            this.beatImpulse *= 0.9; // Decay beat impulse

            // Update particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                if(p.life <= 0) this.particles.splice(i, 1);
            }

            // Update Lights based on pattern
            this.lights.forEach((l, i) => {
                let h = this.baseColor.h;
                let s = this.baseColor.s;
                let lum = 0; // Off by default
                let a = 1;
                let size = 4 + audioLevel * 0.1;

                const nx = l.gx / this.cols;
                const ny = l.gy / this.rows;

                if (this.pattern === 'matrix') {
                    // Digital rain effect + wave
                    const wave = Math.sin(nx * 10 + this.time * 2) * 0.5 + 0.5;
                    const drop = Math.sin(ny * 8 - this.time * 4) * 0.5 + 0.5;
                    lum = (wave * drop) * 50 + (this.beatImpulse * 20);
                    h += nx * 60;
                } 
                else if (this.pattern === 'radial') {
                    // Circular pulses
                    const cx = this.cols / 2;
                    const cy = this.rows / 2;
                    const dist = Math.sqrt((l.gx - cx)**2 + (l.gy - cy)**2);
                    const ring = Math.sin(dist * 0.8 - this.time * 5);
                    lum = ring > 0.8 ? 80 : 5;
                    lum += this.beatImpulse * 30 * (1 - dist/this.cols);
                    h += dist * 10;
                }
                else if (this.pattern === 'sparkle') {
                    // Random twinkling
                    const noise = Math.sin(l.gx * 123.1 + l.gy * 52.4 + this.time * 10);
                    lum = noise > 0.9 ? 100 : 0;
                    if (Math.random() < 0.01 * this.beatImpulse) lum = 100; // Beat sparkles
                    h = Math.random() * 360;
                }
                else if (this.pattern === 'wave') {
                    // Smooth ocean-like wave
                    const z = Math.sin(nx * 5 + this.time) + Math.sin(ny * 3 + this.time * 0.5);
                    lum = (z + 2) * 15 + this.beatImpulse * 10;
                    l.y = l.baseY + Math.sin(nx * 10 + this.time * 3) * 20 * this.beatImpulse;
                    h += z * 30;
                }
                else if (this.pattern === 'converge') {
                    // Lights move to beat
                    const distToCenter = Math.abs(nx - 0.5);
                    lum = (1 - distToCenter) * 50;
                    if (this.beatImpulse > 0.5) lum = 100;
                    h = this.baseColor.h + ny * 20;
                    
                    // Shake effect on beat
                    l.x = l.baseX + (Math.random() - 0.5) * this.beatImpulse * 20;
                    l.y = l.baseY + (Math.random() - 0.5) * this.beatImpulse * 20;
                }

                // Global Intensity Mod
                lum = Math.max(0, Math.min(100, lum * this.intensity));
                
                // Assign to light object
                l.hue = h;
                l.sat = s;
                l.lum = lum;
                l.alpha = a;
                l.size = size + (lum/100) * 5;
            });
        }

        draw() {
            // Fade out trail
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.fillStyle = 'rgba(5, 5, 8, 0.2)'; // Trail effect
            this.ctx.fillRect(0, 0, this.width, this.height);

            this.ctx.globalCompositeOperation = 'lighter'; // Additive blending for neon look

            // Draw Lights
            this.lights.forEach(l => {
                if (l.lum < 5) return; // Optimization

                const glow = l.size * 2;
                
                // Radial gradient for glow
                const grad = this.ctx.createRadialGradient(l.x, l.y, 0, l.x, l.y, glow);
                const color = `hsla(${l.hue}, ${l.sat}%, ${l.lum}%, ${l.alpha})`;
                const coreColor = `hsla(${l.hue}, ${l.sat}%, 90%, ${l.alpha})`;

                grad.addColorStop(0, coreColor);
                grad.addColorStop(0.4, color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');

                this.ctx.fillStyle = grad;
                this.ctx.beginPath();
                this.ctx.arc(l.x, l.y, glow, 0, Math.PI * 2);
                this.ctx.fill();
            });

            // Draw Particles
            this.particles.forEach(p => {
                this.ctx.fillStyle = `hsla(${p.hue}, 100%, 70%, ${p.life})`;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
            });
        }
    }

    /**
     * UI COMPONENTS
     */
    
    // Icon Wrapper
    const Icon = ({ name, size = 20, className }) => {
        useEffect(() => {
            if (window.lucide) {
                window.lucide.createIcons();
            }
        }, [name]);
        return <i data-lucide={name} className={className} style={{ width: size, height: size, display: 'inline-block' }}></i>;
    };

    const ControlPanel = ({ 
        isPlaying, onTogglePlay, 
        pattern, setPattern, 
        color, setColor, 
        speed, setSpeed, 
        intensity, setIntensity 
    }) => {
        const patterns = ['matrix', 'radial', 'wave', 'sparkle', 'converge'];

        return (
            <div className="fixed bottom-8 left-1/2 transform -translate-x-1/2 glass-panel rounded-2xl p-6 w-[90%] max-w-2xl text-white transition-all duration-300">
                <div className="flex flex-col md:flex-row gap-8 items-center justify-between">
                    
                    {/* Play/Pause Main Button */}
                    <div className="flex flex-col items-center gap-2">
                        <button 
                            onClick={onTogglePlay}
                            className={`w-16 h-16 rounded-full flex items-center justify-center transition-all duration-300 shadow-[0_0_20px_rgba(255,255,255,0.2)] hover:scale-105 active:scale-95 ${
                                isPlaying ? 'bg-red-500 hover:bg-red-600 shadow-red-500/50' : 'bg-green-500 hover:bg-green-600 shadow-green-500/50'
                            }`}
                        >
                            <Icon name={isPlaying ? "pause" : "play"} size={32} />
                        </button>
                        <span className="text-xs font-medium uppercase tracking-widest opacity-60">
                            {isPlaying ? 'Live' : 'Start Show'}
                        </span>
                    </div>

                    <div className="flex-1 w-full grid grid-cols-1 md:grid-cols-2 gap-6">
                        
                        {/* Pattern Select */}
                        <div className="space-y-2">
                            <label className="text-xs uppercase tracking-wider text-gray-400 font-bold flex items-center gap-2">
                                <Icon name="grid" size={14} /> Pattern
                            </label>
                            <div className="flex flex-wrap gap-2">
                                {patterns.map(p => (
                                    <button
                                        key={p}
                                        onClick={() => setPattern(p)}
                                        className={`px-3 py-1.5 rounded-md text-xs font-semibold uppercase transition-all ${
                                            pattern === p 
                                            ? 'bg-white text-black shadow-[0_0_15px_rgba(255,255,255,0.4)]' 
                                            : 'bg-white/10 hover:bg-white/20 text-gray-300'
                                        }`}
                                    >
                                        {p}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {/* Controls Group */}
                        <div className="space-y-4">
                            {/* Color */}
                            <div className="space-y-1">
                                <label className="text-xs uppercase tracking-wider text-gray-400 font-bold flex items-center justify-between">
                                    <span className="flex items-center gap-2"><Icon name="palette" size={14} /> Hue</span>
                                    <span>{color}Â°</span>
                                </label>
                                <input 
                                    type="range" min="0" max="360" value={color} 
                                    onChange={(e) => setColor(Number(e.target.value))}
                                    className="w-full h-1 bg-gradient-to-r from-red-500 via-green-500 to-blue-500 rounded-lg appearance-none cursor-pointer"
                                />
                            </div>

                            {/* Speed */}
                            <div className="space-y-1">
                                <label className="text-xs uppercase tracking-wider text-gray-400 font-bold flex items-center justify-between">
                                    <span className="flex items-center gap-2"><Icon name="zap" size={14} /> Speed</span>
                                    <span>{speed.toFixed(1)}x</span>
                                </label>
                                <input 
                                    type="range" min="0.1" max="3.0" step="0.1" value={speed} 
                                    onChange={(e) => setSpeed(Number(e.target.value))}
                                    className="w-full accent-purple-500"
                                />
                            </div>
                            
                            {/* Intensity */}
                            <div className="space-y-1">
                                <label className="text-xs uppercase tracking-wider text-gray-400 font-bold flex items-center justify-between">
                                    <span className="flex items-center gap-2"><Icon name="sun" size={14} /> Brightness</span>
                                    <span>{(intensity * 100).toFixed(0)}%</span>
                                </label>
                                <input 
                                    type="range" min="0" max="2.0" step="0.1" value={intensity} 
                                    onChange={(e) => setIntensity(Number(e.target.value))}
                                    className="w-full accent-blue-400"
                                />
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        );
    };

    const Header = () => (
        <div className="fixed top-0 left-0 w-full p-6 flex justify-between items-start pointer-events-none z-10">
            <div>
                <h1 className="text-4xl font-black italic uppercase tracking-tighter neon-text">
                    Lumina<span className="text-purple-400">Fest</span>
                </h1>
                <p className="text-sm text-gray-400 font-mono mt-1 tracking-widest">VIRTUAL LIGHT SHOW CONTROLLER</p>
            </div>
            <div className="glass-panel px-4 py-2 rounded-full text-xs font-mono text-gray-300 flex items-center gap-2">
                <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                SYSTEM ONLINE
            </div>
        </div>
    );

    const App = () => {
        const canvasRef = useRef(null);
        const rendererRef = useRef(null);
        const audioRef = useRef(new AudioEngine());
        
        // State
        const [isPlaying, setIsPlaying] = useState(false);
        const [pattern, setPattern] = useState('matrix');
        const [color, setColor] = useState(280); // Purple base
        const [speed, setSpeed] = useState(1.0);
        const [intensity, setIntensity] = useState(1.0);

        // Sync React State to Renderer
        useEffect(() => {
            if (rendererRef.current) {
                rendererRef.current.pattern = pattern;
                rendererRef.current.baseColor.h = color;
                rendererRef.current.speed = speed;
                rendererRef.current.intensity = intensity;
            }
        }, [pattern, color, speed, intensity]);

        useEffect(() => {
            // Setup Renderer
            const canvas = canvasRef.current;
            rendererRef.current = new LightShow(canvas);
            
            // Initial Sync
            rendererRef.current.pattern = pattern;
            rendererRef.current.baseColor.h = color;
            rendererRef.current.speed = speed;
            rendererRef.current.intensity = intensity;

            // Setup Audio Callback
            audioRef.current.onBeat = (type) => {
                if (rendererRef.current) {
                    rendererRef.current.triggerBeat(type);
                }
            };

            const animate = () => {
                const renderer = rendererRef.current;
                const audio = audioRef.current;
                
                if (renderer) {
                    const audioLevel = audio.getAudioData();
                    renderer.update(0.016, audioLevel);
                    renderer.draw();
                }
                requestAnimationFrame(animate);
            };

            const animId = requestAnimationFrame(animate);

            // Handle Resize
            const handleResize = () => {
                if (rendererRef.current) rendererRef.current.resize();
            };
            window.addEventListener('resize', handleResize);

            return () => {
                cancelAnimationFrame(animId);
                window.removeEventListener('resize', handleResize);
                audioRef.current.stop();
            };
        }, []); 

        const togglePlay = () => {
            const playing = audioRef.current.toggle();
            setIsPlaying(playing);
        };

        return (
            <div className="relative w-full h-screen bg-black">
                <canvas ref={canvasRef} className="absolute inset-0" />
                <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-black/20 pointer-events-none"></div>
                
                <Header />
                <ControlPanel 
                    isPlaying={isPlaying} 
                    onTogglePlay={togglePlay}
                    pattern={pattern} setPattern={setPattern}
                    color={color} setColor={setColor}
                    speed={speed} setSpeed={setSpeed}
                    intensity={intensity} setIntensity={setIntensity}
                />
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

</script>
</body>
</html>