<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Holiday Card for Kids!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            touch-action: none; /* Prevent scrolling on mobile */
            user-select: none;
            -webkit-user-select: none;
        }
        h1 {
            font-family: 'Fredoka One', cursive;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2);
        }
        .emoji-item {
            cursor: grab;
            transition: transform 0.1s;
            filter: drop-shadow(0 4px 3px rgba(0,0,0,0.2));
            user-select: none;
        }
        .emoji-item:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        .bounce {
            animation: bounce-anim 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes bounce-anim {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); }
        }
        .pop {
            animation: pop-anim 0.3s ease-in-out;
        }
        @keyframes pop-anim {
            0% { transform: scale(1); }
            50% { transform: scale(1.4) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        .wiggle {
            animation: wiggle-anim 1s ease-in-out infinite;
        }
        @keyframes wiggle-anim {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }
        #palette {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
        }
        .palette-item {
            transition: transform 0.2s;
        }
        .palette-item:hover {
            transform: scale(1.2) rotate(5deg);
        }
        /* Snowy Hill Gradient */
        .snow-ground {
            background: linear-gradient(180deg, #e6f3ff 0%, #ffffff 100%);
            border-radius: 100% 100% 0 0 / 20% 20% 0 0;
        }
    </style>
</head>
<body class="bg-gradient-to-b from-blue-900 via-blue-600 to-blue-300 h-screen w-screen relative overflow-hidden">

    <!-- Snow Canvas -->
    <canvas id="snow-canvas" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10"></canvas>

    <!-- Main Content -->
    <div id="app" class="relative w-full h-full flex flex-col justify-between z-0">
        
        <!-- Header -->
        <header class="text-center pt-6 z-20 pointer-events-none">
            <h1 class="text-4xl md:text-6xl text-white tracking-wide animate-pulse">
                ðŸŽ„ Happy Holidays! ðŸŽ„
            </h1>
            <p class="text-white text-lg mt-2 opacity-90 font-bold">Drag stickers to make your card!</p>
        </header>

        <!-- The Scene (Drop Zone) -->
        <div id="scene" class="absolute inset-0 z-0">
            <!-- Ground -->
            <div class="absolute bottom-0 left-[-20%] w-[140%] h-[30%] snow-ground z-0"></div>
            <!-- Moon -->
            <div class="absolute top-10 right-10 text-6xl opacity-80 animate-bounce" style="animation-duration: 3s;">ðŸŒ•</div>
        </div>

        <!-- Palette / Toolbar -->
        <div id="palette" class="z-30 h-24 md:h-32 w-full flex items-center justify-center gap-2 md:gap-6 overflow-x-auto px-4 py-2 relative">
            <button id="reset-btn" class="absolute left-4 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-full shadow-lg transform active:scale-95 transition text-sm md:text-base">
                Reset
            </button>
            
            <!-- Draggables in Palette -->
            <div class="flex gap-4 px-12 overflow-x-auto w-full justify-center" id="sticker-container">
                <!-- Stickers injected by JS -->
            </div>
        </div>
    </div>

    <script>
        /**
         * Sound Manager using Web Audio API
         * Synthesizes cute sounds so no external assets are needed.
         */
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const Sound = {
            playTone: (freq, type, duration) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            pop: () => {
                Sound.playTone(400 + Math.random() * 200, 'sine', 0.1);
                setTimeout(() => Sound.playTone(600 + Math.random() * 200, 'triangle', 0.1), 50);
            },
            jingle: () => {
                const now = audioCtx.currentTime;
                [880, 1100, 1320, 1760].forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.5);
                    }, i * 80);
                });
            },
            magic: () => {
                const now = audioCtx.currentTime;
                for(let i=0; i<10; i++) {
                    setTimeout(() => {
                         Sound.playTone(1000 + i * 200, 'sine', 0.2);
                    }, i * 30);
                }
            }
        };

        /**
         * App Logic
         */
        const stickers = [
            'ðŸŽ…', 'ðŸ¤¶', 'ðŸ¦Œ', 'â›„', 'ðŸŽ„', 'ðŸŽ', 'â„ï¸', 'â­', 'ðŸª', 'ðŸ¥›', 'ðŸ§£', 'ðŸ ', 'ðŸ›·', 'ðŸ§', 'ðŸ»â€â„ï¸'
        ];

        const scene = document.getElementById('scene');
        const stickerContainer = document.getElementById('sticker-container');

        // Initial setup
        function init() {
            // Populate Palette
            stickers.forEach(emoji => {
                const el = document.createElement('div');
                el.className = 'palette-item text-4xl md:text-5xl cursor-grab select-none p-2';
                el.textContent = emoji;
                el.draggable = true; // Use native for desktop, custom for touch
                
                // Desktop Drag Start
                el.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', emoji);
                    e.dataTransfer.effectAllowed = 'copy';
                    Sound.pop();
                });

                // Touch support wrapper logic handles duplication elsewhere
                el.addEventListener('touchstart', handlePaletteTouchStart, {passive: false});

                stickerContainer.appendChild(el);
            });

            // Add default items
            addStickerToScene('ðŸŽ„', 20, 50, 2);
            addStickerToScene('â›„', 70, 60, 1.5);
            addStickerToScene('ðŸŽ…', 45, 55, 1.2);
            
            // Jingle on load
            setTimeout(Sound.jingle, 500);
        }

        // --- Drag & Drop Logic (Mouse/Desktop) ---
        scene.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            e.dataTransfer.dropEffect = 'copy';
        });

        scene.addEventListener('drop', (e) => {
            e.preventDefault();
            const emoji = e.dataTransfer.getData('text/plain');
            if (emoji) {
                // Calculate position relative to scene
                const rect = scene.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width * 100;
                const y = (e.clientY - rect.top) / rect.height * 100;
                addStickerToScene(emoji, x, y);
                Sound.magic();
            }
        });

        // --- Touch Drag Logic for Palette Items ---
        let activeDragEl = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function handlePaletteTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const emoji = e.target.textContent;
            
            // Create a temporary flying element
            activeDragEl = document.createElement('div');
            activeDragEl.textContent = emoji;
            activeDragEl.className = 'fixed text-6xl pointer-events-none z-50';
            activeDragEl.style.left = touch.clientX + 'px';
            activeDragEl.style.top = touch.clientY + 'px';
            activeDragEl.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(activeDragEl);
            
            Sound.pop();

            document.addEventListener('touchmove', handleTouchMove, {passive: false});
            document.addEventListener('touchend', handleTouchEnd);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!activeDragEl) return;
            const touch = e.touches[0];
            activeDragEl.style.left = touch.clientX + 'px';
            activeDragEl.style.top = touch.clientY + 'px';
        }

        function handleTouchEnd(e) {
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
            
            if (activeDragEl) {
                const touch = e.changedTouches[0];
                const sceneRect = scene.getBoundingClientRect();
                
                // Check if dropped within scene bounds (rough check)
                if (touch.clientY < sceneRect.bottom - 50) { // -50 to avoid dropping back in palette
                    const x = (touch.clientX - sceneRect.left) / sceneRect.width * 100;
                    const y = (touch.clientY - sceneRect.top) / sceneRect.height * 100;
                    addStickerToScene(activeDragEl.textContent, x, y);
                    Sound.magic();
                }
                
                activeDragEl.remove();
                activeDragEl = null;
            }
        }


        // --- Scene Item Logic ---
        function addStickerToScene(emoji, xPercent, yPercent, scale = 1) {
            const el = document.createElement('div');
            el.textContent = emoji;
            el.className = 'absolute emoji-item text-6xl bounce select-none';
            el.style.left = xPercent + '%';
            el.style.top = yPercent + '%';
            el.style.transform = `translate(-50%, -50%) scale(${scale})`;
            
            // Interaction
            el.addEventListener('mousedown', startSceneDrag);
            el.addEventListener('touchstart', startSceneDrag, {passive: false});
            el.addEventListener('click', () => {
                Sound.pop();
                el.classList.remove('pop');
                void el.offsetWidth; // trigger reflow
                el.classList.add('pop');
            });

            scene.appendChild(el);
        }

        // Dragging items ALREADY in the scene
        let currentSceneItem = null;
        
        function startSceneDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            currentSceneItem = e.target;
            
            // Get initial touch/click pos
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // We want to move the element by updating left/top % or px
            // Switch to absolute pixel positioning during drag for smoothness, convert back later or just keep %
            // Let's use simple px movement for now
            const rect = currentSceneItem.getBoundingClientRect();
            dragOffsetX = clientX - rect.left - (rect.width / 2); // Center offset
            dragOffsetY = clientY - rect.top - (rect.height / 2);

            currentSceneItem.style.cursor = 'grabbing';
            currentSceneItem.style.zIndex = 100; // Bring to front
            Sound.pop();

            if (e.type === 'touchstart') {
                document.addEventListener('touchmove', moveSceneItem, {passive: false});
                document.addEventListener('touchend', endSceneDrag);
            } else {
                window.addEventListener('mousemove', moveSceneItem);
                window.addEventListener('mouseup', endSceneDrag);
            }
        }

        function moveSceneItem(e) {
            e.preventDefault();
            if (!currentSceneItem) return;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const sceneRect = scene.getBoundingClientRect();
            
            // Calculate new position relative to scene
            let newX = clientX - sceneRect.left;
            let newY = clientY - sceneRect.top;

            // Convert to percentage
            let newXPer = (newX / sceneRect.width) * 100;
            let newYPer = (newY / sceneRect.height) * 100;

            currentSceneItem.style.left = newXPer + '%';
            currentSceneItem.style.top = newYPer + '%';
        }

        function endSceneDrag(e) {
            if (currentSceneItem) {
                currentSceneItem.style.cursor = 'grab';
                currentSceneItem.style.zIndex = '';
                // Check if dragged out of bounds (trash)
                const rect = currentSceneItem.getBoundingClientRect();
                if (rect.top > window.innerHeight - 100) {
                     // Delete item effect
                     Sound.playTone(150, 'sawtooth', 0.2);
                     currentSceneItem.style.transition = 'transform 0.2s, opacity 0.2s';
                     currentSceneItem.style.transform = 'scale(0)';
                     currentSceneItem.style.opacity = '0';
                     setTimeout(() => currentSceneItem.remove(), 200);
                }
            }
            currentSceneItem = null;
            document.removeEventListener('touchmove', moveSceneItem);
            document.removeEventListener('touchend', endSceneDrag);
            window.removeEventListener('mousemove', moveSceneItem);
            window.removeEventListener('mouseup', endSceneDrag);
        }

        // Reset
        document.getElementById('reset-btn').addEventListener('click', () => {
            scene.innerHTML = `
                <div class="absolute bottom-0 left-[-20%] w-[140%] h-[30%] snow-ground z-0"></div>
                <div class="absolute top-10 right-10 text-6xl opacity-80 animate-bounce" style="animation-duration: 3s;">ðŸŒ•</div>
            `;
            // Re-add defaults
            addStickerToScene('ðŸŽ„', 20, 50, 2);
            addStickerToScene('â›„', 70, 60, 1.5);
            addStickerToScene('ðŸŽ…', 45, 55, 1.2);
            Sound.jingle();
        });


        // --- Snow Effect ---
        const canvas = document.getElementById('snow-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        const snowflakes = [];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Snowflake {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * -height;
                this.size = Math.random() * 3 + 1;
                this.speed = Math.random() * 1 + 0.5;
                this.sway = Math.random() * 0.02 - 0.01;
                this.opacity = Math.random() * 0.5 + 0.3;
            }
            update() {
                this.y += this.speed;
                this.x += Math.sin(this.y * 0.01) * 0.5;
                if (this.y > height) this.reset();
            }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        for (let i = 0; i < 100; i++) {
            snowflakes.push(new Snowflake());
        }

        function animateSnow() {
            ctx.clearRect(0, 0, width, height);
            snowflakes.forEach(flake => {
                flake.update();
                flake.draw();
            });
            requestAnimationFrame(animateSnow);
        }
        animateSnow();

        // Start
        init();

    </script>
</body>
</html>
