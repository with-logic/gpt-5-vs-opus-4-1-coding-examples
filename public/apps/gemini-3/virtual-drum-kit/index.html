<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Virtual Drum Kit Studio</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --bg-dark: #1a1a1d;
            --panel-bg: #2d2d30;
            --highlight: #00ffcc;
            --pad-base: #3e3e42;
            --pad-active: #ff0055;
            --led-off: #331111;
            --led-on: #ff3333;
        }

        body {
            background-color: var(--bg-dark);
            color: #eee;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden; /* Prevent scroll bounce on mobile */
            touch-action: manipulation;
        }

        .studio-panel {
            background: linear-gradient(145deg, #2a2a2d, #1f1f22);
            box-shadow: 
                inset 1px 1px 2px rgba(255,255,255,0.1),
                inset -1px -1px 2px rgba(0,0,0,0.5),
                5px 5px 15px rgba(0,0,0,0.5);
            border-radius: 12px;
            border: 1px solid #444;
        }

        .drum-pad {
            transition: all 0.05s ease-out;
            background: linear-gradient(145deg, #3a3a3d, #2f2f32);
            box-shadow: 
                5px 5px 10px #1a1a1d, 
                -5px -5px 10px #3e3e42;
            position: relative;
            overflow: hidden;
        }

        .drum-pad:active, .drum-pad.active {
            transform: scale(0.96);
            box-shadow: inset 3px 3px 7px #1a1a1d, inset -3px -3px 7px #3e3e42;
        }
        
        /* Neon Glows based on type */
        .drum-pad.active.kick { border: 2px solid #ff0055; box-shadow: 0 0 15px #ff0055, inset 0 0 10px #ff0055; }
        .drum-pad.active.snare { border: 2px solid #00ffcc; box-shadow: 0 0 15px #00ffcc, inset 0 0 10px #00ffcc; }
        .drum-pad.active.hat { border: 2px solid #ffcc00; box-shadow: 0 0 15px #ffcc00, inset 0 0 10px #ffcc00; }
        .drum-pad.active.tom { border: 2px solid #cc00ff; box-shadow: 0 0 15px #cc00ff, inset 0 0 10px #cc00ff; }
        .drum-pad.active.cymbal { border: 2px solid #00ccff; box-shadow: 0 0 15px #00ccff, inset 0 0 10px #00ccff; }

        .led {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--led-off);
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.5);
            transition: background-color 0.1s;
        }
        .led.on {
            background-color: var(--led-on);
            box-shadow: 0 0 8px var(--led-on);
        }

        .lcd-screen {
            background-color: #4a5a3a;
            color: #1a1a1d;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.6);
            border: 2px solid #222;
        }

        /* Subtle texture for realism */
        .texture-overlay {
            background-image: url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 3h1v1H1V3zm2-2h1v1H3V1z' fill='%23000000' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E");
            pointer-events: none;
        }

        /* Scanline effect for LCD */
        .scanlines {
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
        }

        /* Key hint styling */
        .key-hint {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.3);
            pointer-events: none;
        }
    </style>
</head>
<body class="h-screen w-screen flex items-center justify-center texture-overlay">

    <div id="root"></div>

    <script type="text/babel">
        // --- Audio Engine (Web Audio API) ---
        class DrumSynth {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
            }

            init() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.8;
                    this.masterGain.connect(this.ctx.destination);
                    
                    // Unlock audio context for iOS/Chrome autoplay policy
                    if (this.ctx.state === 'suspended') {
                        this.ctx.resume();
                    }
                }
            }

            // 808-style Kick
            playKick() {
                this.init();
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                
                gain.gain.setValueAtTime(1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                osc.stop(t + 0.5);
            }

            // Snare: Noise burst + Triangle wave tone
            playSnare() {
                this.init();
                const t = this.ctx.currentTime;
                
                // Tone
                const osc = this.ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(250, t);
                const oscGain = this.ctx.createGain();
                oscGain.gain.setValueAtTime(0.5, t);
                oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                osc.connect(oscGain);
                oscGain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.2);

                // Noise
                const noiseBufferSize = this.ctx.sampleRate * 0.2; // 0.2 seconds
                const buffer = this.ctx.createBuffer(1, noiseBufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < noiseBufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;
                
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.8, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                noise.start(t);
            }

            // Hi-Hat: High pass metallic noise
            playHat(open = false) {
                this.init();
                const t = this.ctx.currentTime;
                const decay = open ? 0.4 : 0.05;

                // Create buffer with random noise but emphasizing high frequencies
                const bufferSize = this.ctx.sampleRate * decay;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                     // Slightly more metallic random
                     data[i] = (Math.random() * 2 - 1); 
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 8000;

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.6, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + decay);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start(t);
            }

            // Tom: Pitch bending sine
            playTom(pitch = 100) {
                this.init();
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.frequency.setValueAtTime(pitch, t);
                osc.frequency.exponentialRampToValueAtTime(pitch * 0.2, t + 0.4);

                gain.gain.setValueAtTime(0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.4);
            }

            // Clap: Multiple bursts of noise
            playClap() {
                this.init();
                const t = this.ctx.currentTime;
                
                const createBurst = (startTime) => {
                    const bufferSize = this.ctx.sampleRate * 0.1;
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                    const noise = this.ctx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 1500;
                    filter.Q.value = 1;

                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.7, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.1);

                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    noise.start(startTime);
                }

                createBurst(t);
                createBurst(t + 0.011);
                createBurst(t + 0.024);
            }
            
            // Crash: Long decaying noise
            playCrash() {
                this.init();
                const t = this.ctx.currentTime;
                const decay = 1.5;
                
                const bufferSize = this.ctx.sampleRate * decay;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 3000;
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + decay);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start(t);
            }
        }

        const audio = new DrumSynth();

        // --- React Components ---

        const PAD_CONFIG = [
            { id: 'kick', label: 'KICK', key: 'q', type: 'kick', color: 'text-rose-500' },
            { id: 'snare', label: 'SNARE', key: 'w', type: 'snare', color: 'text-teal-400' },
            { id: 'clap', label: 'CLAP', key: 'e', type: 'snare', color: 'text-purple-400' },
            { id: 'hat_closed', label: 'HAT (C)', key: 'a', type: 'hat', color: 'text-yellow-400' },
            { id: 'hat_open', label: 'HAT (O)', key: 's', type: 'hat', color: 'text-yellow-200' },
            { id: 'crash', label: 'CRASH', key: 'd', type: 'cymbal', color: 'text-cyan-400' },
            { id: 'tom_hi', label: 'TOM HI', key: 'z', type: 'tom', color: 'text-indigo-400' },
            { id: 'tom_mid', label: 'TOM MID', key: 'x', type: 'tom', color: 'text-indigo-500' },
            { id: 'tom_low', label: 'TOM LO', key: 'c', type: 'tom', color: 'text-indigo-600' },
        ];

        function App() {
            const [activePads, setActivePads] = React.useState({});
            const [isRecording, setIsRecording] = React.useState(false);
            const [isPlaying, setIsPlaying] = React.useState(false);
            const [track, setTrack] = React.useState([]); // Array of { time, id }
            const [startTime, setStartTime] = React.useState(null);
            const [displayText, setDisplayText] = React.useState("READY");

            // Play sound function
            const playSound = (id) => {
                // Visual feedback
                setActivePads(prev => ({ ...prev, [id]: true }));
                setTimeout(() => {
                    setActivePads(prev => ({ ...prev, [id]: false }));
                }, 100);

                // Audio Trigger
                switch(id) {
                    case 'kick': audio.playKick(); break;
                    case 'snare': audio.playSnare(); break;
                    case 'clap': audio.playClap(); break;
                    case 'hat_closed': audio.playHat(false); break;
                    case 'hat_open': audio.playHat(true); break;
                    case 'crash': audio.playCrash(); break;
                    case 'tom_hi': audio.playTom(300); break;
                    case 'tom_mid': audio.playTom(200); break;
                    case 'tom_low': audio.playTom(100); break;
                }

                // Recording logic
                if (isRecording) {
                    const time = Date.now() - startTime;
                    setTrack(prev => [...prev, { time, id }]);
                }
            };

            // Keyboard listeners
            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    const pad = PAD_CONFIG.find(p => p.key === e.key.toLowerCase());
                    if (pad) {
                        playSound(pad.id);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [isRecording, startTime]);

            // Recording Controls
            const toggleRecord = () => {
                if (isRecording) {
                    setIsRecording(false);
                    setDisplayText(`TRACK: ${track.length} NOTES`);
                } else {
                    setTrack([]); // Clear previous track on new record
                    setStartTime(Date.now());
                    setIsRecording(true);
                    setIsPlaying(false);
                    setDisplayText("RECORDING...");
                }
            };

            const togglePlay = () => {
                if (track.length === 0) {
                    setDisplayText("NO TRACK DATA");
                    return;
                }
                
                if (isPlaying) {
                    setIsPlaying(false); // Stop (implementation detail: logic below handles play)
                    setDisplayText("STOPPED");
                    return; // Simple stop, doesn't actually cancel timeouts in this simple version, but prevents loop
                }

                setIsPlaying(true);
                setDisplayText("PLAYING...");
                
                // Schedule playback
                track.forEach(note => {
                    setTimeout(() => {
                        // Only play if we haven't stopped (simple check)
                        playSound(note.id);
                    }, note.time);
                });

                // Reset 'Playing' state after track finishes
                const lastNoteTime = track[track.length - 1].time;
                setTimeout(() => {
                    setIsPlaying(false);
                    setDisplayText("FINISHED");
                }, lastNoteTime + 500);
            };

            return (
                <div className="studio-panel p-6 w-full max-w-lg mx-auto flex flex-col gap-6 select-none">
                    
                    {/* Header / Display Section */}
                    <div className="flex justify-between items-end mb-2 border-b border-gray-700 pb-4">
                        <div>
                            <h1 className="text-2xl font-bold text-gray-200 tracking-wider" style={{fontFamily: 'Orbitron'}}>
                                BEAT<span className="text-red-500">LAB</span> V1
                            </h1>
                            <div className="text-xs text-gray-500 font-mono">VIRTUAL SYNTHESIS ENGINE</div>
                        </div>
                        
                        {/* Status LEDs */}
                        <div className="flex gap-4 items-center">
                            <div className="flex flex-col items-center gap-1">
                                <div className={`led ${isRecording ? 'on' : ''}`}></div>
                                <span className="text-[10px] text-gray-400">REC</span>
                            </div>
                            <div className="flex flex-col items-center gap-1">
                                <div className={`led ${isPlaying ? 'bg-green-500 shadow-[0_0_8px_#00ff00]' : ''}`} style={isPlaying ? {backgroundColor: '#00ff00'} : {}}></div>
                                <span className="text-[10px] text-gray-400">PLAY</span>
                            </div>
                        </div>
                    </div>

                    {/* LCD Screen */}
                    <div className="lcd-screen rounded p-3 h-16 flex items-center justify-between relative overflow-hidden">
                        <div className="scanlines absolute inset-0 z-10 opacity-20 pointer-events-none"></div>
                        <span className="text-lg z-0">{displayText}</span>
                        <div className="text-xs text-right opacity-70 z-0">
                            BPM: N/A<br/>
                            MEM: {track.length}
                        </div>
                    </div>

                    {/* Drum Pads Grid */}
                    <div className="grid grid-cols-3 gap-3 md:gap-4">
                        {PAD_CONFIG.map((pad) => (
                            <button
                                key={pad.id}
                                className={`drum-pad ${activePads[pad.id] ? 'active' : ''} ${pad.type} 
                                            h-24 md:h-28 rounded-lg flex flex-col items-center justify-center cursor-pointer outline-none touch-manipulation`}
                                onMouseDown={() => playSound(pad.id)}
                                onTouchStart={(e) => { e.preventDefault(); playSound(pad.id); }} // Prevent zoom/scroll
                            >
                                <span className={`font-bold text-sm md:text-base ${pad.color} tracking-widest`}>{pad.label}</span>
                                <div className="key-hint border border-white/20 rounded px-1 min-w-[1.2rem] text-center bg-black/40">
                                    {pad.key.toUpperCase()}
                                </div>
                            </button>
                        ))}
                    </div>

                    {/* Controls */}
                    <div className="grid grid-cols-3 gap-4 mt-2">
                        <button 
                            onClick={toggleRecord}
                            className={`py-3 rounded font-bold text-sm tracking-widest transition-colors shadow-lg
                                ${isRecording 
                                    ? 'bg-red-600 text-white shadow-red-900/50' 
                                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                        >
                            <i className="fa-solid fa-circle text-xs mr-2"></i>
                            {isRecording ? 'STOP' : 'REC'}
                        </button>

                        <button 
                            onClick={togglePlay}
                            disabled={isRecording || track.length === 0}
                            className={`py-3 rounded font-bold text-sm tracking-widest transition-colors shadow-lg
                                ${isPlaying 
                                    ? 'bg-green-600 text-white shadow-green-900/50' 
                                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed'}`}
                        >
                            <i className="fa-solid fa-play text-xs mr-2"></i>
                            PLAY
                        </button>

                         <button 
                            onClick={() => { setTrack([]); setDisplayText("CLEARED"); }}
                            disabled={isRecording || isPlaying}
                            className="py-3 rounded font-bold text-sm tracking-widest bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors shadow-lg disabled:opacity-50"
                        >
                            <i className="fa-solid fa-trash text-xs mr-2"></i>
                            CLR
                        </button>
                    </div>

                    {/* Footer Info */}
                    <div className="text-center text-[10px] text-gray-600 font-mono mt-2">
                        KEYBOARD ENABLED â€¢ TAP TO START AUDIO
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
