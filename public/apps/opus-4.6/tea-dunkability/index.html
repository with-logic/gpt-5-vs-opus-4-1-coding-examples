<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tea Dunkability Simulator</title>
<script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0f1117;
    --bg2: #1a1d2e;
    --bg3: #252840;
    --text: #e8e8f0;
    --text2: #9a9ab8;
    --accent: #c8956c;
    --accent2: #e8b88a;
    --glass: rgba(255,255,255,0.06);
    --glass-border: rgba(255,255,255,0.1);
    --glass-hover: rgba(255,255,255,0.1);
    --danger: #e85d5d;
    --success: #5de88a;
    --warning: #e8c85d;
    --tea-color: #c8824a;
    --tea-light: #e0a76a;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
    line-height: 1.5;
  }

  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background:
      radial-gradient(ellipse at 20% 20%, rgba(200,149,108,0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, rgba(100,120,200,0.06) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 50%, rgba(200,149,108,0.03) 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
  }

  #root { position: relative; z-index: 1; }

  .glass {
    background: var(--glass);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    transition: all 0.3s ease;
  }
  .glass:hover {
    background: var(--glass-hover);
    border-color: rgba(255,255,255,0.15);
  }

  .app-container {
    max-width: 1280px;
    margin: 0 auto;
    padding: 24px;
  }

  .header {
    text-align: center;
    padding: 32px 0 24px;
  }
  .header h1 {
    font-size: 2.2rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent2), var(--accent), #a07050);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -0.02em;
  }
  .header p {
    color: var(--text2);
    font-size: 0.95rem;
    margin-top: 6px;
  }

  .main-grid {
    display: grid;
    grid-template-columns: 340px 1fr;
    gap: 24px;
    align-items: start;
  }

  @media (max-width: 900px) {
    .main-grid {
      grid-template-columns: 1fr;
    }
  }

  .controls-panel {
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .control-group label {
    display: block;
    font-size: 0.82rem;
    font-weight: 600;
    color: var(--text2);
    text-transform: uppercase;
    letter-spacing: 0.06em;
    margin-bottom: 8px;
  }

  .control-group .value-display {
    float: right;
    color: var(--accent2);
    font-weight: 500;
    text-transform: none;
    letter-spacing: 0;
    font-size: 0.85rem;
  }

  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: var(--bg3);
    outline: none;
    cursor: pointer;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--accent2), var(--accent));
    border: 2px solid rgba(255,255,255,0.2);
    box-shadow: 0 2px 8px rgba(200,149,108,0.4);
    transition: transform 0.2s;
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.15);
  }
  input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--accent2), var(--accent));
    border: 2px solid rgba(255,255,255,0.2);
    box-shadow: 0 2px 8px rgba(200,149,108,0.4);
    cursor: pointer;
  }

  .biscuit-selector {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }
  .biscuit-btn {
    padding: 10px 8px;
    border-radius: 10px;
    border: 1px solid var(--glass-border);
    background: var(--glass);
    color: var(--text);
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 500;
    transition: all 0.2s;
    text-align: center;
  }
  .biscuit-btn:hover {
    background: var(--glass-hover);
    border-color: rgba(255,255,255,0.2);
  }
  .biscuit-btn.active {
    background: rgba(200,149,108,0.2);
    border-color: var(--accent);
    color: var(--accent2);
    box-shadow: 0 0 12px rgba(200,149,108,0.15);
  }
  .biscuit-btn .emoji {
    font-size: 1.3rem;
    display: block;
    margin-bottom: 2px;
  }

  .dunk-button {
    width: 100%;
    padding: 14px;
    border: none;
    border-radius: 12px;
    background: linear-gradient(135deg, var(--accent), #a07050);
    color: white;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    letter-spacing: 0.02em;
    position: relative;
    overflow: hidden;
  }
  .dunk-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 20px rgba(200,149,108,0.35);
  }
  .dunk-button:active {
    transform: translateY(1px);
  }
  .dunk-button.dunking {
    background: linear-gradient(135deg, #a07050, #806040);
  }
  .dunk-button::after {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
    transition: left 0.5s;
  }
  .dunk-button:hover::after {
    left: 100%;
  }

  .right-col {
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  .sim-area {
    padding: 32px;
    min-height: 380px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  .teacup-scene {
    position: relative;
    width: 280px;
    height: 300px;
  }

  /* Teacup SVG styles */
  .teacup-svg {
    width: 100%;
    height: 100%;
  }

  .bottom-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
  }

  @media (max-width: 700px) {
    .bottom-row {
      grid-template-columns: 1fr;
    }
  }

  .crumble-panel {
    padding: 24px;
  }
  .crumble-panel h3 {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text2);
    margin-bottom: 16px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .graph-container {
    height: 160px;
    position: relative;
  }

  .status-panel {
    padding: 24px;
  }
  .status-panel h3 {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text2);
    margin-bottom: 16px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .status-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
  }
  .status-item:last-child { border: none; }
  .status-label {
    font-size: 0.85rem;
    color: var(--text2);
  }
  .status-value {
    font-size: 0.9rem;
    font-weight: 600;
  }
  .status-value.good { color: var(--success); }
  .status-value.warn { color: var(--warning); }
  .status-value.bad { color: var(--danger); }

  .integrity-bar {
    width: 100%;
    height: 8px;
    background: var(--bg3);
    border-radius: 4px;
    overflow: hidden;
    margin-top: 6px;
  }
  .integrity-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.5s ease, background 0.5s ease;
  }

  .shortcuts-bar {
    text-align: center;
    padding: 12px;
    font-size: 0.75rem;
    color: var(--text2);
  }
  .shortcuts-bar kbd {
    display: inline-block;
    padding: 2px 7px;
    border-radius: 4px;
    background: var(--bg3);
    border: 1px solid rgba(255,255,255,0.1);
    font-family: inherit;
    font-size: 0.72rem;
    margin: 0 2px;
    color: var(--text);
  }

  .crumb {
    position: absolute;
    pointer-events: none;
    z-index: 10;
  }

  .history-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 0;
    font-size: 0.8rem;
    color: var(--text2);
    border-bottom: 1px solid rgba(255,255,255,0.04);
  }
  .history-item:last-child { border: none; }
  .history-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .reset-btn {
    background: transparent;
    border: 1px solid rgba(255,255,255,0.1);
    color: var(--text2);
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s;
  }
  .reset-btn:hover {
    border-color: rgba(255,255,255,0.2);
    color: var(--text);
  }

  @keyframes steamFloat {
    0% { transform: translateY(0) translateX(0) scaleX(1); opacity: 0.6; }
    50% { transform: translateY(-20px) translateX(5px) scaleX(1.3); opacity: 0.3; }
    100% { transform: translateY(-40px) translateX(-3px) scaleX(0.8); opacity: 0; }
  }

  @keyframes biscuitDunk {
    0% { transform: translateY(0) rotate(0deg); }
    20% { transform: translateY(40px) rotate(-5deg); }
    50% { transform: translateY(60px) rotate(-3deg); }
    80% { transform: translateY(40px) rotate(-5deg); }
    100% { transform: translateY(0) rotate(0deg); }
  }

  @keyframes crumbFall {
    0% { transform: translateY(0) rotate(0deg); opacity: 1; }
    100% { transform: translateY(120px) rotate(720deg); opacity: 0; }
  }

  @keyframes ripple {
    0% { transform: scaleX(1); opacity: 0.5; }
    100% { transform: scaleX(1.5); opacity: 0; }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-3px) rotate(-0.5deg); }
    75% { transform: translateX(3px) rotate(0.5deg); }
  }

  @keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 15px rgba(200,149,108,0.1); }
    50% { box-shadow: 0 0 25px rgba(200,149,108,0.2); }
  }

  .pulse-border {
    animation: pulse-glow 3s ease-in-out infinite;
  }

  .tooltip {
    position: relative;
  }
  .tooltip::after {
    content: attr(data-tip);
    position: absolute;
    bottom: 110%;
    left: 50%;
    transform: translateX(-50%) scale(0.9);
    background: var(--bg2);
    border: 1px solid var(--glass-border);
    padding: 4px 10px;
    border-radius: 6px;
    font-size: 0.72rem;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: all 0.2s;
    color: var(--text);
  }
  .tooltip:hover::after {
    opacity: 1;
    transform: translateX(-50%) scale(1);
  }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback, useMemo } = React;

// ‚îÄ‚îÄ‚îÄ Biscuit Data ‚îÄ‚îÄ‚îÄ
const BISCUITS = {
  digestive: {
    name: 'Digestive',
    emoji: 'üç™',
    baseIntegrity: 85,
    soakRate: 1.2,
    crumbliness: 0.6,
    optimalDunk: 3,
    color: '#c4956a',
  },
  hobnob: {
    name: 'Hobnob',
    emoji: 'ü´ì',
    baseIntegrity: 92,
    soakRate: 0.8,
    crumbliness: 0.4,
    optimalDunk: 5,
    color: '#b08050',
  },
  richTea: {
    name: 'Rich Tea',
    emoji: 'ü•†',
    baseIntegrity: 50,
    soakRate: 2.0,
    crumbliness: 0.9,
    optimalDunk: 1.5,
    color: '#dfc090',
  },
  bourbon: {
    name: 'Bourbon',
    emoji: 'üü´',
    baseIntegrity: 75,
    soakRate: 1.0,
    crumbliness: 0.5,
    optimalDunk: 4,
    color: '#5a3520',
  },
  custardCream: {
    name: 'Custard Cream',
    emoji: 'üßà',
    baseIntegrity: 65,
    soakRate: 1.5,
    crumbliness: 0.7,
    optimalDunk: 2.5,
    color: '#f0d890',
  },
  ginger: {
    name: 'Ginger Nut',
    emoji: 'ü´ö',
    baseIntegrity: 95,
    soakRate: 0.5,
    crumbliness: 0.3,
    optimalDunk: 7,
    color: '#a06830',
  },
};

// ‚îÄ‚îÄ‚îÄ Physics Calculations ‚îÄ‚îÄ‚îÄ
function calculateIntegrity(biscuitType, teaTemp, dunkTime, baseIntegritySetting) {
  const b = BISCUITS[biscuitType];
  const tempFactor = 1 + (teaTemp - 60) / 100;
  const soakDamage = b.soakRate * dunkTime * tempFactor;
  const scaledBase = (baseIntegritySetting / 100) * b.baseIntegrity;
  const integrity = Math.max(0, scaledBase - soakDamage * 8);
  return Math.round(integrity);
}

function calculateCrumbleRisk(biscuitType, teaTemp, dunkTime) {
  const b = BISCUITS[biscuitType];
  const tempFactor = (teaTemp - 40) / 60;
  const timeFactor = dunkTime / b.optimalDunk;
  const risk = Math.min(100, Math.max(0, b.crumbliness * timeFactor * tempFactor * 100));
  return Math.round(risk);
}

function getDunkVerdict(integrity, crumbleRisk) {
  if (integrity > 70 && crumbleRisk < 30) return { text: 'Perfect Dunk!', class: 'good' };
  if (integrity > 40 && crumbleRisk < 60) return { text: 'Risky but Tasty', class: 'warn' };
  if (integrity > 20) return { text: 'Soggy Mess', class: 'warn' };
  return { text: 'Catastrophic Collapse!', class: 'bad' };
}

// ‚îÄ‚îÄ‚îÄ Steam Particle Component ‚îÄ‚îÄ‚îÄ
function SteamParticles({ teaTemp, isDunking }) {
  const particleCount = Math.floor((teaTemp - 40) / 8);
  const particles = useMemo(() => {
    return Array.from({ length: Math.max(0, particleCount) }, (_, i) => ({
      id: i,
      left: 35 + Math.random() * 30,
      delay: Math.random() * 2,
      duration: 1.5 + Math.random() * 1.5,
      size: 3 + Math.random() * 5,
    }));
  }, [particleCount]);

  return (
    <g>
      {particles.map(p => (
        <circle
          key={p.id}
          cx={`${p.left}%`}
          cy="28%"
          r={p.size}
          fill="rgba(255,255,255,0.15)"
          style={{
            animation: `steamFloat ${p.duration}s ease-out infinite`,
            animationDelay: `${p.delay}s`,
            opacity: isDunking ? 0.1 : 0.6,
          }}
        />
      ))}
    </g>
  );
}

// ‚îÄ‚îÄ‚îÄ Crumb Particles ‚îÄ‚îÄ‚îÄ
function CrumbParticles({ crumbs }) {
  return (
    <>
      {crumbs.map(c => (
        <div
          key={c.id}
          className="crumb"
          style={{
            left: c.x,
            top: c.y,
            width: c.size,
            height: c.size,
            borderRadius: Math.random() > 0.5 ? '50%' : '2px',
            background: c.color,
            animation: `crumbFall ${c.duration}s ease-in forwards`,
            animationDelay: `${c.delay}s`,
          }}
        />
      ))}
    </>
  );
}

// ‚îÄ‚îÄ‚îÄ Teacup Scene ‚îÄ‚îÄ‚îÄ
function TeacupScene({ teaTemp, isDunking, biscuitType, integrity, crumbleRisk }) {
  const b = BISCUITS[biscuitType];
  const teaHue = 25 + (teaTemp - 40) * 0.15;
  const teaSat = 60 + (teaTemp - 40) * 0.2;
  const teaColor = `hsl(${teaHue}, ${teaSat}%, 40%)`;
  const teaColorLight = `hsl(${teaHue}, ${teaSat}%, 55%)`;
  const biscuitY = isDunking ? 135 : 70;
  const shakeClass = isDunking && integrity < 30 ? 'shake' : '';

  return (
    <div className="teacup-scene" style={{ animation: shakeClass ? 'shake 0.15s infinite' : 'none' }}>
      <svg viewBox="0 0 280 300" className="teacup-svg">
        {/* Saucer */}
        <ellipse cx="130" cy="265" rx="110" ry="18" fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.12)" strokeWidth="1.5" />
        <ellipse cx="130" cy="262" rx="100" ry="14" fill="rgba(255,255,255,0.04)" />

        {/* Cup body */}
        <path d="M55 120 L65 240 C65 255, 195 255, 195 240 L205 120 Z"
          fill="rgba(255,255,255,0.08)"
          stroke="rgba(255,255,255,0.15)"
          strokeWidth="2" />

        {/* Cup inner shadow */}
        <path d="M60 125 L69 235 C69 248, 191 248, 191 235 L200 125 Z"
          fill="rgba(0,0,0,0.15)" />

        {/* Tea liquid */}
        <path d="M65 135 L72 232 C72 244, 188 244, 188 232 L195 135 Z"
          fill={teaColor} opacity="0.85" />

        {/* Tea surface highlight */}
        <ellipse cx="130" cy="135" rx="65" ry="12"
          fill={teaColorLight} opacity="0.5" />

        {/* Tea surface glare */}
        <ellipse cx="110" cy="133" rx="25" ry="5"
          fill="rgba(255,255,255,0.12)" />

        {/* Cup handle */}
        <path d="M205 145 C240 145, 250 190, 205 200"
          fill="none"
          stroke="rgba(255,255,255,0.15)"
          strokeWidth="8"
          strokeLinecap="round" />
        <path d="M205 145 C235 145, 243 190, 205 200"
          fill="none"
          stroke="rgba(255,255,255,0.06)"
          strokeWidth="5"
          strokeLinecap="round" />

        {/* Cup rim highlight */}
        <ellipse cx="130" cy="120" rx="76" ry="13"
          fill="none"
          stroke="rgba(255,255,255,0.2)"
          strokeWidth="3" />
        <ellipse cx="130" cy="120" rx="74" ry="11"
          fill="rgba(255,255,255,0.04)" />

        {/* Biscuit */}
        <g style={{
          transition: isDunking ? 'none' : 'transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)',
          animation: isDunking ? 'biscuitDunk 2s ease-in-out infinite' : 'none',
          transformOrigin: '130px 90px',
        }}>
          {/* Biscuit body */}
          <rect x="105" y="60" width="50" height="30" rx="6"
            fill={b.color}
            stroke="rgba(0,0,0,0.2)"
            strokeWidth="1" />
          {/* Biscuit texture dots */}
          <circle cx="115" cy="72" r="2" fill="rgba(0,0,0,0.15)" />
          <circle cx="125" cy="68" r="1.5" fill="rgba(0,0,0,0.12)" />
          <circle cx="135" cy="75" r="2" fill="rgba(0,0,0,0.15)" />
          <circle cx="145" cy="70" r="1.5" fill="rgba(0,0,0,0.12)" />
          <circle cx="120" cy="80" r="1.5" fill="rgba(0,0,0,0.1)" />
          <circle cx="140" cy="80" r="1.5" fill="rgba(0,0,0,0.1)" />

          {/* Soak indicator (darker bottom of biscuit when dunking) */}
          {isDunking && (
            <rect x="105" y="78" width="50" height="12" rx="0 0 6 6"
              fill="rgba(0,0,0,0.25)"
              style={{ opacity: 0.4 + (1 - integrity / 100) * 0.6 }} />
          )}

          {/* Integrity cracks */}
          {integrity < 50 && (
            <>
              <line x1="115" y1="65" x2="125" y2="85"
                stroke="rgba(0,0,0,0.3)" strokeWidth="1" strokeDasharray="2,2" />
            </>
          )}
          {integrity < 25 && (
            <>
              <line x1="135" y1="62" x2="142" y2="82"
                stroke="rgba(0,0,0,0.3)" strokeWidth="1" strokeDasharray="2,3" />
              <line x1="110" y1="75" x2="150" y2="73"
                stroke="rgba(0,0,0,0.25)" strokeWidth="1" strokeDasharray="3,2" />
            </>
          )}
        </g>

        {/* Ripples when dunking */}
        {isDunking && (
          <>
            <ellipse cx="130" cy="135" rx="20" ry="4"
              fill="none" stroke="rgba(255,255,255,0.15)" strokeWidth="1"
              style={{ animation: 'ripple 1.5s ease-out infinite' }} />
            <ellipse cx="130" cy="135" rx="15" ry="3"
              fill="none" stroke="rgba(255,255,255,0.1)" strokeWidth="1"
              style={{ animation: 'ripple 1.5s ease-out infinite', animationDelay: '0.5s' }} />
          </>
        )}

        {/* Steam */}
        <SteamParticles teaTemp={teaTemp} isDunking={isDunking} />
      </svg>
    </div>
  );
}

// ‚îÄ‚îÄ‚îÄ Crumble-o-Meter Graph ‚îÄ‚îÄ‚îÄ
function CrumbleGraph({ history }) {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.offsetWidth * 2;
    const h = canvas.height = canvas.offsetHeight * 2;
    ctx.scale(2, 2);
    const dw = w / 2;
    const dh = h / 2;

    ctx.clearRect(0, 0, dw, dh);

    // Grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = (dh / 4) * i;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(dw, y);
      ctx.stroke();
    }

    // Labels
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.font = '9px Inter, sans-serif';
    ctx.fillText('100%', 2, 10);
    ctx.fillText('50%', 2, dh / 2 + 4);
    ctx.fillText('0%', 2, dh - 2);

    if (history.length < 2) {
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.font = '12px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Dunk to see data...', dw / 2, dh / 2);
      return;
    }

    const maxPoints = 20;
    const data = history.slice(-maxPoints);
    const stepX = dw / (maxPoints - 1);
    const startOffset = (maxPoints - data.length) * stepX;

    // Integrity line (green)
    ctx.beginPath();
    ctx.strokeStyle = '#5de88a';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    data.forEach((d, i) => {
      const x = startOffset + i * stepX;
      const y = dh - (d.integrity / 100) * dh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Integrity area
    ctx.lineTo(startOffset + (data.length - 1) * stepX, dh);
    ctx.lineTo(startOffset, dh);
    ctx.closePath();
    const grad1 = ctx.createLinearGradient(0, 0, 0, dh);
    grad1.addColorStop(0, 'rgba(93,232,138,0.15)');
    grad1.addColorStop(1, 'rgba(93,232,138,0)');
    ctx.fillStyle = grad1;
    ctx.fill();

    // Crumble risk line (red)
    ctx.beginPath();
    ctx.strokeStyle = '#e85d5d';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    data.forEach((d, i) => {
      const x = startOffset + i * stepX;
      const y = dh - (d.crumbleRisk / 100) * dh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Crumble area
    ctx.lineTo(startOffset + (data.length - 1) * stepX, dh);
    ctx.lineTo(startOffset, dh);
    ctx.closePath();
    const grad2 = ctx.createLinearGradient(0, 0, 0, dh);
    grad2.addColorStop(0, 'rgba(232,93,93,0.15)');
    grad2.addColorStop(1, 'rgba(232,93,93,0)');
    ctx.fillStyle = grad2;
    ctx.fill();

    // Data points
    data.forEach((d, i) => {
      const x = startOffset + i * stepX;
      // Integrity dot
      ctx.beginPath();
      ctx.arc(x, dh - (d.integrity / 100) * dh, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#5de88a';
      ctx.fill();
      // Crumble dot
      ctx.beginPath();
      ctx.arc(x, dh - (d.crumbleRisk / 100) * dh, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#e85d5d';
      ctx.fill();
    });

  }, [history]);

  return (
    <div className="graph-container">
      <canvas ref={canvasRef} style={{ width: '100%', height: '100%' }} />
      <div style={{ display: 'flex', gap: 16, marginTop: 8, justifyContent: 'center' }}>
        <span style={{ fontSize: '0.72rem', color: '#5de88a', display: 'flex', alignItems: 'center', gap: 4 }}>
          <span style={{ width: 8, height: 8, borderRadius: '50%', background: '#5de88a', display: 'inline-block' }} />
          Integrity
        </span>
        <span style={{ fontSize: '0.72rem', color: '#e85d5d', display: 'flex', alignItems: 'center', gap: 4 }}>
          <span style={{ width: 8, height: 8, borderRadius: '50%', background: '#e85d5d', display: 'inline-block' }} />
          Crumble Risk
        </span>
      </div>
    </div>
  );
}

// ‚îÄ‚îÄ‚îÄ Main App ‚îÄ‚îÄ‚îÄ
function App() {
  const [teaTemp, setTeaTemp] = useState(75);
  const [dunkTime, setDunkTime] = useState(3);
  const [biscuitType, setBiscuitType] = useState('digestive');
  const [baseIntegrity, setBaseIntegrity] = useState(100);
  const [isDunking, setIsDunking] = useState(false);
  const [history, setHistory] = useState([]);
  const [crumbs, setCrumbs] = useState([]);
  const [dunkCount, setDunkCount] = useState(0);
  const simAreaRef = useRef(null);
  const crumbIdRef = useRef(0);

  const integrity = calculateIntegrity(biscuitType, teaTemp, dunkTime, baseIntegrity);
  const crumbleRisk = calculateCrumbleRisk(biscuitType, teaTemp, dunkTime);
  const verdict = getDunkVerdict(integrity, crumbleRisk);
  const b = BISCUITS[biscuitType];
  const isOverDunk = integrity < 30 || crumbleRisk > 70;

  const spawnCrumbs = useCallback(() => {
    if (!simAreaRef.current) return;
    const rect = simAreaRef.current.getBoundingClientRect();
    const count = Math.floor(8 + crumbleRisk / 5);
    const newCrumbs = Array.from({ length: count }, () => {
      crumbIdRef.current++;
      return {
        id: crumbIdRef.current,
        x: `${30 + Math.random() * 40}%`,
        y: `${35 + Math.random() * 15}%`,
        size: 2 + Math.random() * 5,
        color: `hsl(${25 + Math.random() * 15}, ${40 + Math.random() * 30}%, ${35 + Math.random() * 25}%)`,
        duration: 0.8 + Math.random() * 1.5,
        delay: Math.random() * 0.5,
      };
    });
    setCrumbs(prev => [...prev, ...newCrumbs]);
    setTimeout(() => {
      setCrumbs(prev => prev.filter(c => !newCrumbs.find(nc => nc.id === c.id)));
    }, 3000);
  }, [crumbleRisk]);

  const doBiscuitDunk = useCallback(() => {
    if (isDunking) return;
    setIsDunking(true);
    setDunkCount(c => c + 1);

    const dunkDuration = Math.min(dunkTime * 400, 3000);

    if (isOverDunk) {
      setTimeout(() => spawnCrumbs(), dunkDuration * 0.3);
      setTimeout(() => spawnCrumbs(), dunkDuration * 0.6);
    }

    setTimeout(() => {
      setIsDunking(false);
      setHistory(prev => [...prev, {
        integrity,
        crumbleRisk,
        biscuit: biscuitType,
        temp: teaTemp,
        time: dunkTime,
        verdict: verdict.text,
      }]);
      if (isOverDunk) spawnCrumbs();
    }, dunkDuration);
  }, [isDunking, dunkTime, isOverDunk, spawnCrumbs, integrity, crumbleRisk, biscuitType, teaTemp, verdict.text]);

  const resetSim = useCallback(() => {
    setHistory([]);
    setCrumbs([]);
    setDunkCount(0);
    setTeaTemp(75);
    setDunkTime(3);
    setBiscuitType('digestive');
    setBaseIntegrity(100);
  }, []);

  // Keyboard shortcuts
  useEffect(() => {
    const handler = (e) => {
      if (e.target.tagName === 'INPUT') return;
      switch (e.key.toLowerCase()) {
        case ' ':
        case 'd':
          e.preventDefault();
          doBiscuitDunk();
          break;
        case 'r':
          e.preventDefault();
          resetSim();
          break;
        case '1': setBiscuitType('digestive'); break;
        case '2': setBiscuitType('hobnob'); break;
        case '3': setBiscuitType('richTea'); break;
        case '4': setBiscuitType('bourbon'); break;
        case '5': setBiscuitType('custardCream'); break;
        case '6': setBiscuitType('ginger'); break;
        case 'arrowup':
          e.preventDefault();
          setTeaTemp(t => Math.min(100, t + 5));
          break;
        case 'arrowdown':
          e.preventDefault();
          setTeaTemp(t => Math.max(40, t - 5));
          break;
        case 'arrowleft':
          e.preventDefault();
          setDunkTime(t => Math.max(0.5, +(t - 0.5).toFixed(1)));
          break;
        case 'arrowright':
          e.preventDefault();
          setDunkTime(t => Math.min(15, +(t + 0.5).toFixed(1)));
          break;
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, [doBiscuitDunk, resetSim]);

  const integrityColor = integrity > 60 ? '#5de88a' : integrity > 30 ? '#e8c85d' : '#e85d5d';
  const soakLevel = Math.min(100, Math.round(dunkTime * b.soakRate * ((teaTemp - 40) / 60) * 20));

  return (
    <div className="app-container">
      <div className="header">
        <h1>‚òï Tea Dunkability Simulator</h1>
        <p>The scientific approach to biscuit dunking</p>
      </div>

      <div className="main-grid">
        {/* Left: Controls */}
        <div>
          <div className="glass controls-panel pulse-border">
            <div className="control-group">
              <label>
                Tea Temperature
                <span className="value-display">{teaTemp}¬∞C</span>
              </label>
              <input
                type="range" min="40" max="100" step="1"
                value={teaTemp}
                onChange={e => setTeaTemp(+e.target.value)}
              />
              <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: 'var(--text2)', marginTop: 4 }}>
                <span>Lukewarm</span>
                <span>Scalding</span>
              </div>
            </div>

            <div className="control-group">
              <label>
                Dunk Time
                <span className="value-display">{dunkTime}s</span>
              </label>
              <input
                type="range" min="0.5" max="15" step="0.5"
                value={dunkTime}
                onChange={e => setDunkTime(+e.target.value)}
              />
              <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: 'var(--text2)', marginTop: 4 }}>
                <span>Quick dip</span>
                <span>Full soak</span>
              </div>
            </div>

            <div className="control-group">
              <label>
                Structural Integrity
                <span className="value-display">{baseIntegrity}%</span>
              </label>
              <input
                type="range" min="10" max="100" step="5"
                value={baseIntegrity}
                onChange={e => setBaseIntegrity(+e.target.value)}
              />
              <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: 'var(--text2)', marginTop: 4 }}>
                <span>Stale & Cracked</span>
                <span>Factory Fresh</span>
              </div>
            </div>

            <div className="control-group">
              <label>Biscuit Type</label>
              <div className="biscuit-selector">
                {Object.entries(BISCUITS).map(([key, val]) => (
                  <button
                    key={key}
                    className={`biscuit-btn ${biscuitType === key ? 'active' : ''}`}
                    onClick={() => setBiscuitType(key)}
                  >
                    <span className="emoji">{val.emoji}</span>
                    {val.name}
                  </button>
                ))}
              </div>
            </div>

            <button
              className={`dunk-button ${isDunking ? 'dunking' : ''}`}
              onClick={doBiscuitDunk}
              disabled={isDunking}
            >
              {isDunking ? 'ü´ñ Dunking...' : 'üç™ Dunk Biscuit!'}
            </button>

            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <span style={{ fontSize: '0.8rem', color: 'var(--text2)' }}>
                Dunks: <strong style={{ color: 'var(--accent2)' }}>{dunkCount}</strong>
              </span>
              <button className="reset-btn" onClick={resetSim}>Reset</button>
            </div>
          </div>
        </div>

        {/* Right: Visualization & Data */}
        <div className="right-col">
          <div className="glass sim-area" ref={simAreaRef}>
            <TeacupScene
              teaTemp={teaTemp}
              isDunking={isDunking}
              biscuitType={biscuitType}
              integrity={integrity}
              crumbleRisk={crumbleRisk}
            />
            <CrumbParticles crumbs={crumbs} />

            {/* Verdict overlay */}
            <div style={{
              position: 'absolute',
              top: 16,
              right: 20,
              textAlign: 'right',
            }}>
              <div style={{
                fontSize: '1.1rem',
                fontWeight: 700,
                color: verdict.class === 'good' ? '#5de88a' : verdict.class === 'warn' ? '#e8c85d' : '#e85d5d',
                textShadow: '0 2px 10px rgba(0,0,0,0.3)',
              }}>
                {verdict.text}
              </div>
              <div style={{ fontSize: '0.75rem', color: 'var(--text2)', marginTop: 2 }}>
                {b.name} ‚Ä¢ {teaTemp}¬∞C ‚Ä¢ {dunkTime}s
              </div>
            </div>

            {/* Integrity badge */}
            <div style={{
              position: 'absolute',
              bottom: 16,
              left: 20,
              background: 'rgba(0,0,0,0.3)',
              padding: '8px 14px',
              borderRadius: 10,
              border: `1px solid ${integrityColor}40`,
            }}>
              <div style={{ fontSize: '0.7rem', color: 'var(--text2)', marginBottom: 2 }}>Integrity</div>
              <div style={{ fontSize: '1.4rem', fontWeight: 700, color: integrityColor }}>{integrity}%</div>
            </div>

            {/* Soak badge */}
            <div style={{
              position: 'absolute',
              bottom: 16,
              right: 20,
              background: 'rgba(0,0,0,0.3)',
              padding: '8px 14px',
              borderRadius: 10,
              border: '1px solid rgba(200,149,108,0.2)',
            }}>
              <div style={{ fontSize: '0.7rem', color: 'var(--text2)', marginBottom: 2 }}>Soak Level</div>
              <div style={{ fontSize: '1.4rem', fontWeight: 700, color: 'var(--accent2)' }}>{soakLevel}%</div>
            </div>
          </div>

          <div className="bottom-row">
            <div className="glass crumble-panel">
              <h3>üìä Crumble-o-Meter</h3>
              <CrumbleGraph history={history} />
            </div>

            <div className="glass status-panel">
              <h3>üìã Dunk Analysis</h3>

              <div className="status-item">
                <span className="status-label">Crumble Risk</span>
                <span className={`status-value ${crumbleRisk < 30 ? 'good' : crumbleRisk < 60 ? 'warn' : 'bad'}`}>
                  {crumbleRisk}%
                </span>
              </div>

              <div className="status-item">
                <span className="status-label">Optimal Dunk Time</span>
                <span className="status-value" style={{ color: 'var(--accent2)' }}>
                  {b.optimalDunk}s
                </span>
              </div>

              <div className="status-item">
                <span className="status-label">Biscuit Rating</span>
                <span className="status-value" style={{ color: 'var(--accent2)' }}>
                  {b.baseIntegrity >= 90 ? '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê' : b.baseIntegrity >= 75 ? '‚≠ê‚≠ê‚≠ê‚≠ê' : b.baseIntegrity >= 60 ? '‚≠ê‚≠ê‚≠ê' : '‚≠ê‚≠ê'}
                </span>
              </div>

              <div style={{ marginTop: 8 }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: 4 }}>
                  <span style={{ fontSize: '0.78rem', color: 'var(--text2)' }}>Structural Integrity</span>
                  <span style={{ fontSize: '0.78rem', fontWeight: 600, color: integrityColor }}>{integrity}%</span>
                </div>
                <div className="integrity-bar">
                  <div className="integrity-fill" style={{
                    width: `${integrity}%`,
                    background: `linear-gradient(90deg, ${integrityColor}, ${integrityColor}88)`,
                  }} />
                </div>
              </div>

              {history.length > 0 && (
                <div style={{ marginTop: 14 }}>
                  <div style={{ fontSize: '0.75rem', color: 'var(--text2)', marginBottom: 6, fontWeight: 600 }}>
                    Recent Dunks
                  </div>
                  {history.slice(-4).reverse().map((h, i) => (
                    <div key={i} className="history-item">
                      <span className="history-dot" style={{
                        background: h.integrity > 60 ? '#5de88a' : h.integrity > 30 ? '#e8c85d' : '#e85d5d',
                      }} />
                      <span>{BISCUITS[h.biscuit]?.emoji} {h.temp}¬∞C / {h.time}s</span>
                      <span style={{ marginLeft: 'auto', fontWeight: 500, color: h.integrity > 60 ? '#5de88a' : h.integrity > 30 ? '#e8c85d' : '#e85d5d' }}>
                        {h.integrity}%
                      </span>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      <div className="shortcuts-bar glass" style={{ marginTop: 20 }}>
        <kbd>Space</kbd> / <kbd>D</kbd> Dunk &nbsp;
        <kbd>‚Üë</kbd><kbd>‚Üì</kbd> Temperature &nbsp;
        <kbd>‚Üê</kbd><kbd>‚Üí</kbd> Dunk Time &nbsp;
        <kbd>1</kbd>-<kbd>6</kbd> Biscuit &nbsp;
        <kbd>R</kbd> Reset
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
