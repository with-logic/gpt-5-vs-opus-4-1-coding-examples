<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Festival Lights Show</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
<style>
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}

  :root {
    --primary: #ff006e;
    --secondary: #8338ec;
    --accent: #3a86ff;
    --neon-green: #39ff14;
    --neon-orange: #ff6700;
    --bg: #0a0a0f;
    --surface: rgba(255,255,255,0.04);
    --surface-hover: rgba(255,255,255,0.08);
    --text: #e0e0e0;
    --text-dim: #888;
  }

  body {
    font-family: 'Rajdhani', sans-serif;
    background: var(--bg);
    color: var(--text);
    overflow-x: hidden;
    min-height: 100vh;
  }

  /* Canvas background */
  #bgCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    pointer-events: none;
  }

  /* Main layout */
  .app-container {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }

  /* Header */
  header {
    text-align: center;
    padding: 20px 20px 10px;
    position: relative;
  }
  header h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(1.6rem, 5vw, 2.8rem);
    font-weight: 900;
    background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent), var(--neon-green));
    background-size: 300% 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: gradientShift 4s ease infinite;
    text-shadow: 0 0 40px rgba(255,0,110,0.3);
    letter-spacing: 3px;
  }
  header .subtitle {
    font-size: 0.9rem;
    color: var(--text-dim);
    letter-spacing: 4px;
    text-transform: uppercase;
    margin-top: 4px;
  }

  @keyframes gradientShift {
    0%,100%{background-position:0% 50%}
    50%{background-position:100% 50%}
  }

  /* Stage area */
  .stage-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px 20px;
    min-height: 0;
  }

  #lightStage {
    width: 100%;
    max-width: 900px;
    height: clamp(250px, 40vh, 450px);
    border-radius: 20px;
    position: relative;
    overflow: hidden;
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 0 60px rgba(131,56,236,0.15), inset 0 0 60px rgba(0,0,0,0.5);
    background: radial-gradient(ellipse at center bottom, rgba(20,20,40,1), rgba(5,5,15,1));
  }

  #stageCanvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* BPM and status display */
  .status-bar {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 24px;
    margin-top: 10px;
    flex-wrap: wrap;
  }
  .status-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.85rem;
    color: var(--text-dim);
    font-weight: 500;
  }
  .status-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--neon-green);
    box-shadow: 0 0 8px var(--neon-green);
    animation: pulse 1s infinite;
  }
  .status-dot.off {
    background: #555;
    box-shadow: none;
    animation: none;
  }
  @keyframes pulse {
    0%,100%{opacity:1;transform:scale(1)}
    50%{opacity:0.5;transform:scale(0.8)}
  }
  .bpm-display {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.1rem;
    color: var(--accent);
    font-weight: 700;
  }

  /* Controls panel */
  .controls-panel {
    max-width: 900px;
    width: 100%;
    margin: 10px auto 20px;
    padding: 0 20px;
  }

  .control-sections {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 14px;
  }

  .control-section {
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 16px;
    padding: 16px;
    backdrop-filter: blur(10px);
    transition: border-color 0.3s;
  }
  .control-section:hover {
    border-color: rgba(255,255,255,0.12);
  }

  .section-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.7rem;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .section-title .icon {
    font-size: 1rem;
  }

  /* Color palette */
  .color-palette {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 10px;
  }
  .color-swatch {
    width: 36px; height: 36px;
    border-radius: 50%;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
  }
  .color-swatch:hover {
    transform: scale(1.15);
  }
  .color-swatch.active {
    border-color: #fff;
    box-shadow: 0 0 15px currentColor;
    transform: scale(1.15);
  }
  .color-swatch.active::after {
    content: 'âœ“';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8);
  }

  .custom-color-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 4px;
  }
  .custom-color-row input[type="color"] {
    width: 36px; height: 36px;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    background: none;
    padding: 0;
  }
  .custom-color-row input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
  .custom-color-row input[type="color"]::-webkit-color-swatch { border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); }
  .custom-color-label { font-size: 0.8rem; color: var(--text-dim); }

  /* Pattern buttons */
  .pattern-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
  .pattern-btn {
    padding: 10px 8px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.08);
    background: rgba(255,255,255,0.03);
    color: var(--text);
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.2s;
    text-align: center;
    letter-spacing: 0.5px;
  }
  .pattern-btn:hover {
    background: rgba(255,255,255,0.08);
    border-color: rgba(255,255,255,0.15);
  }
  .pattern-btn.active {
    background: linear-gradient(135deg, rgba(131,56,236,0.3), rgba(58,134,255,0.3));
    border-color: var(--secondary);
    box-shadow: 0 0 15px rgba(131,56,236,0.2);
    color: #fff;
  }

  /* Sliders */
  .slider-group {
    margin-bottom: 14px;
  }
  .slider-group:last-child { margin-bottom: 0; }
  .slider-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-bottom: 6px;
  }
  .slider-value {
    color: var(--accent);
    font-weight: 700;
    font-family: 'Orbitron', sans-serif;
    font-size: 0.7rem;
  }
  input[type="range"] {
    width: 100%;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(255,255,255,0.1);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    box-shadow: 0 0 10px rgba(131,56,236,0.5);
    cursor: pointer;
    transition: transform 0.2s;
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  /* Music controls */
  .music-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .music-btn-row {
    display: flex;
    gap: 8px;
  }
  .music-btn {
    flex: 1;
    padding: 10px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.08);
    background: rgba(255,255,255,0.03);
    color: var(--text);
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.85rem;
    font-weight: 700;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
  }
  .music-btn:hover {
    background: rgba(255,255,255,0.08);
  }
  .music-btn.playing {
    background: linear-gradient(135deg, rgba(255,0,110,0.3), rgba(255,103,0,0.3));
    border-color: var(--primary);
    box-shadow: 0 0 15px rgba(255,0,110,0.2);
  }

  /* Audio visualizer bars */
  .audio-viz {
    display: flex;
    align-items: flex-end;
    justify-content: center;
    gap: 2px;
    height: 40px;
    margin-top: 6px;
  }
  .viz-bar {
    width: 4px;
    background: linear-gradient(to top, var(--primary), var(--accent));
    border-radius: 2px;
    min-height: 3px;
    transition: height 0.08s ease;
  }

  /* Master controls row */
  .master-row {
    display: flex;
    gap: 10px;
    margin-top: 14px;
    max-width: 900px;
    width: 100%;
    padding: 0 20px;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 20px;
  }
  .master-btn {
    flex: 1;
    padding: 14px;
    border-radius: 14px;
    border: none;
    cursor: pointer;
    font-family: 'Orbitron', sans-serif;
    font-size: 0.85rem;
    font-weight: 700;
    letter-spacing: 2px;
    transition: all 0.3s;
    text-transform: uppercase;
  }
  .master-btn.play {
    background: linear-gradient(135deg, var(--neon-green), #00c853);
    color: #000;
    box-shadow: 0 0 20px rgba(57,255,20,0.3);
  }
  .master-btn.play:hover {
    box-shadow: 0 0 30px rgba(57,255,20,0.5);
    transform: translateY(-1px);
  }
  .master-btn.play.active {
    background: linear-gradient(135deg, #ff4444, #cc0000);
    box-shadow: 0 0 20px rgba(255,68,68,0.3);
  }
  .master-btn.play.active:hover {
    box-shadow: 0 0 30px rgba(255,68,68,0.5);
  }
  .master-btn.blackout {
    background: rgba(255,255,255,0.06);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.1);
  }
  .master-btn.blackout:hover {
    background: rgba(255,255,255,0.1);
  }
  .master-btn.blackout.active {
    background: rgba(255,68,68,0.15);
    border-color: rgba(255,68,68,0.4);
    color: #ff4444;
  }
  .master-btn.strobe-btn {
    background: rgba(255,255,255,0.06);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.1);
  }
  .master-btn.strobe-btn:hover {
    background: rgba(255,255,255,0.1);
  }
  .master-btn.strobe-btn.active {
    background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(200,200,200,0.1));
    border-color: rgba(255,255,255,0.5);
    color: #fff;
    animation: strobeBtn 0.15s infinite alternate;
  }
  @keyframes strobeBtn {
    from { opacity: 1; }
    to { opacity: 0.6; }
  }

  /* Responsive */
  @media (max-width: 600px) {
    .control-sections { grid-template-columns: 1fr; }
    .master-row { flex-direction: column; }
    .pattern-grid { grid-template-columns: repeat(2, 1fr); }
  }

  /* Glow line separator */
  .glow-line {
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--secondary), var(--accent), var(--primary), transparent);
    max-width: 400px;
    margin: 8px auto;
    opacity: 0.5;
  }

  /* Beat flash overlay */
  #beatFlash {
    position: absolute;
    inset: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.05s;
    z-index: 5;
    border-radius: 20px;
  }
</style>
</head>
<body>

<canvas id="bgCanvas"></canvas>

<div class="app-container">
  <header>
    <h1>Festival Lights Show</h1>
    <p class="subtitle">Immersive Light Control System</p>
    <div class="glow-line"></div>
  </header>

  <!-- Stage -->
  <div class="stage-container">
    <div id="lightStage">
      <canvas id="stageCanvas"></canvas>
      <div id="beatFlash"></div>
    </div>
    <div class="status-bar">
      <div class="status-item">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Ready</span>
      </div>
      <div class="status-item">
        <span>BPM</span>
        <span class="bpm-display" id="bpmDisplay">128</span>
      </div>
      <div class="status-item">
        <span>Pattern</span>
        <span class="bpm-display" id="patternDisplay">Pulse</span>
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls-panel">
    <div class="control-sections">
      <!-- Colors -->
      <div class="control-section">
        <div class="section-title"><span class="icon">ðŸŽ¨</span> Colors</div>
        <div class="color-palette" id="colorPalette"></div>
        <div class="custom-color-row">
          <input type="color" id="customColor" value="#ff006e">
          <span class="custom-color-label">Custom</span>
        </div>
      </div>

      <!-- Patterns -->
      <div class="control-section">
        <div class="section-title"><span class="icon">âœ¨</span> Patterns</div>
        <div class="pattern-grid" id="patternGrid"></div>
      </div>

      <!-- Speed & Intensity -->
      <div class="control-section">
        <div class="section-title"><span class="icon">âš¡</span> Parameters</div>
        <div class="slider-group">
          <div class="slider-label"><span>Speed</span><span class="slider-value" id="speedVal">50%</span></div>
          <input type="range" id="speedSlider" min="1" max="100" value="50">
        </div>
        <div class="slider-group">
          <div class="slider-label"><span>Intensity</span><span class="slider-value" id="intensityVal">80%</span></div>
          <input type="range" id="intensitySlider" min="1" max="100" value="80">
        </div>
        <div class="slider-group">
          <div class="slider-label"><span>Beam Width</span><span class="slider-value" id="beamVal">50%</span></div>
          <input type="range" id="beamSlider" min="10" max="100" value="50">
        </div>
        <div class="slider-group">
          <div class="slider-label"><span>BPM</span><span class="slider-value" id="bpmVal">128</span></div>
          <input type="range" id="bpmSlider" min="60" max="200" value="128">
        </div>
      </div>

      <!-- Music Sync -->
      <div class="control-section">
        <div class="section-title"><span class="icon">ðŸŽµ</span> Music Sync</div>
        <div class="music-controls">
          <div class="music-btn-row">
            <button class="music-btn" id="micBtn" onclick="toggleMic()">
              <span>ðŸŽ¤</span> Mic Input
            </button>
            <button class="music-btn" id="demoBtn" onclick="toggleDemo()">
              <span>ðŸ”Š</span> Demo Beat
            </button>
          </div>
          <div class="slider-group">
            <div class="slider-label"><span>Reactivity</span><span class="slider-value" id="reactivityVal">70%</span></div>
            <input type="range" id="reactivitySlider" min="1" max="100" value="70">
          </div>
          <div class="audio-viz" id="audioViz"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Master Controls -->
  <div class="master-row">
    <button class="master-btn play" id="playBtn" onclick="toggleShow()">â–¶ Start Show</button>
    <button class="master-btn strobe-btn" id="strobeBtn" onclick="toggleStrobe()">âš¡ Strobe</button>
    <button class="master-btn blackout" id="blackoutBtn" onclick="toggleBlackout()">â—¼ Blackout</button>
  </div>
</div>

<script>
// ============ STATE ============
const state = {
  running: false,
  blackout: false,
  strobe: false,
  strobeOn: true,
  currentColor: '#ff006e',
  colors: ['#ff006e','#8338ec','#3a86ff','#39ff14','#ff6700','#ffbe0b','#fb5607','#00f5d4','#f72585','#ffffff'],
  pattern: 'pulse',
  speed: 50,
  intensity: 80,
  beamWidth: 50,
  bpm: 128,
  reactivity: 70,
  micActive: false,
  demoActive: false,
  audioData: new Float32Array(64),
  time: 0,
  beatPhase: 0,
  lastBeat: 0,
  spotlights: [],
  particles: [],
  laserBeams: [],
};

// ============ PATTERNS ============
const patterns = [
  { id: 'pulse', name: 'Pulse', icon: 'ðŸ’«' },
  { id: 'rainbow', name: 'Rainbow Wave', icon: 'ðŸŒˆ' },
  { id: 'scanner', name: 'Scanner', icon: 'ðŸ“¡' },
  { id: 'sparkle', name: 'Sparkle Burst', icon: 'âœ¨' },
  { id: 'laser', name: 'Laser Show', icon: 'ðŸ”¦' },
  { id: 'fireworks', name: 'Fireworks', icon: 'ðŸŽ†' },
  { id: 'matrix', name: 'Matrix Rain', icon: 'ðŸ’š' },
  { id: 'aurora', name: 'Aurora', icon: 'ðŸŒŒ' },
];

// ============ INIT ============
const stageCanvas = document.getElementById('stageCanvas');
const stageCtx = stageCanvas.getContext('2d');
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');

function resizeCanvases() {
  const stage = document.getElementById('lightStage');
  stageCanvas.width = stage.clientWidth * devicePixelRatio;
  stageCanvas.height = stage.clientHeight * devicePixelRatio;
  stageCtx.scale(devicePixelRatio, devicePixelRatio);
  stageCanvas.style.width = stage.clientWidth + 'px';
  stageCanvas.style.height = stage.clientHeight + 'px';

  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;

  state.stageW = stage.clientWidth;
  state.stageH = stage.clientHeight;
}

function initSpotlights() {
  state.spotlights = [];
  const count = 7;
  for (let i = 0; i < count; i++) {
    state.spotlights.push({
      x: (i + 0.5) / count,
      angle: 0,
      targetAngle: 0,
      hue: (i / count) * 360,
      intensity: 1,
      width: 0.06,
    });
  }
}

function buildUI() {
  // Color palette
  const palette = document.getElementById('colorPalette');
  state.colors.forEach((c, i) => {
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch' + (i === 0 ? ' active' : '');
    swatch.style.background = c;
    swatch.style.color = c;
    swatch.dataset.color = c;
    swatch.onclick = () => selectColor(c, swatch);
    palette.appendChild(swatch);
  });

  // Patterns
  const grid = document.getElementById('patternGrid');
  patterns.forEach((p, i) => {
    const btn = document.createElement('button');
    btn.className = 'pattern-btn' + (i === 0 ? ' active' : '');
    btn.textContent = p.icon + ' ' + p.name;
    btn.dataset.pattern = p.id;
    btn.onclick = () => selectPattern(p.id, btn);
    grid.appendChild(btn);
  });

  // Audio viz bars
  const viz = document.getElementById('audioViz');
  for (let i = 0; i < 32; i++) {
    const bar = document.createElement('div');
    bar.className = 'viz-bar';
    bar.style.height = '3px';
    viz.appendChild(bar);
  }
}

// ============ CONTROLS ============
function selectColor(c, el) {
  state.currentColor = c;
  document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
  if (el) el.classList.add('active');
}

function selectPattern(id, el) {
  state.pattern = id;
  document.getElementById('patternDisplay').textContent = patterns.find(p => p.id === id)?.name || id;
  document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
  if (el) el.classList.add('active');
  state.particles = [];
  state.laserBeams = [];
}

function toggleShow() {
  state.running = !state.running;
  const btn = document.getElementById('playBtn');
  const dot = document.getElementById('statusDot');
  const text = document.getElementById('statusText');
  if (state.running) {
    btn.textContent = 'â¸ Stop Show';
    btn.classList.add('active');
    dot.classList.remove('off');
    text.textContent = 'Live';
  } else {
    btn.textContent = 'â–¶ Start Show';
    btn.classList.remove('active');
    dot.classList.add('off');
    text.textContent = 'Paused';
  }
}

function toggleBlackout() {
  state.blackout = !state.blackout;
  document.getElementById('blackoutBtn').classList.toggle('active');
}

function toggleStrobe() {
  state.strobe = !state.strobe;
  document.getElementById('strobeBtn').classList.toggle('active');
}

// Sliders
document.getElementById('speedSlider').oninput = e => {
  state.speed = +e.target.value;
  document.getElementById('speedVal').textContent = state.speed + '%';
};
document.getElementById('intensitySlider').oninput = e => {
  state.intensity = +e.target.value;
  document.getElementById('intensityVal').textContent = state.intensity + '%';
};
document.getElementById('beamSlider').oninput = e => {
  state.beamWidth = +e.target.value;
  document.getElementById('beamVal').textContent = state.beamWidth + '%';
};
document.getElementById('bpmSlider').oninput = e => {
  state.bpm = +e.target.value;
  document.getElementById('bpmVal').textContent = state.bpm;
  document.getElementById('bpmDisplay').textContent = state.bpm;
};
document.getElementById('reactivitySlider').oninput = e => {
  state.reactivity = +e.target.value;
  document.getElementById('reactivityVal').textContent = state.reactivity + '%';
};
document.getElementById('customColor').oninput = e => {
  selectColor(e.target.value, null);
  document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
};

// ============ AUDIO ============
let audioCtx, analyser, micStream, demoOsc, demoGain;

function initAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 128;
    analyser.smoothingTimeConstant = 0.75;
  }
}

async function toggleMic() {
  initAudioContext();
  if (state.micActive) {
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
    state.micActive = false;
    document.getElementById('micBtn').classList.remove('playing');
    return;
  }
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    micStream = stream;
    const source = audioCtx.createMediaStreamSource(stream);
    source.connect(analyser);
    state.micActive = true;
    document.getElementById('micBtn').classList.add('playing');
    if (state.demoActive) toggleDemo();
  } catch(e) {
    console.log('Mic not available');
  }
}

function toggleDemo() {
  initAudioContext();
  if (state.demoActive) {
    if (demoOsc) { demoOsc.stop(); demoOsc = null; }
    if (demoGain) { demoGain.disconnect(); demoGain = null; }
    state.demoActive = false;
    document.getElementById('demoBtn').classList.remove('playing');
    return;
  }
  if (state.micActive) toggleMic();

  // Create a rhythmic demo beat using oscillators
  demoGain = audioCtx.createGain();
  demoGain.gain.value = 0.3;
  demoGain.connect(analyser);
  demoGain.connect(audioCtx.destination);

  // Use a combination of oscillators for a beat-like sound
  function scheduleBeat() {
    if (!state.demoActive) return;
    const now = audioCtx.currentTime;
    const beatInterval = 60 / state.bpm;

    // Kick
    const kick = audioCtx.createOscillator();
    const kickGain = audioCtx.createGain();
    kick.type = 'sine';
    kick.frequency.setValueAtTime(150, now);
    kick.frequency.exponentialRampToValueAtTime(30, now + 0.12);
    kickGain.gain.setValueAtTime(0.8, now);
    kickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    kick.connect(kickGain);
    kickGain.connect(demoGain);
    kick.start(now);
    kick.stop(now + 0.2);

    // Hi-hat on offbeat
    const hat = audioCtx.createOscillator();
    const hatGain = audioCtx.createGain();
    hat.type = 'square';
    hat.frequency.value = 6000 + Math.random() * 2000;
    hatGain.gain.setValueAtTime(0.08, now + beatInterval * 0.5);
    hatGain.gain.exponentialRampToValueAtTime(0.001, now + beatInterval * 0.5 + 0.05);
    hat.connect(hatGain);
    hatGain.connect(demoGain);
    hat.start(now + beatInterval * 0.5);
    hat.stop(now + beatInterval * 0.5 + 0.05);

    // Snare on beat 2 and 4
    if (Math.random() < 0.5) {
      const snr = audioCtx.createOscillator();
      const snrGain = audioCtx.createGain();
      snr.type = 'triangle';
      snr.frequency.value = 200 + Math.random() * 100;
      snrGain.gain.setValueAtTime(0.25, now);
      snrGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      snr.connect(snrGain);
      snrGain.connect(demoGain);
      snr.start(now);
      snr.stop(now + 0.1);
    }

    setTimeout(scheduleBeat, beatInterval * 1000);
  }

  state.demoActive = true;
  document.getElementById('demoBtn').classList.add('playing');
  scheduleBeat();
}

function updateAudioData() {
  if (!analyser) return;
  const data = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(data);
  for (let i = 0; i < 64 && i < data.length; i++) {
    state.audioData[i] = data[i] / 255;
  }
}

function getAudioEnergy() {
  let sum = 0;
  const len = Math.min(32, state.audioData.length);
  for (let i = 0; i < len; i++) sum += state.audioData[i];
  return sum / len;
}

function getBassEnergy() {
  let sum = 0;
  for (let i = 0; i < 6; i++) sum += state.audioData[i];
  return sum / 6;
}

// ============ DRAWING HELPERS ============
function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return { r, g, b };
}

function hslToHex(h, s, l) {
  h = ((h % 360) + 360) % 360;
  s /= 100; l /= 100;
  const c = (1 - Math.abs(2*l - 1)) * s;
  const x = c * (1 - Math.abs((h/60) % 2 - 1));
  const m = l - c/2;
  let r,g,b;
  if (h < 60) { r=c; g=x; b=0; }
  else if (h < 120) { r=x; g=c; b=0; }
  else if (h < 180) { r=0; g=c; b=x; }
  else if (h < 240) { r=0; g=x; b=c; }
  else if (h < 300) { r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  r = Math.round((r+m)*255);
  g = Math.round((g+m)*255);
  b = Math.round((b+m)*255);
  return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
}

function lerpColor(c1, c2, t) {
  const a = hexToRgb(c1), b = hexToRgb(c2);
  const r = Math.round(a.r + (b.r - a.r) * t);
  const g = Math.round(a.g + (b.g - a.g) * t);
  const bl = Math.round(a.b + (b.b - a.b) * t);
  return `rgb(${r},${g},${bl})`;
}

// ============ PARTICLE SYSTEM ============
function spawnParticle(x, y, color, vx, vy, life, size) {
  state.particles.push({ x, y, vx: vx || 0, vy: vy || 0, life: life || 1, maxLife: life || 1, color, size: size || 3 });
}

function updateParticles(dt) {
  for (let i = state.particles.length - 1; i >= 0; i--) {
    const p = state.particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 50 * dt; // gravity
    p.life -= dt;
    if (p.life <= 0) state.particles.splice(i, 1);
  }
}

function drawParticles(ctx, w, h) {
  state.particles.forEach(p => {
    const alpha = Math.max(0, p.life / p.maxLife);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

// ============ RENDER PATTERNS ============
function drawSpotlight(ctx, x, y, angle, width, color, intensity, h) {
  const len = h * 1.2;
  const spread = width * state.beamWidth / 50;
  const endX1 = x + Math.sin(angle - spread) * len;
  const endX2 = x + Math.sin(angle + spread) * len;
  const endY = y + Math.cos(angle) * len * 0.3 + h;

  const rgb = hexToRgb(color);

  const grad = ctx.createLinearGradient(x, y, x, endY);
  grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.9 * intensity})`);
  grad.addColorStop(0.3, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.4 * intensity})`);
  grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);

  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(endX1, endY);
  ctx.lineTo(endX2, endY);
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();

  // Light source glow
  ctx.beginPath();
  const glowGrad = ctx.createRadialGradient(x, y, 0, x, y, 15);
  glowGrad.addColorStop(0, `rgba(255,255,255,${0.9 * intensity})`);
  glowGrad.addColorStop(0.3, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.6 * intensity})`);
  glowGrad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
  ctx.arc(x, y, 15, 0, Math.PI * 2);
  ctx.fillStyle = glowGrad;
  ctx.fill();
}

function drawFloor(ctx, w, h, color, intensity) {
  const rgb = hexToRgb(color);
  const grad = ctx.createLinearGradient(0, h * 0.85, 0, h);
  grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
  grad.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.08 * intensity})`);
  grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.15 * intensity})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, h * 0.85, w, h * 0.15);
}

function renderPulse(ctx, w, h, t, beatStrength) {
  const color = state.currentColor;
  const intensity = (state.intensity / 100) * (0.6 + 0.4 * beatStrength);
  const speedMod = state.speed / 50;

  state.spotlights.forEach((s, i) => {
    const phase = t * speedMod * 2 + i * 0.8;
    s.angle = Math.sin(phase) * 0.5;
    const pulseFactor = 0.5 + 0.5 * Math.sin(phase * 1.5);
    const spotColor = state.pattern === 'pulse' ? color : hslToHex(s.hue + t * 30, 80, 55);
    drawSpotlight(ctx, s.x * w, 0, s.angle, s.width * (0.8 + pulseFactor * 0.4), spotColor, intensity * (0.5 + pulseFactor * 0.5), h);
  });

  drawFloor(ctx, w, h, color, intensity);
}

function renderRainbow(ctx, w, h, t, beatStrength) {
  const intensity = (state.intensity / 100) * (0.6 + 0.4 * beatStrength);
  const speedMod = state.speed / 50;

  state.spotlights.forEach((s, i) => {
    const hue = (t * speedMod * 60 + i * 50) % 360;
    const color = hslToHex(hue, 90, 55);
    const phase = t * speedMod * 1.5 + i * 0.9;
    s.angle = Math.sin(phase) * 0.6;
    drawSpotlight(ctx, s.x * w, 0, s.angle, s.width * (0.8 + beatStrength * 0.4), color, intensity, h);
  });

  // Rainbow floor
  for (let i = 0; i < 7; i++) {
    const hue = (t * speedMod * 60 + i * 50) % 360;
    const color = hslToHex(hue, 90, 55);
    const rgb = hexToRgb(color);
    const grad = ctx.createLinearGradient(w * i/7, h * 0.9, w * (i+1)/7, h);
    grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
    grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.12 * intensity})`);
    ctx.fillStyle = grad;
    ctx.fillRect(w * i/7, h * 0.85, w/7, h * 0.15);
  }
}

function renderScanner(ctx, w, h, t, beatStrength) {
  const color = state.currentColor;
  const intensity = (state.intensity / 100) * (0.7 + 0.3 * beatStrength);
  const speedMod = state.speed / 50;
  const scanPos = (Math.sin(t * speedMod * 1.5) + 1) / 2;

  state.spotlights.forEach((s, i) => {
    const targetAngle = (scanPos - s.x) * 1.5;
    s.angle += (targetAngle - s.angle) * 0.1;
    const dist = Math.abs(scanPos - s.x);
    const localIntensity = Math.max(0, 1 - dist * 3) * intensity;
    drawSpotlight(ctx, s.x * w, 0, s.angle, s.width * 1.2, color, localIntensity, h);
  });

  // Scan line on floor
  const rgb = hexToRgb(color);
  const scanX = scanPos * w;
  const scanGrad = ctx.createRadialGradient(scanX, h, 0, scanX, h, w * 0.15);
  scanGrad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.25 * intensity})`);
  scanGrad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
  ctx.fillStyle = scanGrad;
  ctx.fillRect(0, h * 0.8, w, h * 0.2);
}

function renderSparkle(ctx, w, h, t, beatStrength) {
  const color = state.currentColor;
  const intensity = (state.intensity / 100);
  const speedMod = state.speed / 50;

  // Dim base spotlights
  state.spotlights.forEach((s, i) => {
    s.angle = Math.sin(t * speedMod + i) * 0.3;
    drawSpotlight(ctx, s.x * w, 0, s.angle, s.width * 0.6, color, intensity * 0.3, h);
  });

  // Spawn sparkle particles on beat
  if (beatStrength > 0.5 && Math.random() < beatStrength * 0.6) {
    for (let i = 0; i < 15; i++) {
      const px = w * 0.1 + Math.random() * w * 0.8;
      const py = h * 0.1 + Math.random() * h * 0.4;
      const angle = Math.random() * Math.PI * 2;
      const speed = 30 + Math.random() * 80;
      const hue = Math.random() * 360;
      spawnParticle(px, py, hslToHex(hue, 90, 65), Math.cos(angle) * speed, Math.sin(angle) * speed - 30, 0.8 + Math.random() * 0.8, 2 + Math.random() * 3);
    }
  }

  // Constant sparkle
  if (Math.random() < 0.3 * speedMod) {
    const px = Math.random() * w;
    const py = Math.random() * h * 0.7;
    spawnParticle(px, py, color, (Math.random() - 0.5) * 20, -20 - Math.random() * 30, 0.5 + Math.random() * 0.5, 1.5 + Math.random() * 2);
  }

  drawFloor(ctx, w, h, color, intensity);
}

function renderLaser(ctx, w, h, t, beatStrength) {
  const color = state.currentColor;
  const intensity = (state.intensity / 100) * (0.6 + 0.4 * beatStrength);
  const speedMod = state.speed / 50;
  const rgb = hexToRgb(color);

  // Laser beams
  const numLasers = 12;
  for (let i = 0; i < numLasers; i++) {
    const phase = t * speedMod * 3 + i * (Math.PI * 2 / numLasers);
    const originX = w * 0.5 + Math.sin(t * 0.5) * w * 0.2;
    const angle = Math.sin(phase) * 1.2 + Math.cos(phase * 0.7) * 0.5;
    const endX = originX + Math.sin(angle) * h * 2;
    const endY = h;

    ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${0.6 * intensity})`;
    ctx.lineWidth = 1.5 + beatStrength * 1.5;
    ctx.shadowColor = color;
    ctx.shadowBlur = 10 + beatStrength * 10;
    ctx.beginPath();
    ctx.moveTo(originX, 0);
    ctx.lineTo(endX, endY);
    ctx.stroke();
  }

  // Cross lasers
  for (let i = 0; i < 6; i++) {
    const phase = t * speedMod * 2 + i;
    const startX = (i / 6) * w;
    const endX = w - startX + Math.sin(phase) * w * 0.1;

    const hue = (parseInt(color.slice(1), 16) >> 8 & 0xFF) + i * 30;
    ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${0.3 * intensity})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(startX, 0);
    ctx.lineTo(endX, h);
    ctx.stroke();
  }

  ctx.shadowBlur = 0;

  // Origin glow
  const ox = w * 0.5 + Math.sin(t * 0.5) * w * 0.2;
  const originGlow = ctx.createRadialGradient(ox, 0, 0, ox, 0, 40);
  originGlow.addColorStop(0, `rgba(255,255,255,${0.8 * intensity})`);
  originGlow.addColorStop(0.3, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.5 * intensity})`);
  originGlow.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = originGlow;
  ctx.fillRect(ox - 40, 0, 80, 40);
}

function renderFireworks(ctx, w, h, t, beatStrength) {
  const intensity = state.intensity / 100;
  const speedMod = state.speed / 50;

  // Dim ambient light
  const color = state.currentColor;
  state.spotlights.forEach((s, i) => {
    s.angle = Math.sin(t * 0.5 + i) * 0.2;
    drawSpotlight(ctx, s.x * w, 0, s.angle, s.width * 0.4, color, intensity * 0.15, h);
  });

  // Spawn fireworks
  if ((beatStrength > 0.4 && Math.random() < 0.3) || Math.random() < 0.04 * speedMod) {
    const fx = w * 0.15 + Math.random() * w * 0.7;
    const fy = h * 0.15 + Math.random() * h * 0.35;
    const hue = Math.random() * 360;
    const numParticles = 30 + Math.floor(Math.random() * 30);
    for (let j = 0; j < numParticles; j++) {
      const angle = (j / numParticles) * Math.PI * 2 + Math.random() * 0.3;
      const speed = 60 + Math.random() * 120;
      const particleHue = hue + Math.random() * 40 - 20;
      spawnParticle(fx, fy, hslToHex(particleHue, 90, 60), Math.cos(angle) * speed, Math.sin(angle) * speed, 0.8 + Math.random() * 1, 2 + Math.random() * 2.5);
    }
    // Inner ring
    for (let j = 0; j < 10; j++) {
      const angle = (j / 10) * Math.PI * 2;
      const speed = 20 + Math.random() * 40;
      spawnParticle(fx, fy, '#ffffff', Math.cos(angle) * speed, Math.sin(angle) * speed, 0.5, 1.5);
    }
  }
}

function renderMatrix(ctx, w, h, t, beatStrength) {
  const intensity = state.intensity / 100;
  const speedMod = state.speed / 50;
  const color = '#39ff14';
  const rgb = hexToRgb(color);

  // Matrix columns
  const cols = Math.floor(w / 14);
  for (let i = 0; i < cols; i++) {
    const x = i * 14 + 7;
    const phase = (t * speedMod * 2 + i * 0.5) % 4;
    const headY = (phase / 4) * (h + 100) - 50;
    const tailLen = 80 + beatStrength * 60;

    for (let j = 0; j < tailLen; j += 12) {
      const y = headY - j;
      if (y < 0 || y > h) continue;
      const alpha = (1 - j / tailLen) * intensity * (0.5 + beatStrength * 0.5);
      ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
      ctx.font = '11px monospace';
      const char = String.fromCharCode(0x30A0 + Math.floor(Math.random() * 96));
      ctx.fillText(char, x, y);
    }

    // Head glow
    if (headY > 0 && headY < h) {
      const glow = ctx.createRadialGradient(x, headY, 0, x, headY, 8);
      glow.addColorStop(0, `rgba(255,255,255,${0.8 * intensity})`);
      glow.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.4 * intensity})`);
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.fillRect(x - 8, headY - 8, 16, 16);
    }
  }

  drawFloor(ctx, w, h, color, intensity * 0.5);
}

function renderAurora(ctx, w, h, t, beatStrength) {
  const intensity = (state.intensity / 100) * (0.7 + 0.3 * beatStrength);
  const speedMod = state.speed / 50;

  // Multiple aurora layers
  const auroraColors = ['#00f5d4','#8338ec','#3a86ff','#ff006e','#39ff14'];

  for (let layer = 0; layer < 4; layer++) {
    const color = auroraColors[layer % auroraColors.length];
    const rgb = hexToRgb(color);

    ctx.beginPath();
    ctx.moveTo(0, h * 0.3);

    const points = 20;
    for (let i = 0; i <= points; i++) {
      const x = (i / points) * w;
      const wave1 = Math.sin(t * speedMod * 0.5 + i * 0.3 + layer * 1.5) * h * 0.12;
      const wave2 = Math.sin(t * speedMod * 0.3 + i * 0.15 + layer) * h * 0.08;
      const wave3 = Math.cos(t * speedMod * 0.7 + i * 0.5 + layer * 2) * h * 0.05;
      const y = h * (0.15 + layer * 0.08) + wave1 + wave2 + wave3 + beatStrength * 10 * Math.sin(i + t * 3);

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    ctx.lineTo(w, h);
    ctx.lineTo(0, h);
    ctx.closePath();

    const grad = ctx.createLinearGradient(0, h * 0.1, 0, h * 0.8);
    grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.35 * intensity})`);
    grad.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.12 * intensity})`);
    grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
    ctx.fillStyle = grad;
    ctx.fill();
  }

  // Stars
  for (let i = 0; i < 40; i++) {
    const sx = ((i * 47.3 + 13.7) % 1) * w;
    const sy = ((i * 31.1 + 7.3) % 0.4) * h;
    const twinkle = 0.3 + 0.7 * Math.sin(t * 2 + i * 3.7);
    ctx.fillStyle = `rgba(255,255,255,${twinkle * 0.6 * intensity})`;
    ctx.beginPath();
    ctx.arc(sx, sy, 1 + Math.sin(t + i) * 0.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ============ MAIN RENDER ============
function renderStage(dt) {
  const w = state.stageW;
  const h = state.stageH;
  const ctx = stageCtx;

  // Clear
  ctx.clearRect(0, 0, w, h);

  // Dark base
  const bgGrad = ctx.createLinearGradient(0, 0, 0, h);
  bgGrad.addColorStop(0, '#050510');
  bgGrad.addColorStop(1, '#0a0a1a');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, w, h);

  if (!state.running || state.blackout) {
    // Even when not running, show a subtle ambient effect
    if (!state.blackout) {
      const rgb = hexToRgb(state.currentColor);
      const ambGrad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w * 0.5);
      ambGrad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.03)`);
      ambGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = ambGrad;
      ctx.fillRect(0, 0, w, h);
    }

    // Still update/draw remaining particles
    updateParticles(dt);
    drawParticles(ctx, w, h);
    return;
  }

  // Strobe effect
  if (state.strobe) {
    const strobeRate = state.speed / 8;
    state.strobeOn = Math.sin(state.time * strobeRate * Math.PI * 2) > 0;
    if (!state.strobeOn) {
      updateParticles(dt);
      drawParticles(ctx, w, h);
      return;
    }
  }

  // Beat phase
  const beatInterval = 60 / state.bpm;
  state.beatPhase += dt / beatInterval;
  const beatStrength = Math.pow(Math.max(0, 1 - (state.beatPhase % 1) * 2), 2);

  // Audio energy modulation
  let audioMod = 0;
  if (state.micActive || state.demoActive) {
    audioMod = getAudioEnergy() * (state.reactivity / 100);
    const bass = getBassEnergy() * (state.reactivity / 100);
    if (bass > 0.6) {
      state.beatPhase = 0; // resync on bass hit
    }
  }

  const combinedBeat = Math.min(1, beatStrength + audioMod);

  // Beat flash
  const flash = document.getElementById('beatFlash');
  if (combinedBeat > 0.7) {
    const rgb = hexToRgb(state.currentColor);
    flash.style.background = `radial-gradient(ellipse at center, rgba(${rgb.r},${rgb.g},${rgb.b},${combinedBeat * 0.15}) 0%, transparent 70%)`;
    flash.style.opacity = 1;
  } else {
    flash.style.opacity = 0;
  }

  // Global composition
  ctx.globalCompositeOperation = 'lighter';

  const t = state.time;

  switch (state.pattern) {
    case 'pulse': renderPulse(ctx, w, h, t, combinedBeat); break;
    case 'rainbow': renderRainbow(ctx, w, h, t, combinedBeat); break;
    case 'scanner': renderScanner(ctx, w, h, t, combinedBeat); break;
    case 'sparkle': renderSparkle(ctx, w, h, t, combinedBeat); break;
    case 'laser': renderLaser(ctx, w, h, t, combinedBeat); break;
    case 'fireworks': renderFireworks(ctx, w, h, t, combinedBeat); break;
    case 'matrix': renderMatrix(ctx, w, h, t, combinedBeat); break;
    case 'aurora': renderAurora(ctx, w, h, t, combinedBeat); break;
  }

  ctx.globalCompositeOperation = 'source-over';

  // Update and draw particles
  updateParticles(dt);
  drawParticles(ctx, w, h);

  // Fog/haze overlay
  const fogAlpha = 0.03 + combinedBeat * 0.02;
  const rgb = hexToRgb(state.currentColor);
  const fogGrad = ctx.createLinearGradient(0, h * 0.5, 0, h);
  fogGrad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
  fogGrad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},${fogAlpha})`);
  ctx.fillStyle = fogGrad;
  ctx.fillRect(0, 0, w, h);

  // Vignette
  const vig = ctx.createRadialGradient(w/2, h/2, w * 0.25, w/2, h/2, w * 0.65);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.4)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, w, h);
}

// ============ BACKGROUND ANIMATION ============
function renderBackground() {
  const w = bgCanvas.width;
  const h = bgCanvas.height;
  bgCtx.clearRect(0, 0, w, h);

  if (!state.running || state.blackout) return;

  const t = state.time;
  const color = state.currentColor;
  const rgb = hexToRgb(color);
  const intensity = (state.intensity / 100) * 0.04;

  // Subtle ambient glow behind controls
  const grad = bgCtx.createRadialGradient(w/2, h * 0.3, 0, w/2, h * 0.3, w * 0.5);
  grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${intensity})`);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  bgCtx.fillStyle = grad;
  bgCtx.fillRect(0, 0, w, h);

  // Floating orbs
  for (let i = 0; i < 5; i++) {
    const ox = w * (0.2 + 0.6 * ((Math.sin(t * 0.3 + i * 2.1) + 1) / 2));
    const oy = h * (0.2 + 0.6 * ((Math.cos(t * 0.25 + i * 1.7) + 1) / 2));
    const oGrad = bgCtx.createRadialGradient(ox, oy, 0, ox, oy, 100 + Math.sin(t + i) * 30);
    oGrad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${intensity * 0.5})`);
    oGrad.addColorStop(1, 'rgba(0,0,0,0)');
    bgCtx.fillStyle = oGrad;
    bgCtx.fillRect(ox - 150, oy - 150, 300, 300);
  }
}

// ============ AUDIO VISUALIZER UPDATE ============
function updateVizBars() {
  const bars = document.querySelectorAll('.viz-bar');
  bars.forEach((bar, i) => {
    let height = 3;
    if ((state.micActive || state.demoActive) && state.audioData[i] !== undefined) {
      height = 3 + state.audioData[i] * 37;
    } else if (state.running && !state.blackout) {
      // Simulated beats
      const beatInterval = 60 / state.bpm;
      const phase = (state.time / beatInterval) % 1;
      const beat = Math.pow(Math.max(0, 1 - phase * 3), 3);
      const freq = Math.sin(state.time * 4 + i * 0.5) * 0.3 + 0.3;
      height = 3 + (beat * 25 + freq * 10) * (state.intensity / 100);
    }
    bar.style.height = height + 'px';

    // Color based on height
    const ratio = (height - 3) / 37;
    if (ratio > 0.7) bar.style.background = 'linear-gradient(to top, #ff006e, #ff4444)';
    else if (ratio > 0.4) bar.style.background = 'linear-gradient(to top, #ffbe0b, #ff006e)';
    else bar.style.background = 'linear-gradient(to top, #3a86ff, #8338ec)';
  });
}

// ============ MAIN LOOP ============
let lastTime = 0;
function animate(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;

  state.time += dt * (state.speed / 50);

  updateAudioData();
  renderStage(dt);
  renderBackground();
  updateVizBars();

  requestAnimationFrame(animate);
}

// ============ INIT ============
function init() {
  buildUI();
  initSpotlights();
  resizeCanvases();
  window.addEventListener('resize', () => {
    resizeCanvases();
    initSpotlights();
  });

  // Auto-start show
  toggleShow();

  requestAnimationFrame(animate);
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
