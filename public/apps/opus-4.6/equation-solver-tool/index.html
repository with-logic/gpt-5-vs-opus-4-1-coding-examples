<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Equation Solver Tool</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400;1,500&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
<style>
  :root {
    --bg: #faf8f5;
    --bg-card: #ffffff;
    --text: #1a1a1a;
    --text-secondary: #555555;
    --text-muted: #888888;
    --accent: #8b0000;
    --accent-light: #a52a2a;
    --border: #e0dcd5;
    --border-light: #eee9e0;
    --step-bg: #fdfcfa;
    --step-border: #e8e3da;
    --highlight: #fff8e7;
    --shadow: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
    --shadow-lg: 0 4px 16px rgba(0,0,0,0.08), 0 2px 6px rgba(0,0,0,0.04);
    --radius: 6px;
    --transition: 0.25s ease;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Crimson Pro', 'Georgia', 'Times New Roman', serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.7;
    min-height: 100vh;
    -webkit-font-smoothing: antialiased;
  }

  header {
    text-align: center;
    padding: 48px 24px 36px;
    border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, #ffffff 0%, var(--bg) 100%);
  }

  header h1 {
    font-size: 2.2rem;
    font-weight: 600;
    letter-spacing: -0.02em;
    color: var(--text);
    margin-bottom: 6px;
  }

  header p {
    font-size: 1.1rem;
    color: var(--text-secondary);
    font-style: italic;
    font-weight: 300;
  }

  .ornament {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-top: 16px;
    color: var(--text-muted);
    font-size: 0.85rem;
    letter-spacing: 0.3em;
  }

  .ornament::before,
  .ornament::after {
    content: '';
    width: 60px;
    height: 1px;
    background: var(--border);
  }

  main {
    max-width: 780px;
    margin: 0 auto;
    padding: 36px 24px 80px;
  }

  .input-section {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 32px;
    box-shadow: var(--shadow);
    margin-bottom: 32px;
  }

  .input-section label {
    display: block;
    font-size: 1.05rem;
    font-weight: 500;
    margin-bottom: 10px;
    color: var(--text);
  }

  .input-row {
    display: flex;
    gap: 12px;
    align-items: stretch;
  }

  .input-row input {
    flex: 1;
    padding: 12px 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.05rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--step-bg);
    color: var(--text);
    outline: none;
    transition: border-color var(--transition), box-shadow var(--transition);
  }

  .input-row input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(139, 0, 0, 0.08);
  }

  .input-row input::placeholder {
    color: var(--text-muted);
    font-style: italic;
  }

  .btn {
    padding: 12px 28px;
    font-family: 'Crimson Pro', serif;
    font-size: 1.05rem;
    font-weight: 500;
    border: none;
    border-radius: var(--radius);
    cursor: pointer;
    transition: all var(--transition);
    white-space: nowrap;
  }

  .btn-primary {
    background: var(--accent);
    color: #fff;
  }

  .btn-primary:hover {
    background: var(--accent-light);
    box-shadow: 0 2px 8px rgba(139, 0, 0, 0.2);
  }

  .btn-primary:active {
    transform: translateY(1px);
  }

  .btn-secondary {
    background: transparent;
    color: var(--accent);
    border: 1px solid var(--accent);
    padding: 8px 20px;
    font-size: 0.95rem;
  }

  .btn-secondary:hover {
    background: rgba(139, 0, 0, 0.04);
  }

  .examples {
    margin-top: 16px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .examples span {
    font-size: 0.9rem;
    color: var(--text-muted);
    font-style: italic;
  }

  .example-btn {
    padding: 4px 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.82rem;
    background: var(--step-bg);
    border: 1px solid var(--border-light);
    border-radius: 20px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all var(--transition);
  }

  .example-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(139, 0, 0, 0.03);
  }

  .error-msg {
    background: #fef2f2;
    border: 1px solid #fecaca;
    color: #991b1b;
    padding: 12px 16px;
    border-radius: var(--radius);
    margin-top: 16px;
    font-size: 0.95rem;
    display: none;
  }

  .error-msg.show {
    display: block;
    animation: fadeIn 0.3s ease;
  }

  .results-section {
    display: none;
  }

  .results-section.show {
    display: block;
    animation: fadeIn 0.4s ease;
  }

  .result-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 14px;
    border-bottom: 1px solid var(--border);
  }

  .result-header h2 {
    font-size: 1.35rem;
    font-weight: 600;
    color: var(--text);
  }

  .export-buttons {
    display: flex;
    gap: 8px;
  }

  .equation-display {
    text-align: center;
    padding: 24px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 24px;
    box-shadow: var(--shadow);
  }

  .equation-display .katex {
    font-size: 1.5rem;
  }

  .equation-type {
    display: inline-block;
    margin-top: 10px;
    font-size: 0.85rem;
    color: var(--text-muted);
    font-style: italic;
    background: var(--step-bg);
    padding: 3px 12px;
    border-radius: 20px;
    border: 1px solid var(--border-light);
  }

  .solution-box {
    background: var(--highlight);
    border: 1px solid #e8d9a0;
    border-radius: var(--radius);
    padding: 20px 24px;
    margin-bottom: 28px;
    text-align: center;
  }

  .solution-box h3 {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--text-muted);
    margin-bottom: 8px;
    font-weight: 500;
  }

  .solution-box .solution-value {
    font-size: 1.3rem;
  }

  .solution-box .solution-value .katex {
    font-size: 1.35rem;
  }

  .steps-container {
    margin-bottom: 28px;
  }

  .steps-container h3 {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 16px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .steps-container h3::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  .step {
    display: flex;
    gap: 16px;
    margin-bottom: 2px;
    position: relative;
  }

  .step-number-col {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 36px;
  }

  .step-number {
    width: 32px;
    height: 32px;
    background: var(--accent);
    color: #fff;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.85rem;
    font-weight: 600;
    flex-shrink: 0;
    font-family: 'JetBrains Mono', monospace;
    position: relative;
    z-index: 1;
  }

  .step-line {
    width: 2px;
    flex: 1;
    background: var(--border-light);
    min-height: 12px;
  }

  .step:last-child .step-line {
    display: none;
  }

  .step-content {
    flex: 1;
    background: var(--bg-card);
    border: 1px solid var(--step-border);
    border-radius: var(--radius);
    padding: 16px 20px;
    margin-bottom: 12px;
    box-shadow: var(--shadow);
    transition: border-color var(--transition);
  }

  .step-content:hover {
    border-color: #d4cfc5;
  }

  .step-explanation {
    font-size: 1rem;
    color: var(--text-secondary);
    margin-bottom: 8px;
    line-height: 1.6;
  }

  .step-math {
    text-align: center;
    padding: 8px 0;
  }

  .step-math .katex {
    font-size: 1.15rem;
  }

  .verification-box {
    background: #f0fdf4;
    border: 1px solid #bbf7d0;
    border-radius: var(--radius);
    padding: 16px 20px;
    margin-bottom: 24px;
  }

  .verification-box h3 {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: #15803d;
    margin-bottom: 8px;
    font-weight: 500;
  }

  .verification-box .katex {
    font-size: 1.1rem;
  }

  .verification-check {
    color: #15803d;
    font-weight: 600;
    margin-top: 4px;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .loading {
    text-align: center;
    padding: 40px 20px;
    display: none;
  }

  .loading.show {
    display: block;
  }

  .loading-dots {
    display: inline-flex;
    gap: 6px;
  }

  .loading-dots span {
    width: 8px;
    height: 8px;
    background: var(--accent);
    border-radius: 50%;
    animation: bounce 1.2s infinite;
  }

  .loading-dots span:nth-child(2) { animation-delay: 0.15s; }
  .loading-dots span:nth-child(3) { animation-delay: 0.3s; }

  @keyframes bounce {
    0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }
    40% { transform: translateY(-8px); opacity: 1; }
  }

  footer {
    text-align: center;
    padding: 24px;
    color: var(--text-muted);
    font-size: 0.85rem;
    font-style: italic;
    border-top: 1px solid var(--border-light);
    margin-top: 40px;
  }

  .supported-ops {
    margin-top: 12px;
    font-size: 0.85rem;
    color: var(--text-muted);
    font-style: italic;
    line-height: 1.8;
  }

  /* Toast notification */
  .toast {
    position: fixed;
    bottom: 24px;
    right: 24px;
    background: var(--text);
    color: #fff;
    padding: 12px 20px;
    border-radius: var(--radius);
    font-size: 0.9rem;
    font-family: 'Crimson Pro', serif;
    box-shadow: var(--shadow-lg);
    transform: translateY(100px);
    opacity: 0;
    transition: all 0.3s ease;
    z-index: 1000;
  }

  .toast.show {
    transform: translateY(0);
    opacity: 1;
  }

  /* Responsive */
  @media (max-width: 640px) {
    header { padding: 32px 16px 24px; }
    header h1 { font-size: 1.6rem; }
    main { padding: 24px 16px 60px; }
    .input-section { padding: 20px; }
    .input-row { flex-direction: column; }
    .btn { width: 100%; text-align: center; }
    .result-header { flex-direction: column; gap: 12px; align-items: flex-start; }
    .export-buttons { width: 100%; }
    .export-buttons .btn-secondary { flex: 1; text-align: center; }
  }

  /* Print styles */
  @media print {
    body { background: #fff; }
    header { border-bottom: 2px solid #000; }
    .input-section, .export-buttons, .examples, footer, .toast { display: none !important; }
    .results-section { display: block !important; }
    .step-content { box-shadow: none; border: 1px solid #ccc; }
    .result-header { border-bottom: 1px solid #000; }
  }
</style>
</head>
<body>

<header>
  <h1>Equation Solver Tool</h1>
  <p>Solve and understand equations, step by step</p>
  <div class="ornament">&sect;</div>
</header>

<main>
  <div class="input-section">
    <label for="equation-input">Enter an equation</label>
    <div class="input-row">
      <input
        type="text"
        id="equation-input"
        placeholder="e.g., 2x + 5 = 13"
        autocomplete="off"
        spellcheck="false"
      >
      <button class="btn btn-primary" id="solve-btn" onclick="solveEquation()">Solve</button>
    </div>
    <div class="examples">
      <span>Try:</span>
      <button class="example-btn" onclick="loadExample('2x + 5 = 13')">2x + 5 = 13</button>
      <button class="example-btn" onclick="loadExample('x^2 - 5x + 6 = 0')">x² − 5x + 6 = 0</button>
      <button class="example-btn" onclick="loadExample('3(x - 2) = 2x + 7')">3(x − 2) = 2x + 7</button>
      <button class="example-btn" onclick="loadExample('x^2 + 4x + 4 = 0')">x² + 4x + 4 = 0</button>
      <button class="example-btn" onclick="loadExample('2x^2 - 8 = 0')">2x² − 8 = 0</button>
      <button class="example-btn" onclick="loadExample('|x - 3| = 7')">|x − 3| = 7</button>
      <button class="example-btn" onclick="loadExample('x/3 + 2 = 5')">x/3 + 2 = 5</button>
    </div>
    <div class="supported-ops">
      Supports linear equations, quadratic equations, absolute value equations, and basic algebraic expressions.
    </div>
    <div class="error-msg" id="error-msg"></div>
  </div>

  <div class="loading" id="loading">
    <div class="loading-dots">
      <span></span><span></span><span></span>
    </div>
    <p style="margin-top: 12px; color: var(--text-muted); font-style: italic;">Solving...</p>
  </div>

  <div class="results-section" id="results-section">
    <div class="result-header">
      <h2>Solution</h2>
      <div class="export-buttons">
        <button class="btn btn-secondary" onclick="exportAsText()">Export Text</button>
        <button class="btn btn-secondary" onclick="exportAsLaTeX()">Export LaTeX</button>
        <button class="btn btn-secondary" onclick="window.print()">Print</button>
      </div>
    </div>
    <div id="results-content"></div>
  </div>
</main>

<footer>
  Equation Solver Tool &mdash; A tool for learning and understanding algebra.
</footer>

<div class="toast" id="toast"></div>

<script>
// ─────────────────────────────────────────
// Utility: render KaTeX safely
// ─────────────────────────────────────────
function renderKaTeX(latex, displayMode = false) {
  try {
    return katex.renderToString(latex, { throwOnError: false, displayMode });
  } catch {
    return `<code>${latex}</code>`;
  }
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2500);
}

function loadExample(eq) {
  document.getElementById('equation-input').value = eq;
  document.getElementById('error-msg').classList.remove('show');
  solveEquation();
}

document.getElementById('equation-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') solveEquation();
});

// ─────────────────────────────────────────
// Tokenizer / Parser
// ─────────────────────────────────────────
function tokenize(expr) {
  const tokens = [];
  let i = 0;
  const s = expr.replace(/\s+/g, '');
  while (i < s.length) {
    const c = s[i];
    if ('0123456789.'.includes(c)) {
      let num = '';
      while (i < s.length && '0123456789.'.includes(s[i])) { num += s[i]; i++; }
      tokens.push({ type: 'num', value: parseFloat(num) });
    } else if (c === 'x' || c === 'X') {
      tokens.push({ type: 'var', value: 'x' });
      i++;
    } else if ('+-*/^'.includes(c)) {
      tokens.push({ type: 'op', value: c });
      i++;
    } else if (c === '(') {
      tokens.push({ type: 'lparen' });
      i++;
    } else if (c === ')') {
      tokens.push({ type: 'rparen' });
      i++;
    } else if (c === '|') {
      tokens.push({ type: 'abs' });
      i++;
    } else {
      i++;
    }
  }
  return tokens;
}

// ─────────────────────────────────────────
// Parse expression into polynomial {coeff for x^n}
// Represents ax^2 + bx + c as {0: c, 1: b, 2: a}
// ─────────────────────────────────────────
function parseToPolynomial(exprStr) {
  // Preprocess: insert * where implied (e.g., 2x => 2*x, )(=> )*(, etc.)
  let s = exprStr.replace(/\s+/g, '');
  let out = '';
  for (let i = 0; i < s.length; i++) {
    out += s[i];
    if (i + 1 < s.length) {
      const c = s[i], n = s[i + 1];
      const isDigitOrVar = ch => /[0-9.xX]/.test(ch);
      if ((/[0-9.]/.test(c) && /[xX(]/.test(n)) ||
          (/[xX]/.test(c) && /[0-9(]/.test(n)) ||
          (c === ')' && (isDigitOrVar(n) || n === '(')) ||
          (/[0-9.xX)]/.test(c) && n === '(') ||
          (c === ')' && /[xX]/.test(n))) {
        out += '*';
      }
    }
  }
  s = out;

  // Recursive descent parser
  let pos = 0;

  function peek() { return pos < s.length ? s[pos] : null; }
  function consume() { return s[pos++]; }

  function parseExpr() {
    let left = parseTerm();
    while (peek() === '+' || peek() === '-') {
      const op = consume();
      const right = parseTerm();
      if (op === '+') left = polyAdd(left, right);
      else left = polySub(left, right);
    }
    return left;
  }

  function parseTerm() {
    let left = parsePower();
    while (peek() === '*' || peek() === '/') {
      const op = consume();
      const right = parsePower();
      if (op === '*') left = polyMul(left, right);
      else left = polyDiv(left, right);
    }
    return left;
  }

  function parsePower() {
    let base = parseUnary();
    if (peek() === '^') {
      consume();
      const exp = parseUnary();
      // exp must be a constant
      const expVal = exp[0] || 0;
      if (!Number.isInteger(expVal) || expVal < 0 || expVal > 4) {
        throw new Error('Only non-negative integer exponents up to 4 are supported');
      }
      let result = { 0: 1 };
      for (let i = 0; i < expVal; i++) result = polyMul(result, base);
      return result;
    }
    return base;
  }

  function parseUnary() {
    if (peek() === '-') {
      consume();
      const p = parseUnary();
      return polyScale(p, -1);
    }
    if (peek() === '+') {
      consume();
      return parseUnary();
    }
    return parseAtom();
  }

  function parseAtom() {
    if (peek() === '(') {
      consume();
      const result = parseExpr();
      if (peek() === ')') consume();
      return result;
    }
    if (peek() === 'x' || peek() === 'X') {
      consume();
      return { 1: 1 };
    }
    // Number
    let num = '';
    while (pos < s.length && /[0-9.]/.test(s[pos])) {
      num += consume();
    }
    if (num === '') throw new Error('Unexpected character: ' + peek());
    return { 0: parseFloat(num) };
  }

  // Polynomial arithmetic
  function polyAdd(a, b) {
    const r = { ...a };
    for (const k in b) r[k] = (r[k] || 0) + b[k];
    return polyClean(r);
  }
  function polySub(a, b) {
    const r = { ...a };
    for (const k in b) r[k] = (r[k] || 0) - b[k];
    return polyClean(r);
  }
  function polyMul(a, b) {
    const r = {};
    for (const ka in a) for (const kb in b) {
      const k = parseInt(ka) + parseInt(kb);
      r[k] = (r[k] || 0) + a[ka] * b[kb];
    }
    return polyClean(r);
  }
  function polyDiv(a, b) {
    // b must be constant
    const bVal = b[0];
    if (!bVal) throw new Error('Division by zero or non-constant divisor');
    const keys = Object.keys(b).filter(k => Math.abs(b[k]) > 1e-12);
    if (keys.length !== 1 || keys[0] !== '0') throw new Error('Can only divide by constants');
    return polyScale(a, 1 / bVal);
  }
  function polyScale(p, s) {
    const r = {};
    for (const k in p) r[k] = p[k] * s;
    return polyClean(r);
  }
  function polyClean(p) {
    const r = {};
    for (const k in p) if (Math.abs(p[k]) > 1e-12) r[k] = p[k];
    return r;
  }

  const result = parseExpr();
  return result;
}

// ─────────────────────────────────────────
// Format helpers
// ─────────────────────────────────────────
function fmtNum(n) {
  if (Number.isInteger(n)) return n.toString();
  const r = Math.round(n * 10000) / 10000;
  return r.toString();
}

function fmtFrac(num, den) {
  if (den === 1) return fmtNum(num);
  if (den === -1) return fmtNum(-num);
  if (num < 0 && den < 0) { num = -num; den = -den; }
  if (den < 0) { num = -num; den = -den; }
  return `\\frac{${fmtNum(num)}}{${fmtNum(den)}}`;
}

function simplifyFraction(num, den) {
  if (den === 0) return [num, den];
  if (num === 0) return [0, 1];
  const g = gcd(Math.abs(Math.round(num)), Math.abs(Math.round(den)));
  let sn = Math.round(num) / g, sd = Math.round(den) / g;
  if (sd < 0) { sn = -sn; sd = -sd; }
  return [sn, sd];
}

function gcd(a, b) {
  a = Math.abs(Math.round(a));
  b = Math.abs(Math.round(b));
  while (b) { [a, b] = [b, a % b]; }
  return a;
}

function isCleanNumber(n) {
  return Math.abs(n - Math.round(n)) < 1e-9;
}

// ─────────────────────────────────────────
// Solver engine
// ─────────────────────────────────────────
let lastSolution = null;

function solveEquation() {
  const input = document.getElementById('equation-input').value.trim();
  const errorEl = document.getElementById('error-msg');
  const resultsEl = document.getElementById('results-section');
  const loadingEl = document.getElementById('loading');

  errorEl.classList.remove('show');
  resultsEl.classList.remove('show');

  if (!input) {
    errorEl.textContent = 'Please enter an equation to solve.';
    errorEl.classList.add('show');
    return;
  }

  // Check for absolute value equations
  if (input.includes('|')) {
    return solveAbsoluteValue(input);
  }

  // Must contain '='
  if (!input.includes('=')) {
    errorEl.textContent = 'Please enter an equation with an equals sign (=). For example: 2x + 3 = 7';
    errorEl.classList.add('show');
    return;
  }

  const [lhsStr, rhsStr] = input.split('=').map(s => s.trim());

  try {
    const lhs = parseToPolynomial(lhsStr);
    const rhs = parseToPolynomial(rhsStr);

    // Move everything to the left: lhs - rhs = 0
    const poly = {};
    for (const k in lhs) poly[k] = (poly[k] || 0) + (lhs[k] || 0);
    for (const k in rhs) poly[k] = (poly[k] || 0) - (rhs[k] || 0);

    // Clean
    for (const k in poly) if (Math.abs(poly[k]) < 1e-12) delete poly[k];

    // Determine degree
    const degrees = Object.keys(poly).map(Number).filter(k => Math.abs(poly[k] || 0) > 1e-12);
    const maxDeg = degrees.length > 0 ? Math.max(...degrees) : 0;

    // Show loading briefly
    loadingEl.classList.add('show');

    setTimeout(() => {
      loadingEl.classList.remove('show');

      try {
        if (maxDeg === 0) {
          // Constant equation: either 0=0 or contradiction
          const c = poly[0] || 0;
          if (Math.abs(c) < 1e-12) {
            displayIdentity(input);
          } else {
            displayContradiction(input);
          }
        } else if (maxDeg === 1) {
          solveLinear(input, lhsStr, rhsStr, poly);
        } else if (maxDeg === 2) {
          solveQuadratic(input, lhsStr, rhsStr, poly);
        } else {
          errorEl.textContent = 'Equations of degree ' + maxDeg + ' are not yet supported. Please enter a linear or quadratic equation.';
          errorEl.classList.add('show');
        }
      } catch (err) {
        errorEl.textContent = 'Error solving: ' + err.message;
        errorEl.classList.add('show');
      }
    }, 350);

  } catch (err) {
    errorEl.textContent = 'Could not parse the equation. Please check the syntax. (' + err.message + ')';
    errorEl.classList.add('show');
  }
}

// ─────────────────────────────────────────
// Linear solver: ax + b = 0
// ─────────────────────────────────────────
function solveLinear(original, lhsStr, rhsStr, poly) {
  const a = poly[1] || 0;
  const b = poly[0] || 0;
  const solution = -b / a;

  const steps = [];
  const latexSteps = [];

  // Step 1: Show the original equation
  steps.push({
    explanation: 'Start with the given equation.',
    latex: `${latexifyExpr(lhsStr)} = ${latexifyExpr(rhsStr)}`
  });

  // Determine what's on each side to give meaningful steps
  const lhs = parseToPolynomial(lhsStr);
  const rhs = parseToPolynomial(rhsStr);

  // Check if there are variables on both sides
  const lhsHasX = Object.keys(lhs).some(k => parseInt(k) > 0 && Math.abs(lhs[k]) > 1e-12);
  const rhsHasX = Object.keys(rhs).some(k => parseInt(k) > 0 && Math.abs(rhs[k]) > 1e-12);

  if (lhsHasX && rhsHasX) {
    // Variables on both sides
    const rhsXCoeff = rhs[1] || 0;
    if (rhsXCoeff > 0) {
      steps.push({
        explanation: `Subtract ${renderKaTeX(fmtNum(rhsXCoeff) + 'x')} from both sides to collect variable terms on the left.`,
        latex: `${fmtNum(a)}x + ${fmtNum(b)} = 0`
      });
    } else {
      steps.push({
        explanation: `Add ${renderKaTeX(fmtNum(-rhsXCoeff) + 'x')} to both sides to collect variable terms on the left.`,
        latex: `${fmtNum(a)}x + ${fmtNum(b)} = 0`
      });
    }
  }

  // If there's a constant on the same side as x
  if (Math.abs(b) > 1e-12) {
    const addOrSub = b > 0 ? `Subtract ${renderKaTeX(fmtNum(b))} from` : `Add ${renderKaTeX(fmtNum(-b))} to`;
    steps.push({
      explanation: `${addOrSub} both sides to isolate the variable term.`,
      latex: `${fmtNum(a)}x = ${fmtNum(-b)}`
    });
  }

  // If coefficient isn't 1
  if (Math.abs(a) > 1e-12 && Math.abs(a - 1) > 1e-12 && Math.abs(a + 1) > 1e-12) {
    steps.push({
      explanation: `Divide both sides by ${renderKaTeX(fmtNum(a))} to solve for ${renderKaTeX('x')}.`,
      latex: `x = ${fmtNum(-b)} \\div ${fmtNum(a)}`
    });
  } else if (Math.abs(a + 1) < 1e-12) {
    steps.push({
      explanation: `Divide both sides by ${renderKaTeX('-1')} to solve for ${renderKaTeX('x')}.`,
      latex: `x = ${fmtNum(-b)} \\div (-1)`
    });
  }

  // Final answer
  let solutionLatex;
  if (isCleanNumber(solution)) {
    solutionLatex = `x = ${fmtNum(solution)}`;
  } else {
    const [sn, sd] = simplifyFraction(Math.round(-b * 1000), Math.round(a * 1000));
    const [fn, fd] = simplifyFraction(sn, sd);
    solutionLatex = `x = ${fmtFrac(fn, fd)}`;
  }

  steps.push({
    explanation: 'The solution is:',
    latex: solutionLatex
  });

  // Verification
  const verifyLatex = buildVerification(lhsStr, rhsStr, solution);

  lastSolution = {
    type: 'Linear Equation',
    original,
    solutionLatex,
    solutions: [solution],
    steps,
    verification: verifyLatex,
    lhsStr,
    rhsStr
  };

  renderResults(lastSolution);
}

// ─────────────────────────────────────────
// Quadratic solver: ax² + bx + c = 0
// ─────────────────────────────────────────
function solveQuadratic(original, lhsStr, rhsStr, poly) {
  const a = poly[2] || 0;
  const b = poly[1] || 0;
  const c = poly[0] || 0;

  const discriminant = b * b - 4 * a * c;
  const steps = [];

  // Step 1: original
  steps.push({
    explanation: 'Start with the given equation.',
    latex: `${latexifyExpr(lhsStr)} = ${latexifyExpr(rhsStr)}`
  });

  // Step 2: standard form if RHS isn't 0
  const rhs = parseToPolynomial(rhsStr);
  const rhsIsZero = Object.keys(rhs).every(k => Math.abs(rhs[k] || 0) < 1e-12);

  if (!rhsIsZero) {
    steps.push({
      explanation: 'Rearrange into standard form by moving all terms to one side.',
      latex: `${fmtPolyLatex(a, b, c)} = 0`
    });
  }

  // Step 3: Identify coefficients
  steps.push({
    explanation: `Identify the coefficients: ${renderKaTeX(`a = ${fmtNum(a)}`)} , ${renderKaTeX(`b = ${fmtNum(b)}`)} , ${renderKaTeX(`c = ${fmtNum(c)}`)}.`,
    latex: `a = ${fmtNum(a)}, \\quad b = ${fmtNum(b)}, \\quad c = ${fmtNum(c)}`
  });

  // Step 4: Discriminant
  steps.push({
    explanation: `Calculate the discriminant ${renderKaTeX('\\Delta = b^2 - 4ac')}.`,
    latex: `\\Delta = (${fmtNum(b)})^2 - 4(${fmtNum(a)})(${fmtNum(c)}) = ${fmtNum(b * b)} - ${fmtNum(4 * a * c)} = ${fmtNum(discriminant)}`
  });

  let solutionLatex;
  let solutions = [];

  if (discriminant > 0) {
    // Two real roots
    steps.push({
      explanation: `Since ${renderKaTeX('\\Delta > 0')}, there are two distinct real solutions.`,
      latex: `x = \\frac{-b \\pm \\sqrt{\\Delta}}{2a}`
    });

    const sqrtD = Math.sqrt(discriminant);
    const x1 = (-b + sqrtD) / (2 * a);
    const x2 = (-b - sqrtD) / (2 * a);
    solutions = [x1, x2];

    steps.push({
      explanation: 'Apply the quadratic formula.',
      latex: `x = \\frac{${fmtNum(-b)} \\pm \\sqrt{${fmtNum(discriminant)}}}{${fmtNum(2 * a)}} = \\frac{${fmtNum(-b)} \\pm ${fmtNum(sqrtD)}}{${fmtNum(2 * a)}}`
    });

    // Format solutions nicely
    let x1Latex, x2Latex;
    if (isCleanNumber(x1) && isCleanNumber(x2)) {
      x1Latex = fmtNum(Math.round(x1));
      x2Latex = fmtNum(Math.round(x2));
    } else if (isCleanNumber(discriminant) && isCleanNumber(Math.sqrt(discriminant))) {
      const [n1, d1] = simplifyFraction(-b + sqrtD, 2 * a);
      const [n2, d2] = simplifyFraction(-b - sqrtD, 2 * a);
      x1Latex = d1 === 1 ? fmtNum(n1) : fmtFrac(n1, d1);
      x2Latex = d2 === 1 ? fmtNum(n2) : fmtFrac(n2, d2);
    } else {
      x1Latex = fmtNum(x1);
      x2Latex = fmtNum(x2);
    }

    solutionLatex = `x_1 = ${x1Latex}, \\quad x_2 = ${x2Latex}`;

    steps.push({
      explanation: 'The solutions are:',
      latex: solutionLatex
    });

  } else if (Math.abs(discriminant) < 1e-10) {
    // One repeated root
    const x = -b / (2 * a);
    solutions = [x];

    steps.push({
      explanation: `Since ${renderKaTeX('\\Delta = 0')}, there is exactly one repeated real solution.`,
      latex: `x = \\frac{-b}{2a} = \\frac{${fmtNum(-b)}}{${fmtNum(2 * a)}}`
    });

    let xLatex;
    if (isCleanNumber(x)) {
      xLatex = fmtNum(Math.round(x));
    } else {
      const [n, d] = simplifyFraction(-b, 2 * a);
      xLatex = d === 1 ? fmtNum(n) : fmtFrac(n, d);
    }

    solutionLatex = `x = ${xLatex}`;

    steps.push({
      explanation: 'The solution is:',
      latex: solutionLatex
    });

  } else {
    // Complex roots
    const realPart = -b / (2 * a);
    const imagPart = Math.sqrt(-discriminant) / (2 * a);

    steps.push({
      explanation: `Since ${renderKaTeX('\\Delta < 0')}, the solutions are complex (non-real).`,
      latex: `x = \\frac{-b \\pm \\sqrt{\\Delta}}{2a} = \\frac{${fmtNum(-b)} \\pm \\sqrt{${fmtNum(discriminant)}}}{${fmtNum(2 * a)}}`
    });

    solutionLatex = `x = ${fmtNum(realPart)} \\pm ${fmtNum(Math.abs(imagPart))}i`;
    solutions = [{ re: realPart, im: imagPart }, { re: realPart, im: -imagPart }];

    steps.push({
      explanation: 'The complex solutions are:',
      latex: solutionLatex
    });
  }

  // Verification (only for real solutions)
  let verifyLatex = null;
  if (typeof solutions[0] === 'number') {
    verifyLatex = buildVerification(lhsStr, rhsStr, solutions[0]);
  }

  // Also try factoring for presentation
  let factorNote = null;
  if (typeof solutions[0] === 'number' && typeof solutions[1] === 'number' &&
      isCleanNumber(solutions[0]) && isCleanNumber(solutions[1])) {
    const r1 = Math.round(solutions[0]), r2 = Math.round(solutions[1]);
    let factorLatex;
    if (Math.abs(a - 1) < 1e-12) {
      const s1 = r1 >= 0 ? `(x - ${r1})` : `(x + ${-r1})`;
      const s2 = r2 >= 0 ? `(x - ${r2})` : `(x + ${-r2})`;
      factorLatex = `${s1}${s2} = 0`;
    } else {
      factorLatex = `${fmtNum(a)}(x - ${fmtNum(r1)})(x - ${fmtNum(r2)}) = 0`;
    }
    factorNote = factorLatex;
  }

  lastSolution = {
    type: 'Quadratic Equation',
    original,
    solutionLatex,
    solutions,
    steps,
    verification: verifyLatex,
    factorNote,
    lhsStr,
    rhsStr
  };

  renderResults(lastSolution);
}

// ─────────────────────────────────────────
// Absolute value solver: |expr| = value
// ─────────────────────────────────────────
function solveAbsoluteValue(original) {
  const errorEl = document.getElementById('error-msg');
  const loadingEl = document.getElementById('loading');

  if (!original.includes('=')) {
    errorEl.textContent = 'Please include an equals sign (=) in the equation.';
    errorEl.classList.add('show');
    return;
  }

  // Parse |expr| = value form
  const eqParts = original.split('=');
  let absExprStr, otherStr;
  let absOnLeft = true;

  if (eqParts[0].includes('|')) {
    absExprStr = eqParts[0].trim();
    otherStr = eqParts[1].trim();
  } else {
    absExprStr = eqParts[1].trim();
    otherStr = eqParts[0].trim();
    absOnLeft = false;
  }

  // Extract content inside | |
  const absMatch = absExprStr.match(/\|(.+)\|/);
  if (!absMatch) {
    errorEl.textContent = 'Could not parse the absolute value expression. Use format: |expression| = value';
    errorEl.classList.add('show');
    return;
  }

  const innerExpr = absMatch[1];
  let otherVal;
  try {
    const otherPoly = parseToPolynomial(otherStr);
    if (Object.keys(otherPoly).some(k => parseInt(k) > 0 && Math.abs(otherPoly[k]) > 1e-12)) {
      errorEl.textContent = 'The right side of an absolute value equation must be a constant.';
      errorEl.classList.add('show');
      return;
    }
    otherVal = otherPoly[0] || 0;
  } catch {
    errorEl.textContent = 'Could not parse the right side of the equation.';
    errorEl.classList.add('show');
    return;
  }

  loadingEl.classList.add('show');

  setTimeout(() => {
    loadingEl.classList.remove('show');

    const steps = [];

    steps.push({
      explanation: 'Start with the given equation.',
      latex: `|${latexifyExpr(innerExpr)}| = ${fmtNum(otherVal)}`
    });

    if (otherVal < 0) {
      steps.push({
        explanation: `An absolute value cannot be negative. Since ${renderKaTeX(fmtNum(otherVal) + ' < 0')}, there is no solution.`,
        latex: `|${latexifyExpr(innerExpr)}| \\geq 0 > ${fmtNum(otherVal)}`
      });

      lastSolution = {
        type: 'Absolute Value Equation',
        original,
        solutionLatex: '\\text{No solution}',
        solutions: [],
        steps,
        verification: null,
        noSolution: true
      };
      renderResults(lastSolution);
      return;
    }

    if (Math.abs(otherVal) < 1e-12) {
      steps.push({
        explanation: 'Since the absolute value equals zero, the expression inside must equal zero.',
        latex: `${latexifyExpr(innerExpr)} = 0`
      });

      // Solve innerExpr = 0
      try {
        const inner = parseToPolynomial(innerExpr);
        const a = inner[1] || 0;
        const b = inner[0] || 0;
        const x = -b / a;

        steps.push({
          explanation: 'Solving for x:',
          latex: `x = ${fmtNum(x)}`
        });

        lastSolution = {
          type: 'Absolute Value Equation',
          original,
          solutionLatex: `x = ${fmtNum(x)}`,
          solutions: [x],
          steps,
          verification: null
        };
        renderResults(lastSolution);
      } catch (e) {
        errorEl.textContent = 'Could not solve the inner expression.';
        errorEl.classList.add('show');
      }
      return;
    }

    steps.push({
      explanation: `By the definition of absolute value, if ${renderKaTeX(`|A| = ${fmtNum(otherVal)}`)}, then ${renderKaTeX(`A = ${fmtNum(otherVal)}`)} or ${renderKaTeX(`A = ${fmtNum(-otherVal)}`)}.`,
      latex: `${latexifyExpr(innerExpr)} = ${fmtNum(otherVal)} \\quad \\text{or} \\quad ${latexifyExpr(innerExpr)} = ${fmtNum(-otherVal)}`
    });

    // Solve both cases
    try {
      const inner = parseToPolynomial(innerExpr);
      const a = inner[1] || 0;
      const b = inner[0] || 0;

      // Case 1: innerExpr = otherVal
      const x1 = (otherVal - b) / a;
      // Case 2: innerExpr = -otherVal
      const x2 = (-otherVal - b) / a;

      steps.push({
        explanation: `<strong>Case 1:</strong> ${renderKaTeX(`${latexifyExpr(innerExpr)} = ${fmtNum(otherVal)}`)}`,
        latex: `x = ${fmtNum(x1)}`
      });

      steps.push({
        explanation: `<strong>Case 2:</strong> ${renderKaTeX(`${latexifyExpr(innerExpr)} = ${fmtNum(-otherVal)}`)}`,
        latex: `x = ${fmtNum(x2)}`
      });

      const solutionLatex = `x = ${fmtNum(x1)} \\quad \\text{or} \\quad x = ${fmtNum(x2)}`;

      steps.push({
        explanation: 'The solutions are:',
        latex: solutionLatex
      });

      lastSolution = {
        type: 'Absolute Value Equation',
        original,
        solutionLatex,
        solutions: [x1, x2],
        steps,
        verification: null
      };
      renderResults(lastSolution);
    } catch (e) {
      errorEl.textContent = 'Could not solve: ' + e.message;
      errorEl.classList.add('show');
    }
  }, 350);
}

// ─────────────────────────────────────────
// Special cases
// ─────────────────────────────────────────
function displayIdentity(original) {
  const steps = [
    { explanation: 'Start with the given equation.', latex: latexifyExpr(original.split('=')[0]) + ' = ' + latexifyExpr(original.split('=')[1]) },
    { explanation: 'After simplifying both sides, all terms cancel out, yielding:', latex: '0 = 0' },
    { explanation: 'This is always true. The equation is an <em>identity</em>, meaning every real number is a solution.', latex: 'x \\in \\mathbb{R}' }
  ];

  lastSolution = {
    type: 'Identity',
    original,
    solutionLatex: 'x \\in \\mathbb{R} \\quad \\text{(all real numbers)}',
    solutions: ['all'],
    steps,
    verification: null,
    identity: true
  };
  renderResults(lastSolution);
}

function displayContradiction(original) {
  const steps = [
    { explanation: 'Start with the given equation.', latex: latexifyExpr(original.split('=')[0]) + ' = ' + latexifyExpr(original.split('=')[1]) },
    { explanation: 'After simplifying, the equation reduces to a false statement.', latex: '0 \\neq \\text{nonzero}' },
    { explanation: 'This is a <em>contradiction</em>. There is no value of x that satisfies this equation.', latex: '\\text{No solution}' }
  ];

  lastSolution = {
    type: 'Contradiction',
    original,
    solutionLatex: '\\text{No solution}',
    solutions: [],
    steps,
    verification: null,
    noSolution: true
  };
  renderResults(lastSolution);
}

// ─────────────────────────────────────────
// Format polynomial ax²+bx+c as LaTeX
// ─────────────────────────────────────────
function fmtPolyLatex(a, b, c) {
  let parts = [];
  if (Math.abs(a) > 1e-12) {
    if (Math.abs(a - 1) < 1e-12) parts.push('x^2');
    else if (Math.abs(a + 1) < 1e-12) parts.push('-x^2');
    else parts.push(fmtNum(a) + 'x^2');
  }
  if (Math.abs(b) > 1e-12) {
    if (parts.length > 0) {
      if (b > 0) parts.push('+ ' + (Math.abs(b - 1) < 1e-12 ? '' : fmtNum(b)) + 'x');
      else parts.push('- ' + (Math.abs(b + 1) < 1e-12 ? '' : fmtNum(-b)) + 'x');
    } else {
      if (Math.abs(b - 1) < 1e-12) parts.push('x');
      else if (Math.abs(b + 1) < 1e-12) parts.push('-x');
      else parts.push(fmtNum(b) + 'x');
    }
  }
  if (Math.abs(c) > 1e-12) {
    if (parts.length > 0) {
      if (c > 0) parts.push('+ ' + fmtNum(c));
      else parts.push('- ' + fmtNum(-c));
    } else {
      parts.push(fmtNum(c));
    }
  }
  if (parts.length === 0) return '0';
  return parts.join(' ');
}

// ─────────────────────────────────────────
// Convert expression string to LaTeX
// ─────────────────────────────────────────
function latexifyExpr(expr) {
  let s = expr.trim();
  // Replace ^ with LaTeX power
  s = s.replace(/\^(\d+)/g, '^{$1}');
  // Replace * with \cdot
  s = s.replace(/\*/g, ' \\cdot ');
  // Handle fractions like x/3
  s = s.replace(/(\w+)\/(\w+)/g, '\\frac{$1}{$2}');
  // |expr| => \left| expr \right|
  s = s.replace(/\|([^|]+)\|/g, '\\left|$1\\right|');
  return s;
}

// ─────────────────────────────────────────
// Build verification string
// ─────────────────────────────────────────
function buildVerification(lhsStr, rhsStr, x) {
  function evalExpr(exprStr, xVal) {
    let s = exprStr.replace(/\s/g, '');
    // Insert multiplication signs
    s = s.replace(/(\d)([xX])/g, '$1*$2');
    s = s.replace(/([xX])(\d)/g, '$1*$2');
    s = s.replace(/\)(\d)/g, ')*$1');
    s = s.replace(/(\d)\(/g, '$1*(');
    s = s.replace(/\)\(/g, ')*(');
    s = s.replace(/([xX])\(/g, '$1*(');
    s = s.replace(/\)([xX])/g, ')*$1');
    // Replace x with value
    s = s.replace(/[xX]/g, `(${xVal})`);
    // Replace ^ with **
    s = s.replace(/\^/g, '**');
    // Handle absolute values
    s = s.replace(/\|([^|]+)\|/g, 'Math.abs($1)');
    try {
      return Function('"use strict"; return (' + s + ')')();
    } catch {
      return NaN;
    }
  }

  const lhsVal = evalExpr(lhsStr, x);
  const rhsVal = evalExpr(rhsStr, x);

  if (isNaN(lhsVal) || isNaN(rhsVal)) return null;

  const xDisplay = isCleanNumber(x) ? fmtNum(x) : fmtNum(x);
  return {
    latex: `\\text{LHS} = ${fmtNum(Math.round(lhsVal * 10000) / 10000)}, \\quad \\text{RHS} = ${fmtNum(Math.round(rhsVal * 10000) / 10000)}`,
    equal: Math.abs(lhsVal - rhsVal) < 1e-6,
    xUsed: xDisplay
  };
}

// ─────────────────────────────────────────
// Render the results
// ─────────────────────────────────────────
function renderResults(sol) {
  const container = document.getElementById('results-content');
  const resultsEl = document.getElementById('results-section');

  let html = '';

  // Equation display
  html += `<div class="equation-display">`;
  html += renderKaTeX(latexifyExpr(sol.original.replace('=', ' = ')), true);
  html += `<div class="equation-type">${sol.type}</div>`;
  html += `</div>`;

  // Solution box
  html += `<div class="solution-box">`;
  html += `<h3>Solution</h3>`;
  html += `<div class="solution-value">${renderKaTeX(sol.solutionLatex, true)}</div>`;
  html += `</div>`;

  // Steps
  html += `<div class="steps-container">`;
  html += `<h3>Step-by-Step Solution</h3>`;

  sol.steps.forEach((step, i) => {
    html += `<div class="step">`;
    html += `<div class="step-number-col">`;
    html += `<div class="step-number">${i + 1}</div>`;
    html += `<div class="step-line"></div>`;
    html += `</div>`;
    html += `<div class="step-content">`;
    html += `<div class="step-explanation">${step.explanation}</div>`;
    html += `<div class="step-math">${renderKaTeX(step.latex, true)}</div>`;
    html += `</div>`;
    html += `</div>`;
  });

  html += `</div>`;

  // Factor note for quadratics
  if (sol.factorNote) {
    html += `<div class="solution-box" style="background: #f0f7ff; border-color: #bbd4f0;">`;
    html += `<h3>Factored Form</h3>`;
    html += `<div class="solution-value">${renderKaTeX(sol.factorNote, true)}</div>`;
    html += `</div>`;
  }

  // Verification
  if (sol.verification && sol.verification.equal) {
    html += `<div class="verification-box">`;
    html += `<h3>Verification</h3>`;
    html += `<p>Substituting ${renderKaTeX('x = ' + sol.verification.xUsed)} back into the original equation:</p>`;
    html += `<div style="text-align:center;margin:8px 0">${renderKaTeX(sol.verification.latex, true)}</div>`;
    html += `<p class="verification-check">&#10003; Both sides are equal. The solution is verified.</p>`;
    html += `</div>`;
  }

  container.innerHTML = html;
  resultsEl.classList.add('show');

  // Scroll to results
  resultsEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// ─────────────────────────────────────────
// Export functions
// ─────────────────────────────────────────
function exportAsText() {
  if (!lastSolution) return;
  const sol = lastSolution;

  let text = '═══════════════════════════════════════\n';
  text += '  EQUATION SOLVER - Solution Report\n';
  text += '═══════════════════════════════════════\n\n';
  text += `Equation: ${sol.original}\n`;
  text += `Type: ${sol.type}\n\n`;
  text += `─── Solution ───\n`;

  if (sol.solutions && sol.solutions.length > 0 && typeof sol.solutions[0] === 'number') {
    sol.solutions.forEach((s, i) => {
      if (sol.solutions.length === 1) text += `  x = ${fmtNum(s)}\n`;
      else text += `  x${i + 1} = ${fmtNum(s)}\n`;
    });
  } else if (sol.identity) {
    text += '  x ∈ ℝ (all real numbers)\n';
  } else if (sol.noSolution) {
    text += '  No solution\n';
  } else if (sol.solutions && sol.solutions[0] && sol.solutions[0].re !== undefined) {
    text += `  x = ${fmtNum(sol.solutions[0].re)} ± ${fmtNum(Math.abs(sol.solutions[0].im))}i\n`;
  }

  text += `\n─── Steps ───\n`;
  sol.steps.forEach((step, i) => {
    const cleanExpl = step.explanation.replace(/<[^>]+>/g, '').replace(/&[^;]+;/g, '');
    text += `\n  Step ${i + 1}: ${cleanExpl}\n`;
    // Convert LaTeX to plain-ish text
    let plainMath = step.latex
      .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1)/($2)')
      .replace(/\\quad/g, '   ')
      .replace(/\\text\{([^}]+)\}/g, '$1')
      .replace(/\\left\|/g, '|').replace(/\\right\|/g, '|')
      .replace(/\\pm/g, '±').replace(/\\cdot/g, '·')
      .replace(/\\sqrt\{([^}]+)\}/g, '√($1)')
      .replace(/\\geq/g, '≥').replace(/\\neq/g, '≠')
      .replace(/\\mathbb\{R\}/g, 'ℝ')
      .replace(/\\div/g, '÷')
      .replace(/\^{(\d+)}/g, '^$1')
      .replace(/\\/g, '');
    text += `           ${plainMath}\n`;
  });

  if (sol.verification && sol.verification.equal) {
    text += `\n─── Verification ───\n`;
    text += `  Substituting x = ${sol.verification.xUsed}: ✓ Verified\n`;
  }

  text += `\n═══════════════════════════════════════\n`;

  downloadFile(text, 'equation-solution.txt', 'text/plain');
  showToast('Solution exported as text');
}

function exportAsLaTeX() {
  if (!lastSolution) return;
  const sol = lastSolution;

  let tex = '\\documentclass{article}\n';
  tex += '\\usepackage{amsmath, amssymb}\n';
  tex += '\\title{Equation Solution}\n';
  tex += '\\date{}\n';
  tex += '\\begin{document}\n';
  tex += '\\maketitle\n\n';
  tex += '\\section*{Problem}\n';
  tex += `\\[ ${latexifyExpr(sol.original.replace('=', ' = '))} \\]\n\n`;
  tex += `\\textit{Type: ${sol.type}}\n\n`;
  tex += '\\section*{Solution}\n';
  tex += `\\[ ${sol.solutionLatex} \\]\n\n`;
  tex += '\\section*{Step-by-Step}\n';
  tex += '\\begin{enumerate}\n';

  sol.steps.forEach(step => {
    const cleanExpl = step.explanation.replace(/<[^>]+>/g, '').replace(/&[^;]+;/g, '');
    tex += `  \\item ${cleanExpl}\n`;
    tex += `  \\[ ${step.latex} \\]\n`;
  });

  tex += '\\end{enumerate}\n\n';

  if (sol.verification && sol.verification.equal) {
    tex += '\\section*{Verification}\n';
    tex += `Substituting $x = ${sol.verification.xUsed}$ confirms the solution. \\checkmark\n`;
  }

  tex += '\\end{document}\n';

  downloadFile(tex, 'equation-solution.tex', 'text/x-latex');
  showToast('Solution exported as LaTeX');
}

function downloadFile(content, filename, mimeType) {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
</script>

</body>
</html>
