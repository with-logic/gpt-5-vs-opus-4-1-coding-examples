<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Typing Rain</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    background: #050510;
    font-family: 'Share Tech Mono', monospace;
    user-select: none;
    height: 100vh;
    width: 100vw;
  }

  canvas#bgCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
  }

  #gameContainer {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
    overflow: hidden;
  }

  /* HUD */
  #hud {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 10;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 30px;
    background: linear-gradient(180deg, rgba(0,0,0,0.75) 0%, rgba(0,0,0,0.3) 60%, rgba(0,0,0,0) 100%);
    pointer-events: none;
  }

  .hud-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
    min-width: 80px;
  }

  .hud-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    letter-spacing: 3px;
    color: rgba(100, 180, 255, 0.5);
    text-transform: uppercase;
  }

  .hud-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 20px;
    font-weight: 700;
    color: #e0f0ff;
    text-shadow: 0 0 10px rgba(100, 180, 255, 0.4);
  }

  #comboDisplay {
    position: fixed;
    top: 68px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    font-family: 'Orbitron', sans-serif;
    font-size: 20px;
    font-weight: 700;
    color: #ffcc00;
    text-shadow: 0 0 20px rgba(255, 204, 0, 0.7);
    opacity: 0;
    transition: opacity 0.3s, transform 0.3s;
    pointer-events: none;
  }

  #comboDisplay.visible {
    opacity: 1;
    transform: translateX(-50%) scale(1.1);
  }

  /* Input area */
  #inputArea {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
  }

  #typingInput {
    width: 340px;
    padding: 14px 24px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 22px;
    color: #e0f0ff;
    background: rgba(8, 15, 30, 0.9);
    border: 2px solid rgba(100, 180, 255, 0.25);
    border-radius: 12px;
    outline: none;
    text-align: center;
    letter-spacing: 3px;
    backdrop-filter: blur(12px);
    transition: border-color 0.3s, box-shadow 0.3s;
  }

  #typingInput:focus {
    border-color: rgba(100, 180, 255, 0.6);
    box-shadow: 0 0 30px rgba(100, 180, 255, 0.15), 0 0 60px rgba(100, 180, 255, 0.05), inset 0 0 20px rgba(100, 180, 255, 0.03);
  }

  #typingInput::placeholder { color: rgba(100, 180, 255, 0.25); letter-spacing: 4px; }

  /* Danger zone */
  #dangerZone {
    position: fixed;
    bottom: 85px;
    left: 0; right: 0;
    height: 3px;
    z-index: 5;
    background: linear-gradient(90deg,
      transparent 0%, rgba(255,60,60,0) 5%,
      rgba(255,60,60,0.15) 20%, rgba(255,60,60,0.5) 50%,
      rgba(255,60,60,0.15) 80%, rgba(255,60,60,0) 95%, transparent 100%
    );
    pointer-events: none;
    animation: dangerPulse 2s ease-in-out infinite;
  }

  @keyframes dangerPulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }

  /* Overlay screens */
  .overlay-screen {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 100;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(3, 3, 15, 0.93);
    backdrop-filter: blur(10px);
    transition: opacity 0.6s ease;
  }

  .overlay-screen.hidden { opacity: 0; pointer-events: none; }

  .overlay-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 56px;
    font-weight: 900;
    color: #e0f0ff;
    text-shadow: 0 0 40px rgba(80,160,255,0.5), 0 0 80px rgba(80,160,255,0.2);
    margin-bottom: 6px;
    letter-spacing: 6px;
  }

  .title-accent {
    display: block;
    font-size: 14px;
    letter-spacing: 12px;
    color: rgba(0,229,255,0.5);
    margin-top: 4px;
    font-weight: 400;
  }

  .overlay-subtitle {
    font-family: 'Share Tech Mono', monospace;
    font-size: 15px;
    color: rgba(100, 180, 255, 0.5);
    margin-bottom: 16px;
    letter-spacing: 2px;
    text-align: center;
    line-height: 1.6;
  }

  .controls-hint {
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px;
    color: rgba(100, 180, 255, 0.3);
    margin-bottom: 36px;
    letter-spacing: 1px;
  }

  .controls-hint kbd {
    display: inline-block;
    padding: 2px 8px;
    border: 1px solid rgba(100,180,255,0.2);
    border-radius: 4px;
    background: rgba(100,180,255,0.05);
    color: rgba(100,180,255,0.5);
    font-size: 11px;
  }

  .overlay-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 15px;
    font-weight: 700;
    color: #e0f0ff;
    background: linear-gradient(135deg, rgba(0,229,255,0.12), rgba(0,229,255,0.03));
    border: 2px solid rgba(0,229,255,0.35);
    border-radius: 10px;
    padding: 15px 48px;
    cursor: pointer;
    letter-spacing: 4px;
    transition: all 0.3s;
    text-transform: uppercase;
    position: relative;
    overflow: hidden;
  }

  .overlay-btn::before {
    content: '';
    position: absolute;
    top: 0; left: -100%; width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0,229,255,0.1), transparent);
    transition: left 0.5s;
  }

  .overlay-btn:hover::before { left: 100%; }

  .overlay-btn:hover {
    background: linear-gradient(135deg, rgba(0,229,255,0.25), rgba(0,229,255,0.08));
    border-color: rgba(0,229,255,0.7);
    box-shadow: 0 0 30px rgba(0,229,255,0.25), inset 0 0 20px rgba(0,229,255,0.05);
    transform: translateY(-2px);
  }

  .stat-row {
    display: flex;
    justify-content: space-between;
    width: 300px;
    margin: 10px 0;
    font-size: 15px;
    color: rgba(180, 210, 255, 0.7);
  }

  .stat-row .stat-val {
    color: #e0f0ff;
    font-weight: 700;
    text-shadow: 0 0 8px rgba(100,180,255,0.3);
  }

  .stats-block {
    margin-bottom: 32px;
    padding: 24px 32px;
    background: rgba(100, 180, 255, 0.04);
    border: 1px solid rgba(100, 180, 255, 0.12);
    border-radius: 14px;
    backdrop-filter: blur(5px);
  }

  /* Falling word */
  .falling-word {
    position: absolute;
    font-family: 'Share Tech Mono', monospace;
    font-size: 18px;
    color: rgba(180, 215, 255, 0.85);
    pointer-events: none;
    white-space: nowrap;
    z-index: 2;
    padding: 4px 10px;
    border-radius: 4px;
    background: rgba(20, 40, 80, 0.25);
    border-left: 2px solid rgba(100, 180, 255, 0.2);
    text-shadow: 0 0 6px rgba(100, 180, 255, 0.3);
    transition: background 0.2s, border-color 0.2s;
  }

  .falling-word::before {
    content: '';
    position: absolute;
    top: -20px;
    left: 50%;
    width: 1px;
    height: 20px;
    background: linear-gradient(180deg, transparent, rgba(100,180,255,0.3));
  }

  .falling-word.targeted {
    color: #ffffff;
    background: rgba(0, 100, 180, 0.2);
    border-left: 2px solid rgba(0, 229, 255, 0.6);
    text-shadow: 0 0 12px rgba(0, 229, 255, 0.6), 0 0 25px rgba(0, 229, 255, 0.2);
    font-size: 20px;
    z-index: 3;
    box-shadow: 0 0 20px rgba(0, 229, 255, 0.1);
  }

  .falling-word .typed {
    color: #00e5ff;
    text-shadow: 0 0 10px rgba(0, 229, 255, 0.9);
  }

  .falling-word.danger {
    color: #ff7777;
    border-left-color: rgba(255, 80, 80, 0.6);
    background: rgba(120, 20, 20, 0.2);
    text-shadow: 0 0 10px rgba(255, 80, 80, 0.5);
    animation: wordPulse 0.5s ease-in-out infinite alternate;
  }

  .falling-word.danger::before {
    background: linear-gradient(180deg, transparent, rgba(255, 80, 80, 0.3));
  }

  @keyframes wordPulse {
    from { opacity: 0.8; }
    to { opacity: 1; }
  }

  /* Splash */
  .splash-particle {
    position: absolute;
    width: 3px;
    height: 3px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 4;
  }

  /* Lives */
  #livesDisplay { display: flex; gap: 6px; }

  .life-icon {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 40%, #4df0ff, #00b8d4);
    box-shadow: 0 0 8px rgba(0, 229, 255, 0.5);
    transition: all 0.4s;
  }

  .life-icon.lost {
    background: rgba(80, 80, 100, 0.3);
    box-shadow: none;
    transform: scale(0.7);
  }

  /* Level up */
  #levelUp {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 20;
    font-family: 'Orbitron', sans-serif;
    font-size: 40px;
    font-weight: 900;
    color: #00e5ff;
    text-shadow: 0 0 40px rgba(0, 229, 255, 0.6), 0 0 80px rgba(0, 229, 255, 0.3);
    opacity: 0;
    pointer-events: none;
    letter-spacing: 8px;
  }

  /* Score popup */
  .score-popup {
    position: absolute;
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    font-weight: 700;
    color: #00e5ff;
    text-shadow: 0 0 10px rgba(0,229,255,0.5);
    pointer-events: none;
    z-index: 5;
    animation: scoreFloat 1s ease-out forwards;
  }

  @keyframes scoreFloat {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-50px) scale(0.7); }
  }

  /* Screen shake */
  .shake { animation: shake 0.35s ease-out; }

  @keyframes shake {
    0%, 100% { transform: translate(0, 0); }
    20% { transform: translate(-5px, 3px); }
    40% { transform: translate(5px, -3px); }
    60% { transform: translate(-3px, 5px); }
    80% { transform: translate(3px, -2px); }
  }

  /* Flash on miss */
  #missFlash {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 6;
    pointer-events: none;
    background: radial-gradient(ellipse at center bottom, rgba(255,40,40,0.15), transparent 70%);
    opacity: 0;
    transition: opacity 0.1s;
  }

  #missFlash.active { opacity: 1; }

  /* Responsive */
  @media (max-width: 600px) {
    .overlay-title { font-size: 34px; letter-spacing: 3px; }
    .overlay-subtitle { font-size: 13px; }
    #typingInput { width: 280px; font-size: 18px; padding: 12px 16px; }
    .hud-value { font-size: 15px; }
    .hud-label { font-size: 8px; }
    .falling-word { font-size: 15px; }
    .falling-word.targeted { font-size: 17px; }
    .stat-row { width: 260px; font-size: 13px; }
    .stats-block { padding: 16px 20px; }
  }
</style>
</head>
<body>

<canvas id="bgCanvas"></canvas>

<div id="gameContainer">
  <div id="wordsContainer"></div>
</div>

<div id="missFlash"></div>

<div id="hud">
  <div class="hud-item">
    <span class="hud-label">Score</span>
    <span class="hud-value" id="scoreDisplay">0</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">Level</span>
    <span class="hud-value" id="levelDisplay">1</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">Accuracy</span>
    <span class="hud-value" id="accuracyDisplay">100%</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">WPM</span>
    <span class="hud-value" id="wpmDisplay">0</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">Lives</span>
    <div id="livesDisplay"></div>
  </div>
</div>

<div id="comboDisplay"></div>
<div id="levelUp"></div>
<div id="dangerZone"></div>

<div id="inputArea">
  <input type="text" id="typingInput" placeholder="type to begin..." autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false">
</div>

<!-- Start Screen -->
<div class="overlay-screen" id="startScreen">
  <div class="overlay-title">
    TYPING RAIN
    <span class="title-accent">KEYBOARD STORM</span>
  </div>
  <div class="overlay-subtitle">Type the falling words before they reach the ground<br>Build combos for bonus points</div>
  <div class="controls-hint"><kbd>ESC</kbd> to cancel current word &bull; Just start typing to target</div>
  <button class="overlay-btn" id="startBtn">BEGIN</button>
</div>

<!-- Game Over Screen -->
<div class="overlay-screen hidden" id="gameOverScreen">
  <div class="overlay-title" style="font-size:42px; margin-bottom:24px;">GAME OVER</div>
  <div class="stats-block">
    <div class="stat-row"><span>Final Score</span><span class="stat-val" id="finalScore">0</span></div>
    <div class="stat-row"><span>Level Reached</span><span class="stat-val" id="finalLevel">1</span></div>
    <div class="stat-row"><span>Words Typed</span><span class="stat-val" id="finalWords">0</span></div>
    <div class="stat-row"><span>Accuracy</span><span class="stat-val" id="finalAccuracy">100%</span></div>
    <div class="stat-row"><span>Best Combo</span><span class="stat-val" id="finalCombo">0</span></div>
    <div class="stat-row"><span>WPM</span><span class="stat-val" id="finalWPM">0</span></div>
  </div>
  <button class="overlay-btn" id="restartBtn">PLAY AGAIN</button>
</div>

<script>
// ===== AUDIO ENGINE (Web Audio API) =====
let audioCtx = null;
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playTone(freq, duration, vol = 0.08, type = 'sine') {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playTypeSound() {
  playTone(800 + Math.random() * 400, 0.05, 0.04, 'square');
}

function playCompleteSound() {
  const now = audioCtx ? audioCtx.currentTime : 0;
  playTone(523, 0.15, 0.06, 'sine');
  setTimeout(() => playTone(659, 0.15, 0.06, 'sine'), 60);
  setTimeout(() => playTone(784, 0.2, 0.07, 'sine'), 120);
}

function playMissSound() {
  playTone(180, 0.3, 0.1, 'sawtooth');
  setTimeout(() => playTone(140, 0.4, 0.08, 'sawtooth'), 100);
}

function playLevelUpSound() {
  [523, 659, 784, 1047].forEach((f, i) => {
    setTimeout(() => playTone(f, 0.2, 0.06, 'sine'), i * 80);
  });
}

// ===== CITY BACKGROUND (Canvas) =====
const bgCanvas = document.getElementById('bgCanvas');
const ctx = bgCanvas.getContext('2d');

function resizeCanvas() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

function generateBuildings() {
  const buildings = [];
  const W = window.innerWidth;
  const H = window.innerHeight;
  let x = -20;

  // Far layer (faded)
  while (x < W + 50) {
    const w = 30 + Math.random() * 60;
    const h = 80 + Math.random() * (H * 0.3);
    buildings.push({ x, w, h, layer: 'far', windows: [] });
    const cols = Math.floor(w / 18);
    const rows = Math.floor(h / 24);
    for (let r = 1; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (Math.random() > 0.5) {
          buildings[buildings.length-1].windows.push({
            cx: x + 6 + c * 18,
            cy: H - h + 14 + r * 24,
            brightness: Math.random() * 0.4,
            flickerSpeed: 0.3 + Math.random() * 2,
            flickerOffset: Math.random() * Math.PI * 2,
            color: Math.random() > 0.6 ? 'warm' : 'cool'
          });
        }
      }
    }
    x += w + 3 + Math.random() * 15;
  }

  // Near layer
  x = -10;
  while (x < W + 50) {
    const w = 45 + Math.random() * 90;
    const h = 120 + Math.random() * (H * 0.5);
    buildings.push({ x, w, h, layer: 'near', windows: [] });
    const cols = Math.floor(w / 15);
    const rows = Math.floor(h / 20);
    for (let r = 1; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (Math.random() > 0.3) {
          buildings[buildings.length-1].windows.push({
            cx: x + 6 + c * 15,
            cy: H - h + 10 + r * 20,
            brightness: 0.2 + Math.random() * 0.8,
            flickerSpeed: 0.5 + Math.random() * 3,
            flickerOffset: Math.random() * Math.PI * 2,
            color: Math.random() > 0.65 ? 'warm' : 'cool'
          });
        }
      }
    }
    x += w + 1 + Math.random() * 6;
  }

  return buildings;
}

let buildings = generateBuildings();
window.addEventListener('resize', () => {
  buildings = generateBuildings();
  resizeCanvas();
});

// Canvas rain particles
const rainParticles = [];
const RAIN_COUNT = 250;
for (let i = 0; i < RAIN_COUNT; i++) {
  rainParticles.push({
    x: Math.random() * window.innerWidth * 1.2,
    y: Math.random() * window.innerHeight,
    speed: 5 + Math.random() * 10,
    length: 12 + Math.random() * 25,
    opacity: 0.08 + Math.random() * 0.18,
    wind: 0.1 + Math.random() * 0.2
  });
}

// Lightning system
let lightningFlash = 0;
let nextLightning = 5000 + Math.random() * 15000;
let lightningBolts = [];

function createLightningBolt(x, y, branches) {
  const bolt = [];
  let cx = x, cy = y;
  const segments = 8 + Math.floor(Math.random() * 12);
  for (let i = 0; i < segments; i++) {
    const nx = cx + (Math.random() - 0.5) * 60;
    const ny = cy + 20 + Math.random() * 40;
    bolt.push({ x1: cx, y1: cy, x2: nx, y2: ny });
    cx = nx; cy = ny;
    if (branches && Math.random() > 0.7) {
      const bx = cx + (Math.random() - 0.5) * 80;
      const by = cy + 15 + Math.random() * 30;
      bolt.push({ x1: cx, y1: cy, x2: bx, y2: by });
    }
  }
  return bolt;
}

function drawBackground(time) {
  const W = bgCanvas.width;
  const H = bgCanvas.height;

  // Sky
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#030308');
  skyGrad.addColorStop(0.3, '#070720');
  skyGrad.addColorStop(0.6, '#0a0d28');
  skyGrad.addColorStop(1, '#0e1420');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Clouds
  ctx.save();
  for (let i = 0; i < 6; i++) {
    const cx = ((W * 0.18 * i + time * 0.003 * (0.5 + i * 0.3)) % (W + 500)) - 250;
    const cy = 30 + i * 35 + Math.sin(time * 0.0003 + i) * 10;
    ctx.globalAlpha = 0.025 + i * 0.003;
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 120 + i * 25);
    grad.addColorStop(0, '#3366aa');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(cx, cy, 160 + i * 20, 50 + i * 8, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // Lightning
  nextLightning -= 16;
  if (nextLightning <= 0) {
    lightningFlash = 1.0;
    lightningBolts = [createLightningBolt(100 + Math.random() * (W - 200), 0, true)];
    nextLightning = 4000 + Math.random() * 20000;
  }

  if (lightningFlash > 0) {
    // Flash
    ctx.save();
    ctx.globalAlpha = lightningFlash * 0.06;
    ctx.fillStyle = '#aaccff';
    ctx.fillRect(0, 0, W, H);

    // Bolts
    if (lightningFlash > 0.3) {
      ctx.globalAlpha = lightningFlash * 0.8;
      ctx.strokeStyle = '#ccddff';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#88bbff';
      ctx.shadowBlur = 20;
      for (const bolt of lightningBolts) {
        for (const seg of bolt) {
          ctx.beginPath();
          ctx.moveTo(seg.x1, seg.y1);
          ctx.lineTo(seg.x2, seg.y2);
          ctx.stroke();
        }
      }
      ctx.shadowBlur = 0;
    }
    ctx.restore();

    lightningFlash *= 0.9;
    if (lightningFlash < 0.01) lightningFlash = 0;
  }

  // Buildings (sorted by layer)
  const farBuildings = buildings.filter(b => b.layer === 'far');
  const nearBuildings = buildings.filter(b => b.layer === 'near');

  // Draw far layer
  for (const b of farBuildings) {
    ctx.fillStyle = '#080c14';
    ctx.fillRect(b.x, H - b.h, b.w, b.h);
    for (const win of b.windows) {
      const flicker = 0.5 + 0.5 * Math.sin(time * 0.001 * win.flickerSpeed + win.flickerOffset);
      const alpha = win.brightness * flicker * 0.4;
      ctx.fillStyle = win.color === 'warm' ? `rgba(255, 200, 100, ${alpha})` : `rgba(140, 190, 255, ${alpha})`;
      ctx.fillRect(win.cx, win.cy, 6, 10);
    }
  }

  // Draw near layer
  for (const b of nearBuildings) {
    const bGrad = ctx.createLinearGradient(b.x, H - b.h, b.x + b.w, H);
    bGrad.addColorStop(0, '#0c1320');
    bGrad.addColorStop(1, '#080e18');
    ctx.fillStyle = bGrad;
    ctx.fillRect(b.x, H - b.h, b.w, b.h);

    // Roof details
    ctx.fillStyle = '#0a1018';
    ctx.fillRect(b.x - 2, H - b.h, b.w + 4, 4);

    // Edge lines
    ctx.strokeStyle = 'rgba(50, 90, 130, 0.12)';
    ctx.lineWidth = 1;
    ctx.strokeRect(b.x, H - b.h, b.w, b.h);

    for (const win of b.windows) {
      const flicker = 0.5 + 0.5 * Math.sin(time * 0.001 * win.flickerSpeed + win.flickerOffset);
      const alpha = win.brightness * flicker * 0.65;
      const isWarm = win.color === 'warm';

      ctx.fillStyle = isWarm ? `rgba(255, 200, 100, ${alpha})` : `rgba(150, 200, 255, ${alpha})`;
      ctx.fillRect(win.cx, win.cy, 7, 11);

      // Glow
      if (alpha > 0.25) {
        ctx.save();
        ctx.globalAlpha = alpha * 0.12;
        const glow = ctx.createRadialGradient(win.cx + 3.5, win.cy + 5.5, 0, win.cx + 3.5, win.cy + 5.5, 18);
        glow.addColorStop(0, isWarm ? '#ffcc66' : '#88bbff');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.fillRect(win.cx - 14, win.cy - 12, 35, 35);
        ctx.restore();
      }
    }
  }

  // Ground
  const groundGrad = ctx.createLinearGradient(0, H - 40, 0, H);
  groundGrad.addColorStop(0, '#090e18');
  groundGrad.addColorStop(0.5, '#070b14');
  groundGrad.addColorStop(1, '#050810');
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, H - 40, W, 40);

  // Wet reflection (simple shimmer)
  ctx.save();
  ctx.globalAlpha = 0.02;
  for (const b of nearBuildings) {
    for (const win of b.windows) {
      const flicker = 0.5 + 0.5 * Math.sin(time * 0.0015 * win.flickerSpeed + win.flickerOffset + 1);
      const alpha = win.brightness * flicker;
      if (alpha > 0.3) {
        const isWarm = win.color === 'warm';
        const reflGrad = ctx.createLinearGradient(win.cx, H - 35, win.cx, H);
        reflGrad.addColorStop(0, isWarm ? `rgba(255,200,100,${alpha})` : `rgba(150,200,255,${alpha})`);
        reflGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = reflGrad;
        ctx.fillRect(win.cx - 2, H - 35, 12, 35);
      }
    }
  }
  ctx.restore();

  // Rain
  ctx.save();
  ctx.lineCap = 'round';
  for (const r of rainParticles) {
    r.y += r.speed;
    r.x -= r.speed * r.wind;
    if (r.y > H + 10) {
      r.y = -r.length - Math.random() * 50;
      r.x = Math.random() * (W + 200) - 50;
    }
    if (r.x < -50) r.x = W + 30;

    ctx.strokeStyle = `rgba(140, 190, 240, ${r.opacity})`;
    ctx.lineWidth = 0.7;
    ctx.beginPath();
    const dx = -r.speed * r.wind * (r.length / r.speed);
    ctx.moveTo(r.x, r.y);
    ctx.lineTo(r.x + dx, r.y - r.length);
    ctx.stroke();
  }
  ctx.restore();

  // Atmospheric fog
  const fogGrad = ctx.createLinearGradient(0, H - 150, 0, H);
  fogGrad.addColorStop(0, 'rgba(8, 12, 20, 0)');
  fogGrad.addColorStop(0.6, 'rgba(8, 12, 20, 0.3)');
  fogGrad.addColorStop(1, 'rgba(8, 12, 20, 0.6)');
  ctx.fillStyle = fogGrad;
  ctx.fillRect(0, H - 150, W, 150);

  // Top vignette
  const topVig = ctx.createLinearGradient(0, 0, 0, 60);
  topVig.addColorStop(0, 'rgba(0,0,0,0.3)');
  topVig.addColorStop(1, 'transparent');
  ctx.fillStyle = topVig;
  ctx.fillRect(0, 0, W, 60);
}

// ===== WORD LISTS =====
const wordLists = {
  easy: [
    'rain','drop','wet','sky','fog','dew','mist','drip','fall','cold',
    'dark','wind','pool','flow','haze','grey','down','pour','rush','gust',
    'cool','damp','hail','blur','soft','deep','wave','lake','icy','glow',
    'bolt','clap','dome','edge','fade','grim','howl','iron','jump','keen'
  ],
  medium: [
    'storm','cloud','water','flood','river','frost','vapor','ocean','windy','misty',
    'muddy','foggy','drizzle','puddle','breeze','rainy','soggy','heavy','gloomy','splash',
    'stream','spray','drift','humid','shower','squall','deluge','rumble','flurry','frozen',
    'shadow','ripple','harbor','silver','velvet','whisper','flight','gentle','cinder','beacon'
  ],
  hard: [
    'thunder','monsoon','cyclone','typhoon','cascade','tempest','overcast','downpour','rainfall',
    'climate','weather','droplets','flooding','moisture','blizzard','cumulus','stratus','tsunami',
    'erosion','forecast','barometer','humidity','pressure','saturate','condense','whirlwind',
    'maelstrom','torrent','avalanche','electric','midnight','spectrum','twilight','obsidian'
  ],
  expert: [
    'precipitation','thunderstorm','meteorology','atmosphere','condensation','evaporation',
    'stratosphere','troposphere','temperature','catastrophic','cumulonimbus','intermittent',
    'extraordinary','phenomenon','treacherous','overwhelming','accumulation','barometric',
    'electricity','thermometer','anticyclone','subtropical','hemisphere','ultraviolet'
  ]
};

// ===== GAME STATE =====
let gameState = {
  running: false,
  score: 0,
  level: 1,
  lives: 5,
  maxLives: 5,
  combo: 0,
  bestCombo: 0,
  totalKeystrokes: 0,
  correctKeystrokes: 0,
  wordsTyped: 0,
  startTime: 0,
  words: [],
  currentTarget: null,
  typedSoFar: '',
  spawnInterval: 2400,
  fallSpeed: 0.45,
  lastSpawn: 0,
  maxWords: 5,
  wordIdCounter: 0,
  scoreAnimTarget: 0,
  scoreAnimCurrent: 0
};

const wordsContainer = document.getElementById('wordsContainer');
const typingInput = document.getElementById('typingInput');
const scoreDisplay = document.getElementById('scoreDisplay');
const levelDisplay = document.getElementById('levelDisplay');
const accuracyDisplay = document.getElementById('accuracyDisplay');
const wpmDisplay = document.getElementById('wpmDisplay');
const livesDisplay = document.getElementById('livesDisplay');
const comboDisplay = document.getElementById('comboDisplay');
const levelUpDisplay = document.getElementById('levelUp');
const missFlash = document.getElementById('missFlash');

// ===== HELPERS =====
function getWordForLevel(level) {
  const existing = gameState.words.map(w => w.text);
  let pool;
  if (level <= 2) pool = wordLists.easy;
  else if (level <= 4) pool = [...wordLists.easy, ...wordLists.medium];
  else if (level <= 7) pool = [...wordLists.medium, ...wordLists.hard];
  else pool = [...wordLists.medium, ...wordLists.hard, ...wordLists.expert];

  // Avoid duplicates on screen and avoid words starting with same letter as others
  const existingFirstChars = existing.map(w => w[0]);
  let filtered = pool.filter(w => !existing.includes(w) && !existingFirstChars.includes(w[0]));
  if (filtered.length === 0) filtered = pool.filter(w => !existing.includes(w));
  if (filtered.length === 0) filtered = pool;

  return filtered[Math.floor(Math.random() * filtered.length)];
}

function updateLives() {
  livesDisplay.innerHTML = '';
  for (let i = 0; i < gameState.maxLives; i++) {
    const dot = document.createElement('div');
    dot.className = 'life-icon' + (i >= gameState.lives ? ' lost' : '');
    livesDisplay.appendChild(dot);
  }
}

function getAccuracy() {
  return gameState.totalKeystrokes > 0
    ? Math.round((gameState.correctKeystrokes / gameState.totalKeystrokes) * 100) : 100;
}

function getWPM() {
  const elapsed = (performance.now() - gameState.startTime) / 1000 / 60;
  return elapsed > 0.05 ? Math.round(gameState.wordsTyped / elapsed) : 0;
}

function updateHUD() {
  gameState.scoreAnimTarget = gameState.score;
  levelDisplay.textContent = gameState.level;
  accuracyDisplay.textContent = getAccuracy() + '%';
  wpmDisplay.textContent = getWPM();
}

function animateScore() {
  if (gameState.scoreAnimCurrent < gameState.scoreAnimTarget) {
    const diff = gameState.scoreAnimTarget - gameState.scoreAnimCurrent;
    gameState.scoreAnimCurrent += Math.max(1, Math.ceil(diff * 0.15));
    if (gameState.scoreAnimCurrent > gameState.scoreAnimTarget) {
      gameState.scoreAnimCurrent = gameState.scoreAnimTarget;
    }
  }
  scoreDisplay.textContent = gameState.scoreAnimCurrent.toLocaleString();
}

function showCombo(combo) {
  if (combo >= 3) {
    const labels = ['', '', '', 'NICE', 'GREAT', 'AWESOME', 'AMAZING', 'INCREDIBLE', 'UNSTOPPABLE', 'LEGENDARY', 'GODLIKE'];
    const label = combo < labels.length ? labels[combo] : 'INSANE';
    comboDisplay.textContent = `${combo}x ${label}!`;
    comboDisplay.classList.add('visible');
    if (combo >= 10) comboDisplay.style.color = '#ff4466';
    else if (combo >= 7) comboDisplay.style.color = '#ff9944';
    else if (combo >= 5) comboDisplay.style.color = '#ffdd44';
    else comboDisplay.style.color = '#44ddff';
    comboDisplay.style.textShadow = `0 0 20px currentColor`;
  } else {
    comboDisplay.classList.remove('visible');
  }
}

function showLevelUp(level) {
  levelUpDisplay.textContent = `LEVEL ${level}`;
  levelUpDisplay.style.opacity = '1';
  levelUpDisplay.style.transform = 'translate(-50%, -50%) scale(1.3)';
  levelUpDisplay.style.transition = 'none';
  playLevelUpSound();

  requestAnimationFrame(() => {
    levelUpDisplay.style.transition = 'all 1.5s ease-out';
    levelUpDisplay.style.opacity = '0';
    levelUpDisplay.style.transform = 'translate(-50%, -50%) scale(0.8)';
  });

  setTimeout(() => { levelUpDisplay.style.transition = 'none'; }, 1600);
}

function showScorePopup(x, y, points) {
  const popup = document.createElement('div');
  popup.className = 'score-popup';
  popup.textContent = '+' + points;
  popup.style.left = x + 'px';
  popup.style.top = y + 'px';
  wordsContainer.appendChild(popup);
  setTimeout(() => popup.remove(), 1000);
}

// ===== SPLASH EFFECT =====
function createSplash(x, y, color = '#00e5ff', count = 10) {
  const container = document.getElementById('gameContainer');
  for (let i = 0; i < count; i++) {
    const particle = document.createElement('div');
    particle.className = 'splash-particle';
    particle.style.left = x + 'px';
    particle.style.top = y + 'px';
    particle.style.background = color;
    particle.style.boxShadow = `0 0 8px ${color}`;
    container.appendChild(particle);

    const angle = (Math.PI * 2 / count) * i + (Math.random() - 0.5);
    const speed = 1.5 + Math.random() * 5;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed - 3;
    let px = x, py = y, life = 1;

    function anim() {
      life -= 0.025;
      if (life <= 0) { particle.remove(); return; }
      px += vx * life;
      py += vy + 0.6;
      particle.style.left = px + 'px';
      particle.style.top = py + 'px';
      particle.style.opacity = life;
      particle.style.width = particle.style.height = (3 * life) + 'px';
      requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
  }
}

// ===== WORD MANAGEMENT =====
function spawnWord() {
  const text = getWordForLevel(gameState.level);
  const W = window.innerWidth;
  const wordPixelWidth = text.length * 11 + 30;
  const margin = 50;
  const x = margin + Math.random() * (W - wordPixelWidth - margin * 2);
  const id = gameState.wordIdCounter++;

  const el = document.createElement('div');
  el.className = 'falling-word';
  el.id = 'word-' + id;
  el.textContent = text;
  el.style.left = x + 'px';
  el.style.top = '-50px';
  el.style.opacity = '0';
  wordsContainer.appendChild(el);

  // Fade in
  requestAnimationFrame(() => {
    el.style.transition = 'opacity 0.4s';
    el.style.opacity = '1';
    setTimeout(() => el.style.transition = '', 400);
  });

  const wordObj = {
    id,
    text,
    el,
    x,
    y: -50,
    speed: gameState.fallSpeed * (0.85 + Math.random() * 0.3),
    active: true
  };
  gameState.words.push(wordObj);
}

function removeWord(wordObj) {
  wordObj.active = false;
  if (wordObj.el && wordObj.el.parentNode) wordObj.el.remove();
  gameState.words = gameState.words.filter(w => w.id !== wordObj.id);
}

function wordCompleted(wordObj) {
  const basePoints = wordObj.text.length * 10 * gameState.level;
  const comboMult = 1 + gameState.combo * 0.15;
  const points = Math.round(basePoints * comboMult);
  gameState.score += points;
  gameState.combo++;
  gameState.wordsTyped++;
  if (gameState.combo > gameState.bestCombo) gameState.bestCombo = gameState.combo;
  showCombo(gameState.combo);

  const rect = wordObj.el.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  createSplash(cx, cy, '#00e5ff', 12);
  showScorePopup(cx - 20, cy - 20, points);
  playCompleteSound();

  removeWord(wordObj);
  gameState.currentTarget = null;
  gameState.typedSoFar = '';
  typingInput.value = '';

  checkLevelUp();
  updateHUD();
}

function wordMissed(wordObj) {
  gameState.lives--;
  gameState.combo = 0;
  showCombo(0);
  updateLives();

  const rect = wordObj.el.getBoundingClientRect();
  createSplash(rect.left + rect.width / 2, rect.top + rect.height / 2, '#ff4444', 8);
  playMissSound();

  // Flash + shake
  missFlash.classList.add('active');
  setTimeout(() => missFlash.classList.remove('active'), 200);
  document.getElementById('gameContainer').classList.add('shake');
  setTimeout(() => document.getElementById('gameContainer').classList.remove('shake'), 350);

  if (wordObj === gameState.currentTarget) {
    gameState.currentTarget = null;
    gameState.typedSoFar = '';
    typingInput.value = '';
    // Untarget visual
    gameState.words.forEach(w => {
      w.el.classList.remove('targeted');
      w.el.textContent = w.text;
    });
  }

  removeWord(wordObj);
  updateHUD();

  if (gameState.lives <= 0) endGame();
}

function checkLevelUp() {
  const thresholds = [0, 5, 12, 22, 35, 50, 68, 90, 115, 145, 180, 220, 265, 320, 380, 450, 530];
  let newLevel = 1;
  for (let i = 1; i < thresholds.length; i++) {
    if (gameState.wordsTyped >= thresholds[i]) newLevel = i + 1;
  }
  if (gameState.wordsTyped >= thresholds[thresholds.length - 1]) {
    newLevel = thresholds.length;
  }

  if (newLevel > gameState.level) {
    gameState.level = newLevel;
    gameState.spawnInterval = Math.max(500, 2400 - (newLevel - 1) * 140);
    gameState.fallSpeed = 0.45 + (newLevel - 1) * 0.07;
    gameState.maxWords = Math.min(14, 5 + Math.floor((newLevel - 1) * 0.7));
    showLevelUp(newLevel);
  }
}

// ===== INPUT HANDLING =====
typingInput.addEventListener('input', () => {
  if (!gameState.running) return;

  const val = typingInput.value.toLowerCase();
  if (val.length === 0) {
    // Cleared - deselect target
    if (gameState.currentTarget) {
      gameState.currentTarget.el.classList.remove('targeted');
      gameState.currentTarget.el.textContent = gameState.currentTarget.text;
    }
    gameState.currentTarget = null;
    gameState.typedSoFar = '';
    return;
  }

  gameState.totalKeystrokes++;

  if (!gameState.currentTarget) {
    // Find matching word - prefer closest to bottom
    const matches = gameState.words
      .filter(w => w.active && w.text.startsWith(val))
      .sort((a, b) => b.y - a.y);

    if (matches.length > 0) {
      gameState.currentTarget = matches[0];
      gameState.typedSoFar = val;
      gameState.correctKeystrokes++;
      highlightTarget(matches[0], val);
      playTypeSound();

      if (val === matches[0].text) wordCompleted(matches[0]);
    } else {
      // No match - count as miss, clear
      typingInput.value = '';
      gameState.typedSoFar = '';
    }
  } else {
    const target = gameState.currentTarget;
    if (!target.active) {
      gameState.currentTarget = null;
      gameState.typedSoFar = '';
      typingInput.value = '';
      return;
    }

    if (target.text.startsWith(val)) {
      gameState.typedSoFar = val;
      gameState.correctKeystrokes++;
      highlightTarget(target, val);
      playTypeSound();

      if (val === target.text) wordCompleted(target);
    } else {
      // Wrong char - revert to last good state
      typingInput.value = gameState.typedSoFar;
    }
  }
});

typingInput.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (gameState.currentTarget) {
      gameState.currentTarget.el.classList.remove('targeted');
      gameState.currentTarget.el.textContent = gameState.currentTarget.text;
    }
    gameState.currentTarget = null;
    gameState.typedSoFar = '';
    typingInput.value = '';
    gameState.words.forEach(w => {
      w.el.classList.remove('targeted');
      w.el.textContent = w.text;
    });
  }
  if (e.key === ' ') e.preventDefault();
});

function highlightTarget(wordObj, typed) {
  gameState.words.forEach(w => {
    if (w.id !== wordObj.id) {
      w.el.classList.remove('targeted');
      w.el.textContent = w.text;
    }
  });

  wordObj.el.classList.add('targeted');
  const typedSpan = document.createElement('span');
  typedSpan.className = 'typed';
  typedSpan.textContent = typed;
  wordObj.el.textContent = '';
  wordObj.el.appendChild(typedSpan);
  wordObj.el.appendChild(document.createTextNode(wordObj.text.substring(typed.length)));
}

// ===== GAME LOOP =====
let lastTime = 0;
let animFrame;
let hudUpdateTimer = 0;

function gameLoop(timestamp) {
  if (!gameState.running) return;

  const dt = Math.min(timestamp - lastTime, 50); // cap dt
  lastTime = timestamp;

  drawBackground(timestamp);
  animateScore();

  // Update WPM periodically
  hudUpdateTimer += dt;
  if (hudUpdateTimer > 500) {
    hudUpdateTimer = 0;
    wpmDisplay.textContent = getWPM();
  }

  // Spawn
  if (timestamp - gameState.lastSpawn > gameState.spawnInterval && gameState.words.length < gameState.maxWords) {
    spawnWord();
    gameState.lastSpawn = timestamp;
  }

  // Update words
  const bottomLimit = window.innerHeight - 95;
  for (const w of [...gameState.words]) {
    if (!w.active) continue;
    w.y += w.speed * (dt / 16); // framerate independent
    w.el.style.top = w.y + 'px';

    const dangerRatio = w.y / bottomLimit;
    if (dangerRatio > 0.7 && !w.el.classList.contains('danger')) {
      if (w !== gameState.currentTarget) {
        w.el.classList.add('danger');
      }
    }

    if (w.y >= bottomLimit) wordMissed(w);
  }

  animFrame = requestAnimationFrame(gameLoop);
}

// ===== START / END =====
function startGame() {
  initAudio();

  gameState = {
    running: true,
    score: 0,
    level: 1,
    lives: 5,
    maxLives: 5,
    combo: 0,
    bestCombo: 0,
    totalKeystrokes: 0,
    correctKeystrokes: 0,
    wordsTyped: 0,
    startTime: performance.now(),
    words: [],
    currentTarget: null,
    typedSoFar: '',
    spawnInterval: 2400,
    fallSpeed: 0.45,
    lastSpawn: 0,
    maxWords: 5,
    wordIdCounter: 0,
    scoreAnimTarget: 0,
    scoreAnimCurrent: 0
  };

  wordsContainer.innerHTML = '';
  updateHUD();
  updateLives();
  showCombo(0);
  scoreDisplay.textContent = '0';

  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');

  typingInput.value = '';
  typingInput.focus();

  lastTime = performance.now();
  animFrame = requestAnimationFrame(gameLoop);
}

function endGame() {
  gameState.running = false;
  cancelAnimationFrame(animFrame);

  const elapsed = (performance.now() - gameState.startTime) / 1000 / 60;
  const wpm = elapsed > 0.05 ? Math.round(gameState.wordsTyped / elapsed) : 0;
  const acc = getAccuracy();

  document.getElementById('finalScore').textContent = gameState.score.toLocaleString();
  document.getElementById('finalLevel').textContent = gameState.level;
  document.getElementById('finalWords').textContent = gameState.wordsTyped;
  document.getElementById('finalAccuracy').textContent = acc + '%';
  document.getElementById('finalCombo').textContent = gameState.bestCombo;
  document.getElementById('finalWPM').textContent = wpm;

  // Continue drawing background
  function endBgLoop(ts) {
    drawBackground(ts);
    if (!gameState.running) requestAnimationFrame(endBgLoop);
  }
  requestAnimationFrame(endBgLoop);

  setTimeout(() => {
    document.getElementById('gameOverScreen').classList.remove('hidden');
  }, 600);
}

// ===== EVENT LISTENERS =====
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

document.addEventListener('click', () => {
  if (gameState.running) typingInput.focus();
});

document.addEventListener('keydown', (e) => {
  if (!gameState.running) {
    if (e.key === 'Enter' || e.key === ' ') {
      const startVisible = !document.getElementById('startScreen').classList.contains('hidden');
      const overVisible = !document.getElementById('gameOverScreen').classList.contains('hidden');
      if (startVisible || overVisible) {
        e.preventDefault();
        startGame();
      }
    }
    return;
  }
  // Auto-focus on any alphanumeric key
  if (e.key.length === 1 && e.key.match(/[a-z]/i) && document.activeElement !== typingInput) {
    typingInput.focus();
  }
});

// Background loop (menu)
function bgLoop(timestamp) {
  drawBackground(timestamp);
  if (!gameState.running) requestAnimationFrame(bgLoop);
}
requestAnimationFrame(bgLoop);
</script>
</body>
</html>
