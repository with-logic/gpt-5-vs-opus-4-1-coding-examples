<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Solar System Explorer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    color: #e0e0e0;
    font-family: 'Inter', sans-serif;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    user-select: none;
  }

  #canvas-container {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
  }

  canvas { display: block; }

  /* Title */
  #title-bar {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    text-align: center;
    pointer-events: none;
  }

  #title-bar h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.6rem;
    font-weight: 600;
    letter-spacing: 4px;
    text-transform: uppercase;
    background: linear-gradient(135deg, #f0c27f, #fc5c7d, #6a82fb);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    filter: drop-shadow(0 0 20px rgba(252, 92, 125, 0.3));
  }

  #title-bar p {
    font-size: 0.75rem;
    color: rgba(255,255,255,0.4);
    margin-top: 4px;
    letter-spacing: 2px;
  }

  /* Controls Panel */
  #controls {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 16px;
    background: rgba(10, 10, 30, 0.75);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 16px;
    padding: 12px 24px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  }

  #controls label {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.65rem;
    letter-spacing: 2px;
    color: rgba(255,255,255,0.5);
    text-transform: uppercase;
  }

  #speed-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 180px;
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }

  #speed-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: linear-gradient(135deg, #fc5c7d, #6a82fb);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(252,92,125,0.5);
    transition: transform 0.2s;
  }

  #speed-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  #speed-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.75rem;
    color: #fc5c7d;
    min-width: 36px;
    text-align: center;
  }

  .control-btn {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.6);
    border-radius: 10px;
    padding: 8px 14px;
    font-family: 'Inter', sans-serif;
    font-size: 0.72rem;
    cursor: pointer;
    transition: all 0.3s;
    letter-spacing: 0.5px;
  }

  .control-btn:hover {
    background: rgba(255,255,255,0.12);
    color: #fff;
    border-color: rgba(255,255,255,0.2);
  }

  .control-btn.active {
    background: rgba(252,92,125,0.15);
    border-color: rgba(252,92,125,0.4);
    color: #fc5c7d;
  }

  .divider {
    width: 1px;
    height: 24px;
    background: rgba(255,255,255,0.1);
  }

  /* Planet Info Panel */
  #planet-info {
    position: fixed;
    top: 50%;
    right: 30px;
    transform: translateY(-50%);
    z-index: 100;
    background: rgba(10, 10, 30, 0.8);
    backdrop-filter: blur(24px);
    -webkit-backdrop-filter: blur(24px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 20px;
    padding: 0;
    width: 300px;
    max-height: 80vh;
    overflow: hidden;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease, transform 0.4s ease;
    box-shadow: 0 12px 48px rgba(0,0,0,0.5);
  }

  #planet-info.visible {
    opacity: 1;
    pointer-events: all;
  }

  #planet-info-header {
    padding: 24px 24px 16px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
  }

  #planet-info-header h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.1rem;
    font-weight: 600;
    letter-spacing: 2px;
  }

  #close-info {
    background: rgba(255,255,255,0.06);
    border: none;
    color: rgba(255,255,255,0.4);
    width: 28px;
    height: 28px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    transition: all 0.2s;
  }

  #close-info:hover {
    background: rgba(255,255,255,0.12);
    color: #fff;
  }

  #planet-info-body {
    padding: 16px 24px 24px;
    overflow-y: auto;
    max-height: calc(80vh - 80px);
  }

  .info-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid rgba(255,255,255,0.04);
  }

  .info-row:last-child {
    border-bottom: none;
  }

  .info-label {
    font-size: 0.72rem;
    color: rgba(255,255,255,0.4);
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .info-value {
    font-size: 0.82rem;
    color: rgba(255,255,255,0.85);
    font-weight: 500;
    text-align: right;
  }

  #planet-description {
    font-size: 0.78rem;
    line-height: 1.6;
    color: rgba(255,255,255,0.55);
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.06);
  }

  /* Planet List */
  #planet-list {
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    z-index: 100;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .planet-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 14px;
    background: rgba(10,10,30,0.5);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.05);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 130px;
  }

  .planet-btn:hover {
    background: rgba(255,255,255,0.08);
    border-color: rgba(255,255,255,0.15);
    transform: translateX(4px);
  }

  .planet-btn.active {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.2);
  }

  .planet-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 6px currentColor;
  }

  .planet-btn span {
    font-size: 0.72rem;
    color: rgba(255,255,255,0.65);
    letter-spacing: 1px;
    font-weight: 400;
  }

  .planet-btn:hover span {
    color: #fff;
  }

  /* Tooltip */
  #hover-tooltip {
    position: fixed;
    z-index: 200;
    background: rgba(10,10,30,0.85);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    padding: 6px 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    font-family: 'Orbitron', sans-serif;
    font-size: 0.7rem;
    letter-spacing: 1px;
    white-space: nowrap;
  }

  /* Loading */
  #loading {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    transition: opacity 0.8s ease;
  }

  #loading.hidden {
    opacity: 0;
    pointer-events: none;
  }

  #loading h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.2rem;
    letter-spacing: 4px;
    margin-bottom: 24px;
    background: linear-gradient(135deg, #f0c27f, #fc5c7d, #6a82fb);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .loading-ring {
    width: 60px;
    height: 60px;
    border: 2px solid rgba(255,255,255,0.06);
    border-top-color: #fc5c7d;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

  /* Responsive */
  @media (max-width: 768px) {
    #planet-list { display: none; }
    #planet-info {
      right: 10px;
      width: calc(100% - 20px);
      max-height: 50vh;
      top: auto;
      bottom: 100px;
      transform: none;
    }
    #controls {
      padding: 10px 16px;
      gap: 10px;
    }
    #speed-slider { width: 100px; }
  }
</style>
</head>
<body>

<div id="loading">
  <h2>Solar System Explorer</h2>
  <div class="loading-ring"></div>
</div>

<div id="title-bar">
  <h1>Solar System Explorer</h1>
  <p>Click a planet to learn more</p>
</div>

<div id="planet-list"></div>

<div id="controls">
  <label>Speed</label>
  <input type="range" id="speed-slider" min="0" max="5" step="0.1" value="1">
  <span id="speed-value">1.0x</span>
  <div class="divider"></div>
  <button class="control-btn" id="toggle-orbits">Orbits</button>
  <button class="control-btn" id="toggle-labels">Labels</button>
  <button class="control-btn" id="reset-view">Reset</button>
</div>

<div id="planet-info">
  <div id="planet-info-header">
    <h2 id="info-name"></h2>
    <button id="close-info">&times;</button>
  </div>
  <div id="planet-info-body"></div>
</div>

<div id="hover-tooltip"></div>

<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function() {
  "use strict";

  // ─── Planet Data ───
  const PLANETS = [
    {
      name: "Mercury",
      radius: 0.38,
      distance: 8,
      orbitalSpeed: 4.15,
      rotationSpeed: 0.017,
      color: 0xb5b5b5,
      emissive: 0x333333,
      tilt: 0.034,
      description: "The smallest planet in our solar system and closest to the Sun. Mercury is only slightly larger than Earth's Moon. Despite being closest to the Sun, it's not the hottest planet due to its lack of atmosphere.",
      info: {
        "Type": "Terrestrial",
        "Diameter": "4,879 km",
        "Distance from Sun": "57.9M km",
        "Orbital Period": "88 days",
        "Day Length": "59 Earth days",
        "Moons": "0",
        "Temperature": "-180 to 430\u00B0C",
        "Atmosphere": "Minimal"
      }
    },
    {
      name: "Venus",
      radius: 0.72,
      distance: 12,
      orbitalSpeed: 1.62,
      rotationSpeed: -0.004,
      color: 0xe8cda0,
      emissive: 0x4a3520,
      tilt: 3.096,
      description: "Often called Earth's sister planet due to their similar size. Venus has a thick, toxic atmosphere that traps heat, making it the hottest planet in our solar system with surface temperatures around 465\u00B0C.",
      info: {
        "Type": "Terrestrial",
        "Diameter": "12,104 km",
        "Distance from Sun": "108.2M km",
        "Orbital Period": "225 days",
        "Day Length": "243 Earth days",
        "Moons": "0",
        "Temperature": "~465\u00B0C",
        "Atmosphere": "CO\u2082, N\u2082"
      }
    },
    {
      name: "Earth",
      radius: 0.76,
      distance: 16,
      orbitalSpeed: 1.0,
      rotationSpeed: 1.0,
      color: 0x4488cc,
      emissive: 0x112244,
      tilt: 0.409,
      description: "Our home planet and the only world known to harbor life. Earth's atmosphere and magnetic field protect us from harmful solar radiation. About 71% of the surface is covered with water.",
      info: {
        "Type": "Terrestrial",
        "Diameter": "12,756 km",
        "Distance from Sun": "149.6M km",
        "Orbital Period": "365.25 days",
        "Day Length": "24 hours",
        "Moons": "1",
        "Temperature": "-89 to 57\u00B0C",
        "Atmosphere": "N\u2082, O\u2082"
      }
    },
    {
      name: "Mars",
      radius: 0.53,
      distance: 20.5,
      orbitalSpeed: 0.53,
      rotationSpeed: 0.97,
      color: 0xc1440e,
      emissive: 0x441100,
      tilt: 0.440,
      description: "Known as the Red Planet due to iron oxide on its surface. Mars has the largest volcano and canyon in the solar system \u2014 Olympus Mons and Valles Marineris. It's the most explored planet aside from Earth.",
      info: {
        "Type": "Terrestrial",
        "Diameter": "6,792 km",
        "Distance from Sun": "227.9M km",
        "Orbital Period": "687 days",
        "Day Length": "24.6 hours",
        "Moons": "2",
        "Temperature": "-140 to 20\u00B0C",
        "Atmosphere": "CO\u2082"
      }
    },
    {
      name: "Jupiter",
      radius: 2.2,
      distance: 28,
      orbitalSpeed: 0.084,
      rotationSpeed: 2.44,
      color: 0xc8a87c,
      emissive: 0x3d2b15,
      tilt: 0.055,
      description: "The largest planet in our solar system, more than twice as massive as all other planets combined. Jupiter's Great Red Spot is a storm larger than Earth that has raged for hundreds of years.",
      info: {
        "Type": "Gas Giant",
        "Diameter": "142,984 km",
        "Distance from Sun": "778.6M km",
        "Orbital Period": "11.9 years",
        "Day Length": "9.9 hours",
        "Moons": "95",
        "Temperature": "~-110\u00B0C",
        "Atmosphere": "H\u2082, He"
      }
    },
    {
      name: "Saturn",
      radius: 1.85,
      distance: 36,
      orbitalSpeed: 0.034,
      rotationSpeed: 2.24,
      color: 0xe8d5a3,
      emissive: 0x3d3015,
      tilt: 0.467,
      hasRings: true,
      description: "Famous for its stunning ring system made of ice and rock particles. Saturn is the least dense planet \u2014 it would float in water if you could find a bathtub big enough. Its rings span up to 282,000 km.",
      info: {
        "Type": "Gas Giant",
        "Diameter": "120,536 km",
        "Distance from Sun": "1,433.5M km",
        "Orbital Period": "29.4 years",
        "Day Length": "10.7 hours",
        "Moons": "146",
        "Temperature": "~-140\u00B0C",
        "Rings": "7 main ring groups"
      }
    },
    {
      name: "Uranus",
      radius: 1.2,
      distance: 44,
      orbitalSpeed: 0.012,
      rotationSpeed: -1.39,
      color: 0x7ec8c8,
      emissive: 0x1a3a3a,
      tilt: 1.706,
      description: "An ice giant that rotates on its side, likely due to a massive ancient collision. Uranus has the coldest atmosphere of any planet at -224\u00B0C. It has faint rings and 27 known moons named after literary characters.",
      info: {
        "Type": "Ice Giant",
        "Diameter": "51,118 km",
        "Distance from Sun": "2,872.5M km",
        "Orbital Period": "84 years",
        "Day Length": "17.2 hours",
        "Moons": "27",
        "Temperature": "~-224\u00B0C",
        "Atmosphere": "H\u2082, He, CH\u2084"
      }
    },
    {
      name: "Neptune",
      radius: 1.15,
      distance: 52,
      orbitalSpeed: 0.006,
      rotationSpeed: 1.49,
      color: 0x3f54ba,
      emissive: 0x111a3d,
      tilt: 0.494,
      description: "The windiest planet with speeds reaching 2,100 km/h. Neptune is the farthest known planet from the Sun. It was the first planet found by mathematical prediction rather than direct observation.",
      info: {
        "Type": "Ice Giant",
        "Diameter": "49,528 km",
        "Distance from Sun": "4,495.1M km",
        "Orbital Period": "164.8 years",
        "Day Length": "16.1 hours",
        "Moons": "16",
        "Temperature": "~-214\u00B0C",
        "Atmosphere": "H\u2082, He, CH\u2084"
      }
    }
  ];

  // ─── Three.js Setup ───
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  // ─── Camera ───
  let cameraDistance = 65;
  let cameraTheta = Math.PI / 6;
  let cameraPhi = Math.PI / 4;
  let cameraTarget = new THREE.Vector3(0, 0, 0);
  let targetCameraTarget = new THREE.Vector3(0, 0, 0);
  let targetDistance = cameraDistance;
  let targetTheta = cameraTheta;
  let targetPhi = cameraPhi;

  function updateCamera() {
    cameraDistance += (targetDistance - cameraDistance) * 0.08;
    cameraTheta += (targetTheta - cameraTheta) * 0.08;
    cameraPhi += (targetPhi - cameraPhi) * 0.08;
    cameraTarget.lerp(targetCameraTarget, 0.06);

    camera.position.set(
      cameraTarget.x + cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta),
      cameraTarget.y + cameraDistance * Math.cos(cameraPhi),
      cameraTarget.z + cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta)
    );
    camera.lookAt(cameraTarget);
  }

  // ─── Starfield ───
  function createStarfield() {
    const starsGeo = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    for (let i = 0; i < 12000; i++) {
      const r = 400 + Math.random() * 600;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      positions.push(r * Math.sin(phi) * Math.cos(theta));
      positions.push(r * Math.sin(phi) * Math.sin(theta));
      positions.push(r * Math.cos(phi));

      const temp = Math.random();
      if (temp < 0.3) { colors.push(0.8, 0.85, 1.0); }
      else if (temp < 0.6) { colors.push(1.0, 0.95, 0.85); }
      else { colors.push(1.0, 1.0, 1.0); }

      sizes.push(0.3 + Math.random() * 1.2);
    }
    starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    starsGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    starsGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    const starsMat = new THREE.ShaderMaterial({
      uniforms: { time: { value: 0 } },
      vertexShader: `
        attribute float size;
        varying vec3 vColor;
        varying float vSize;
        uniform float time;
        void main() {
          vColor = color;
          vSize = size;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (200.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        varying float vSize;
        void main() {
          float d = length(gl_PointCoord - 0.5);
          if (d > 0.5) discard;
          float alpha = smoothstep(0.5, 0.0, d);
          alpha *= alpha;
          gl_FragColor = vec4(vColor, alpha * 0.9);
        }
      `,
      transparent: true,
      vertexColors: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    return new THREE.Points(starsGeo, starsMat);
  }
  scene.add(createStarfield());

  // ─── Ambient Light ───
  const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
  scene.add(ambientLight);

  // ─── Sun ───
  const sunGroup = new THREE.Group();
  const sunGeo = new THREE.SphereGeometry(3.5, 64, 64);
  const sunMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      baseColor1: { value: new THREE.Color(0xffaa33) },
      baseColor2: { value: new THREE.Color(0xff5500) },
      baseColor3: { value: new THREE.Color(0xffdd44) }
    },
    vertexShader: `
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec2 vUv;
      void main() {
        vNormal = normal;
        vPosition = position;
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform vec3 baseColor1;
      uniform vec3 baseColor2;
      uniform vec3 baseColor3;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec2 vUv;

      // Simplex-like noise
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute(permute(permute(
          i.z + vec4(0.0, i1.z, i2.z, 1.0))
          + i.y + vec4(0.0, i1.y, i2.y, 1.0))
          + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
      }

      void main() {
        float n1 = snoise(vPosition * 1.5 + time * 0.15);
        float n2 = snoise(vPosition * 3.0 - time * 0.1);
        float n3 = snoise(vPosition * 6.0 + time * 0.25);
        float pattern = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;

        vec3 col = mix(baseColor1, baseColor2, smoothstep(-0.3, 0.3, pattern));
        col = mix(col, baseColor3, smoothstep(0.2, 0.8, n3) * 0.4);

        float edge = 1.0 - pow(dot(vNormal, vec3(0.0, 0.0, 1.0)), 0.3);
        col += vec3(1.0, 0.6, 0.1) * edge * 0.3;

        gl_FragColor = vec4(col * 1.4, 1.0);
      }
    `
  });

  const sunMesh = new THREE.Mesh(sunGeo, sunMat);
  sunGroup.add(sunMesh);

  // Sun glow
  const sunGlowGeo = new THREE.SphereGeometry(5.5, 32, 32);
  const sunGlowMat = new THREE.ShaderMaterial({
    uniforms: {
      viewVector: { value: camera.position }
    },
    vertexShader: `
      uniform vec3 viewVector;
      varying float intensity;
      void main() {
        vec3 vNormal = normalize(normalMatrix * normal);
        vec3 vNormel = normalize(normalMatrix * viewVector);
        intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying float intensity;
      void main() {
        vec3 glow = vec3(1.0, 0.6, 0.2) * intensity;
        gl_FragColor = vec4(glow, intensity * 0.6);
      }
    `,
    side: THREE.FrontSide,
    blending: THREE.AdditiveBlending,
    transparent: true,
    depthWrite: false
  });
  sunGroup.add(new THREE.Mesh(sunGlowGeo, sunGlowMat));

  // Sun point light
  const sunLight = new THREE.PointLight(0xfff0dd, 2.0, 200);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 1024;
  sunLight.shadow.mapSize.height = 1024;
  sunGroup.add(sunLight);

  scene.add(sunGroup);

  // ─── Create Planets ───
  const planetMeshes = [];
  const orbitLines = [];
  const labelSprites = [];
  let showOrbits = true;
  let showLabels = true;

  function createPlanetTexture(baseColor, type) {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');

    const c = new THREE.Color(baseColor);
    const r = Math.floor(c.r * 255);
    const g = Math.floor(c.g * 255);
    const b = Math.floor(c.b * 255);

    // Base
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, 0, 512, 256);

    // Bands and noise
    for (let y = 0; y < 256; y++) {
      for (let x = 0; x < 512; x++) {
        const bandNoise = Math.sin(y * 0.08 + Math.sin(x * 0.02) * 3) * 20;
        const noise = (Math.random() - 0.5) * 30;
        const spotNoise = Math.sin(x * 0.05) * Math.cos(y * 0.07) * 15;

        const pr = Math.max(0, Math.min(255, r + bandNoise + noise + spotNoise));
        const pg = Math.max(0, Math.min(255, g + bandNoise * 0.8 + noise + spotNoise * 0.8));
        const pb = Math.max(0, Math.min(255, b + bandNoise * 0.6 + noise + spotNoise * 0.6));

        ctx.fillStyle = `rgb(${Math.floor(pr)},${Math.floor(pg)},${Math.floor(pb)})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    return texture;
  }

  function createEarthTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');

    // Ocean base
    for (let y = 0; y < 256; y++) {
      for (let x = 0; x < 512; x++) {
        const lon = (x / 512) * Math.PI * 2;
        const lat = (y / 256) * Math.PI - Math.PI / 2;

        // Simple procedural continents
        const n1 = Math.sin(lon * 2.5 + 0.5) * Math.cos(lat * 1.8) * 0.5;
        const n2 = Math.sin(lon * 4 + 1.2) * Math.cos(lat * 3 + 0.7) * 0.3;
        const n3 = Math.cos(lon * 1.5 - 0.8) * Math.sin(lat * 2.5) * 0.4;
        const continent = n1 + n2 + n3;

        // Polar ice
        const polar = Math.abs(lat) > 1.2 ? 1.0 : 0.0;

        let r, g, b;
        if (polar > 0.5) {
          r = 220 + Math.random() * 20;
          g = 225 + Math.random() * 15;
          b = 235 + Math.random() * 10;
        } else if (continent > 0.15) {
          // Land
          const green = 0.5 + Math.cos(lat * 2) * 0.3;
          r = 60 + Math.random() * 30 + (1 - green) * 60;
          g = 90 + Math.random() * 30 + green * 40;
          b = 40 + Math.random() * 20;
        } else {
          // Ocean
          const depth = 0.5 + continent * 0.5;
          r = 20 + depth * 20 + Math.random() * 10;
          g = 50 + depth * 30 + Math.random() * 15;
          b = 130 + depth * 40 + Math.random() * 20;
        }

        ctx.fillStyle = `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    return texture;
  }

  PLANETS.forEach((data, index) => {
    const group = new THREE.Group();

    // Planet sphere
    const geo = new THREE.SphereGeometry(data.radius, 48, 48);
    let material;

    if (data.name === "Earth") {
      material = new THREE.MeshPhongMaterial({
        map: createEarthTexture(),
        shininess: 25,
        specular: new THREE.Color(0x333333)
      });
    } else {
      material = new THREE.MeshPhongMaterial({
        map: createPlanetTexture(data.color, data.name),
        shininess: data.name === "Venus" ? 40 : 15,
        specular: new THREE.Color(0x222222),
        emissive: new THREE.Color(data.emissive),
        emissiveIntensity: 0.15
      });
    }

    const mesh = new THREE.Mesh(geo, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.rotation.z = data.tilt;
    group.add(mesh);

    // Atmosphere for Earth and Venus
    if (data.name === "Earth" || data.name === "Venus") {
      const atmosGeo = new THREE.SphereGeometry(data.radius * 1.04, 32, 32);
      const atmosColor = data.name === "Earth" ? 0x4488ff : 0xe8c080;
      const atmosMat = new THREE.ShaderMaterial({
        uniforms: {
          atmosColor: { value: new THREE.Color(atmosColor) }
        },
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 atmosColor;
          varying vec3 vNormal;
          void main() {
            float intensity = pow(0.65 - dot(vNormal, vec3(0,0,1)), 2.0);
            gl_FragColor = vec4(atmosColor, intensity * 0.6);
          }
        `,
        transparent: true,
        side: THREE.FrontSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      group.add(new THREE.Mesh(atmosGeo, atmosMat));
    }

    // Saturn rings
    if (data.hasRings) {
      const ringGeo = new THREE.RingGeometry(data.radius * 1.4, data.radius * 2.6, 128);
      // Adjust UVs for ring texture
      const pos = ringGeo.attributes.position;
      const uv = ringGeo.attributes.uv;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        const dist = Math.sqrt(x * x + z * z);
        const normalized = (dist - data.radius * 1.4) / (data.radius * 1.2);
        uv.setXY(i, normalized, 0.5);
      }

      // Create ring texture
      const ringCanvas = document.createElement('canvas');
      ringCanvas.width = 512;
      ringCanvas.height = 8;
      const rctx = ringCanvas.getContext('2d');
      for (let x = 0; x < 512; x++) {
        const t = x / 512;
        const bandIntensity =
          Math.sin(t * 40) * 0.2 +
          Math.sin(t * 80) * 0.1 +
          Math.cos(t * 20 + 1) * 0.15 +
          0.5;
        const gap1 = (t > 0.38 && t < 0.42) ? 0.1 : 1.0; // Cassini Division
        const gap2 = (t > 0.6 && t < 0.62) ? 0.4 : 1.0;
        const alpha = Math.max(0, Math.min(1, bandIntensity * gap1 * gap2));
        const fade = 1.0 - Math.pow(Math.abs(t - 0.5) * 2, 3);
        const r = 210 + Math.random() * 20;
        const g = 190 + Math.random() * 20;
        const b = 150 + Math.random() * 20;
        rctx.fillStyle = `rgba(${r},${g},${b},${alpha * fade * 0.8})`;
        rctx.fillRect(x, 0, 1, 8);
      }
      const ringTexture = new THREE.CanvasTexture(ringCanvas);

      const ringMat = new THREE.MeshPhongMaterial({
        map: ringTexture,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
        opacity: 0.85,
        emissive: new THREE.Color(0x332200),
        emissiveIntensity: 0.1
      });

      const ringMesh = new THREE.Mesh(ringGeo, ringMat);
      ringMesh.rotation.x = -Math.PI / 2 + 0.05;
      group.add(ringMesh);
    }

    // Store data
    group.userData = {
      planetData: data,
      mesh: mesh,
      angle: Math.random() * Math.PI * 2,
      index: index
    };

    scene.add(group);
    planetMeshes.push(group);

    // Orbit line
    const orbitGeo = new THREE.BufferGeometry();
    const orbitPoints = [];
    const segments = 256;
    for (let i = 0; i <= segments; i++) {
      const angle = (i / segments) * Math.PI * 2;
      orbitPoints.push(Math.cos(angle) * data.distance, 0, Math.sin(angle) * data.distance);
    }
    orbitGeo.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
    const orbitMat = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.07,
      depthWrite: false
    });
    const orbitLine = new THREE.Line(orbitGeo, orbitMat);
    scene.add(orbitLine);
    orbitLines.push(orbitLine);

    // Label (as a sprite)
    const labelCanvas = document.createElement('canvas');
    labelCanvas.width = 256;
    labelCanvas.height = 64;
    const lctx = labelCanvas.getContext('2d');
    lctx.font = '24px Inter, sans-serif';
    lctx.fillStyle = 'rgba(255,255,255,0.65)';
    lctx.textAlign = 'center';
    lctx.fillText(data.name, 128, 40);
    const labelTexture = new THREE.CanvasTexture(labelCanvas);
    const labelMat = new THREE.SpriteMaterial({
      map: labelTexture,
      transparent: true,
      depthWrite: false,
      depthTest: false
    });
    const label = new THREE.Sprite(labelMat);
    label.scale.set(4, 1, 1);
    scene.add(label);
    labelSprites.push(label);
  });

  // ─── Planet List UI ───
  const planetListEl = document.getElementById('planet-list');
  PLANETS.forEach((data, i) => {
    const btn = document.createElement('div');
    btn.className = 'planet-btn';
    btn.innerHTML = `<div class="planet-dot" style="color:#${new THREE.Color(data.color).getHexString()};background:#${new THREE.Color(data.color).getHexString()}"></div><span>${data.name}</span>`;
    btn.addEventListener('click', () => selectPlanet(i));
    planetListEl.appendChild(btn);
  });

  // ─── State ───
  let speedMultiplier = 1.0;
  let selectedPlanet = -1;
  let time = 0;
  let isDragging = false;
  let lastMouse = { x: 0, y: 0 };
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // ─── Planet Selection ───
  function selectPlanet(index) {
    selectedPlanet = index;
    const data = PLANETS[index];

    // Update UI
    document.querySelectorAll('.planet-btn').forEach((btn, i) => {
      btn.classList.toggle('active', i === index);
    });

    // Show info panel
    const panel = document.getElementById('planet-info');
    document.getElementById('info-name').textContent = data.name;
    document.getElementById('info-name').style.color = '#' + new THREE.Color(data.color).getHexString();

    let bodyHTML = '';
    for (const [key, value] of Object.entries(data.info)) {
      bodyHTML += `<div class="info-row"><span class="info-label">${key}</span><span class="info-value">${value}</span></div>`;
    }
    bodyHTML += `<p id="planet-description">${data.description}</p>`;
    document.getElementById('planet-info-body').innerHTML = bodyHTML;

    panel.classList.add('visible');

    // Zoom camera towards planet
    const planetGroup = planetMeshes[index];
    const pos = planetGroup.position;
    targetCameraTarget.set(pos.x, pos.y, pos.z);
    targetDistance = Math.max(data.radius * 6, 8);
  }

  function deselectPlanet() {
    selectedPlanet = -1;
    document.querySelectorAll('.planet-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById('planet-info').classList.remove('visible');
    targetCameraTarget.set(0, 0, 0);
    targetDistance = 65;
    targetTheta = Math.PI / 6;
    targetPhi = Math.PI / 4;
  }

  document.getElementById('close-info').addEventListener('click', deselectPlanet);

  // ─── Controls ───
  const speedSlider = document.getElementById('speed-slider');
  const speedValue = document.getElementById('speed-value');
  speedSlider.addEventListener('input', () => {
    speedMultiplier = parseFloat(speedSlider.value);
    speedValue.textContent = speedMultiplier.toFixed(1) + 'x';
  });

  const toggleOrbitsBtn = document.getElementById('toggle-orbits');
  toggleOrbitsBtn.classList.add('active');
  toggleOrbitsBtn.addEventListener('click', () => {
    showOrbits = !showOrbits;
    toggleOrbitsBtn.classList.toggle('active', showOrbits);
    orbitLines.forEach(line => line.visible = showOrbits);
  });

  const toggleLabelsBtn = document.getElementById('toggle-labels');
  toggleLabelsBtn.classList.add('active');
  toggleLabelsBtn.addEventListener('click', () => {
    showLabels = !showLabels;
    toggleLabelsBtn.classList.toggle('active', showLabels);
    labelSprites.forEach(label => label.visible = showLabels);
  });

  document.getElementById('reset-view').addEventListener('click', deselectPlanet);

  // ─── Mouse/Touch Interaction ───
  const canvasEl = renderer.domElement;

  canvasEl.addEventListener('mousedown', (e) => {
    if (e.button === 0) {
      isDragging = true;
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    }
  });

  window.addEventListener('mousemove', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

    if (isDragging) {
      const dx = e.clientX - lastMouse.x;
      const dy = e.clientY - lastMouse.y;
      targetTheta -= dx * 0.005;
      targetPhi = Math.max(0.15, Math.min(Math.PI - 0.15, targetPhi + dy * 0.005));
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    }
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
  });

  canvasEl.addEventListener('wheel', (e) => {
    e.preventDefault();
    targetDistance = Math.max(5, Math.min(150, targetDistance + e.deltaY * 0.04));
  }, { passive: false });

  // Click to select planet
  canvasEl.addEventListener('click', (e) => {
    if (Math.abs(e.clientX - lastMouse.x) > 5 || Math.abs(e.clientY - lastMouse.y) > 5) return;

    const clickMouse = new THREE.Vector2(
      (e.clientX / window.innerWidth) * 2 - 1,
      -(e.clientY / window.innerHeight) * 2 + 1
    );
    raycaster.setFromCamera(clickMouse, camera);

    const meshes = planetMeshes.map(g => g.userData.mesh);
    const intersects = raycaster.intersectObjects(meshes);

    if (intersects.length > 0) {
      const clickedMesh = intersects[0].object;
      const planetIndex = planetMeshes.findIndex(g => g.userData.mesh === clickedMesh);
      if (planetIndex >= 0) {
        selectPlanet(planetIndex);
      }
    } else {
      // Check if clicked on sun
      const sunIntersects = raycaster.intersectObject(sunMesh);
      if (sunIntersects.length === 0 && !e.target.closest('#planet-info') && !e.target.closest('#controls') && !e.target.closest('#planet-list')) {
        deselectPlanet();
      }
    }
  });

  // Touch support
  let touchStartDist = 0;
  let lastTouch = { x: 0, y: 0 };

  canvasEl.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length === 1) {
      isDragging = true;
      lastTouch.x = e.touches[0].clientX;
      lastTouch.y = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
      isDragging = false;
      touchStartDist = Math.hypot(
        e.touches[1].clientX - e.touches[0].clientX,
        e.touches[1].clientY - e.touches[0].clientY
      );
    }
  }, { passive: false });

  canvasEl.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length === 1 && isDragging) {
      const dx = e.touches[0].clientX - lastTouch.x;
      const dy = e.touches[0].clientY - lastTouch.y;
      targetTheta -= dx * 0.005;
      targetPhi = Math.max(0.15, Math.min(Math.PI - 0.15, targetPhi + dy * 0.005));
      lastTouch.x = e.touches[0].clientX;
      lastTouch.y = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
      const dist = Math.hypot(
        e.touches[1].clientX - e.touches[0].clientX,
        e.touches[1].clientY - e.touches[0].clientY
      );
      const delta = touchStartDist - dist;
      targetDistance = Math.max(5, Math.min(150, targetDistance + delta * 0.1));
      touchStartDist = dist;
    }
  }, { passive: false });

  canvasEl.addEventListener('touchend', () => {
    isDragging = false;
  });

  // ─── Hover Tooltip ───
  const tooltip = document.getElementById('hover-tooltip');
  let hoveredPlanet = -1;

  function updateTooltip(e) {
    raycaster.setFromCamera(mouse, camera);
    const meshes = planetMeshes.map(g => g.userData.mesh);
    const intersects = raycaster.intersectObjects(meshes);

    if (intersects.length > 0 && !isDragging) {
      const hMesh = intersects[0].object;
      const idx = planetMeshes.findIndex(g => g.userData.mesh === hMesh);
      if (idx >= 0) {
        hoveredPlanet = idx;
        tooltip.textContent = PLANETS[idx].name;
        tooltip.style.left = (e?.clientX || 0) + 16 + 'px';
        tooltip.style.top = (e?.clientY || 0) - 10 + 'px';
        tooltip.style.opacity = '1';
        canvasEl.style.cursor = 'pointer';
        return;
      }
    }
    hoveredPlanet = -1;
    tooltip.style.opacity = '0';
    canvasEl.style.cursor = isDragging ? 'grabbing' : 'grab';
  }

  window.addEventListener('mousemove', updateTooltip);

  // ─── Resize ───
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // ─── Animation Loop ───
  let lastTime = performance.now();

  function animate(now) {
    requestAnimationFrame(animate);

    const delta = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    time += delta * speedMultiplier;

    // Update sun
    sunMat.uniforms.time.value = time;
    sunMesh.rotation.y = time * 0.05;

    // Update planets
    planetMeshes.forEach((group, i) => {
      const data = group.userData.planetData;
      group.userData.angle += delta * speedMultiplier * data.orbitalSpeed * 0.15;
      const angle = group.userData.angle;

      group.position.x = Math.cos(angle) * data.distance;
      group.position.z = Math.sin(angle) * data.distance;

      // Rotation
      group.userData.mesh.rotation.y += delta * speedMultiplier * data.rotationSpeed * 0.3;

      // Update label position
      labelSprites[i].position.set(
        group.position.x,
        data.radius + 1.2,
        group.position.z
      );

      // Scale label based on distance
      const dist = camera.position.distanceTo(group.position);
      const scale = Math.max(2, Math.min(6, dist * 0.06));
      labelSprites[i].scale.set(scale, scale * 0.25, 1);
    });

    // Follow selected planet
    if (selectedPlanet >= 0) {
      const pos = planetMeshes[selectedPlanet].position;
      targetCameraTarget.set(pos.x, pos.y, pos.z);
    }

    updateCamera();
    renderer.render(scene, camera);
  }

  // ─── Start ───
  // Hide loading after a brief moment to ensure everything renders
  setTimeout(() => {
    document.getElementById('loading').classList.add('hidden');
    setTimeout(() => document.getElementById('loading').remove(), 800);
  }, 800);

  canvasEl.style.cursor = 'grab';
  animate(performance.now());

})();
</script>
</body>
</html>
