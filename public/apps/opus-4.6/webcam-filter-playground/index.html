<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Webcam Filter Playground</title>
<style>
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  :root{
    --bg:#0a0a0f;--surface:#14141f;--surface2:#1e1e2e;--border:#2a2a3e;
    --text:#e8e8f0;--text-dim:#8888aa;--accent:#7c5cfc;--accent-hover:#9a7fff;
    --accent-glow:rgba(124,92,252,0.3);--danger:#ff4d6a;--success:#3ddfa0;
    --radius:12px;--transition:0.2s ease;
  }
  html,body{height:100%;overflow:hidden}
  body{
    font-family:'Inter','Segoe UI',system-ui,-apple-system,sans-serif;
    background:var(--bg);color:var(--text);display:flex;flex-direction:column;
  }

  /* Header */
  header{
    display:flex;align-items:center;justify-content:space-between;
    padding:12px 24px;border-bottom:1px solid var(--border);
    background:var(--surface);flex-shrink:0;z-index:10;
  }
  .logo{display:flex;align-items:center;gap:10px;font-weight:700;font-size:18px;letter-spacing:-0.5px}
  .logo-icon{
    width:34px;height:34px;border-radius:8px;
    background:linear-gradient(135deg,var(--accent),#ff6bca);
    display:flex;align-items:center;justify-content:center;font-size:18px;
  }
  .header-actions{display:flex;gap:8px}

  /* Buttons */
  .btn{
    display:inline-flex;align-items:center;gap:6px;padding:8px 16px;
    border-radius:8px;border:1px solid var(--border);background:var(--surface2);
    color:var(--text);font-size:13px;font-weight:500;cursor:pointer;
    transition:all var(--transition);white-space:nowrap;
  }
  .btn:hover{background:var(--border);border-color:#3a3a5e}
  .btn:active{transform:scale(0.97)}
  .btn-primary{
    background:var(--accent);border-color:var(--accent);color:#fff;
  }
  .btn-primary:hover{background:var(--accent-hover);border-color:var(--accent-hover)}
  .btn-danger{border-color:var(--danger);color:var(--danger)}
  .btn-danger:hover{background:var(--danger);color:#fff}
  .btn svg{width:16px;height:16px;flex-shrink:0}
  .btn-icon{padding:8px 10px}

  /* Main layout */
  main{
    flex:1;display:flex;overflow:hidden;position:relative;
  }

  /* Sidebar */
  .sidebar{
    width:280px;min-width:280px;background:var(--surface);
    border-right:1px solid var(--border);display:flex;flex-direction:column;
    overflow-y:auto;flex-shrink:0;
  }
  .sidebar-section{padding:16px}
  .sidebar-section+.sidebar-section{border-top:1px solid var(--border)}
  .section-title{
    font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:1px;
    color:var(--text-dim);margin-bottom:12px;
  }

  /* Filter grid */
  .filter-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px}
  .filter-btn{
    padding:10px 8px;border-radius:8px;border:2px solid transparent;
    background:var(--surface2);color:var(--text-dim);font-size:11px;font-weight:500;
    cursor:pointer;transition:all var(--transition);text-align:center;
    display:flex;flex-direction:column;align-items:center;gap:4px;
  }
  .filter-btn:hover{background:var(--border);color:var(--text)}
  .filter-btn.active{
    border-color:var(--accent);color:var(--text);
    background:rgba(124,92,252,0.1);
    box-shadow:0 0 16px var(--accent-glow);
  }
  .filter-btn .filter-icon{font-size:20px;line-height:1}

  /* Sliders */
  .slider-group{margin-bottom:12px}
  .slider-group:last-child{margin-bottom:0}
  .slider-label{
    display:flex;justify-content:space-between;align-items:center;
    font-size:12px;margin-bottom:6px;
  }
  .slider-label span:first-child{color:var(--text-dim);font-weight:500}
  .slider-label span:last-child{color:var(--accent);font-variant-numeric:tabular-nums}
  input[type=range]{
    -webkit-appearance:none;width:100%;height:6px;border-radius:3px;
    background:var(--surface2);outline:none;cursor:pointer;
  }
  input[type=range]::-webkit-slider-thumb{
    -webkit-appearance:none;width:16px;height:16px;border-radius:50%;
    background:var(--accent);border:2px solid var(--bg);
    box-shadow:0 0 8px var(--accent-glow);cursor:pointer;
  }
  input[type=range]::-moz-range-thumb{
    width:16px;height:16px;border-radius:50%;
    background:var(--accent);border:2px solid var(--bg);
    box-shadow:0 0 8px var(--accent-glow);cursor:pointer;
  }

  /* Canvas area */
  .canvas-area{
    flex:1;display:flex;align-items:center;justify-content:center;
    position:relative;overflow:hidden;
    background:radial-gradient(ellipse at center,#12121f 0%,var(--bg) 70%);
  }
  .canvas-wrapper{
    position:relative;border-radius:var(--radius);overflow:hidden;
    box-shadow:0 8px 40px rgba(0,0,0,0.5),0 0 0 1px var(--border);
    max-width:95%;max-height:95%;
  }
  #preview{display:block;border-radius:var(--radius)}
  video{display:none}

  /* Overlay controls */
  .overlay-controls{
    position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
    display:flex;gap:8px;z-index:5;
    background:rgba(10,10,15,0.8);backdrop-filter:blur(12px);
    padding:8px 12px;border-radius:14px;border:1px solid var(--border);
  }

  /* Snapshot flash */
  .flash{
    position:fixed;top:0;left:0;right:0;bottom:0;
    background:#fff;z-index:100;pointer-events:none;
    opacity:0;transition:opacity 0.1s;
  }
  .flash.active{opacity:0.8;transition:none}

  /* Toast */
  .toast{
    position:fixed;bottom:24px;right:24px;
    padding:12px 20px;border-radius:10px;
    background:var(--surface2);border:1px solid var(--border);
    color:var(--text);font-size:13px;font-weight:500;
    transform:translateY(80px);opacity:0;transition:all 0.3s ease;z-index:200;
    display:flex;align-items:center;gap:8px;
    box-shadow:0 8px 32px rgba(0,0,0,0.4);
  }
  .toast.show{transform:translateY(0);opacity:1}
  .toast.success{border-color:var(--success);color:var(--success)}

  /* Snapshot gallery */
  .gallery{
    padding:0 16px 16px;display:flex;flex-direction:column;gap:6px;
  }
  .gallery-item{
    position:relative;border-radius:8px;overflow:hidden;cursor:pointer;
    border:2px solid transparent;transition:border-color var(--transition);
  }
  .gallery-item:hover{border-color:var(--accent)}
  .gallery-item img{width:100%;display:block;aspect-ratio:4/3;object-fit:cover}
  .gallery-item .gallery-actions{
    position:absolute;top:4px;right:4px;display:flex;gap:4px;
    opacity:0;transition:opacity var(--transition);
  }
  .gallery-item:hover .gallery-actions{opacity:1}
  .gallery-actions .btn{
    padding:4px 6px;font-size:11px;background:rgba(10,10,15,0.85);
    backdrop-filter:blur(8px);
  }

  /* No camera state */
  .no-camera{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    gap:16px;padding:40px;text-align:center;
  }
  .no-camera-icon{
    width:80px;height:80px;border-radius:50%;
    background:var(--surface2);display:flex;align-items:center;
    justify-content:center;font-size:36px;
    border:2px dashed var(--border);
  }
  .no-camera h2{font-size:18px;font-weight:600}
  .no-camera p{color:var(--text-dim);font-size:14px;max-width:300px;line-height:1.5}

  /* Recording indicator */
  .rec-indicator{
    position:absolute;top:16px;left:16px;display:flex;align-items:center;gap:6px;
    font-size:12px;font-weight:600;color:var(--danger);
    background:rgba(10,10,15,0.7);padding:6px 12px;border-radius:8px;
    backdrop-filter:blur(8px);z-index:5;opacity:0;pointer-events:none;
    transition:opacity 0.3s;
  }
  .rec-indicator.visible{opacity:1}
  .rec-dot{
    width:8px;height:8px;border-radius:50%;background:var(--danger);
    animation:pulse 1s ease-in-out infinite;
  }
  @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.3}}

  /* FPS counter */
  .fps-counter{
    position:absolute;top:16px;right:16px;
    font-size:11px;font-weight:600;color:var(--text-dim);
    background:rgba(10,10,15,0.7);padding:4px 10px;border-radius:6px;
    backdrop-filter:blur(8px);z-index:5;font-variant-numeric:tabular-nums;
  }

  /* Mirror toggle */
  .mirror-active #preview{transform:scaleX(-1)}

  /* Responsive */
  @media(max-width:768px){
    main{flex-direction:column}
    .sidebar{
      width:100%;min-width:auto;flex-direction:row;overflow-x:auto;
      border-right:none;border-bottom:1px solid var(--border);
      max-height:200px;
    }
    .sidebar-section{min-width:200px}
    .filter-grid{grid-template-columns:repeat(4,1fr)}
  }

  /* Scrollbar */
  ::-webkit-scrollbar{width:6px}
  ::-webkit-scrollbar-track{background:transparent}
  ::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
  ::-webkit-scrollbar-thumb:hover{background:#3a3a5e}

  /* Keyframes */
  @keyframes fadeIn{from{opacity:0;transform:scale(0.95)}to{opacity:1;transform:scale(1)}}
  .canvas-wrapper{animation:fadeIn 0.4s ease}
</style>
</head>
<body>
<div class="flash" id="flash"></div>

<header>
  <div class="logo">
    <div class="logo-icon">
      <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
        <circle cx="12" cy="13" r="4"/>
      </svg>
    </div>
    Webcam Filter Playground
  </div>
  <div class="header-actions">
    <button class="btn" id="mirrorBtn" title="Mirror">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="8 3 4 7 8 11"/><polyline points="16 3 20 7 16 11"/><line x1="4" y1="7" x2="20" y2="7"/></svg>
      Mirror
    </button>
    <button class="btn" id="cameraSelect" title="Switch Camera">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>
      Cameras
    </button>
    <button class="btn btn-primary" id="startBtn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>
      Start Camera
    </button>
  </div>
</header>

<main>
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-section">
      <div class="section-title">Filters</div>
      <div class="filter-grid" id="filterGrid"></div>
    </div>
    <div class="sidebar-section">
      <div class="section-title">Adjustments</div>
      <div class="slider-group">
        <div class="slider-label"><span>Intensity</span><span id="intensityVal">100%</span></div>
        <input type="range" id="intensity" min="0" max="100" value="100">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Brightness</span><span id="brightnessVal">100%</span></div>
        <input type="range" id="brightness" min="50" max="200" value="100">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Contrast</span><span id="contrastVal">100%</span></div>
        <input type="range" id="contrast" min="50" max="200" value="100">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Saturation</span><span id="saturationVal">100%</span></div>
        <input type="range" id="saturation" min="0" max="300" value="100">
      </div>
    </div>
    <div class="sidebar-section">
      <div class="section-title">Snapshots</div>
    </div>
    <div class="gallery" id="gallery"></div>
  </aside>

  <div class="canvas-area" id="canvasArea">
    <div class="no-camera" id="noCameraState">
      <div class="no-camera-icon">
        <svg viewBox="0 0 24 24" width="36" height="36" fill="none" stroke="var(--text-dim)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
          <circle cx="12" cy="13" r="4"/>
        </svg>
      </div>
      <h2>No Camera Connected</h2>
      <p>Click "Start Camera" to begin. Grant camera permissions when prompted.</p>
    </div>
    <div class="canvas-wrapper" id="canvasWrapper" style="display:none">
      <canvas id="preview"></canvas>
      <div class="rec-indicator" id="recIndicator"><div class="rec-dot"></div>LIVE</div>
      <div class="fps-counter" id="fpsCounter">-- FPS</div>
    </div>
    <div class="overlay-controls" id="overlayControls" style="display:none">
      <button class="btn" id="snapBtn" title="Take Snapshot (Space)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4" fill="currentColor"/></svg>
        Snapshot
      </button>
      <button class="btn" id="resetBtn" title="Reset Filters">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
        Reset
      </button>
    </div>
  </div>
</main>

<div class="toast" id="toast"></div>

<video id="video" autoplay playsinline></video>

<script>
(function() {
  'use strict';

  // ---- Elements ----
  const video = document.getElementById('video');
  const canvas = document.getElementById('preview');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const filterGrid = document.getElementById('filterGrid');
  const gallery = document.getElementById('gallery');
  const flashEl = document.getElementById('flash');
  const toastEl = document.getElementById('toast');
  const startBtn = document.getElementById('startBtn');
  const snapBtn = document.getElementById('snapBtn');
  const resetBtn = document.getElementById('resetBtn');
  const mirrorBtn = document.getElementById('mirrorBtn');
  const cameraSelect = document.getElementById('cameraSelect');
  const canvasWrapper = document.getElementById('canvasWrapper');
  const canvasArea = document.getElementById('canvasArea');
  const noCameraState = document.getElementById('noCameraState');
  const overlayControls = document.getElementById('overlayControls');
  const recIndicator = document.getElementById('recIndicator');
  const fpsCounter = document.getElementById('fpsCounter');

  // Sliders
  const intensitySlider = document.getElementById('intensity');
  const brightnessSlider = document.getElementById('brightness');
  const contrastSlider = document.getElementById('contrast');
  const saturationSlider = document.getElementById('saturation');

  // ---- State ----
  let stream = null;
  let currentFilter = 'none';
  let mirrored = true;
  let animId = null;
  let snapshots = [];
  let cameras = [];
  let currentCameraIdx = 0;
  let frameCount = 0;
  let lastFpsTime = performance.now();

  // ---- Filter Definitions ----
  const filters = [
    { id: 'none',        name: 'None',        icon: 'ðŸš«', category: 'basic' },
    { id: 'grayscale',   name: 'Grayscale',   icon: 'ðŸ–¤', category: 'basic' },
    { id: 'sepia',       name: 'Sepia',       icon: 'ðŸŸ¤', category: 'basic' },
    { id: 'invert',      name: 'Invert',      icon: 'ðŸ”„', category: 'basic' },
    { id: 'posterize',   name: 'Posterize',   icon: 'ðŸŽ¨', category: 'basic' },
    { id: 'pixelate',    name: 'Pixelate',    icon: 'ðŸŸ©', category: 'fun' },
    { id: 'vhs',         name: 'VHS',         icon: 'ðŸ“¼', category: 'fun' },
    { id: 'thermal',     name: 'Thermal',     icon: 'ðŸŒ¡ï¸', category: 'fun' },
    { id: 'matrix',      name: 'Matrix',      icon: 'ðŸ’š', category: 'fun' },
    { id: 'duotone',     name: 'Duotone',     icon: 'ðŸ’œ', category: 'art' },
    { id: 'emboss',      name: 'Emboss',      icon: 'ðŸ—¿', category: 'art' },
    { id: 'edge',        name: 'Edge Detect', icon: 'âœï¸', category: 'art' },
    { id: 'halftone',    name: 'Halftone',    icon: 'ðŸ”µ', category: 'art' },
    { id: 'glitch',      name: 'Glitch',      icon: 'âš¡', category: 'fun' },
    { id: 'blur',        name: 'Blur',        icon: 'ðŸŒ€', category: 'basic' },
    { id: 'rainbow',     name: 'Rainbow',     icon: 'ðŸŒˆ', category: 'fun' },
    { id: 'oil',         name: 'Oil Paint',   icon: 'ðŸ–Œï¸', category: 'art' },
    { id: 'vintage',     name: 'Vintage',     icon: 'ðŸ“·', category: 'art' },
    { id: 'nightvision', name: 'Night Vision',icon: 'ðŸ‘ï¸', category: 'fun' },
    { id: 'ascii',       name: 'ASCII',       icon: 'ðŸ”¤', category: 'fun' },
  ];

  // ---- Build Filter Buttons ----
  filters.forEach(f => {
    const btn = document.createElement('button');
    btn.className = 'filter-btn' + (f.id === 'none' ? ' active' : '');
    btn.dataset.filter = f.id;
    btn.innerHTML = `<span class="filter-icon">${f.icon}</span>${f.name}`;
    btn.addEventListener('click', () => {
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentFilter = f.id;
    });
    filterGrid.appendChild(btn);
  });

  // ---- Slider handlers ----
  function updateSliderLabel(slider, labelId, suffix = '%') {
    document.getElementById(labelId).textContent = slider.value + suffix;
  }
  intensitySlider.addEventListener('input', () => updateSliderLabel(intensitySlider, 'intensityVal'));
  brightnessSlider.addEventListener('input', () => updateSliderLabel(brightnessSlider, 'brightnessVal'));
  contrastSlider.addEventListener('input', () => updateSliderLabel(contrastSlider, 'contrastVal'));
  saturationSlider.addEventListener('input', () => updateSliderLabel(saturationSlider, 'saturationVal'));

  // ---- Camera ----
  async function startCamera(deviceId) {
    try {
      if (stream) stream.getTracks().forEach(t => t.stop());
      const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 } } };
      if (deviceId) constraints.video.deviceId = { exact: deviceId };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();

      // Enumerate cameras
      const devices = await navigator.mediaDevices.enumerateDevices();
      cameras = devices.filter(d => d.kind === 'videoinput');

      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 480;

      noCameraState.style.display = 'none';
      canvasWrapper.style.display = 'block';
      overlayControls.style.display = 'flex';
      recIndicator.classList.add('visible');
      startBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>Stop`;
      startBtn.classList.add('btn-danger');
      startBtn.classList.remove('btn-primary');

      if (mirrored) canvasArea.classList.add('mirror-active');
      if (!animId) render();
      showToast('Camera started', 'success');
    } catch (e) {
      console.error(e);
      showToast('Camera access denied or unavailable');
    }
  }

  function stopCamera() {
    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = null;
    if (animId) { cancelAnimationFrame(animId); animId = null; }
    noCameraState.style.display = 'flex';
    canvasWrapper.style.display = 'none';
    overlayControls.style.display = 'none';
    recIndicator.classList.remove('visible');
    startBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>Start Camera`;
    startBtn.classList.remove('btn-danger');
    startBtn.classList.add('btn-primary');
    canvasArea.classList.remove('mirror-active');
  }

  startBtn.addEventListener('click', () => stream ? stopCamera() : startCamera());

  cameraSelect.addEventListener('click', () => {
    if (cameras.length < 2) { showToast('Only one camera detected'); return; }
    currentCameraIdx = (currentCameraIdx + 1) % cameras.length;
    startCamera(cameras[currentCameraIdx].deviceId);
  });

  mirrorBtn.addEventListener('click', () => {
    mirrored = !mirrored;
    canvasArea.classList.toggle('mirror-active', mirrored);
    mirrorBtn.style.color = mirrored ? 'var(--accent)' : '';
  });
  mirrorBtn.style.color = 'var(--accent)';

  // ---- Reset ----
  resetBtn.addEventListener('click', () => {
    currentFilter = 'none';
    intensitySlider.value = 100; updateSliderLabel(intensitySlider, 'intensityVal');
    brightnessSlider.value = 100; updateSliderLabel(brightnessSlider, 'brightnessVal');
    contrastSlider.value = 100; updateSliderLabel(contrastSlider, 'contrastVal');
    saturationSlider.value = 100; updateSliderLabel(saturationSlider, 'saturationVal');
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    document.querySelector('[data-filter="none"]').classList.add('active');
    showToast('Filters reset', 'success');
  });

  // ---- Snapshot ----
  function takeSnapshot() {
    flashEl.classList.add('active');
    setTimeout(() => flashEl.classList.remove('active'), 150);

    // Create a temporary canvas for saving (unmirrored or mirrored as displayed)
    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = canvas.width;
    tmpCanvas.height = canvas.height;
    const tmpCtx = tmpCanvas.getContext('2d');
    if (mirrored) {
      tmpCtx.translate(tmpCanvas.width, 0);
      tmpCtx.scale(-1, 1);
    }
    tmpCtx.drawImage(canvas, 0, 0);

    const dataUrl = tmpCanvas.toDataURL('image/png');
    snapshots.unshift(dataUrl);
    updateGallery();
    showToast('Snapshot captured!', 'success');
  }

  snapBtn.addEventListener('click', takeSnapshot);

  function updateGallery() {
    gallery.innerHTML = '';
    snapshots.forEach((src, i) => {
      const item = document.createElement('div');
      item.className = 'gallery-item';
      item.innerHTML = `
        <img src="${src}" alt="Snapshot ${i + 1}">
        <div class="gallery-actions">
          <button class="btn btn-icon" data-save="${i}" title="Save">
            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
          </button>
          <button class="btn btn-icon btn-danger" data-del="${i}" title="Delete">
            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
          </button>
        </div>
      `;
      gallery.appendChild(item);
    });

    // Save handlers
    gallery.querySelectorAll('[data-save]').forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        const idx = parseInt(btn.dataset.save);
        const a = document.createElement('a');
        a.href = snapshots[idx];
        a.download = `webcam-snapshot-${Date.now()}.png`;
        a.click();
        showToast('Image saved!', 'success');
      });
    });

    // Delete handlers
    gallery.querySelectorAll('[data-del]').forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        snapshots.splice(parseInt(btn.dataset.del), 1);
        updateGallery();
      });
    });
  }

  // ---- Toast ----
  let toastTimeout;
  function showToast(msg, type = '') {
    toastEl.textContent = msg;
    toastEl.className = 'toast show' + (type ? ' ' + type : '');
    clearTimeout(toastTimeout);
    toastTimeout = setTimeout(() => toastEl.classList.remove('show'), 2000);
  }

  // ---- Keyboard shortcuts ----
  document.addEventListener('keydown', e => {
    if (e.code === 'Space' && stream) { e.preventDefault(); takeSnapshot(); }
    if (e.code === 'KeyM') { mirrorBtn.click(); }
    if (e.code === 'KeyR' && !e.ctrlKey && !e.metaKey) { resetBtn.click(); }
  });

  // ---- Render loop ----
  function render() {
    animId = requestAnimationFrame(render);
    if (!video.videoWidth) return;

    // Resize canvas if needed
    if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    const w = canvas.width, h = canvas.height;
    const intensity = intensitySlider.value / 100;
    const brightness = brightnessSlider.value / 100;
    const contrastVal = contrastSlider.value / 100;
    const satVal = saturationSlider.value / 100;

    // Draw base video frame
    ctx.filter = `brightness(${brightness}) contrast(${contrastVal}) saturate(${satVal})`;
    ctx.drawImage(video, 0, 0, w, h);
    ctx.filter = 'none';

    // Apply filter
    if (currentFilter !== 'none') {
      applyFilter(currentFilter, intensity, w, h);
    }

    // FPS counter
    frameCount++;
    const now = performance.now();
    if (now - lastFpsTime >= 1000) {
      fpsCounter.textContent = frameCount + ' FPS';
      frameCount = 0;
      lastFpsTime = now;
    }
  }

  // ---- Filter Implementations ----
  function applyFilter(filter, intensity, w, h) {
    let imageData, data;

    switch(filter) {
      case 'grayscale':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
          data[i]   = lerp(data[i], gray, intensity);
          data[i+1] = lerp(data[i+1], gray, intensity);
          data[i+2] = lerp(data[i+2], gray, intensity);
        }
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'sepia':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i], g = data[i+1], b = data[i+2];
          const sr = Math.min(255, 0.393*r + 0.769*g + 0.189*b);
          const sg = Math.min(255, 0.349*r + 0.686*g + 0.168*b);
          const sb = Math.min(255, 0.272*r + 0.534*g + 0.131*b);
          data[i]   = lerp(r, sr, intensity);
          data[i+1] = lerp(g, sg, intensity);
          data[i+2] = lerp(b, sb, intensity);
        }
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'invert':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          data[i]   = lerp(data[i], 255 - data[i], intensity);
          data[i+1] = lerp(data[i+1], 255 - data[i+1], intensity);
          data[i+2] = lerp(data[i+2], 255 - data[i+2], intensity);
        }
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'posterize':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        const levels = Math.max(2, Math.round(2 + (1 - intensity) * 8));
        for (let i = 0; i < data.length; i += 4) {
          data[i]   = Math.round(data[i]   / 255 * (levels - 1)) / (levels - 1) * 255;
          data[i+1] = Math.round(data[i+1] / 255 * (levels - 1)) / (levels - 1) * 255;
          data[i+2] = Math.round(data[i+2] / 255 * (levels - 1)) / (levels - 1) * 255;
        }
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'pixelate': {
        const size = Math.max(2, Math.round(intensity * 20));
        ctx.imageSmoothingEnabled = false;
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');
        const sw = Math.ceil(w / size), sh = Math.ceil(h / size);
        tmpCanvas.width = sw; tmpCanvas.height = sh;
        tmpCtx.drawImage(canvas, 0, 0, sw, sh);
        ctx.clearRect(0, 0, w, h);
        ctx.drawImage(tmpCanvas, 0, 0, sw, sh, 0, 0, w, h);
        ctx.imageSmoothingEnabled = true;
        break;
      }

      case 'vhs':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        const time = performance.now() * 0.001;
        // Color channel shift
        const shift = Math.round(intensity * 6);
        for (let y = 0; y < h; y++) {
          const scanlineFlicker = Math.sin(y * 0.5 + time * 10) * 0.1 * intensity;
          for (let x = 0; x < w; x++) {
            const idx = (y * w + x) * 4;
            const rIdx = (y * w + Math.min(w-1, x + shift)) * 4;
            const bIdx = (y * w + Math.max(0, x - shift)) * 4;
            const r = data[rIdx];
            const b = data[bIdx + 2];
            data[idx] = Math.min(255, r + scanlineFlicker * 60);
            data[idx+2] = Math.min(255, b + scanlineFlicker * 40);
            // Scanlines
            if (y % 3 === 0) {
              data[idx]   = Math.max(0, data[idx] - 30 * intensity);
              data[idx+1] = Math.max(0, data[idx+1] - 30 * intensity);
              data[idx+2] = Math.max(0, data[idx+2] - 30 * intensity);
            }
          }
        }
        // Random noise
        for (let i = 0; i < data.length; i += 4) {
          const noise = (Math.random() - 0.5) * 40 * intensity;
          data[i] += noise; data[i+1] += noise; data[i+2] += noise;
        }
        ctx.putImageData(imageData, 0, 0);
        // Static bar
        if (Math.random() < 0.05 * intensity) {
          const barY = Math.random() * h;
          const barH = 2 + Math.random() * 8;
          ctx.fillStyle = `rgba(255,255,255,${0.1 * intensity})`;
          ctx.fillRect(0, barY, w, barH);
        }
        break;

      case 'thermal':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const val = (data[i] + data[i+1] + data[i+2]) / 3 / 255;
          let r, g, b;
          if (val < 0.25) { r = 0; g = 0; b = val * 4 * 255; }
          else if (val < 0.5) { r = 0; g = (val - 0.25) * 4 * 255; b = (0.5 - val) * 4 * 255; }
          else if (val < 0.75) { r = (val - 0.5) * 4 * 255; g = 255; b = 0; }
          else { r = 255; g = (1 - val) * 4 * 255; b = 0; }
          data[i]   = lerp(data[i], r, intensity);
          data[i+1] = lerp(data[i+1], g, intensity);
          data[i+2] = lerp(data[i+2], b, intensity);
        }
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'matrix':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const avg = (data[i] + data[i+1] + data[i+2]) / 3;
          data[i]   = lerp(data[i], avg * 0.1, intensity);
          data[i+1] = lerp(data[i+1], avg, intensity);
          data[i+2] = lerp(data[i+2], avg * 0.2, intensity);
        }
        ctx.putImageData(imageData, 0, 0);
        // Matrix rain overlay
        ctx.fillStyle = `rgba(0,0,0,${0.15 * intensity})`;
        ctx.fillRect(0, 0, w, h);
        const t = performance.now() * 0.001;
        ctx.font = '12px monospace';
        ctx.fillStyle = `rgba(0,255,65,${0.5 * intensity})`;
        for (let x = 0; x < w; x += 16) {
          const offset = (Math.sin(x * 0.1 + t) * h + t * 100) % h;
          for (let y = offset % 20; y < h; y += 20) {
            const char = String.fromCharCode(0x30A0 + Math.random() * 96);
            ctx.fillText(char, x, y);
          }
        }
        break;

      case 'duotone':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        // Purple to orange duotone
        for (let i = 0; i < data.length; i += 4) {
          const gray = (data[i] + data[i+1] + data[i+2]) / 3 / 255;
          const r = lerp(50, 255, gray);
          const g = lerp(20, 150, gray);
          const b = lerp(180, 50, gray);
          data[i]   = lerp(data[i], r, intensity);
          data[i+1] = lerp(data[i+1], g, intensity);
          data[i+2] = lerp(data[i+2], b, intensity);
        }
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'emboss':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        const embossed = new Uint8ClampedArray(data);
        for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
            const idx = (y * w + x) * 4;
            for (let c = 0; c < 3; c++) {
              const val = -data[((y-1)*w+(x-1))*4+c] - data[((y-1)*w+x)*4+c]
                         + data[((y+1)*w+x)*4+c] + data[((y+1)*w+(x+1))*4+c] + 128;
              embossed[idx + c] = lerp(data[idx + c], Math.min(255, Math.max(0, val)), intensity);
            }
          }
        }
        imageData.data.set(embossed);
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'edge':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        const edged = new Uint8ClampedArray(data);
        for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
            const idx = (y * w + x) * 4;
            for (let c = 0; c < 3; c++) {
              const gx = -data[((y-1)*w+(x-1))*4+c] + data[((y-1)*w+(x+1))*4+c]
                       - 2*data[(y*w+(x-1))*4+c] + 2*data[(y*w+(x+1))*4+c]
                       - data[((y+1)*w+(x-1))*4+c] + data[((y+1)*w+(x+1))*4+c];
              const gy = -data[((y-1)*w+(x-1))*4+c] - 2*data[((y-1)*w+x)*4+c] - data[((y-1)*w+(x+1))*4+c]
                       + data[((y+1)*w+(x-1))*4+c] + 2*data[((y+1)*w+x)*4+c] + data[((y+1)*w+(x+1))*4+c];
              edged[idx + c] = lerp(data[idx + c], Math.min(255, Math.sqrt(gx*gx + gy*gy)), intensity);
            }
          }
        }
        imageData.data.set(edged);
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'halftone':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, w, h);
        const dotSize = 6;
        for (let y = 0; y < h; y += dotSize) {
          for (let x = 0; x < w; x += dotSize) {
            const idx = (y * w + x) * 4;
            const avg = (data[idx] + data[idx+1] + data[idx+2]) / 3;
            const radius = (avg / 255) * (dotSize / 2) * intensity + (dotSize / 2) * (1 - intensity);
            ctx.beginPath();
            ctx.arc(x + dotSize/2, y + dotSize/2, Math.max(0.5, radius * intensity + (1-intensity) * dotSize/4), 0, Math.PI * 2);
            ctx.fillStyle = `rgb(${data[idx]}, ${data[idx+1]}, ${data[idx+2]})`;
            ctx.fill();
          }
        }
        break;

      case 'glitch':
        imageData = ctx.getImageData(0, 0, w, h);
        const t2 = performance.now();
        // Random horizontal slices
        const numSlices = Math.round(3 + intensity * 12);
        for (let s = 0; s < numSlices; s++) {
          if (Math.random() > 0.5 * intensity) continue;
          const sliceY = Math.floor(Math.random() * h);
          const sliceH = Math.floor(2 + Math.random() * 30 * intensity);
          const offset = Math.floor((Math.random() - 0.5) * 60 * intensity);
          const sliceData = ctx.getImageData(0, sliceY, w, Math.min(sliceH, h - sliceY));
          ctx.putImageData(sliceData, offset, sliceY);
        }
        // Color channel offset
        if (Math.random() < 0.4 * intensity) {
          imageData = ctx.getImageData(0, 0, w, h);
          data = imageData.data;
          const channelShift = Math.floor(Math.random() * 20 * intensity);
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const idx = (y * w + x) * 4;
              const shiftIdx = (y * w + Math.min(w-1, x + channelShift)) * 4;
              data[idx] = data[shiftIdx]; // Red channel shift
            }
          }
          ctx.putImageData(imageData, 0, 0);
        }
        // Random blocks
        if (Math.random() < 0.15 * intensity) {
          const bx = Math.random() * w, by = Math.random() * h;
          const bw = 20 + Math.random() * 100, bh = 5 + Math.random() * 30;
          ctx.fillStyle = `rgba(${Math.random()*255|0},${Math.random()*255|0},${Math.random()*255|0},${0.5*intensity})`;
          ctx.fillRect(bx, by, bw, bh);
        }
        break;

      case 'blur':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        const blurred = new Uint8ClampedArray(data);
        const radius = Math.max(1, Math.round(intensity * 5));
        for (let y = radius; y < h - radius; y += 1) {
          for (let x = radius; x < w - radius; x += 1) {
            let r = 0, g = 0, b = 0, count = 0;
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const idx2 = ((y+dy) * w + (x+dx)) * 4;
                r += data[idx2]; g += data[idx2+1]; b += data[idx2+2];
                count++;
              }
            }
            const idx = (y * w + x) * 4;
            blurred[idx] = r / count;
            blurred[idx+1] = g / count;
            blurred[idx+2] = b / count;
          }
        }
        imageData.data.set(blurred);
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'rainbow':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        const rt = performance.now() * 0.002;
        for (let y = 0; y < h; y++) {
          const hue = ((y / h) * 360 + rt * 50) % 360;
          const [rr, rg, rb] = hslToRgb(hue / 360, 1, 0.5);
          for (let x = 0; x < w; x++) {
            const idx = (y * w + x) * 4;
            data[idx]   = lerp(data[idx], (data[idx] + rr) / 2, intensity * 0.8);
            data[idx+1] = lerp(data[idx+1], (data[idx+1] + rg) / 2, intensity * 0.8);
            data[idx+2] = lerp(data[idx+2], (data[idx+2] + rb) / 2, intensity * 0.8);
          }
        }
        ctx.putImageData(imageData, 0, 0);
        break;

      case 'oil': {
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        const oilResult = new Uint8ClampedArray(data);
        const oilRadius = Math.max(2, Math.round(intensity * 4));
        const step = 2; // Process every other pixel for performance
        for (let y = oilRadius; y < h - oilRadius; y += step) {
          for (let x = oilRadius; x < w - oilRadius; x += step) {
            const bins = new Array(20).fill(0);
            const avgR = new Array(20).fill(0);
            const avgG = new Array(20).fill(0);
            const avgB = new Array(20).fill(0);
            for (let dy = -oilRadius; dy <= oilRadius; dy += 1) {
              for (let dx = -oilRadius; dx <= oilRadius; dx += 1) {
                const si = ((y+dy)*w + (x+dx)) * 4;
                const curIntensity = Math.floor(((data[si]+data[si+1]+data[si+2])/3) * 19 / 255);
                bins[curIntensity]++;
                avgR[curIntensity] += data[si];
                avgG[curIntensity] += data[si+1];
                avgB[curIntensity] += data[si+2];
              }
            }
            let maxBin = 0, maxCount = 0;
            for (let b = 0; b < 20; b++) {
              if (bins[b] > maxCount) { maxCount = bins[b]; maxBin = b; }
            }
            const idx = (y * w + x) * 4;
            const nr = avgR[maxBin] / maxCount;
            const ng = avgG[maxBin] / maxCount;
            const nb = avgB[maxBin] / maxCount;
            // Fill step x step block
            for (let sy = 0; sy < step && y+sy < h; sy++) {
              for (let sx = 0; sx < step && x+sx < w; sx++) {
                const fi = ((y+sy)*w + (x+sx)) * 4;
                oilResult[fi]   = lerp(data[fi], nr, intensity);
                oilResult[fi+1] = lerp(data[fi+1], ng, intensity);
                oilResult[fi+2] = lerp(data[fi+2], nb, intensity);
              }
            }
          }
        }
        imageData.data.set(oilResult);
        ctx.putImageData(imageData, 0, 0);
        break;
      }

      case 'vintage':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          // Warm tint + desaturate
          const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
          let r = lerp(data[i], gray, 0.3) * 1.1;
          let g = lerp(data[i+1], gray, 0.3) * 0.95;
          let b = lerp(data[i+2], gray, 0.3) * 0.8;
          // Vignette approximation
          const x = (i / 4) % w, y = Math.floor((i / 4) / w);
          const dx = (x - w/2) / (w/2), dy = (y - h/2) / (h/2);
          const vignette = 1 - (dx*dx + dy*dy) * 0.4;
          r *= vignette; g *= vignette; b *= vignette;
          data[i]   = lerp(data[i], Math.min(255, r), intensity);
          data[i+1] = lerp(data[i+1], Math.min(255, g), intensity);
          data[i+2] = lerp(data[i+2], Math.min(255, b), intensity);
        }
        ctx.putImageData(imageData, 0, 0);
        // Film grain
        ctx.globalAlpha = 0.06 * intensity;
        for (let i = 0; i < 2000; i++) {
          const gx = Math.random() * w, gy = Math.random() * h;
          ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000';
          ctx.fillRect(gx, gy, 1, 1);
        }
        ctx.globalAlpha = 1;
        break;

      case 'nightvision':
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const avg = (data[i] + data[i+1] + data[i+2]) / 3;
          const boosted = Math.min(255, avg * 1.5);
          const noise = (Math.random() - 0.5) * 30 * intensity;
          data[i]   = lerp(data[i], 30 + noise, intensity);
          data[i+1] = lerp(data[i+1], Math.min(255, boosted + 50 + noise), intensity);
          data[i+2] = lerp(data[i+2], 30 + noise, intensity);
        }
        ctx.putImageData(imageData, 0, 0);
        // Vignette
        const gradient = ctx.createRadialGradient(w/2, h/2, h*0.3, w/2, h/2, h*0.8);
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, `rgba(0,0,0,${0.7 * intensity})`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);
        break;

      case 'ascii': {
        imageData = ctx.getImageData(0, 0, w, h);
        data = imageData.data;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
        const chars = ' .,:;+*?%S#@';
        const cellSize = 8;
        ctx.font = `${cellSize}px monospace`;
        ctx.textBaseline = 'top';
        for (let y = 0; y < h; y += cellSize) {
          for (let x = 0; x < w; x += cellSize) {
            const idx = (y * w + x) * 4;
            const avg = (data[idx] + data[idx+1] + data[idx+2]) / 3;
            const charIdx = Math.floor((avg / 255) * (chars.length - 1));
            const r = data[idx], g = data[idx+1], b = data[idx+2];
            ctx.fillStyle = intensity > 0.5
              ? `rgb(${lerp(r, 0, intensity-0.5)}, ${lerp(g, 255, intensity-0.5)}, ${lerp(b, 0, intensity-0.5)})`
              : `rgb(${r}, ${g}, ${b})`;
            ctx.fillText(chars[charIdx], x, y);
          }
        }
        break;
      }
    }
  }

  // ---- Utility functions ----
  function lerp(a, b, t) { return a + (b - a) * t; }

  function hslToRgb(h, s, l) {
    let r, g, b;
    if (s === 0) { r = g = b = l; }
    else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1; if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return [r * 255, g * 255, b * 255];
  }

  // Auto-start hint
  noCameraState.style.cursor = 'pointer';
  noCameraState.addEventListener('click', () => startCamera());
})();
</script>
</body>
</html>
