<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Weather Theatre</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Inter:wght@300;400;500;600&family=Special+Elite&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --curtain-red: #8B1A1A;
    --curtain-dark: #5C0E0E;
    --gold: #D4AF37;
    --gold-light: #F0D060;
    --theatre-bg: #0e0e1a;
  }

  body {
    background: var(--theatre-bg);
    font-family: 'Inter', sans-serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    color: #e0e0e0;
  }

  #root { height: 100%; width: 100%; }

  .theatre-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    position: relative;
    overflow: hidden;
  }

  /* Ornamental header */
  .theatre-header {
    text-align: center;
    padding: 6px 0 0;
    position: relative;
    z-index: 2;
  }

  .theatre-header h1 {
    font-family: 'Playfair Display', serif;
    font-size: 15px;
    font-weight: 400;
    letter-spacing: 6px;
    text-transform: uppercase;
    color: var(--gold);
    opacity: 0.5;
  }

  /* Stage Frame */
  .stage-frame {
    position: relative;
    flex: 1;
    margin: 4px 14px 0 14px;
    border-radius: 16px 16px 0 0;
    overflow: hidden;
    box-shadow:
      inset 0 0 80px rgba(0,0,0,0.5),
      0 0 40px rgba(0,0,0,0.9),
      0 -2px 20px rgba(212,175,55,0.05);
  }

  .stage-frame::before {
    content: '';
    position: absolute;
    inset: 0;
    border: 2px solid var(--gold);
    border-bottom: none;
    border-radius: 16px 16px 0 0;
    z-index: 100;
    pointer-events: none;
    opacity: 0.25;
  }

  .stage-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  /* Curtains */
  .curtain {
    position: absolute;
    top: -5%;
    height: 110%;
    width: 55%;
    z-index: 50;
    transition: transform 2.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    pointer-events: none;
  }

  .curtain-left {
    left: 0;
    transform: translateX(0);
    background: linear-gradient(90deg,
      var(--curtain-dark) 0%,
      var(--curtain-red) 12%,
      #A02020 22%,
      var(--curtain-red) 35%,
      var(--curtain-dark) 48%,
      var(--curtain-red) 58%,
      #A02020 72%,
      var(--curtain-red) 85%,
      var(--curtain-dark) 100%
    );
  }

  .curtain-right {
    right: 0;
    transform: translateX(0);
    background: linear-gradient(270deg,
      var(--curtain-dark) 0%,
      var(--curtain-red) 12%,
      #A02020 22%,
      var(--curtain-red) 35%,
      var(--curtain-dark) 48%,
      var(--curtain-red) 58%,
      #A02020 72%,
      var(--curtain-red) 85%,
      var(--curtain-dark) 100%
    );
  }

  .curtain-left.open { transform: translateX(-93%); }
  .curtain-right.open { transform: translateX(93%); }

  .curtain::after {
    content: '';
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(180deg, transparent 0px, rgba(0,0,0,0.02) 1px, transparent 3px);
  }

  .curtain-fold {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(90deg,
      transparent 0px, rgba(255,255,255,0.03) 6px, transparent 12px,
      rgba(0,0,0,0.06) 18px, transparent 24px
    );
  }

  /* Gathered curtain shadow at edges */
  .curtain-left .curtain-shadow {
    position: absolute;
    right: 0;
    top: 0;
    width: 30%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0,0,0,0.25));
  }

  .curtain-right .curtain-shadow {
    position: absolute;
    left: 0;
    top: 0;
    width: 30%;
    height: 100%;
    background: linear-gradient(270deg, transparent, rgba(0,0,0,0.25));
  }

  /* Valance (top drape) */
  .valance {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 45px;
    z-index: 60;
    background: linear-gradient(180deg, var(--curtain-dark) 0%, var(--curtain-red) 50%, transparent 100%);
    pointer-events: none;
  }

  .valance-scallop {
    position: absolute;
    bottom: -20px;
    left: 0;
    right: 0;
    height: 30px;
    z-index: 60;
    pointer-events: none;
  }

  .gold-trim {
    position: absolute;
    bottom: -1px;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg,
      transparent 0%, var(--gold) 8%, var(--gold-light) 50%, var(--gold) 92%, transparent 100%
    );
    z-index: 61;
    opacity: 0.4;
  }

  /* Typewriter subtitle */
  .subtitle-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 70;
    padding: 20px 40px 16px;
    background: linear-gradient(transparent, rgba(0,0,0,0.7) 40%, rgba(0,0,0,0.85));
    pointer-events: none;
  }

  .subtitle-text {
    font-family: 'Special Elite', 'Courier New', monospace;
    font-size: 17px;
    color: #f0e6d2;
    text-shadow: 0 0 12px rgba(240,214,96,0.2), 1px 1px 3px rgba(0,0,0,0.9);
    letter-spacing: 0.3px;
    min-height: 26px;
    text-align: center;
    line-height: 1.5;
  }

  .subtitle-text .cursor {
    display: inline-block;
    width: 2px;
    height: 17px;
    background: var(--gold-light);
    margin-left: 1px;
    vertical-align: text-bottom;
    animation: blink 0.7s step-end infinite;
    opacity: 0.8;
  }

  @keyframes blink { 50% { opacity: 0; } }

  /* Control Panel */
  .control-panel {
    background: linear-gradient(180deg, #0a0a18 0%, #12122a 100%);
    border-top: 1px solid rgba(212,175,55,0.15);
    padding: 12px 28px 14px;
    display: flex;
    align-items: center;
    gap: 24px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .panel-title {
    font-family: 'Playfair Display', serif;
    font-size: 13px;
    color: var(--gold);
    letter-spacing: 3px;
    text-transform: uppercase;
    opacity: 0.6;
    white-space: nowrap;
  }

  .slider-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .slider-label {
    font-family: 'Inter', sans-serif;
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 1.8px;
    text-transform: uppercase;
    min-width: 48px;
    text-align: right;
  }

  .label-cosy { color: #FFB347; }
  .label-eerie { color: #9B7DFF; }
  .label-heroic { color: #FF6B6B; }

  .slider-value {
    font-size: 10px;
    font-weight: 600;
    min-width: 26px;
    text-align: center;
    font-family: 'Inter', sans-serif;
    opacity: 0.7;
  }

  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 110px;
    height: 3px;
    border-radius: 2px;
    outline: none;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  input[type="range"]:hover { opacity: 0.9; }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid rgba(255,255,255,0.2);
    box-shadow: 0 0 8px rgba(0,0,0,0.5), 0 0 4px rgba(0,0,0,0.3);
    transition: transform 0.15s, box-shadow 0.15s;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.25);
    box-shadow: 0 0 12px rgba(0,0,0,0.5), 0 0 6px rgba(255,255,255,0.1);
  }

  input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid rgba(255,255,255,0.2);
    box-shadow: 0 0 8px rgba(0,0,0,0.5);
  }

  .slider-cosy { background: linear-gradient(90deg, #3a2510, #FFB347); }
  .slider-cosy::-webkit-slider-thumb { background: #FFB347; }
  .slider-cosy::-moz-range-thumb { background: #FFB347; }

  .slider-eerie { background: linear-gradient(90deg, #1f1840, #9B7DFF); }
  .slider-eerie::-webkit-slider-thumb { background: #9B7DFF; }
  .slider-eerie::-moz-range-thumb { background: #9B7DFF; }

  .slider-heroic { background: linear-gradient(90deg, #301515, #FF6B6B); }
  .slider-heroic::-webkit-slider-thumb { background: #FF6B6B; }
  .slider-heroic::-moz-range-thumb { background: #FF6B6B; }

  /* Toggle */
  .toggle-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-left: 4px;
  }

  .toggle-label {
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    transition: color 0.4s, opacity 0.4s;
    cursor: default;
  }

  .toggle-label.active { color: var(--gold-light); opacity: 1; }
  .toggle-label.inactive { color: #555; opacity: 0.6; }

  .toggle-switch {
    width: 44px;
    height: 22px;
    border-radius: 11px;
    background: #1e1e3a;
    border: 1px solid rgba(212,175,55,0.2);
    cursor: pointer;
    position: relative;
    transition: background 0.4s, border-color 0.4s;
  }

  .toggle-switch:hover { border-color: rgba(212,175,55,0.4); }
  .toggle-switch.night { background: #141430; }

  .toggle-knob {
    position: absolute;
    top: 2px;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1), background 0.4s;
    box-shadow: 0 1px 6px rgba(0,0,0,0.5);
  }

  .toggle-knob.matinee {
    left: 2px;
    background: linear-gradient(135deg, #FFD700, #FFA500);
  }

  .toggle-knob.night {
    left: 24px;
    background: linear-gradient(135deg, #7C6EF6, #4338CA);
  }

  /* Forecast badge */
  .forecast-badge {
    position: absolute;
    top: 54px;
    right: 18px;
    z-index: 65;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(212,175,55,0.15);
    border-radius: 12px;
    padding: 12px 18px;
    pointer-events: none;
    transition: opacity 0.8s;
  }

  .forecast-temp {
    font-family: 'Playfair Display', serif;
    font-size: 30px;
    font-weight: 700;
    color: #fff;
    line-height: 1;
  }

  .forecast-condition {
    font-size: 11px;
    color: rgba(255,255,255,0.55);
    margin-top: 3px;
    letter-spacing: 0.5px;
  }

  .forecast-details {
    display: flex;
    gap: 14px;
    margin-top: 8px;
    font-size: 10px;
    color: rgba(255,255,255,0.4);
    letter-spacing: 0.3px;
  }

  .forecast-details span {
    display: flex;
    align-items: center;
    gap: 3px;
  }

  /* Scene title */
  .scene-title {
    position: absolute;
    top: 54px;
    left: 18px;
    z-index: 65;
    pointer-events: none;
    transition: opacity 0.8s;
  }

  .scene-title h2 {
    font-family: 'Playfair Display', serif;
    font-size: 22px;
    font-weight: 700;
    font-style: italic;
    color: var(--gold-light);
    text-shadow: 0 2px 12px rgba(0,0,0,0.7);
    opacity: 0.85;
  }

  .scene-title .act {
    font-family: 'Inter', sans-serif;
    font-size: 9px;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: rgba(212,175,55,0.45);
    margin-bottom: 3px;
    font-weight: 500;
  }

  .separator {
    width: 1px;
    height: 24px;
    background: rgba(212,175,55,0.12);
  }

  @media (max-width: 900px) {
    .control-panel { gap: 12px; padding: 10px 12px 12px; }
    input[type="range"] { width: 75px; }
    .separator { display: none; }
    .panel-title { display: none; }
    .theatre-header { display: none; }
    .forecast-badge { top: 50px; right: 10px; padding: 8px 12px; }
    .forecast-temp { font-size: 22px; }
    .scene-title { top: 50px; left: 10px; }
    .scene-title h2 { font-size: 16px; }
  }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// ============================================================
// MOCK FORECAST DATA
// ============================================================
const FORECAST = {
  temp: 14, high: 18, low: 9,
  condition: "Partly Cloudy",
  humidity: 67, wind: 12, windDir: "SW",
  pressure: 1013, uvIndex: 4,
  sunrise: "06:42", sunset: "18:15",
};

// ============================================================
// SCENE TEXT GENERATION
// ============================================================
function getSceneDescription(cosy, eerie, heroic, isNight) {
  const dominant = cosy >= eerie && cosy >= heroic ? 'cosy' : eerie >= heroic ? 'eerie' : 'heroic';
  const timeStr = isNight ? "night" : "afternoon";
  const scenes = {
    cosy: {
      afternoon: [
        `A gentle ${FORECAST.temp}\u00B0 breeze drifts through amber-lit windows\u2026 the clouds part like old friends reuniting.`,
        `Warm light spills across the cobblestones at ${FORECAST.temp}\u00B0\u2026 somewhere, a kettle begins to whistle softly.`,
        `The ${FORECAST.condition.toLowerCase()} sky wraps the village in ${FORECAST.temp}\u00B0 of quiet contentment and lazy chimney smoke.`,
      ],
      night: [
        `Firelight flickers against the frost\u2026 ${FORECAST.temp}\u00B0 and falling, but the hearth holds its golden warmth.`,
        `Stars peek through the ${FORECAST.condition.toLowerCase()} canopy\u2026 ${FORECAST.temp}\u00B0 of silver stillness and sleeping gardens.`,
        `The night draws close at ${FORECAST.temp}\u00B0\u2026 embers glow like earthbound constellations beneath the eaves.`,
      ]
    },
    eerie: {
      afternoon: [
        `Fog curls at ${FORECAST.temp}\u00B0\u2026 the ${FORECAST.condition.toLowerCase()} sky conceals more than it reveals.`,
        `Something stirs beneath the ${FORECAST.temp}\u00B0 haze\u2026 the wind shifts to ${FORECAST.windDir} without reason or warning.`,
        `At ${FORECAST.temp}\u00B0, the light bends wrong\u2026 even the ${FORECAST.condition.toLowerCase()} feels like a held breath.`,
      ],
      night: [
        `The darkness thickens at ${FORECAST.temp}\u00B0\u2026 ${FORECAST.wind}km/h winds carry whispers from the hollow beyond.`,
        `Moonlight fractures through the ${FORECAST.condition.toLowerCase()} veil\u2026 ${FORECAST.temp}\u00B0 of creeping, patient dread.`,
        `At ${FORECAST.temp}\u00B0 the shadows lengthen past reason\u2026 something ancient watches from the gathering mist.`,
      ]
    },
    heroic: {
      afternoon: [
        `Thunder builds at ${FORECAST.temp}\u00B0\u2026 the ${FORECAST.wind}km/h ${FORECAST.windDir} gale heralds a reckoning on the horizon.`,
        `The sky blazes at ${FORECAST.temp}\u00B0\u2026 ${FORECAST.condition.toLowerCase()} gives way to triumphant, blinding light.`,
        `At ${FORECAST.temp}\u00B0, the storm breaks\u2014and through the sundering clouds, glory marches forth.`,
      ],
      night: [
        `Lightning crowns the mountains at ${FORECAST.temp}\u00B0\u2026 the ${FORECAST.wind}km/h tempest roars its ancient challenge.`,
        `Stars blaze like war-banners at ${FORECAST.temp}\u00B0\u2026 the ${FORECAST.windDir} wind carries the distant sound of drums.`,
        `The ${FORECAST.temp}\u00B0 darkness crackles with power\u2026 destiny rides the ${FORECAST.condition.toLowerCase()} sky tonight.`,
      ]
    }
  };
  const opts = scenes[dominant][timeStr];
  return opts[Math.floor((cosy * 3 + eerie * 7 + heroic * 11) % opts.length)];
}

function getSceneTitle(cosy, eerie, heroic, isNight) {
  const dominant = cosy >= eerie && cosy >= heroic ? 'cosy' : eerie >= heroic ? 'eerie' : 'heroic';
  const titles = {
    cosy: isNight ? "The Hearthkeeper\u2019s Watch" : "Golden Afternoon",
    eerie: isNight ? "The Whispering Dark" : "Fog & Forgetfulness",
    heroic: isNight ? "Storm\u2019s Coronation" : "The Vanguard Rises"
  };
  return titles[dominant];
}

function getActNumber(cosy, eerie, heroic) {
  return `Act ${Math.max(1, Math.round((cosy + eerie + heroic) / 100 * 5))}`;
}

// ============================================================
// UTILITIES
// ============================================================
function lerp(a, b, t) { return a + (b - a) * t; }
function smoothstep(a, b, t) { const x = Math.max(0, Math.min(1, (t - a) / (b - a))); return x * x * (3 - 2 * x); }

// ============================================================
// CANVAS RENDERER
// ============================================================
class WeatherRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.time = 0;
    this.particles = [];
    this.stars = [];
    this.lightningFlash = 0;
    this.lightningBolts = [];
    this.spotlightAngle = 0;
    this.initStars();
    this.initParticles();
  }

  initStars() {
    this.stars = [];
    for (let i = 0; i < 220; i++) {
      this.stars.push({
        x: Math.random(), y: Math.random() * 0.55,
        size: Math.random() * 2 + 0.4,
        twinkleSpeed: Math.random() * 2.5 + 0.8,
        twinklePhase: Math.random() * Math.PI * 2,
        brightness: Math.random() * 0.5 + 0.5,
      });
    }
  }

  initParticles() {
    this.particles = [];
    for (let i = 0; i < 180; i++) {
      this.particles.push({
        x: Math.random(), y: Math.random(),
        vx: (Math.random() - 0.5) * 0.0008,
        vy: Math.random() * 0.001 + 0.0004,
        size: Math.random() * 3 + 0.8,
        opacity: Math.random() * 0.5 + 0.2,
        type: i % 3 === 0 ? 'ember' : i % 2 === 0 ? 'rain' : 'snow',
        life: Math.random(),
        phase: Math.random() * Math.PI * 2,
      });
    }
  }

  resize(w, h) {
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = w * dpr;
    this.canvas.height = h * dpr;
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    this.w = w;
    this.h = h;
  }

  render(dt, moods, isNight, mouseX) {
    this.time += dt;
    const { cosy, eerie, heroic } = moods;
    const cn = cosy / 100, en = eerie / 100, hn = heroic / 100;
    const ctx = this.ctx;
    const w = this.w, h = this.h;
    if (!w || !h) return;

    ctx.clearRect(0, 0, w, h);

    this.drawSky(ctx, w, h, cn, en, hn, isNight);
    if (isNight) this.drawStars(ctx, w, h, cn, en, hn);
    this.drawAurora(ctx, w, h, cn, en, hn, isNight);
    this.drawCelestial(ctx, w, h, cn, en, hn, isNight);
    this.drawClouds(ctx, w, h, cn, en, hn, isNight, mouseX, 0);
    this.drawMountains(ctx, w, h, cn, en, hn, isNight, mouseX);
    this.drawClouds(ctx, w, h, cn, en, hn, isNight, mouseX, 1);
    this.drawForeground(ctx, w, h, cn, en, hn, isNight, mouseX);
    this.drawParticles(ctx, w, h, cn, en, hn, isNight);
    if (hn > 0.25) this.drawLightning(ctx, w, h, hn, isNight);
    this.drawSpotlights(ctx, w, h, cn, en, hn, isNight);
    if (en > 0.15) this.drawFog(ctx, w, h, en, isNight);
    this.drawVignette(ctx, w, h, en, hn);
    this.drawStageEdge(ctx, w, h);
  }

  drawSky(ctx, w, h, cn, en, hn, isNight) {
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    if (isNight) {
      const topR = lerp(lerp(8, 12, en), 18, hn);
      const topG = lerp(lerp(8, 5, en), 10, hn);
      const topB = lerp(lerp(28, 35, en), 42, hn);
      const midR = lerp(lerp(15, 20, en), 30, hn);
      const midG = lerp(lerp(12, 10, en), 15, hn);
      const midB = lerp(lerp(42, 50, en), 58, hn);
      const botR = lerp(lerp(22, 18, en), 35, cn * 0.5);
      const botG = lerp(lerp(18, 12, en), 22, cn * 0.5);
      const botB = lerp(lerp(35, 40, en), 45, hn * 0.5);
      grad.addColorStop(0, `rgb(${topR},${topG},${topB})`);
      grad.addColorStop(0.55, `rgb(${midR},${midG},${midB})`);
      grad.addColorStop(1, `rgb(${botR},${botG},${botB})`);
    } else {
      const topR = lerp(lerp(95, 75, en), 45, hn);
      const topG = lerp(lerp(145, 115, en), 75, hn);
      const topB = lerp(lerp(215, 145, en), 155, hn);
      const midR = lerp(lerp(175, 155, en), 135, hn);
      const midG = lerp(lerp(195, 165, en), 125, hn);
      const midB = lerp(lerp(225, 170, en), 165, hn);
      const botR = lerp(lerp(250, 195, en), 215, hn);
      const botG = lerp(lerp(215, 175, en), 145, cn * 0.5);
      const botB = lerp(lerp(175, 155, en), 95, hn);
      grad.addColorStop(0, `rgb(${topR},${topG},${topB})`);
      grad.addColorStop(0.55, `rgb(${midR},${midG},${midB})`);
      grad.addColorStop(1, `rgb(${botR},${botG},${botB})`);
    }
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // Warm ambient (cosy)
    if (cn > 0.2) {
      const wg = ctx.createRadialGradient(w * 0.5, h * 0.35, 0, w * 0.5, h * 0.35, w * 0.55);
      wg.addColorStop(0, `rgba(255,190,90,${cn * 0.1})`);
      wg.addColorStop(1, 'rgba(255,190,90,0)');
      ctx.fillStyle = wg;
      ctx.fillRect(0, 0, w, h);
    }

    // Dramatic tinting (heroic)
    if (hn > 0.2) {
      const dg = ctx.createLinearGradient(0, 0, 0, h);
      dg.addColorStop(0, `rgba(50,0,25,${hn * 0.12})`);
      dg.addColorStop(0.5, 'rgba(0,0,0,0)');
      dg.addColorStop(1, `rgba(170,55,15,${hn * 0.08})`);
      ctx.fillStyle = dg;
      ctx.fillRect(0, 0, w, h);
    }

    // Eerie desaturation tint
    if (en > 0.3) {
      ctx.fillStyle = `rgba(80,90,80,${en * 0.06})`;
      ctx.fillRect(0, 0, w, h);
    }
  }

  drawStars(ctx, w, h, cn, en, hn) {
    for (const s of this.stars) {
      const twinkle = Math.sin(this.time * s.twinkleSpeed + s.twinklePhase) * 0.5 + 0.5;
      const alpha = s.brightness * 0.7 * (0.4 + twinkle * 0.6);
      const r = lerp(255, 210, en);
      const g = lerp(255, 235, en);
      const b = lerp(245, 255, en);
      ctx.beginPath();
      ctx.arc(s.x * w, s.y * h, s.size * (0.7 + twinkle * 0.5), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
      ctx.fill();
      if (s.size > 1.8) {
        ctx.beginPath();
        ctx.arc(s.x * w, s.y * h, s.size * 3.5, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${r},${g},${b},${alpha * 0.08})`;
        ctx.fill();
      }
    }
  }

  drawAurora(ctx, w, h, cn, en, hn, isNight) {
    if (!isNight || hn < 0.3) return;
    const intensity = (hn - 0.3) / 0.7;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(0, h * 0.15);
      for (let x = 0; x <= w; x += 8) {
        const y = h * (0.1 + i * 0.06) +
          Math.sin(x * 0.003 + this.time * 0.3 + i * 1.5) * 30 +
          Math.sin(x * 0.007 + this.time * 0.15) * 15;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h * 0.3);
      ctx.lineTo(0, h * 0.3);
      ctx.closePath();
      const colors = ['80,255,160', '100,180,255', '180,100,255'];
      ctx.fillStyle = `rgba(${colors[i]},${intensity * 0.04})`;
      ctx.fill();
    }
  }

  drawCelestial(ctx, w, h, cn, en, hn, isNight) {
    const cx = w * 0.73, cy = h * 0.17;
    if (isNight) {
      const moonR = Math.min(w, h) * 0.055;
      const glowR = moonR * 5;
      const gc = en > 0.5 ? '150,180,255' : cn > 0.5 ? '255,230,180' : '200,215,255';
      const mg = ctx.createRadialGradient(cx, cy, moonR * 0.3, cx, cy, glowR);
      mg.addColorStop(0, `rgba(${gc},0.18)`);
      mg.addColorStop(0.4, `rgba(${gc},0.06)`);
      mg.addColorStop(1, `rgba(${gc},0)`);
      ctx.fillStyle = mg;
      ctx.fillRect(cx - glowR, cy - glowR, glowR * 2, glowR * 2);

      ctx.beginPath();
      ctx.arc(cx, cy, moonR, 0, Math.PI * 2);
      ctx.fillStyle = en > 0.5 ? '#C0D0F8' : cn > 0.5 ? '#FFF3DD' : '#E5EDFF';
      ctx.fill();

      // Craters
      ctx.globalAlpha = 0.06;
      [[-.3,-.2,.18],[.2,.3,.13],[.1,-.35,.09]].forEach(([dx,dy,r]) => {
        ctx.beginPath();
        ctx.arc(cx + moonR*dx, cy + moonR*dy, moonR*r, 0, Math.PI*2);
        ctx.fillStyle = '#777';
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    } else {
      const sunR = Math.min(w, h) * 0.045;
      const sg = ctx.createRadialGradient(cx, cy, 0, cx, cy, sunR * 7);
      if (cn > 0.5) {
        sg.addColorStop(0, 'rgba(255,225,130,0.35)');
        sg.addColorStop(0.25, 'rgba(255,200,80,0.12)');
        sg.addColorStop(1, 'rgba(255,180,60,0)');
      } else if (hn > 0.5) {
        sg.addColorStop(0, 'rgba(255,170,60,0.45)');
        sg.addColorStop(0.25, 'rgba(255,110,30,0.18)');
        sg.addColorStop(1, 'rgba(255,60,20,0)');
      } else {
        sg.addColorStop(0, 'rgba(200,210,230,0.25)');
        sg.addColorStop(0.25, 'rgba(180,195,215,0.08)');
        sg.addColorStop(1, 'rgba(160,175,200,0)');
      }
      ctx.fillStyle = sg;
      ctx.fillRect(0, 0, w, h * 0.5);

      ctx.beginPath();
      ctx.arc(cx, cy, sunR, 0, Math.PI*2);
      ctx.fillStyle = cn > 0.5 ? '#FFE080' : hn > 0.5 ? '#FFA040' : '#DCE0E8';
      ctx.fill();

      // Heroic god-rays
      if (hn > 0.25) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < 8; i++) {
          const a = (i/8)*Math.PI*2 + this.time*0.08;
          const len = sunR * (3 + Math.sin(this.time*1.2+i*1.1)*1.2) * hn;
          const rw = sunR * 0.3;
          ctx.beginPath();
          ctx.moveTo(cx + Math.cos(a-0.04)*sunR*1.1, cy + Math.sin(a-0.04)*sunR*1.1);
          ctx.lineTo(cx + Math.cos(a)*(sunR+len), cy + Math.sin(a)*(sunR+len));
          ctx.lineTo(cx + Math.cos(a+0.04)*sunR*1.1, cy + Math.sin(a+0.04)*sunR*1.1);
          ctx.closePath();
          ctx.fillStyle = `rgba(255,210,90,${hn*0.06})`;
          ctx.fill();
        }
        ctx.restore();
      }
    }
  }

  drawClouds(ctx, w, h, cn, en, hn, isNight, mouseX, layer) {
    const px = (mouseX - 0.5) * (layer === 0 ? 25 : 50);
    const baseY = layer === 0 ? h * 0.1 : h * 0.32;
    const num = layer === 0 ? 6 : 5;
    for (let i = 0; i < num; i++) {
      const seed = i * 137.5 + layer * 57;
      const cx = ((seed % w) + this.time * (6 + i * 2.5) * (layer === 0 ? 0.4 : 0.8) + px) % (w + 350) - 175;
      const cy = baseY + Math.sin(seed * 0.08 + this.time * 0.15) * 18 + i * (layer === 0 ? 22 : 28);
      const sc = 0.65 + (seed % 100) / 180;
      let a, r, g, b;
      if (isNight) {
        a = lerp(0.12, 0.25, en) * sc;
        r = lerp(28, 38, en); g = lerp(28, 26, en); b = lerp(48, 58, en);
      } else if (hn > 0.5) {
        a = lerp(0.35, 0.55, hn) * sc;
        r = lerp(135, 95, hn); g = lerp(135, 75, hn); b = lerp(145, 85, hn);
      } else if (en > 0.5) {
        a = lerp(0.3, 0.5, en) * sc;
        r = lerp(155, 125, en); g = lerp(155, 130, en); b = lerp(160, 135, en);
      } else {
        a = lerp(0.25, 0.45, cn) * sc;
        r = 225; g = 220; b = 215;
      }
      this.drawCloudShape(ctx, cx, cy, 85*sc, 28*sc, `rgba(${r},${g},${b},${a})`);
    }
  }

  drawCloudShape(ctx, x, y, cw, ch, color) {
    ctx.fillStyle = color;
    const blobs = [
      [0, 0, 1, 1], [-0.5, 0.2, 0.6, 0.8], [0.45, 0.1, 0.7, 0.75],
      [-0.2, -0.45, 0.5, 0.65], [0.2, -0.3, 0.55, 0.6]
    ];
    for (const [dx, dy, rw, rh] of blobs) {
      ctx.beginPath();
      ctx.ellipse(x + cw*dx, y + ch*dy, cw*rw, ch*rh, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  drawMountains(ctx, w, h, cn, en, hn, isNight, mouseX) {
    const p1 = (mouseX - 0.5) * 18;
    const p2 = (mouseX - 0.5) * 40;
    this.drawRange(ctx, w, h, [
      [0,.62],[.12,.44],[.28,.50],[.42,.37],[.55,.41],[.65,.34],[.78,.43],[.92,.39],[1,.52]
    ], cn, en, hn, isNight, p1, 0.65);
    this.drawRange(ctx, w, h, [
      [0,.68],[.1,.54],[.22,.47],[.38,.52],[.5,.43],[.62,.49],[.75,.41],[.88,.47],[1,.58]
    ], cn, en, hn, isNight, p2, 1);
  }

  drawRange(ctx, w, h, pts, cn, en, hn, isNight, px, dark) {
    ctx.beginPath();
    ctx.moveTo(-30, h);
    for (let i = 0; i < pts.length; i++) {
      const x = pts[i][0]*w + px, y = pts[i][1]*h;
      if (i === 0) { ctx.lineTo(x, y); }
      else {
        const prev = pts[i-1];
        ctx.quadraticCurveTo((prev[0]*w+px+x)/2, prev[1]*h, x, y);
      }
    }
    ctx.lineTo(w+30, h);
    ctx.closePath();
    let r, g, b;
    if (isNight) {
      r = lerp(12, 18, en)*dark; g = lerp(15, 12, en)*dark; b = lerp(25, 32, en)*dark;
    } else if (cn > en && cn > hn) {
      r = lerp(95, 75, dark)+cn*18; g = lerp(85, 72, dark)+cn*8; b = lerp(105, 85, dark);
    } else if (hn > en) {
      r = lerp(65, 45, dark)+hn*12; g = lerp(50, 38, dark); b = lerp(75, 60, dark)+hn*8;
    } else {
      r = lerp(75, 60, dark); g = lerp(80, 65, dark); b = lerp(90, 75, dark);
    }
    const gr = ctx.createLinearGradient(0, h*0.28, 0, h);
    gr.addColorStop(0, `rgb(${r},${g},${b})`);
    gr.addColorStop(1, `rgb(${r*.65},${g*.65},${b*.75})`);
    ctx.fillStyle = gr;
    ctx.fill();

    // Snow caps (heroic/cosy daytime)
    if (!isNight && (hn > 0.4 || cn > 0.4)) {
      ctx.save();
      ctx.globalAlpha = 0.12 * Math.max(hn, cn) * (1 - dark * 0.5);
      ctx.beginPath();
      for (let i = 1; i < pts.length - 1; i++) {
        const x = pts[i][0]*w + px, y = pts[i][1]*h;
        ctx.moveTo(x, y);
        ctx.lineTo(x - 12, y + 8);
        ctx.lineTo(x + 12, y + 8);
        ctx.closePath();
      }
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.restore();
    }
  }

  drawForeground(ctx, w, h, cn, en, hn, isNight, mouseX) {
    const px = (mouseX - 0.5) * 55;
    const baseY = h * 0.72;

    // Rolling ground
    const gg = ctx.createLinearGradient(0, baseY, 0, h);
    if (isNight) {
      const gr = lerp(10, 6, en), gn = lerp(13, 8, en), gb = lerp(8, 10, en);
      gg.addColorStop(0, `rgb(${gr+4},${gn+4},${gb})`);
      gg.addColorStop(1, `rgb(${gr},${gn},${gb})`);
    } else if (cn > en && cn > hn) {
      gg.addColorStop(0, `rgb(${65+cn*18},${75+cn*14},${42+cn*8})`);
      gg.addColorStop(1, `rgb(${42+cn*12},${52+cn*8},${28+cn*4})`);
    } else if (en > hn) {
      gg.addColorStop(0, `rgb(${48+en*8},${52+en*4},${42+en*8})`);
      gg.addColorStop(1, `rgb(${32},${35},${28})`);
    } else {
      gg.addColorStop(0, `rgb(${52+hn*12},${57+hn*4},${38})`);
      gg.addColorStop(1, `rgb(${38+hn*8},${40},${28})`);
    }

    ctx.beginPath();
    for (let i = 0; i <= 24; i++) {
      const x = (i/24)*(w+60)-30 + px*0.4;
      const y = baseY + Math.sin(i*0.45+0.8)*14 + Math.sin(i*0.28)*7;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.lineTo(w+30, h); ctx.lineTo(-30, h); ctx.closePath();
    ctx.fillStyle = gg;
    ctx.fill();

    // Pine tree silhouettes
    for (let i = 0; i < 14; i++) {
      const tx = (i/14)*w*1.35 - w*0.18 + px*(0.45 + i*0.04);
      const ty = baseY + Math.sin(i*1.15+0.4)*11 + 4;
      const th = 28 + Math.sin(i*2.8)*14 + hn*18;
      const tw = th * 0.32;
      const ta = isNight ? lerp(0.85, 0.96, en) : lerp(0.45, 0.65, en);
      const tc = isNight ? '3,6,3' : '22,32,18';
      ctx.fillStyle = `rgba(${tc},${ta})`;

      // Multi-tier pine
      ctx.beginPath();
      ctx.moveTo(tx, ty - th);
      ctx.lineTo(tx + tw, ty - th*0.15);
      ctx.lineTo(tx + tw*0.15, ty - th*0.15);
      ctx.lineTo(tx + tw*0.15, ty + 6);
      ctx.lineTo(tx - tw*0.15, ty + 6);
      ctx.lineTo(tx - tw*0.15, ty - th*0.15);
      ctx.lineTo(tx - tw, ty - th*0.15);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(tx, ty - th*0.85);
      ctx.lineTo(tx + tw*0.75, ty - th*0.25);
      ctx.lineTo(tx - tw*0.75, ty - th*0.25);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(tx, ty - th*0.65);
      ctx.lineTo(tx + tw*0.55, ty - th*0.35);
      ctx.lineTo(tx - tw*0.55, ty - th*0.35);
      ctx.closePath();
      ctx.fill();
    }

    // Cosy cottage
    if (cn > 0.25) {
      const hx = w*0.32 + px*0.65;
      const hy = baseY - 3;
      const hAlpha = Math.min(1, cn * 1.2);
      const hc = isNight ? '8,10,8' : '38,32,28';
      ctx.fillStyle = `rgba(${hc},${hAlpha * 0.85})`;

      // House body
      ctx.fillRect(hx - 22, hy - 26, 44, 32);

      // Roof
      ctx.beginPath();
      ctx.moveTo(hx - 28, hy - 26);
      ctx.lineTo(hx, hy - 48);
      ctx.lineTo(hx + 28, hy - 26);
      ctx.closePath();
      ctx.fill();

      // Chimney
      ctx.fillRect(hx + 12, hy - 52, 8, 18);

      // Window glow
      const glowStr = cn * (isNight ? 0.95 : 0.45);
      if (glowStr > 0.1) {
        const wg = ctx.createRadialGradient(hx, hy - 13, 2, hx, hy - 13, 35);
        wg.addColorStop(0, `rgba(255,200,100,${glowStr * 0.8})`);
        wg.addColorStop(1, 'rgba(255,180,80,0)');
        ctx.fillStyle = wg;
        ctx.fillRect(hx - 40, hy - 50, 80, 60);

        ctx.fillStyle = `rgba(255,215,130,${glowStr})`;
        ctx.fillRect(hx - 12, hy - 20, 8, 9);
        ctx.fillRect(hx + 4, hy - 20, 8, 9);

        // Smoke
        ctx.globalAlpha = cn * 0.18;
        for (let s = 0; s < 6; s++) {
          const sx = hx + 16 + Math.sin(this.time*0.7 + s*0.6) * (2 + s*2.5);
          const sy = hy - 52 - s*11 - (this.time*2.5) % 18;
          ctx.beginPath();
          ctx.arc(sx, sy, 3.5 + s*2.2, 0, Math.PI*2);
          ctx.fillStyle = `rgba(${isNight ? '140,140,160' : '195,195,205'},${0.25 - s*0.04})`;
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
    }

    // Eerie gravestones
    if (en > 0.35) {
      for (let i = 0; i < 5; i++) {
        const gx = w*(0.52 + i*0.09) + px*0.55 + Math.sin(i*3.1)*12;
        const gy = baseY + Math.sin(i*2.3)*4;
        const gc = isNight ? '18,18,22' : '48,48,52';
        ctx.fillStyle = `rgba(${gc},${en * 0.75})`;
        ctx.beginPath();
        ctx.moveTo(gx - 4.5, gy);
        ctx.lineTo(gx - 4.5, gy - 14 - i*3);
        ctx.quadraticCurveTo(gx, gy - 21 - i*3, gx + 4.5, gy - 14 - i*3);
        ctx.lineTo(gx + 4.5, gy);
        ctx.closePath();
        ctx.fill();
      }

      // Dead tree (eerie)
      if (en > 0.5) {
        const dtx = w*0.78 + px*0.5;
        const dty = baseY - 2;
        ctx.strokeStyle = `rgba(${isNight ? '12,12,15' : '35,30,28'},${en * 0.8})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(dtx, dty);
        ctx.lineTo(dtx + 2, dty - 50);
        ctx.stroke();
        // Branches
        ctx.lineWidth = 2;
        [[-15,-35,.7], [12,-40,.6], [-8,-25,.5], [18,-28,.55]].forEach(([dx,dy,l]) => {
          ctx.beginPath();
          ctx.moveTo(dtx + dx*0.3, dty + dy);
          ctx.quadraticCurveTo(dtx + dx*0.6, dty + dy - 5, dtx + dx, dty + dy + 4);
          ctx.stroke();
        });
        ctx.lineWidth = 1;
      }
    }
  }

  drawParticles(ctx, w, h, cn, en, hn, isNight) {
    for (const p of this.particles) {
      const windForce = hn > 0.4 ? Math.sin(this.time*2.5 + p.life*8) * 0.0025 * hn : 0;
      p.x += p.vx + windForce;
      p.y += p.vy * (1 + hn * 2.5);
      if (p.y > 1.08) { p.y = -0.04; p.x = Math.random(); }
      if (p.x > 1.08 || p.x < -0.08) p.x = Math.random();
      const px = p.x * w, py = p.y * h;

      // Rain (heroic/eerie)
      if ((hn > 0.25 || en > 0.35) && p.type === 'rain') {
        const ra = Math.max(hn, en*0.7) * p.opacity * 0.5;
        const rLen = 7 + hn * 8;
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px - 0.8 - windForce*200, py + rLen);
        ctx.strokeStyle = `rgba(175,195,255,${ra})`;
        ctx.lineWidth = 0.8;
        ctx.stroke();
      }

      // Snow / embers (cosy)
      if (cn > 0.25 && p.type === 'snow') {
        const sa = cn * p.opacity * 0.45;
        const wobble = Math.sin(this.time*1.8 + p.phase) * 2.5;
        ctx.beginPath();
        ctx.arc(px + wobble, py, p.size * (isNight ? 0.7 : 0.9), 0, Math.PI*2);
        ctx.fillStyle = isNight
          ? `rgba(255,195,90,${sa * 0.75})` // embers
          : `rgba(255,255,248,${sa})`;
        ctx.fill();
        if (isNight && p.size > 1.5) {
          ctx.beginPath();
          ctx.arc(px + wobble, py, p.size * 2.5, 0, Math.PI*2);
          ctx.fillStyle = `rgba(255,180,60,${sa * 0.12})`;
          ctx.fill();
        }
      }

      // Fireflies (eerie night)
      if (isNight && en > 0.4 && p.type === 'ember') {
        const fa = en * 0.3 * (Math.sin(this.time*3 + p.phase*5)*0.5 + 0.5);
        const fx = px + Math.sin(this.time*1.2 + p.phase*3)*8;
        const fy = py + Math.cos(this.time*0.9 + p.phase*4)*6;
        if (fy > h*0.5) {
          ctx.beginPath();
          ctx.arc(fx, fy, 1.5, 0, Math.PI*2);
          ctx.fillStyle = `rgba(160,255,180,${fa})`;
          ctx.fill();
          ctx.beginPath();
          ctx.arc(fx, fy, 6, 0, Math.PI*2);
          ctx.fillStyle = `rgba(140,255,170,${fa*0.1})`;
          ctx.fill();
        }
      }
    }
  }

  drawLightning(ctx, w, h, hn, isNight) {
    // Flash fade
    if (this.lightningFlash > 0) {
      ctx.fillStyle = `rgba(220,230,255,${this.lightningFlash * 0.12})`;
      ctx.fillRect(0, 0, w, h);
      this.lightningFlash = Math.max(0, this.lightningFlash - 0.06);
    }

    // Fade old bolts
    this.lightningBolts = this.lightningBolts.filter(b => b.alpha > 0.02);
    for (const bolt of this.lightningBolts) {
      bolt.alpha *= 0.88;
      ctx.beginPath();
      for (let i = 0; i < bolt.pts.length; i++) {
        i === 0 ? ctx.moveTo(bolt.pts[i][0], bolt.pts[i][1]) : ctx.lineTo(bolt.pts[i][0], bolt.pts[i][1]);
      }
      ctx.strokeStyle = `rgba(200,220,255,${bolt.alpha})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.strokeStyle = `rgba(255,255,255,${bolt.alpha*0.5})`;
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    // New bolt
    if (Math.random() < 0.004 * hn) {
      this.lightningFlash = 1;
      const pts = [];
      let lx = w*(0.2 + Math.random()*0.6), ly = 0;
      pts.push([lx, ly]);
      const segs = 7 + Math.floor(Math.random()*5);
      for (let i = 0; i < segs; i++) {
        lx += (Math.random()-0.5)*55;
        ly += h/segs*(0.65 + Math.random()*0.5);
        pts.push([lx, ly]);
      }
      this.lightningBolts.push({ pts, alpha: 0.9 });
    }
  }

  drawSpotlights(ctx, w, h, cn, en, hn, isNight) {
    this.spotlightAngle += 0.006;
    for (let i = 0; i < 2; i++) {
      const phase = this.spotlightAngle + i*Math.PI;
      const sx = w*0.5 + Math.sin(phase)*w*0.32;
      const tx = sx + Math.sin(phase*0.65)*40;
      const ty = h*0.78;
      const sg = ctx.createRadialGradient(sx, -15, 0, tx, ty, h*0.38);
      let sa = 0.025 + hn*0.035;
      if (isNight) sa *= 1.4;
      const sc = cn > en && cn > hn ? '255,215,145' : en > hn ? '145,175,255' : '255,175,115';
      sg.addColorStop(0, `rgba(${sc},${sa*2.2})`);
      sg.addColorStop(0.3, `rgba(${sc},${sa})`);
      sg.addColorStop(1, `rgba(${sc},0)`);
      ctx.fillStyle = sg;
      ctx.fillRect(0, 0, w, h);
    }
  }

  drawFog(ctx, w, h, en, isNight) {
    for (let i = 0; i < 4; i++) {
      const y = h*(0.38 + i*0.12);
      const amp = 25 + i*8;
      const spd = 0.25 + i*0.08;
      ctx.beginPath();
      ctx.moveTo(-20, y + amp);
      for (let x = 0; x <= w + 20; x += 8) {
        const fy = y + Math.sin(x*0.004 + this.time*spd + i*2.1)*amp +
                   Math.sin(x*0.009 + this.time*spd*0.6)*amp*0.4;
        ctx.lineTo(x, fy);
      }
      ctx.lineTo(w+20, h); ctx.lineTo(-20, h); ctx.closePath();
      const fa = en * (0.025 + i*0.012) * (isNight ? 1.3 : 0.75);
      ctx.fillStyle = isNight ? `rgba(90,100,130,${fa})` : `rgba(175,180,190,${fa})`;
      ctx.fill();
    }
  }

  drawVignette(ctx, w, h, en, hn) {
    const str = 0.35 + en*0.25 + hn*0.05;
    const vg = ctx.createRadialGradient(w/2, h/2, w*0.22, w/2, h/2, w*0.72);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, `rgba(0,0,0,${str})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, w, h);
  }

  drawStageEdge(ctx, w, h) {
    // Subtle stage floor reflection line
    const y = h * 0.985;
    const eg = ctx.createLinearGradient(0, y-2, 0, h);
    eg.addColorStop(0, 'rgba(212,175,55,0.06)');
    eg.addColorStop(1, 'rgba(212,175,55,0)');
    ctx.fillStyle = eg;
    ctx.fillRect(0, y-2, w, 4);
  }
}

// ============================================================
// REACT APP
// ============================================================
function App() {
  const [cosy, setCosy] = useState(60);
  const [eerie, setEerie] = useState(20);
  const [heroic, setHeroic] = useState(20);
  const [isNight, setIsNight] = useState(false);
  const [curtainOpen, setCurtainOpen] = useState(false);
  const [subtitle, setSubtitle] = useState('');
  const [mouseX, setMouseX] = useState(0.5);

  const canvasRef = useRef(null);
  const rendererRef = useRef(null);
  const animFrameRef = useRef(null);
  const lastTimeRef = useRef(0);
  const subtitleTimerRef = useRef(null);
  const subtitleDelayRef = useRef(null);
  const subtitleIdxRef = useRef(0);
  const debounceRef = useRef(null);

  // Curtain reveal
  useEffect(() => {
    const t = setTimeout(() => setCurtainOpen(true), 700);
    return () => clearTimeout(t);
  }, []);

  // Initialize renderer
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const renderer = new WeatherRenderer(canvas);
    rendererRef.current = renderer;
    const resize = () => {
      const p = canvas.parentElement;
      if (p) renderer.resize(p.clientWidth, p.clientHeight);
    };
    resize();
    window.addEventListener('resize', resize);
    return () => {
      window.removeEventListener('resize', resize);
      if (animFrameRef.current) cancelAnimationFrame(animFrameRef.current);
    };
  }, []);

  // Animation loop
  useEffect(() => {
    const loop = (time) => {
      const dt = Math.min((time - lastTimeRef.current) / 1000, 0.1);
      lastTimeRef.current = time;
      if (rendererRef.current) rendererRef.current.render(dt, { cosy, eerie, heroic }, isNight, mouseX);
      animFrameRef.current = requestAnimationFrame(loop);
    };
    animFrameRef.current = requestAnimationFrame(loop);
    return () => { if (animFrameRef.current) cancelAnimationFrame(animFrameRef.current); };
  }, [cosy, eerie, heroic, isNight, mouseX]);

  // Typewriter with debounce
  useEffect(() => {
    if (debounceRef.current) clearTimeout(debounceRef.current);
    debounceRef.current = setTimeout(() => {
      const text = getSceneDescription(cosy, eerie, heroic, isNight);
      subtitleIdxRef.current = 0;
      setSubtitle('');
      if (subtitleTimerRef.current) clearInterval(subtitleTimerRef.current);
      if (subtitleDelayRef.current) clearTimeout(subtitleDelayRef.current);
      subtitleDelayRef.current = setTimeout(() => {
        subtitleTimerRef.current = setInterval(() => {
          subtitleIdxRef.current++;
          if (subtitleIdxRef.current <= text.length) {
            setSubtitle(text.substring(0, subtitleIdxRef.current));
          } else {
            clearInterval(subtitleTimerRef.current);
          }
        }, 32);
      }, 250);
    }, 180);
    return () => {
      if (debounceRef.current) clearTimeout(debounceRef.current);
      if (subtitleDelayRef.current) clearTimeout(subtitleDelayRef.current);
      if (subtitleTimerRef.current) clearInterval(subtitleTimerRef.current);
    };
  }, [cosy, eerie, heroic, isNight]);

  // Mouse parallax (smooth)
  const mouseXTarget = useRef(0.5);
  const handleMouseMove = useCallback((e) => {
    const rect = e.currentTarget.getBoundingClientRect();
    mouseXTarget.current = (e.clientX - rect.left) / rect.width;
  }, []);

  useEffect(() => {
    const smooth = setInterval(() => {
      setMouseX(prev => prev + (mouseXTarget.current - prev) * 0.08);
    }, 16);
    return () => clearInterval(smooth);
  }, []);

  const sceneTitle = getSceneTitle(cosy, eerie, heroic, isNight);
  const actNumber = getActNumber(cosy, eerie, heroic);

  return (
    <div className="theatre-container">
      <div className="theatre-header">
        <h1>Weather Theatre</h1>
      </div>
      <div className="stage-frame" onMouseMove={handleMouseMove}>
        <canvas ref={canvasRef} className="stage-canvas" />

        <div className={`curtain curtain-left ${curtainOpen ? 'open' : ''}`}>
          <div className="curtain-fold" />
          <div className="curtain-shadow" />
        </div>
        <div className={`curtain curtain-right ${curtainOpen ? 'open' : ''}`}>
          <div className="curtain-fold" />
          <div className="curtain-shadow" />
        </div>

        <div className="valance">
          <div className="gold-trim" />
        </div>
        <div className="valance-scallop" />

        <div className="scene-title" style={{ opacity: curtainOpen ? 1 : 0, transition: 'opacity 1.5s 1.2s' }}>
          <div className="act">{actNumber}</div>
          <h2>{sceneTitle}</h2>
        </div>

        <div className="forecast-badge" style={{ opacity: curtainOpen ? 1 : 0, transition: 'opacity 1.5s 1.5s' }}>
          <div className="forecast-temp">{FORECAST.temp}&deg;C</div>
          <div className="forecast-condition">{FORECAST.condition}</div>
          <div className="forecast-details">
            <span>{FORECAST.wind} km/h {FORECAST.windDir}</span>
            <span>{FORECAST.humidity}% RH</span>
          </div>
        </div>

        <div className="subtitle-bar">
          <div className="subtitle-text">
            {subtitle}<span className="cursor" />
          </div>
        </div>
      </div>

      <div className="control-panel">
        <span className="panel-title">Stage Controls</span>
        <div className="separator" />

        <div className="slider-group">
          <span className="slider-label label-cosy">Cosy</span>
          <input type="range" className="slider-cosy" min="0" max="100" value={cosy}
            onChange={e => setCosy(Number(e.target.value))} />
          <span className="slider-value label-cosy">{cosy}</span>
        </div>

        <div className="slider-group">
          <span className="slider-label label-eerie">Eerie</span>
          <input type="range" className="slider-eerie" min="0" max="100" value={eerie}
            onChange={e => setEerie(Number(e.target.value))} />
          <span className="slider-value label-eerie">{eerie}</span>
        </div>

        <div className="slider-group">
          <span className="slider-label label-heroic">Heroic</span>
          <input type="range" className="slider-heroic" min="0" max="100" value={heroic}
            onChange={e => setHeroic(Number(e.target.value))} />
          <span className="slider-value label-heroic">{heroic}</span>
        </div>

        <div className="separator" />

        <div className="toggle-group">
          <span className={`toggle-label ${!isNight ? 'active' : 'inactive'}`}>Matin&#233;e</span>
          <div className={`toggle-switch ${isNight ? 'night' : ''}`} onClick={() => setIsNight(!isNight)}>
            <div className={`toggle-knob ${isNight ? 'night' : 'matinee'}`} />
          </div>
          <span className={`toggle-label ${isNight ? 'active' : 'inactive'}`}>Night</span>
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
