<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fruit Catcher!</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700;800&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    background: linear-gradient(180deg, #87CEEB 0%, #E0F7FF 60%, #98D882 95%, #6BBF59 100%);
    font-family: 'Fredoka One', 'Nunito', sans-serif;
    user-select: none;
    -webkit-user-select: none;
    height: 100vh;
    width: 100vw;
  }

  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }

  #ui-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  #score-board {
    position: fixed;
    top: 16px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 24px;
    align-items: center;
    z-index: 20;
    background: rgba(255,255,255,0.85);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border-radius: 20px;
    padding: 10px 28px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.12), 0 0 0 3px rgba(255,255,255,0.5);
  }

  .score-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 22px;
    color: #333;
  }

  .score-item .emoji { font-size: 28px; }
  .score-item .value { font-weight: 800; color: #E85D04; font-family: 'Nunito', sans-serif; }
  .lives .value { color: #E63946; }

  #combo-display {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    color: #FF6B00;
    text-shadow: 0 2px 8px rgba(255,107,0,0.3);
    z-index: 20;
    opacity: 0;
    transition: opacity 0.3s;
    font-family: 'Fredoka One', sans-serif;
  }

  #start-screen, #game-over-screen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100;
    background: linear-gradient(180deg, rgba(135,206,235,0.95) 0%, rgba(224,247,255,0.95) 60%, rgba(152,216,130,0.95) 100%);
    transition: opacity 0.5s;
  }

  .screen-title {
    font-size: clamp(42px, 8vw, 72px);
    color: #E85D04;
    text-shadow: 0 4px 0 #C44B03, 0 6px 20px rgba(232,93,4,0.3);
    margin-bottom: 12px;
    letter-spacing: 2px;
  }

  .screen-subtitle {
    font-size: clamp(16px, 3vw, 24px);
    color: #555;
    margin-bottom: 36px;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
  }

  .btn-play {
    pointer-events: all;
    font-family: 'Fredoka One', sans-serif;
    font-size: clamp(22px, 4vw, 32px);
    padding: 16px 52px;
    border: none;
    border-radius: 50px;
    background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%);
    color: #fff;
    cursor: pointer;
    box-shadow: 0 6px 0 #C44B03, 0 8px 24px rgba(232,93,4,0.35);
    transition: all 0.15s;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  .btn-play:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 0 #C44B03, 0 12px 30px rgba(232,93,4,0.4);
  }

  .btn-play:active {
    transform: translateY(3px);
    box-shadow: 0 3px 0 #C44B03, 0 4px 12px rgba(232,93,4,0.3);
  }

  .falling-emoji-bg {
    position: fixed;
    font-size: 48px;
    opacity: 0.15;
    pointer-events: none;
    animation: floatDown 8s linear infinite;
    z-index: 0;
  }

  @keyframes floatDown {
    0% { transform: translateY(-60px) rotate(0deg); opacity: 0; }
    10% { opacity: 0.15; }
    90% { opacity: 0.15; }
    100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
  }

  .final-score {
    font-size: clamp(28px, 5vw, 44px);
    color: #2D6A4F;
    margin-bottom: 8px;
  }

  .high-score-text {
    font-size: clamp(16px, 3vw, 22px);
    color: #888;
    margin-bottom: 30px;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
  }

  .new-high {
    color: #E85D04 !important;
    animation: pulse 0.6s ease-in-out infinite alternate;
  }

  @keyframes pulse {
    from { transform: scale(1); }
    to { transform: scale(1.08); }
  }

  .fruit-parade {
    font-size: clamp(36px, 6vw, 56px);
    margin-bottom: 20px;
    letter-spacing: 8px;
  }

  .instructions {
    display: flex;
    gap: 20px;
    margin-top: 20px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .instruction-item {
    background: rgba(255,255,255,0.7);
    border-radius: 14px;
    padding: 12px 20px;
    font-size: clamp(13px, 2vw, 16px);
    color: #555;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .level-badge {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 32px;
    color: #2D6A4F;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.5s, transform 0.5s;
    font-family: 'Fredoka One', sans-serif;
    text-shadow: 0 2px 10px rgba(45,106,79,0.3);
  }

  .hearts-container {
    display: flex;
    gap: 4px;
  }

  .heart {
    font-size: 26px;
    transition: all 0.3s;
  }

  .heart.lost {
    opacity: 0.2;
    transform: scale(0.8);
    filter: grayscale(1);
  }
</style>
</head>
<body>

<div id="score-board" style="display:none;">
  <div class="score-item">
    <span class="emoji">üçé</span>
    <span class="value" id="score-val">0</span>
  </div>
  <div class="score-item">
    <span class="emoji">‚≠ê</span>
    <span>Lv</span>
    <span class="value" id="level-val">1</span>
  </div>
  <div class="score-item lives">
    <div class="hearts-container" id="hearts-container">
      <span class="heart">‚ù§Ô∏è</span>
      <span class="heart">‚ù§Ô∏è</span>
      <span class="heart">‚ù§Ô∏è</span>
    </div>
  </div>
</div>

<div id="combo-display"></div>

<canvas id="gameCanvas"></canvas>

<div id="start-screen">
  <div class="fruit-parade">üçé üçä üçã üçá üçì üçë</div>
  <div class="screen-title">Fruit Catcher!</div>
  <div class="screen-subtitle">Catch the falling fruits before they hit the ground!</div>
  <button class="btn-play" id="btn-start" onclick="startGame()">Play!</button>
  <div class="instructions">
    <div class="instruction-item">‚¨ÖÔ∏è‚û°Ô∏è Arrow Keys</div>
    <div class="instruction-item">üñ±Ô∏è Mouse / Touch</div>
    <div class="instruction-item">‚ù§Ô∏è 3 Lives</div>
  </div>
</div>

<div id="game-over-screen" style="display:none;">
  <div class="fruit-parade">üçé üçä üçã üçá üçì üçë</div>
  <div class="screen-title">Game Over!</div>
  <div class="final-score" id="final-score">Score: 0</div>
  <div class="high-score-text" id="high-score-text">Best: 0</div>
  <button class="btn-play" onclick="startGame()">Play Again!</button>
</div>

<script>
// =================== GAME ENGINE ===================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// High DPI support
let dpr = window.devicePixelRatio || 1;
let W, H;

function resizeCanvas() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// =================== FRUIT DATA ===================
const FRUITS = [
  { emoji: 'üçé', name: 'apple', points: 10, color: '#E63946' },
  { emoji: 'üçä', name: 'orange', points: 10, color: '#F77F00' },
  { emoji: 'üçã', name: 'lemon', points: 10, color: '#FFD60A' },
  { emoji: 'üçá', name: 'grapes', points: 15, color: '#7B2D8E' },
  { emoji: 'üçì', name: 'strawberry', points: 15, color: '#E63946' },
  { emoji: 'üçë', name: 'peach', points: 15, color: '#FFAA5C' },
  { emoji: 'üçâ', name: 'watermelon', points: 20, color: '#2D6A4F' },
  { emoji: 'üçí', name: 'cherry', points: 20, color: '#C1121F' },
  { emoji: 'ü•ù', name: 'kiwi', points: 25, color: '#6A994E' },
  { emoji: 'üåü', name: 'star', points: 50, color: '#FFD700' },
];

// =================== GAME STATE ===================
let gameState = 'menu'; // menu, playing, over
let score = 0;
let lives = 3;
let level = 1;
let combo = 0;
let maxCombo = 0;
let highScore = parseInt(localStorage.getItem('fruitCatcherHigh') || '0');
let fruits = [];
let particles = [];
let splashes = [];
let clouds = [];
let grassBlades = [];
let basketTrail = [];
let shakeTimer = 0;
let shakeIntensity = 0;
let levelUpTimer = 0;
let frameCount = 0;
let lastSpawnTime = 0;
let animFrame = null;
let lastTime = 0;

// Basket
const basket = {
  x: 0,
  y: 0,
  w: 100,
  h: 70,
  targetX: 0,
  speed: 0,
  tilt: 0,
  bobPhase: 0,
  catchScale: 1,
};

// Input
let keys = {};
let mouseX = null;
let useMouseControl = false;

// =================== BACKGROUND ===================
function initClouds() {
  clouds = [];
  for (let i = 0; i < 5; i++) {
    clouds.push({
      x: Math.random() * W,
      y: 30 + Math.random() * H * 0.2,
      w: 80 + Math.random() * 120,
      speed: 0.15 + Math.random() * 0.3,
      opacity: 0.3 + Math.random() * 0.4,
    });
  }
}

function initGrass() {
  grassBlades = [];
  const count = Math.floor(W / 6);
  for (let i = 0; i < count; i++) {
    grassBlades.push({
      x: (i / count) * W + Math.random() * 6,
      h: 12 + Math.random() * 20,
      phase: Math.random() * Math.PI * 2,
      speed: 0.5 + Math.random() * 1.5,
      shade: Math.random(),
    });
  }
}

function drawBackground(t) {
  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#87CEEB');
  skyGrad.addColorStop(0.55, '#C8E6F5');
  skyGrad.addColorStop(0.75, '#E8F5E9');
  skyGrad.addColorStop(0.88, '#A5D6A7');
  skyGrad.addColorStop(1, '#66BB6A');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Sun
  const sunX = W * 0.85;
  const sunY = H * 0.1;
  const sunGlow = ctx.createRadialGradient(sunX, sunY, 20, sunX, sunY, 120);
  sunGlow.addColorStop(0, 'rgba(255,236,179,0.9)');
  sunGlow.addColorStop(0.4, 'rgba(255,224,130,0.3)');
  sunGlow.addColorStop(1, 'rgba(255,224,130,0)');
  ctx.fillStyle = sunGlow;
  ctx.fillRect(sunX - 120, sunY - 120, 240, 240);
  ctx.beginPath();
  ctx.arc(sunX, sunY, 32, 0, Math.PI * 2);
  ctx.fillStyle = '#FFE082';
  ctx.fill();
  // Sun rays
  ctx.save();
  ctx.translate(sunX, sunY);
  ctx.rotate(t * 0.0003);
  for (let i = 0; i < 12; i++) {
    ctx.rotate(Math.PI / 6);
    ctx.beginPath();
    ctx.moveTo(36, -3);
    ctx.lineTo(52 + Math.sin(t * 0.002 + i) * 5, 0);
    ctx.lineTo(36, 3);
    ctx.fillStyle = 'rgba(255,224,130,0.5)';
    ctx.fill();
  }
  ctx.restore();

  // Clouds
  clouds.forEach(c => {
    c.x += c.speed;
    if (c.x > W + c.w) c.x = -c.w;
    ctx.save();
    ctx.globalAlpha = c.opacity;
    ctx.fillStyle = '#fff';
    const cx = c.x, cy = c.y, cw = c.w;
    ctx.beginPath();
    ctx.ellipse(cx, cy, cw * 0.5, cw * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx - cw * 0.2, cy - cw * 0.08, cw * 0.25, cw * 0.16, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + cw * 0.15, cy - cw * 0.06, cw * 0.22, cw * 0.14, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });

  // Rolling hills
  const groundY = H * 0.88;
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  for (let x = 0; x <= W; x += 2) {
    const y = groundY + Math.sin(x * 0.008 + 1) * 8 + Math.sin(x * 0.003) * 12;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(W, H);
  ctx.lineTo(0, H);
  ctx.closePath();
  const grassGrad = ctx.createLinearGradient(0, groundY, 0, H);
  grassGrad.addColorStop(0, '#66BB6A');
  grassGrad.addColorStop(0.4, '#4CAF50');
  grassGrad.addColorStop(1, '#388E3C');
  ctx.fillStyle = grassGrad;
  ctx.fill();

  // Grass blades
  grassBlades.forEach(g => {
    const sway = Math.sin(t * 0.001 * g.speed + g.phase) * 4;
    const baseY = groundY + Math.sin(g.x * 0.008 + 1) * 8 + Math.sin(g.x * 0.003) * 12;
    ctx.beginPath();
    ctx.moveTo(g.x - 1.5, baseY);
    ctx.quadraticCurveTo(g.x + sway, baseY - g.h * 0.6, g.x + sway * 1.5, baseY - g.h);
    ctx.quadraticCurveTo(g.x + sway, baseY - g.h * 0.6, g.x + 1.5, baseY);
    ctx.fillStyle = g.shade > 0.5 ? '#43A047' : '#2E7D32';
    ctx.fill();
  });
}

// =================== BASKET ===================
function drawBasket(t) {
  const bx = basket.x;
  const groundY = H * 0.88;
  const by = groundY - basket.h * 0.3 + Math.sin(basket.bobPhase) * 2;
  basket.y = by;

  // Shadow
  ctx.save();
  ctx.globalAlpha = 0.15;
  ctx.beginPath();
  ctx.ellipse(bx, groundY + 4 + Math.sin(bx * 0.008 + 1) * 8 + Math.sin(bx * 0.003) * 12, basket.w * 0.5 * basket.catchScale, 8, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.translate(bx, by);
  ctx.rotate(basket.tilt * 0.03);
  ctx.scale(basket.catchScale, basket.catchScale);

  const bw = basket.w;
  const bh = basket.h;

  // Basket body - woven look
  ctx.beginPath();
  ctx.moveTo(-bw * 0.5, -bh * 0.15);
  ctx.bezierCurveTo(-bw * 0.5, bh * 0.35, -bw * 0.35, bh * 0.45, 0, bh * 0.45);
  ctx.bezierCurveTo(bw * 0.35, bh * 0.45, bw * 0.5, bh * 0.35, bw * 0.5, -bh * 0.15);
  ctx.lineTo(-bw * 0.5, -bh * 0.15);
  ctx.closePath();

  const basketGrad = ctx.createLinearGradient(0, -bh * 0.15, 0, bh * 0.45);
  basketGrad.addColorStop(0, '#D4A373');
  basketGrad.addColorStop(0.5, '#C68B4D');
  basketGrad.addColorStop(1, '#A0652E');
  ctx.fillStyle = basketGrad;
  ctx.fill();
  ctx.strokeStyle = '#8B5E3C';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Weave pattern horizontal lines
  for (let i = 0; i < 4; i++) {
    const ly = -bh * 0.05 + i * bh * 0.12;
    const leftX = -bw * 0.48 + i * 3;
    const rightX = bw * 0.48 - i * 3;
    ctx.beginPath();
    ctx.moveTo(leftX, ly);
    ctx.lineTo(rightX, ly);
    ctx.strokeStyle = 'rgba(139,94,60,0.3)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // Weave vertical lines
  for (let i = -3; i <= 3; i++) {
    const vx = i * bw * 0.07;
    ctx.beginPath();
    ctx.moveTo(vx, -bh * 0.12);
    ctx.lineTo(vx * 0.85, bh * 0.4);
    ctx.strokeStyle = 'rgba(139,94,60,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Basket rim
  ctx.beginPath();
  ctx.ellipse(0, -bh * 0.15, bw * 0.52, bh * 0.1, 0, 0, Math.PI * 2);
  const rimGrad = ctx.createLinearGradient(-bw * 0.5, -bh * 0.25, bw * 0.5, -bh * 0.05);
  rimGrad.addColorStop(0, '#DEB887');
  rimGrad.addColorStop(0.5, '#E8C99B');
  rimGrad.addColorStop(1, '#C8A06E');
  ctx.fillStyle = rimGrad;
  ctx.fill();
  ctx.strokeStyle = '#A0652E';
  ctx.lineWidth = 2.5;
  ctx.stroke();

  // Inner rim detail
  ctx.beginPath();
  ctx.ellipse(0, -bh * 0.13, bw * 0.44, bh * 0.06, 0, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(101,67,33,0.25)';
  ctx.fill();

  // Handle
  ctx.beginPath();
  ctx.ellipse(0, -bh * 0.5, bw * 0.3, bh * 0.35, 0, Math.PI + 0.3, -0.3);
  ctx.strokeStyle = '#A0652E';
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  ctx.stroke();
  ctx.strokeStyle = '#DEB887';
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.restore();
}

// =================== FRUITS ===================
function spawnFruit() {
  const fruitIdx = Math.random() < 0.08 ? 9 : Math.floor(Math.random() * 9); // 8% star
  const fruit = FRUITS[fruitIdx];
  const size = 38 + Math.random() * 14; // Large for kids

  // Avoid spawning too close to edges
  const margin = 50;
  const x = margin + Math.random() * (W - margin * 2);

  const baseSpeed = 1.2 + level * 0.35;
  const speed = baseSpeed + Math.random() * 0.8;

  fruits.push({
    x,
    y: -size,
    size,
    speed,
    rotation: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.04,
    wobblePhase: Math.random() * Math.PI * 2,
    wobbleAmp: 0.3 + Math.random() * 0.6,
    type: fruitIdx,
    emoji: fruit.emoji,
    points: fruit.points,
    color: fruit.color,
    alpha: 1,
    caught: false,
    missed: false,
    scale: 1,
  });
}

function drawFruit(f, t) {
  ctx.save();
  ctx.translate(f.x, f.y);
  ctx.rotate(f.rotation);
  ctx.scale(f.scale, f.scale);
  ctx.globalAlpha = f.alpha;

  // Glow for star
  if (f.type === 9) {
    ctx.save();
    const glowSize = f.size * 1.2 + Math.sin(t * 0.005) * 5;
    const glow = ctx.createRadialGradient(0, 0, f.size * 0.3, 0, 0, glowSize);
    glow.addColorStop(0, 'rgba(255,215,0,0.4)');
    glow.addColorStop(1, 'rgba(255,215,0,0)');
    ctx.fillStyle = glow;
    ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
    ctx.restore();
  }

  // Fruit shadow (subtle)
  ctx.save();
  ctx.globalAlpha = 0.1 * f.alpha;
  ctx.beginPath();
  ctx.ellipse(3, 3, f.size * 0.4, f.size * 0.35, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();
  ctx.restore();

  // Draw emoji
  ctx.font = `${f.size}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(f.emoji, 0, 0);

  ctx.restore();
}

// =================== PARTICLES ===================
function spawnCatchParticles(x, y, color, emoji) {
  // Burst of colorful particles
  for (let i = 0; i < 14; i++) {
    const angle = (Math.PI * 2 * i) / 14 + Math.random() * 0.3;
    const speed = 2 + Math.random() * 4;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 2,
      size: 4 + Math.random() * 6,
      color: color,
      life: 1,
      decay: 0.015 + Math.random() * 0.015,
      type: 'circle',
    });
  }
  // Floating score text
  particles.push({
    x, y: y - 20,
    vx: 0,
    vy: -1.5,
    size: 24,
    color: color,
    life: 1,
    decay: 0.012,
    type: 'text',
    text: '+' + (combo > 1 ? Math.floor(FRUITS[fruits.length > 0 ? 0 : 0].points * (1 + combo * 0.2)) : ''),
    emoji: emoji,
  });
  // Mini fruit emojis flying out
  for (let i = 0; i < 3; i++) {
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
    const speed = 2 + Math.random() * 3;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 1,
      size: 18 + Math.random() * 10,
      life: 1,
      decay: 0.018,
      type: 'emoji',
      emoji: emoji,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.1,
    });
  }
}

function spawnMissParticles(x, y) {
  // Sad splash
  for (let i = 0; i < 8; i++) {
    const angle = -Math.PI * 0.2 - Math.random() * Math.PI * 0.6;
    const speed = 1 + Math.random() * 3;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed * (Math.random() > 0.5 ? 1 : -1),
      vy: Math.sin(angle) * speed,
      size: 3 + Math.random() * 4,
      color: '#E63946',
      life: 1,
      decay: 0.02,
      type: 'circle',
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 0.06 * dt; // gravity
    p.life -= p.decay * dt;
    if (p.rotation !== undefined) p.rotation += (p.rotSpeed || 0) * dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life);
    if (p.type === 'circle') {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.fill();
    } else if (p.type === 'text') {
      ctx.font = `bold ${p.size}px 'Fredoka One', sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = p.color;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.strokeText(p.emoji + ' ' + p.text, p.x, p.y);
      ctx.fillText(p.emoji + ' ' + p.text, p.x, p.y);
    } else if (p.type === 'emoji') {
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rotation || 0);
      ctx.font = `${p.size}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.emoji, 0, 0);
    }
    ctx.restore();
  });
}

// =================== GAME LOGIC ===================
function getSpawnInterval() {
  return Math.max(400, 1400 - level * 100);
}

function updateGame(t, dt) {
  frameCount++;
  basket.bobPhase += 0.04 * dt;

  // Basket movement
  const basketSpeed = 8 + level * 0.5;

  if (useMouseControl && mouseX !== null) {
    basket.targetX = mouseX;
  } else {
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
      basket.targetX = basket.x - basketSpeed * dt;
      useMouseControl = false;
    }
    if (keys['ArrowRight'] || keys['d'] || keys['D']) {
      basket.targetX = basket.x + basketSpeed * dt;
      useMouseControl = false;
    }
  }

  // Clamp basket position
  const halfW = basket.w * 0.5;
  basket.targetX = Math.max(halfW, Math.min(W - halfW, basket.targetX));

  // Smooth movement
  const dx = basket.targetX - basket.x;
  basket.speed = dx * 0.15 * dt;
  basket.x += basket.speed;
  basket.tilt = basket.speed * 0.6;
  basket.tilt *= 0.92;

  // Catch animation recovery
  basket.catchScale += (1 - basket.catchScale) * 0.08 * dt;

  // Screen shake recovery
  if (shakeTimer > 0) shakeTimer -= dt;

  // Spawn fruits
  if (t - lastSpawnTime > getSpawnInterval()) {
    spawnFruit();
    lastSpawnTime = t;
    // Occasionally spawn two at higher levels
    if (level >= 3 && Math.random() < 0.3) {
      setTimeout(() => { if (gameState === 'playing') spawnFruit(); }, 200);
    }
  }

  const groundY = H * 0.88;
  const catchY = groundY - basket.h * 0.2;

  // Update fruits
  for (let i = fruits.length - 1; i >= 0; i--) {
    const f = fruits[i];
    if (f.caught || f.missed) {
      if (f.caught) {
        f.scale *= 0.85;
        f.alpha *= 0.85;
      } else {
        f.alpha -= 0.03 * dt;
        f.y += 1 * dt;
      }
      if (f.alpha <= 0.05 || f.scale <= 0.05) {
        fruits.splice(i, 1);
      }
      continue;
    }

    f.y += f.speed * dt;
    f.rotation += f.rotSpeed * dt;
    f.x += Math.sin(f.wobblePhase + f.y * 0.01) * f.wobbleAmp * 0.3 * dt;

    // Check catch
    const bx = basket.x;
    const catchDist = basket.w * 0.55;
    const fruitBottom = f.y + f.size * 0.3;

    if (fruitBottom > catchY - basket.h * 0.4 && fruitBottom < catchY + 15 &&
        Math.abs(f.x - bx) < catchDist) {
      // Caught!
      f.caught = true;
      combo++;
      if (combo > maxCombo) maxCombo = combo;

      const multiplier = 1 + (combo - 1) * 0.2;
      const points = Math.floor(f.points * multiplier);
      score += points;

      basket.catchScale = 1.15;

      spawnCatchParticles(f.x, catchY, f.color, f.emoji);

      // Update UI
      updateScoreUI();
      updateComboUI();

      // Level up every 100 points
      const newLevel = Math.floor(score / 100) + 1;
      if (newLevel > level) {
        level = newLevel;
        showLevelUp();
      }
    }
    // Check miss
    else if (f.y > groundY + f.size) {
      f.missed = true;
      combo = 0;
      updateComboUI();
      lives--;
      updateHeartsUI();
      spawnMissParticles(f.x, groundY);
      shakeTimer = 15;
      shakeIntensity = 6;

      if (lives <= 0) {
        endGame();
      }
    }
  }

  updateParticles(dt);
}

// =================== RENDERING ===================
function render(t) {
  ctx.clearRect(0, 0, W, H);

  ctx.save();
  // Screen shake
  if (shakeTimer > 0) {
    const shake = shakeIntensity * (shakeTimer / 15);
    ctx.translate(
      (Math.random() - 0.5) * shake,
      (Math.random() - 0.5) * shake
    );
  }

  drawBackground(t);

  // Draw fruits
  fruits.forEach(f => drawFruit(f, t));

  // Draw particles behind basket that are above catch line
  drawParticles();

  // Draw basket
  drawBasket(t);

  ctx.restore();
}

// =================== GAME LOOP ===================
function gameLoop(timestamp) {
  if (gameState !== 'playing') return;

  if (!lastTime) lastTime = timestamp;
  const rawDt = (timestamp - lastTime) / 16.667; // normalize to ~60fps
  const dt = Math.min(rawDt, 3); // cap delta to prevent tunneling
  lastTime = timestamp;

  updateGame(timestamp, dt);
  render(timestamp);

  animFrame = requestAnimationFrame(gameLoop);
}

// =================== UI UPDATES ===================
function updateScoreUI() {
  document.getElementById('score-val').textContent = score;
  document.getElementById('level-val').textContent = level;
}

function updateComboUI() {
  const comboEl = document.getElementById('combo-display');
  if (combo >= 2) {
    const phrases = ['Nice!', 'Great!', 'Awesome!', 'Amazing!', 'Incredible!', 'LEGENDARY!'];
    const idx = Math.min(combo - 2, phrases.length - 1);
    comboEl.textContent = `${combo}x Combo - ${phrases[idx]}`;
    comboEl.style.opacity = '1';
    comboEl.style.fontSize = (24 + Math.min(combo * 2, 20)) + 'px';
    comboEl.style.color = combo >= 5 ? '#E63946' : '#FF6B00';
  } else {
    comboEl.style.opacity = '0';
  }
}

function updateHeartsUI() {
  const container = document.getElementById('hearts-container');
  const hearts = container.querySelectorAll('.heart');
  hearts.forEach((h, i) => {
    if (i >= lives) {
      h.classList.add('lost');
    } else {
      h.classList.remove('lost');
    }
  });
}

function showLevelUp() {
  levelUpTimer = 120;
  const comboEl = document.getElementById('combo-display');
  comboEl.textContent = `Level ${level}!`;
  comboEl.style.opacity = '1';
  comboEl.style.fontSize = '36px';
  comboEl.style.color = '#2D6A4F';
  setTimeout(() => {
    if (combo < 2) comboEl.style.opacity = '0';
    else updateComboUI();
  }, 1500);
}

// =================== GAME CONTROL ===================
function startGame() {
  // Reset state
  score = 0;
  lives = 3;
  level = 1;
  combo = 0;
  maxCombo = 0;
  fruits = [];
  particles = [];
  shakeTimer = 0;
  frameCount = 0;
  lastSpawnTime = 0;
  lastTime = 0;

  basket.x = W / 2;
  basket.targetX = W / 2;
  basket.speed = 0;
  basket.tilt = 0;
  basket.catchScale = 1;

  initClouds();
  initGrass();

  // UI
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('game-over-screen').style.display = 'none';
  document.getElementById('score-board').style.display = 'flex';
  document.getElementById('combo-display').style.opacity = '0';

  updateScoreUI();
  updateComboUI();
  updateHeartsUI();

  // Reset hearts
  const container = document.getElementById('hearts-container');
  container.querySelectorAll('.heart').forEach(h => h.classList.remove('lost'));

  gameState = 'playing';

  if (animFrame) cancelAnimationFrame(animFrame);
  animFrame = requestAnimationFrame(gameLoop);
}

function endGame() {
  gameState = 'over';
  if (animFrame) cancelAnimationFrame(animFrame);

  const isNewHigh = score > highScore;
  if (isNewHigh) {
    highScore = score;
    localStorage.setItem('fruitCatcherHigh', highScore.toString());
  }

  document.getElementById('score-board').style.display = 'none';
  document.getElementById('final-score').textContent = `Score: ${score}`;
  const highEl = document.getElementById('high-score-text');
  highEl.textContent = isNewHigh ? `New High Score!` : `Best: ${highScore}`;
  highEl.className = 'high-score-text' + (isNewHigh ? ' new-high' : '');
  document.getElementById('game-over-screen').style.display = 'flex';
}

// =================== INPUT ===================
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
    useMouseControl = false;
    e.preventDefault();
  }
  if ((e.key === ' ' || e.key === 'Enter') && gameState !== 'playing') {
    startGame();
    e.preventDefault();
  }
});

window.addEventListener('keyup', e => {
  keys[e.key] = false;
});

window.addEventListener('mousemove', e => {
  mouseX = e.clientX;
  useMouseControl = true;
});

window.addEventListener('touchmove', e => {
  if (e.touches.length > 0) {
    mouseX = e.touches[0].clientX;
    useMouseControl = true;
  }
  e.preventDefault();
}, { passive: false });

window.addEventListener('touchstart', e => {
  if (e.touches.length > 0) {
    mouseX = e.touches[0].clientX;
    useMouseControl = true;
  }
  if (gameState !== 'playing') {
    // Let the button handle it
  }
});

// =================== INIT ===================
// Draw initial menu background
initClouds();
initGrass();

function drawMenuBg(t) {
  if (gameState !== 'menu' && gameState !== 'over') return;
  render(t || 0);
  requestAnimationFrame(drawMenuBg);
}

// Animate background on menus
(function animateMenuBg() {
  if (gameState === 'playing') {
    requestAnimationFrame(animateMenuBg);
    return;
  }

  const t = performance.now();
  ctx.clearRect(0, 0, W, H);
  drawBackground(t);
  drawBasket(t);

  // Gently bob the basket on menu
  basket.x += (W / 2 - basket.x) * 0.02;
  basket.bobPhase += 0.03;

  requestAnimationFrame(animateMenuBg);
})();

// Focus button
document.getElementById('btn-start').focus();
</script>
</body>
</html>
