<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Escape the Maze</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a1a;
    --panel: #12122a;
    --border: #2a2a5a;
    --accent: #6c5ce7;
    --accent-glow: #a29bfe;
    --gold: #ffd700;
    --success: #00e676;
    --danger: #ff5252;
    --text: #e0e0f0;
    --text-dim: #8888aa;
  }

  @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes pulse { 0%,100% { opacity: 0.6; } 50% { opacity: 1; } }
  @keyframes shimmer { 0% { background-position: -200% center; } 100% { background-position: 200% center; } }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    user-select: none;
  }

  /* Subtle background pattern */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: radial-gradient(circle at 30% 20%, rgba(108,92,231,0.04) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(255,215,0,0.03) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
  }

  #app {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 14px;
    padding: 16px;
    max-width: 100vw;
    animation: fadeIn 0.5s ease;
  }

  h1 {
    font-size: 1.7rem;
    font-weight: 800;
    letter-spacing: 3px;
    text-transform: uppercase;
    background: linear-gradient(135deg, var(--accent-glow) 0%, var(--gold) 50%, var(--accent-glow) 100%);
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: shimmer 4s linear infinite;
  }

  .stats-bar {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
    background: var(--panel);
    padding: 8px 20px;
    border-radius: 8px;
    border: 1px solid var(--border);
  }

  .stat {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.9rem;
    color: var(--text-dim);
  }

  .stat .label { font-weight: 500; }
  .stat .value {
    font-weight: 700;
    color: var(--text);
    font-variant-numeric: tabular-nums;
    min-width: 28px;
  }

  .stat .value.gold { color: var(--gold); }
  .stat .value.accent { color: var(--accent-glow); }

  .stat-divider {
    width: 1px;
    height: 18px;
    background: var(--border);
  }

  #game-container {
    position: relative;
    border: 2px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 0 40px rgba(108, 92, 231, 0.12), 0 0 80px rgba(108, 92, 231, 0.04);
    background: #0d0d22;
  }

  canvas { display: block; }

  .controls-row {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: var(--panel);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 18px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
    letter-spacing: 0.5px;
    transition: all 0.2s;
    white-space: nowrap;
  }

  button:hover {
    background: var(--accent);
    border-color: var(--accent-glow);
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(108, 92, 231, 0.3);
  }

  button:active { transform: translateY(0); }

  button.primary {
    background: var(--accent);
    border-color: var(--accent-glow);
  }

  button.primary:hover {
    background: #7c6cf7;
    box-shadow: 0 4px 20px rgba(108, 92, 231, 0.5);
  }

  .size-selector {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .size-selector label {
    font-size: 0.82rem;
    color: var(--text-dim);
    font-weight: 500;
  }

  .size-selector select {
    background: var(--panel);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 0.82rem;
    cursor: pointer;
    outline: none;
  }

  .size-selector select:focus { border-color: var(--accent); }

  /* Overlays */
  .overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(10, 10, 26, 0.9);
    backdrop-filter: blur(6px);
    z-index: 10;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
  }

  .overlay.visible { opacity: 1; pointer-events: all; }

  .overlay h2 { font-size: 1.8rem; margin-bottom: 8px; }

  .overlay .subtitle {
    font-size: 0.95rem;
    color: var(--text-dim);
    margin-bottom: 6px;
    line-height: 1.5;
  }

  .overlay .bonus {
    font-size: 1rem;
    font-weight: 700;
    margin-bottom: 16px;
    padding: 6px 16px;
    border-radius: 20px;
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.2);
  }

  .overlay .result-stats {
    display: flex;
    gap: 24px;
    margin-bottom: 18px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .overlay .result-stat { text-align: center; }

  .overlay .result-stat .rs-val {
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--accent-glow);
  }

  .overlay .result-stat .rs-label {
    font-size: 0.75rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 2px;
  }

  .win-text {
    background: linear-gradient(135deg, var(--gold), #ff9100, var(--gold));
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: shimmer 2s linear infinite;
  }

  /* Mobile controls */
  .mobile-controls { display: none; gap: 4px; margin-top: 4px; }

  .mobile-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 4px;
  }

  .mobile-grid button {
    width: 52px;
    height: 52px;
    font-size: 1.3rem;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 10px;
  }

  .mobile-grid .empty { visibility: hidden; }

  @media (hover: none) and (pointer: coarse) { .mobile-controls { display: flex; } }
  @media (max-width: 520px) {
    h1 { font-size: 1.2rem; letter-spacing: 2px; }
    .stats-bar { gap: 10px; padding: 6px 12px; }
    .stat { font-size: 0.78rem; }
    .mobile-controls { display: flex; }
    #app { gap: 10px; padding: 10px; }
  }

  .hint-text {
    font-size: 0.78rem;
    color: var(--text-dim);
    text-align: center;
    line-height: 1.4;
  }

  .hint-text kbd {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 1px 5px;
    font-size: 0.75rem;
    font-family: inherit;
  }

  #particles {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 5;
  }
</style>
</head>
<body>
<div id="app">
  <h1>Escape the Maze</h1>

  <div class="stats-bar">
    <div class="stat">
      <span class="label">Time</span>
      <span class="value accent" id="timer">0.0s</span>
    </div>
    <div class="stat-divider"></div>
    <div class="stat">
      <span class="label">Steps</span>
      <span class="value" id="steps">0</span>
    </div>
    <div class="stat-divider"></div>
    <div class="stat">
      <span class="label">Optimal</span>
      <span class="value gold" id="shortest">&mdash;</span>
    </div>
    <div class="stat-divider"></div>
    <div class="stat">
      <span class="label">Level</span>
      <span class="value" id="level">1</span>
    </div>
  </div>

  <div id="game-container">
    <canvas id="maze-canvas"></canvas>
    <canvas id="particles"></canvas>

    <!-- Win overlay -->
    <div class="overlay" id="win-overlay">
      <h2 class="win-text">You Escaped!</h2>
      <div class="result-stats">
        <div class="result-stat">
          <div class="rs-val" id="result-time">0.0s</div>
          <div class="rs-label">Time</div>
        </div>
        <div class="result-stat">
          <div class="rs-val" id="result-steps">0</div>
          <div class="rs-label">Your Steps</div>
        </div>
        <div class="result-stat">
          <div class="rs-val" id="result-shortest">0</div>
          <div class="rs-label">Optimal</div>
        </div>
      </div>
      <div class="bonus" id="bonus-text"></div>
      <div class="controls-row" style="margin-top:4px">
        <button class="primary" id="replay-btn">Play Again</button>
        <button id="next-btn">Next Level</button>
      </div>
    </div>

    <!-- Start overlay -->
    <div class="overlay visible" id="start-overlay">
      <h2 style="margin-bottom:12px;font-size:1.6rem">Escape the Maze</h2>
      <p class="subtitle" style="max-width:280px;text-align:center;margin-bottom:18px">
        Navigate from <span style="color:var(--success);font-weight:700">Start</span> to the <span style="color:var(--danger);font-weight:700">Exit</span>.<br>
        Find the shortest path for a bonus!
      </p>
      <button class="primary" id="start-btn" style="font-size:1rem;padding:10px 32px">Start Game</button>
    </div>
  </div>

  <div class="controls-row">
    <div class="size-selector">
      <label for="maze-size">Size:</label>
      <select id="maze-size">
        <option value="8">Tiny (8x8)</option>
        <option value="12">Small (12x12)</option>
        <option value="16" selected>Medium (16x16)</option>
        <option value="22">Large (22x22)</option>
        <option value="30">Huge (30x30)</option>
      </select>
    </div>
    <button id="show-path-btn">Show Path</button>
    <button id="new-maze-btn">New Maze</button>
  </div>

  <div class="mobile-controls">
    <div class="mobile-grid">
      <div class="empty"></div>
      <button data-dir="up">&#9650;</button>
      <div class="empty"></div>
      <button data-dir="left">&#9664;</button>
      <button data-dir="down">&#9660;</button>
      <button data-dir="right">&#9654;</button>
    </div>
  </div>

  <p class="hint-text">Use <kbd>Arrow Keys</kbd> or <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> to move</p>
</div>

<script>
(function() {
  'use strict';

  // DOM
  const $ = id => document.getElementById(id);
  const canvas = $('maze-canvas');
  const ctx = canvas.getContext('2d');
  const pCanvas = $('particles');
  const pCtx = pCanvas.getContext('2d');
  const timerEl = $('timer');
  const stepsEl = $('steps');
  const shortestEl = $('shortest');
  const levelEl = $('level');
  const winOverlay = $('win-overlay');
  const startOverlay = $('start-overlay');
  const resultTime = $('result-time');
  const resultSteps = $('result-steps');
  const resultShortest = $('result-shortest');
  const bonusText = $('bonus-text');
  const replayBtn = $('replay-btn');
  const nextBtn = $('next-btn');
  const startBtn = $('start-btn');
  const showPathBtn = $('show-path-btn');
  const newMazeBtn = $('new-maze-btn');
  const sizeSelect = $('maze-size');

  // State
  let cols, rows, cellSize;
  let maze = [];
  let player = { x: 0, y: 0 };
  let exitPos = { x: 0, y: 0 };
  let shortestPath = [];
  let shortestLen = 0;
  let stepCount = 0;
  let startTime = 0;
  let elapsedTime = 0;
  let timerRAF = null;
  let gameActive = false;
  let gameWon = false;
  let level = 1;
  let showHintPath = false;
  let visitedCells = new Set();
  let playerTrail = [];
  let particles = [];
  let animRunning = false;
  let lastMoveDir = { dx: 0, dy: 1 }; // For eye direction

  // Smooth player position
  let renderX = 0, renderY = 0;
  const LERP_SPEED = 0.25;

  // Directions
  const DIRS = [
    { dx: 0, dy: -1, wall: 'N', opp: 'S' },
    { dx: 0, dy: 1,  wall: 'S', opp: 'N' },
    { dx: 1, dy: 0,  wall: 'E', opp: 'W' },
    { dx: -1, dy: 0, wall: 'W', opp: 'E' }
  ];

  // =====================
  // Maze generation (Recursive Backtracker)
  // =====================
  function createMaze(c, r) {
    cols = c; rows = r;
    maze = [];
    for (let y = 0; y < rows; y++) {
      maze[y] = [];
      for (let x = 0; x < cols; x++) {
        maze[y][x] = { N: true, S: true, E: true, W: true };
      }
    }

    const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
    const stack = [{ x: 0, y: 0 }];
    visited[0][0] = true;

    while (stack.length) {
      const cur = stack[stack.length - 1];
      const neighbors = [];
      for (const d of DIRS) {
        const nx = cur.x + d.dx, ny = cur.y + d.dy;
        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited[ny][nx]) {
          neighbors.push({ x: nx, y: ny, w: d.wall, o: d.opp });
        }
      }
      if (!neighbors.length) { stack.pop(); continue; }
      const n = neighbors[Math.floor(Math.random() * neighbors.length)];
      maze[cur.y][cur.x][n.w] = false;
      maze[n.y][n.x][n.o] = false;
      visited[n.y][n.x] = true;
      stack.push({ x: n.x, y: n.y });
    }
  }

  // =====================
  // BFS shortest path
  // =====================
  function bfs(sx, sy, ex, ey) {
    const vis = Array.from({ length: rows }, () => Array(cols).fill(false));
    const par = Array.from({ length: rows }, () => Array(cols).fill(null));
    const q = [{ x: sx, y: sy }];
    vis[sy][sx] = true;

    while (q.length) {
      const c = q.shift();
      if (c.x === ex && c.y === ey) {
        const path = [];
        let n = c;
        while (n) { path.unshift(n); n = par[n.y][n.x]; }
        return path;
      }
      for (const d of DIRS) {
        const nx = c.x + d.dx, ny = c.y + d.dy;
        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !vis[ny][nx] && !maze[c.y][c.x][d.wall]) {
          vis[ny][nx] = true;
          par[ny][nx] = c;
          q.push({ x: nx, y: ny });
        }
      }
    }
    return [];
  }

  // =====================
  // Canvas sizing
  // =====================
  function resize() {
    const maxW = Math.min(window.innerWidth - 40, 600);
    const maxH = Math.min(window.innerHeight - 260, 600);
    const dim = Math.min(maxW, maxH);
    cellSize = Math.floor(dim / cols);
    cellSize = Math.max(cellSize, 8);
    const w = cols * cellSize, h = rows * cellSize;
    canvas.width = w; canvas.height = h;
    pCanvas.width = w; pCanvas.height = h;
  }

  // =====================
  // Rendering
  // =====================
  let frameTime = 0;

  function render(ts) {
    frameTime = ts || 0;
    const cs = cellSize;
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    // Background
    ctx.fillStyle = '#0d0d22';
    ctx.fillRect(0, 0, w, h);

    // Visited cell tint
    ctx.fillStyle = 'rgba(108, 92, 231, 0.05)';
    for (const key of visitedCells) {
      const i = key.indexOf(',');
      const vx = +key.substring(0, i), vy = +key.substring(i + 1);
      ctx.fillRect(vx * cs + 1, vy * cs + 1, cs - 2, cs - 2);
    }

    // Player trail line
    if (playerTrail.length > 1) {
      ctx.strokeStyle = 'rgba(108, 92, 231, 0.15)';
      ctx.lineWidth = Math.max(1.5, cs * 0.12);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(playerTrail[0].x * cs + cs / 2, playerTrail[0].y * cs + cs / 2);
      for (let i = 1; i < playerTrail.length; i++) {
        ctx.lineTo(playerTrail[i].x * cs + cs / 2, playerTrail[i].y * cs + cs / 2);
      }
      ctx.stroke();
    }

    // Shortest path hint
    if (showHintPath && shortestPath.length > 1) {
      const dashAnim = (frameTime * 0.03) % (cs * 0.4);
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
      ctx.lineWidth = Math.max(2, cs * 0.14);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.setLineDash([cs * 0.22, cs * 0.18]);
      ctx.lineDashOffset = -dashAnim;
      ctx.beginPath();
      ctx.moveTo(shortestPath[0].x * cs + cs / 2, shortestPath[0].y * cs + cs / 2);
      for (let i = 1; i < shortestPath.length; i++) {
        ctx.lineTo(shortestPath[i].x * cs + cs / 2, shortestPath[i].y * cs + cs / 2);
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Start marker
    ctx.fillStyle = 'rgba(0, 230, 118, 0.2)';
    ctx.fillRect(1, 1, cs - 2, cs - 2);
    // Start "S"
    ctx.fillStyle = 'rgba(0, 230, 118, 0.6)';
    ctx.font = `bold ${Math.max(8, cs * 0.4)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('S', cs / 2, cs / 2);

    // Exit glow (pulsing)
    const pulse = 0.3 + 0.15 * Math.sin(frameTime * 0.004);
    const ecx = exitPos.x * cs + cs / 2, ecy = exitPos.y * cs + cs / 2;
    const glow = ctx.createRadialGradient(ecx, ecy, cs * 0.05, ecx, ecy, cs * 1.0);
    glow.addColorStop(0, `rgba(255, 82, 82, ${pulse})`);
    glow.addColorStop(1, 'rgba(255, 82, 82, 0)');
    ctx.fillStyle = glow;
    ctx.fillRect(exitPos.x * cs - cs * 0.5, exitPos.y * cs - cs * 0.5, cs * 2, cs * 2);

    // Exit marker
    ctx.fillStyle = `rgba(255, 82, 82, ${0.6 + pulse * 0.5})`;
    const ep = cs * 0.2;
    ctx.beginPath();
    roundRect(ctx, exitPos.x * cs + ep, exitPos.y * cs + ep, cs - ep * 2, cs - ep * 2, cs * 0.15);
    ctx.fill();

    // Exit text
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.max(8, cs * 0.38)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('EXIT', ecx, ecy);

    // === Walls (batched for performance) ===
    ctx.strokeStyle = '#3a3a7a';
    ctx.lineWidth = Math.max(1.5, cs * 0.07);
    ctx.lineCap = 'square';
    ctx.beginPath();
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = maze[y][x];
        const px = x * cs, py = y * cs;
        if (cell.N) { ctx.moveTo(px, py); ctx.lineTo(px + cs, py); }
        if (cell.W) { ctx.moveTo(px, py); ctx.lineTo(px, py + cs); }
        // Only draw S for bottom row, E for rightmost col (avoid double-drawing)
        if (y === rows - 1 && cell.S) { ctx.moveTo(px, py + cs); ctx.lineTo(px + cs, py + cs); }
        if (x === cols - 1 && cell.E) { ctx.moveTo(px + cs, py); ctx.lineTo(px + cs, py + cs); }
      }
    }
    ctx.stroke();

    // Outer border (slightly brighter / thicker)
    ctx.strokeStyle = '#4a4a8a';
    ctx.lineWidth = Math.max(2, cs * 0.1);
    ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

    // === Player (smooth lerp) ===
    renderX += (player.x - renderX) * LERP_SPEED;
    renderY += (player.y - renderY) * LERP_SPEED;

    const pcx = renderX * cs + cs / 2;
    const pcy = renderY * cs + cs / 2;
    const pRadius = cs / 2 - cs * 0.18;

    // Player glow
    const pGlow = ctx.createRadialGradient(pcx, pcy, cs * 0.05, pcx, pcy, cs);
    pGlow.addColorStop(0, 'rgba(162, 155, 254, 0.4)');
    pGlow.addColorStop(1, 'rgba(162, 155, 254, 0)');
    ctx.fillStyle = pGlow;
    ctx.beginPath();
    ctx.arc(pcx, pcy, cs, 0, Math.PI * 2);
    ctx.fill();

    // Player body gradient
    const pGrad = ctx.createRadialGradient(pcx - pRadius * 0.3, pcy - pRadius * 0.3, pRadius * 0.1, pcx, pcy, pRadius);
    pGrad.addColorStop(0, '#d4c5ff');
    pGrad.addColorStop(0.7, '#7c6cf7');
    pGrad.addColorStop(1, '#5a4bd6');
    ctx.fillStyle = pGrad;
    ctx.beginPath();
    ctx.arc(pcx, pcy, pRadius, 0, Math.PI * 2);
    ctx.fill();

    // Player border
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Eyes that follow movement direction
    const eyeOff = pRadius * 0.28;
    const eyeR = Math.max(1.2, pRadius * 0.2);
    const pupilR = eyeR * 0.55;
    const edx = lastMoveDir.dx * pRadius * 0.1;
    const edy = lastMoveDir.dy * pRadius * 0.1;

    // Left eye
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(pcx - eyeOff + edx, pcy - pRadius * 0.1 + edy, eyeR, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#1a1a2e';
    ctx.beginPath();
    ctx.arc(pcx - eyeOff + edx * 1.5, pcy - pRadius * 0.1 + edy * 1.5, pupilR, 0, Math.PI * 2);
    ctx.fill();

    // Right eye
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(pcx + eyeOff + edx, pcy - pRadius * 0.1 + edy, eyeR, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#1a1a2e';
    ctx.beginPath();
    ctx.arc(pcx + eyeOff + edx * 1.5, pcy - pRadius * 0.1 + edy * 1.5, pupilR, 0, Math.PI * 2);
    ctx.fill();

    // Small mouth/smile
    if (gameWon) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = Math.max(0.8, pRadius * 0.08);
      ctx.beginPath();
      ctx.arc(pcx, pcy + pRadius * 0.05, pRadius * 0.3, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.stroke();
    }

    // Particles
    updateParticles();

    // Continue animation?
    const dx = Math.abs(player.x - renderX);
    const dy = Math.abs(player.y - renderY);
    const needsAnim = dx > 0.005 || dy > 0.005 || particles.length > 0 || showHintPath || (!gameWon && gameActive);

    if (needsAnim) {
      animRunning = true;
      requestAnimationFrame(render);
    } else {
      animRunning = false;
    }
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function startAnim() {
    if (!animRunning) {
      animRunning = true;
      requestAnimationFrame(render);
    }
  }

  // =====================
  // Particles
  // =====================
  function spawnParticles(cx, cy, count, colors) {
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2;
      const v = 1.5 + Math.random() * 4;
      particles.push({
        x: cx, y: cy,
        vx: Math.cos(a) * v,
        vy: Math.sin(a) * v - 2,
        life: 1,
        decay: 0.008 + Math.random() * 0.015,
        size: 2 + Math.random() * 4,
        color: colors[Math.floor(Math.random() * colors.length)]
      });
    }
  }

  function updateParticles() {
    pCtx.clearRect(0, 0, pCanvas.width, pCanvas.height);
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.06;
      p.vx *= 0.99;
      p.life -= p.decay;
      if (p.life <= 0) { particles.splice(i, 1); continue; }
      pCtx.globalAlpha = p.life * p.life;
      pCtx.fillStyle = p.color;
      pCtx.beginPath();
      pCtx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      pCtx.fill();
    }
    pCtx.globalAlpha = 1;
  }

  // =====================
  // Game logic
  // =====================
  function movePlayer(dx, dy) {
    if (!gameActive || gameWon) return;

    let wall;
    if (dx === 1) wall = 'E';
    else if (dx === -1) wall = 'W';
    else if (dy === -1) wall = 'N';
    else wall = 'S';

    const nx = player.x + dx, ny = player.y + dy;
    if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return;
    if (maze[player.y][player.x][wall]) return;

    player.x = nx; player.y = ny;
    lastMoveDir = { dx, dy };
    stepCount++;
    stepsEl.textContent = stepCount;
    visitedCells.add(`${nx},${ny}`);
    playerTrail.push({ x: nx, y: ny });

    // Small step particles
    const pcx = nx * cellSize + cellSize / 2;
    const pcy = ny * cellSize + cellSize / 2;
    spawnParticles(pcx, pcy, 3, ['rgba(162,155,254,0.6)', 'rgba(108,92,231,0.4)']);

    startAnim();

    if (nx === exitPos.x && ny === exitPos.y) {
      winGame();
    }
  }

  // Timer using rAF for smooth display
  function tickTimer() {
    if (!gameActive || gameWon) return;
    elapsedTime = (performance.now() - startTime) / 1000;
    timerEl.textContent = elapsedTime.toFixed(1) + 's';
    timerRAF = requestAnimationFrame(tickTimer);
  }

  function startTimer() {
    startTime = performance.now();
    timerRAF = requestAnimationFrame(tickTimer);
  }

  function stopTimer() {
    if (timerRAF) { cancelAnimationFrame(timerRAF); timerRAF = null; }
  }

  function winGame() {
    gameWon = true;
    gameActive = false;
    stopTimer();

    elapsedTime = (performance.now() - startTime) / 1000;
    timerEl.textContent = elapsedTime.toFixed(1) + 's';

    resultTime.textContent = elapsedTime.toFixed(1) + 's';
    resultSteps.textContent = stepCount;
    resultShortest.textContent = shortestLen;

    const ratio = shortestLen / stepCount;
    if (stepCount <= shortestLen) {
      bonusText.textContent = 'PERFECT - Shortest path!';
      bonusText.style.color = 'var(--gold)';
      bonusText.style.borderColor = 'rgba(255,215,0,0.3)';
      bonusText.style.background = 'rgba(255,215,0,0.1)';
    } else if (ratio >= 0.85) {
      bonusText.textContent = 'Excellent - Near optimal!';
      bonusText.style.color = 'var(--accent-glow)';
      bonusText.style.borderColor = 'rgba(162,155,254,0.3)';
      bonusText.style.background = 'rgba(162,155,254,0.1)';
    } else if (ratio >= 0.6) {
      bonusText.textContent = 'Good - Room to improve';
      bonusText.style.color = 'var(--success)';
      bonusText.style.borderColor = 'rgba(0,230,118,0.3)';
      bonusText.style.background = 'rgba(0,230,118,0.1)';
    } else {
      bonusText.textContent = 'Try for a shorter path!';
      bonusText.style.color = '#ff9100';
      bonusText.style.borderColor = 'rgba(255,145,0,0.3)';
      bonusText.style.background = 'rgba(255,145,0,0.1)';
    }

    // Celebration particles
    const cx = exitPos.x * cellSize + cellSize / 2;
    const cy = exitPos.y * cellSize + cellSize / 2;
    const colors = ['#ffd700', '#ff9100', '#ff5252', '#a29bfe', '#6c5ce7', '#00e676', '#fff'];

    spawnParticles(cx, cy, 60, colors);
    // Delayed secondary bursts
    setTimeout(() => spawnParticles(cx - 30, cy - 20, 30, colors), 150);
    setTimeout(() => spawnParticles(cx + 30, cy + 10, 30, colors), 300);

    setTimeout(() => { winOverlay.classList.add('visible'); }, 700);
    startAnim();
  }

  // =====================
  // Game setup
  // =====================
  function newGame(sizeOverride) {
    const size = sizeOverride || parseInt(sizeSelect.value);
    gameWon = false;
    gameActive = false;
    showHintPath = false;
    showPathBtn.textContent = 'Show Path';
    stepCount = 0;
    stepsEl.textContent = '0';
    elapsedTime = 0;
    timerEl.textContent = '0.0s';
    visitedCells.clear();
    playerTrail = [];
    particles = [];
    lastMoveDir = { dx: 0, dy: 1 };
    stopTimer();
    winOverlay.classList.remove('visible');

    createMaze(size, size);

    player.x = 0; player.y = 0;
    exitPos.x = cols - 1; exitPos.y = rows - 1;
    renderX = 0; renderY = 0;

    shortestPath = bfs(0, 0, exitPos.x, exitPos.y);
    shortestLen = shortestPath.length - 1;
    shortestEl.textContent = shortestLen;

    visitedCells.add('0,0');
    playerTrail.push({ x: 0, y: 0 });
    levelEl.textContent = level;

    resize();
    startAnim();
  }

  function beginPlay() {
    startOverlay.classList.remove('visible');
    gameActive = true;
    startTimer();
    startAnim();
  }

  // =====================
  // Input
  // =====================
  document.addEventListener('keydown', e => {
    // Start game on any key if start overlay visible
    if (startOverlay.classList.contains('visible')) {
      if (['Enter', ' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key)) {
        e.preventDefault();
        newGame();
        beginPlay();
      }
      return;
    }

    switch (e.key) {
      case 'ArrowUp': case 'w': case 'W': e.preventDefault(); movePlayer(0, -1); break;
      case 'ArrowDown': case 's': case 'S': e.preventDefault(); movePlayer(0, 1); break;
      case 'ArrowLeft': case 'a': case 'A': e.preventDefault(); movePlayer(-1, 0); break;
      case 'ArrowRight': case 'd': case 'D': e.preventDefault(); movePlayer(1, 0); break;
    }
  });

  // Mobile buttons
  document.querySelectorAll('[data-dir]').forEach(btn => {
    const map = { up: [0,-1], down: [0,1], left: [-1,0], right: [1,0] };
    const [dx, dy] = map[btn.dataset.dir];

    // Handle both click and touchstart for responsiveness
    const handler = e => {
      e.preventDefault();
      if (startOverlay.classList.contains('visible')) {
        newGame(); beginPlay();
      }
      movePlayer(dx, dy);
    };
    btn.addEventListener('click', handler);
  });

  // Swipe on canvas
  let touchX = 0, touchY = 0, touchTime = 0;
  canvas.addEventListener('touchstart', e => {
    touchX = e.touches[0].clientX;
    touchY = e.touches[0].clientY;
    touchTime = Date.now();
  }, { passive: true });

  canvas.addEventListener('touchend', e => {
    if (!gameActive || Date.now() - touchTime > 500) return;
    const dx = e.changedTouches[0].clientX - touchX;
    const dy = e.changedTouches[0].clientY - touchY;
    const minSwipe = 15;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (Math.abs(dx) > minSwipe) movePlayer(dx > 0 ? 1 : -1, 0);
    } else {
      if (Math.abs(dy) > minSwipe) movePlayer(0, dy > 0 ? 1 : -1);
    }
  }, { passive: true });

  // Buttons
  startBtn.onclick = () => { newGame(); beginPlay(); };
  replayBtn.onclick = () => { newGame(); beginPlay(); };
  nextBtn.onclick = () => {
    level++;
    // Progressive difficulty
    const sizes = [8, 10, 12, 14, 16, 18, 20, 22, 25, 28, 30];
    const idx = Math.min(level - 1, sizes.length - 1);
    newGame(sizes[idx]);
    beginPlay();
  };

  showPathBtn.onclick = () => {
    showHintPath = !showHintPath;
    showPathBtn.textContent = showHintPath ? 'Hide Path' : 'Show Path';
    startAnim();
  };

  newMazeBtn.onclick = () => { level = 1; newGame(); beginPlay(); };

  sizeSelect.onchange = () => {
    level = 1;
    newGame();
    beginPlay();
  };

  window.addEventListener('resize', () => {
    resize();
    renderX = player.x;
    renderY = player.y;
    startAnim();
  });

  // =====================
  // Init
  // =====================
  newGame();
  render(0);
})();
</script>
</body>
</html>
