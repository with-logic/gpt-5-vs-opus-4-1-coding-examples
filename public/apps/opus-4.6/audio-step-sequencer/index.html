<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Audio Step Sequencer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&display=swap');

  :root {
    --bg-dark: #0a0a12;
    --bg-panel: #0f0f1e;
    --bg-cell: #141428;
    --bg-cell-hover: #1a1a3a;
    --accent-cyan: #00f0ff;
    --accent-magenta: #ff00e5;
    --accent-purple: #8b5cf6;
    --accent-green: #00ff88;
    --accent-orange: #ff6b2b;
    --accent-yellow: #ffe03a;
    --accent-red: #ff2b5e;
    --text-primary: #e0e0ff;
    --text-secondary: #7a7aaa;
    --border-color: #1e1e3a;
    --glow-cyan: 0 0 15px rgba(0,240,255,0.3);
    --glow-magenta: 0 0 15px rgba(255,0,229,0.3);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg-dark);
    color: var(--text-primary);
    font-family: 'Rajdhani', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Animated background grid */
  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background:
      linear-gradient(rgba(0,240,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,240,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  body::after {
    content: '';
    position: fixed;
    top: -50%; left: -50%; right: -50%; bottom: -50%;
    background: radial-gradient(ellipse at center, rgba(139,92,246,0.08) 0%, transparent 60%);
    pointer-events: none;
    z-index: 0;
    animation: bgPulse 8s ease-in-out infinite;
  }

  @keyframes bgPulse {
    0%, 100% { opacity: 0.5; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.1); }
  }

  #app {
    position: relative;
    z-index: 1;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }

  /* Header */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 24px;
    margin-bottom: 20px;
    background: linear-gradient(135deg, rgba(15,15,30,0.9), rgba(20,20,40,0.9));
    border: 1px solid var(--border-color);
    border-radius: 16px;
    backdrop-filter: blur(10px);
  }

  .logo {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .logo-icon {
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    animation: logoSpin 4s linear infinite;
    box-shadow: var(--glow-cyan);
  }

  @keyframes logoSpin {
    0% { box-shadow: 0 0 15px rgba(0,240,255,0.4); }
    50% { box-shadow: 0 0 15px rgba(255,0,229,0.4); }
    100% { box-shadow: 0 0 15px rgba(0,240,255,0.4); }
  }

  .logo h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 22px;
    font-weight: 700;
    background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: 2px;
  }

  .logo .subtitle {
    font-size: 11px;
    color: var(--text-secondary);
    letter-spacing: 4px;
    text-transform: uppercase;
  }

  /* Transport controls */
  .transport {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .btn {
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    font-size: 14px;
    padding: 8px 18px;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background: var(--bg-panel);
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    position: relative;
    overflow: hidden;
  }

  .btn:hover {
    border-color: var(--accent-cyan);
    box-shadow: var(--glow-cyan);
    transform: translateY(-1px);
  }

  .btn:active { transform: translateY(0); }

  .btn-play {
    background: linear-gradient(135deg, rgba(0,240,255,0.15), rgba(0,255,136,0.15));
    border-color: var(--accent-cyan);
    color: var(--accent-cyan);
    min-width: 100px;
  }

  .btn-play.playing {
    background: linear-gradient(135deg, rgba(255,43,94,0.2), rgba(255,107,43,0.2));
    border-color: var(--accent-red);
    color: var(--accent-red);
    animation: playPulse 1s ease-in-out infinite;
  }

  @keyframes playPulse {
    0%, 100% { box-shadow: 0 0 10px rgba(255,43,94,0.2); }
    50% { box-shadow: 0 0 20px rgba(255,43,94,0.4); }
  }

  .btn-stop {
    background: linear-gradient(135deg, rgba(255,43,94,0.1), rgba(255,0,229,0.1));
    border-color: rgba(255,43,94,0.5);
    color: var(--accent-red);
  }

  /* Controls panel */
  .controls-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
    margin-bottom: 20px;
  }

  .control-group {
    background: var(--bg-panel);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 14px 16px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .control-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  .control-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 24px;
    font-weight: 700;
    color: var(--accent-cyan);
    text-shadow: 0 0 10px rgba(0,240,255,0.3);
  }

  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    background: var(--bg-cell);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0,240,255,0.4);
    transition: box-shadow 0.2s;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    box-shadow: 0 0 20px rgba(0,240,255,0.6);
  }

  input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px rgba(0,240,255,0.4);
  }

  /* Sequencer Grid */
  .sequencer-container {
    background: var(--bg-panel);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 20px;
    overflow-x: auto;
  }

  .beat-indicators {
    display: grid;
    grid-template-columns: 140px repeat(16, 1fr);
    gap: 4px;
    margin-bottom: 8px;
    padding: 0 2px;
  }

  .beat-num {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: var(--text-secondary);
    text-align: center;
    padding: 4px 0;
  }

  .beat-num.downbeat {
    color: var(--accent-cyan);
    font-weight: 700;
  }

  .grid {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .grid-row {
    display: grid;
    grid-template-columns: 140px repeat(16, 1fr);
    gap: 4px;
    align-items: center;
  }

  .row-label {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 8px;
    border-radius: 8px;
    background: rgba(20,20,40,0.5);
  }

  .row-icon {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 700;
    flex-shrink: 0;
  }

  .row-info {
    display: flex;
    flex-direction: column;
    min-width: 0;
  }

  .row-name {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 1px;
    white-space: nowrap;
  }

  .row-controls {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .row-btn {
    font-size: 9px;
    padding: 1px 5px;
    border-radius: 4px;
    border: 1px solid var(--border-color);
    background: transparent;
    color: var(--text-secondary);
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    transition: all 0.15s;
  }

  .row-btn:hover {
    border-color: var(--accent-cyan);
    color: var(--accent-cyan);
  }

  .row-btn.muted {
    border-color: var(--accent-red);
    color: var(--accent-red);
    background: rgba(255,43,94,0.1);
  }

  .row-btn.solo-active {
    border-color: var(--accent-yellow);
    color: var(--accent-yellow);
    background: rgba(255,224,58,0.1);
  }

  .vol-slider {
    width: 40px;
    height: 4px;
  }

  .vol-slider::-webkit-slider-thumb {
    width: 10px;
    height: 10px;
  }

  .cell {
    aspect-ratio: 1;
    min-height: 32px;
    border-radius: 6px;
    border: 1px solid rgba(30,30,58,0.8);
    cursor: pointer;
    transition: all 0.1s ease;
    position: relative;
    overflow: hidden;
  }

  .cell::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 5px;
    opacity: 0;
    transition: opacity 0.1s;
  }

  .cell:hover {
    border-color: rgba(0,240,255,0.3);
    background: var(--bg-cell-hover);
  }

  .cell.active {
    border-color: transparent;
  }

  .cell.active::before {
    opacity: 1;
  }

  .cell.current-step {
    box-shadow: inset 0 0 0 2px rgba(255,255,255,0.6), 0 0 12px rgba(255,255,255,0.2);
  }

  .cell.current-step.active {
    box-shadow: inset 0 0 0 2px rgba(255,255,255,0.8), 0 0 20px rgba(255,255,255,0.3);
  }

  .cell.flash {
    animation: cellFlash 0.15s ease-out;
  }

  @keyframes cellFlash {
    0% { filter: brightness(2); }
    100% { filter: brightness(1); }
  }

  /* Velocity indicator on cells */
  .cell .velocity-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: rgba(255,255,255,0.3);
    border-radius: 0 0 5px 5px;
  }

  /* Beat group separators */
  .cell.beat-start {
    margin-left: 3px;
  }

  /* Pattern & Actions */
  .bottom-panel {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 20px;
  }

  .panel-section {
    background: var(--bg-panel);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 16px;
  }

  .panel-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 12px;
  }

  .pattern-slots {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 6px;
  }

  .pattern-slot {
    aspect-ratio: 1;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    background: var(--bg-cell);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    font-weight: 700;
    color: var(--text-secondary);
    transition: all 0.2s;
    position: relative;
  }

  .pattern-slot:hover {
    border-color: var(--accent-purple);
    color: var(--accent-purple);
  }

  .pattern-slot.has-data {
    border-color: rgba(139,92,246,0.4);
    color: var(--accent-purple);
    background: rgba(139,92,246,0.05);
  }

  .pattern-slot.current {
    border-color: var(--accent-cyan);
    color: var(--accent-cyan);
    background: rgba(0,240,255,0.1);
    box-shadow: var(--glow-cyan);
  }

  .pattern-slot .dot {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: var(--accent-green);
  }

  .action-btns {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .btn-action {
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    font-size: 13px;
    padding: 8px 16px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--bg-cell);
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .btn-action:hover {
    border-color: var(--accent-cyan);
    box-shadow: var(--glow-cyan);
  }

  .btn-action.export {
    border-color: rgba(0,255,136,0.4);
    color: var(--accent-green);
  }

  .btn-action.export:hover {
    box-shadow: 0 0 15px rgba(0,255,136,0.3);
  }

  .btn-action.clear {
    border-color: rgba(255,43,94,0.4);
    color: var(--accent-red);
  }

  .btn-action.clear:hover {
    box-shadow: 0 0 15px rgba(255,43,94,0.3);
  }

  .btn-action.randomize {
    border-color: rgba(255,224,58,0.4);
    color: var(--accent-yellow);
  }

  /* Visualizer */
  .visualizer-container {
    background: var(--bg-panel);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 8px;
    margin-bottom: 20px;
    height: 80px;
    position: relative;
    overflow: hidden;
  }

  #visualizer {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* Step position indicator bar */
  .step-bar {
    display: grid;
    grid-template-columns: 140px repeat(16, 1fr);
    gap: 4px;
    margin-top: 6px;
    padding: 0 2px;
  }

  .step-indicator {
    height: 4px;
    border-radius: 2px;
    background: var(--bg-cell);
    transition: background 0.1s;
  }

  .step-indicator.active {
    background: var(--accent-cyan);
    box-shadow: 0 0 8px rgba(0,240,255,0.5);
  }

  /* Notifications */
  .notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    background: rgba(15,15,30,0.95);
    border: 1px solid var(--accent-cyan);
    border-radius: 10px;
    color: var(--accent-cyan);
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    font-size: 14px;
    z-index: 100;
    box-shadow: var(--glow-cyan);
    animation: notifyIn 0.3s ease-out, notifyOut 0.3s ease-in 1.7s forwards;
    pointer-events: none;
  }

  @keyframes notifyIn {
    from { opacity: 0; transform: translateX(40px); }
    to { opacity: 1; transform: translateX(0); }
  }

  @keyframes notifyOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  /* Responsive */
  @media (max-width: 768px) {
    .header { flex-direction: column; gap: 12px; }
    .bottom-panel { grid-template-columns: 1fr; }
    .controls-panel { grid-template-columns: repeat(2, 1fr); }
    .logo h1 { font-size: 16px; }
    .cell { min-height: 24px; }
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; height: 6px; }
  ::-webkit-scrollbar-track { background: var(--bg-dark); }
  ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--accent-purple); }

  /* Select styling */
  select {
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    font-size: 13px;
    padding: 6px 10px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-cell);
    color: var(--text-primary);
    cursor: pointer;
    outline: none;
  }

  select:hover { border-color: var(--accent-cyan); }

  /* Exporting overlay */
  .export-overlay {
    position: fixed;
    inset: 0;
    background: rgba(10,10,18,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 200;
    backdrop-filter: blur(5px);
  }

  .export-overlay .msg {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    color: var(--accent-cyan);
    text-shadow: 0 0 20px rgba(0,240,255,0.5);
    animation: exportPulse 0.8s ease-in-out infinite;
  }

  @keyframes exportPulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }

  .swing-label { color: var(--accent-magenta); }
  .master-vol-label { color: var(--accent-green); }
</style>
</head>
<body>
<div id="app">
  <!-- Header -->
  <div class="header">
    <div class="logo">
      <div class="logo-icon">&#9835;</div>
      <div>
        <h1>STEP SEQ</h1>
        <div class="subtitle">Audio Step Sequencer</div>
      </div>
    </div>
    <div class="transport">
      <button class="btn btn-play" id="playBtn" onclick="togglePlay()">&#9654; PLAY</button>
      <button class="btn btn-stop" onclick="stopSequencer()">&#9632; STOP</button>
    </div>
  </div>

  <!-- Visualizer -->
  <div class="visualizer-container">
    <canvas id="visualizer"></canvas>
  </div>

  <!-- Controls -->
  <div class="controls-panel">
    <div class="control-group">
      <div class="control-label">Tempo BPM</div>
      <div class="control-value" id="tempoValue">128</div>
      <input type="range" id="tempoSlider" min="60" max="200" value="128" oninput="setTempo(this.value)">
    </div>
    <div class="control-group">
      <div class="control-label swing-label">Swing %</div>
      <div class="control-value" id="swingValue" style="color:var(--accent-magenta)">0</div>
      <input type="range" id="swingSlider" min="0" max="80" value="0" oninput="setSwing(this.value)">
    </div>
    <div class="control-group">
      <div class="control-label master-vol-label">Master Vol</div>
      <div class="control-value" id="volValue" style="color:var(--accent-green)">80</div>
      <input type="range" id="volSlider" min="0" max="100" value="80" oninput="setMasterVol(this.value)">
    </div>
    <div class="control-group">
      <div class="control-label">Kit</div>
      <select id="kitSelect" onchange="changeKit(this.value)" style="margin-top:4px;">
        <option value="electronic">Electronic</option>
        <option value="808">808 Heavy</option>
        <option value="acoustic">Acoustic</option>
      </select>
    </div>
  </div>

  <!-- Sequencer Grid -->
  <div class="sequencer-container">
    <div class="beat-indicators" id="beatIndicators"></div>
    <div class="grid" id="grid"></div>
    <div class="step-bar" id="stepBar"></div>
  </div>

  <!-- Bottom Panel -->
  <div class="bottom-panel">
    <div class="panel-section">
      <div class="panel-title">Patterns</div>
      <div class="pattern-slots" id="patternSlots"></div>
    </div>
    <div class="panel-section">
      <div class="panel-title">Actions</div>
      <div class="action-btns">
        <button class="btn-action export" onclick="exportWAV()">&#128190; Export WAV</button>
        <button class="btn-action" onclick="savePatternToFile()">&#128229; Save File</button>
        <button class="btn-action" onclick="loadPatternFromFile()">&#128228; Load File</button>
        <button class="btn-action randomize" onclick="randomizePattern()">&#127922; Random</button>
        <button class="btn-action clear" onclick="clearPattern()">&#128465; Clear</button>
        <button class="btn-action" onclick="copyPattern()">&#128203; Copy</button>
        <button class="btn-action" onclick="pastePattern()">&#128195; Paste</button>
      </div>
    </div>
  </div>
</div>

<input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFileLoad(event)">

<script>
// ============== AUDIO ENGINE ==============
let audioCtx = null;
let masterGain = null;
let analyser = null;
let compressor = null;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  compressor = audioCtx.createDynamicsCompressor();
  compressor.threshold.value = -12;
  compressor.knee.value = 10;
  compressor.ratio.value = 4;
  compressor.attack.value = 0.003;
  compressor.release.value = 0.15;

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.8;

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.8;

  masterGain.connect(compressor);
  compressor.connect(analyser);
  analyser.connect(audioCtx.destination);
}

// ============== DRUM KITS ==============
const INSTRUMENTS = [
  { id: 'kick',    name: 'KICK',    icon: 'K', color: '#ff2b5e' },
  { id: 'snare',   name: 'SNARE',   icon: 'S', color: '#00f0ff' },
  { id: 'hihat',   name: 'HI-HAT',  icon: 'H', color: '#ffe03a' },
  { id: 'openhat', name: 'OPEN HH', icon: 'O', color: '#ff6b2b' },
  { id: 'clap',    name: 'CLAP',    icon: 'C', color: '#8b5cf6' },
  { id: 'tom',     name: 'TOM',     icon: 'T', color: '#00ff88' },
  { id: 'rim',     name: 'RIM',     icon: 'R', color: '#ff00e5' },
  { id: 'perc',    name: 'PERC',    icon: 'P', color: '#4dc9f6' },
];

let currentKit = 'electronic';

function synthDrum(instrument, time, velocity, ctx, dest) {
  const v = velocity || 1;
  const t = time;

  switch(instrument) {
    case 'kick': {
      const osc = ctx.createOscillator();
      const oscGain = ctx.createGain();
      const clickOsc = ctx.createOscillator();
      const clickGain = ctx.createGain();

      let freq = currentKit === '808' ? 55 : (currentKit === 'acoustic' ? 80 : 65);
      let decay = currentKit === '808' ? 0.6 : 0.3;

      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq * 4, t);
      osc.frequency.exponentialRampToValueAtTime(freq, t + 0.04);
      oscGain.gain.setValueAtTime(v * 1.2, t);
      oscGain.gain.exponentialRampToValueAtTime(0.001, t + decay);

      clickOsc.type = 'square';
      clickOsc.frequency.setValueAtTime(1200, t);
      clickOsc.frequency.exponentialRampToValueAtTime(100, t + 0.02);
      clickGain.gain.setValueAtTime(v * 0.4, t);
      clickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.03);

      osc.connect(oscGain).connect(dest);
      clickOsc.connect(clickGain).connect(dest);
      osc.start(t); osc.stop(t + decay + 0.05);
      clickOsc.start(t); clickOsc.stop(t + 0.05);
      break;
    }
    case 'snare': {
      const noiseLen = currentKit === '808' ? 0.18 : 0.15;
      const bufferSize = ctx.sampleRate * noiseLen;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);

      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      const noiseFilter = ctx.createBiquadFilter();
      noiseFilter.type = 'highpass';
      noiseFilter.frequency.value = currentKit === '808' ? 2000 : 3000;
      const noiseGain = ctx.createGain();
      noiseGain.gain.setValueAtTime(v * 0.7, t);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, t + noiseLen);

      const osc = ctx.createOscillator();
      const oscGain = ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(currentKit === '808' ? 180 : 200, t);
      osc.frequency.exponentialRampToValueAtTime(100, t + 0.05);
      oscGain.gain.setValueAtTime(v * 0.6, t);
      oscGain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);

      noise.connect(noiseFilter).connect(noiseGain).connect(dest);
      osc.connect(oscGain).connect(dest);
      noise.start(t); osc.start(t); osc.stop(t + 0.2);
      break;
    }
    case 'hihat': {
      const bufLen = 0.06;
      const bufferSize = ctx.sampleRate * bufLen;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);

      const src = ctx.createBufferSource();
      src.buffer = buffer;
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 7000;
      const bp = ctx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 10000;
      bp.Q.value = 1;
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(v * 0.4, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + bufLen);

      src.connect(hp).connect(bp).connect(gain).connect(dest);
      src.start(t);
      break;
    }
    case 'openhat': {
      const bufLen = 0.3;
      const bufferSize = ctx.sampleRate * bufLen;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);

      const src = ctx.createBufferSource();
      src.buffer = buffer;
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 6000;
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(v * 0.35, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + bufLen);

      src.connect(hp).connect(gain).connect(dest);
      src.start(t);
      break;
    }
    case 'clap': {
      const len = 0.15;
      for (let n = 0; n < 3; n++) {
        const bufferSize = ctx.sampleRate * 0.02;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);

        const src = ctx.createBufferSource();
        src.buffer = buffer;
        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass';
        bp.frequency.value = 2500;
        bp.Q.value = 3;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(v * 0.5, t + n * 0.012);
        gain.gain.exponentialRampToValueAtTime(0.001, t + n * 0.012 + len);

        src.connect(bp).connect(gain).connect(dest);
        src.start(t + n * 0.012);
      }
      break;
    }
    case 'tom': {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      let freq = currentKit === '808' ? 100 : 150;
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq * 2, t);
      osc.frequency.exponentialRampToValueAtTime(freq, t + 0.06);
      gain.gain.setValueAtTime(v * 0.8, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.connect(gain).connect(dest);
      osc.start(t); osc.stop(t + 0.35);
      break;
    }
    case 'rim': {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.exponentialRampToValueAtTime(400, t + 0.01);
      gain.gain.setValueAtTime(v * 0.4, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

      const osc2 = ctx.createOscillator();
      const gain2 = ctx.createGain();
      osc2.type = 'triangle';
      osc2.frequency.value = 1600;
      gain2.gain.setValueAtTime(v * 0.2, t);
      gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.02);

      osc.connect(gain).connect(dest);
      osc2.connect(gain2).connect(dest);
      osc.start(t); osc.stop(t + 0.06);
      osc2.start(t); osc2.stop(t + 0.04);
      break;
    }
    case 'perc': {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.exponentialRampToValueAtTime(300, t + 0.08);
      gain.gain.setValueAtTime(v * 0.5, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);

      const bufferSize = ctx.sampleRate * 0.05;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      const nGain = ctx.createGain();
      nGain.gain.setValueAtTime(v * 0.15, t);
      nGain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

      osc.connect(gain).connect(dest);
      src.connect(nGain).connect(dest);
      osc.start(t); osc.stop(t + 0.15);
      src.start(t);
      break;
    }
  }
}

// ============== SEQUENCER STATE ==============
const STEPS = 16;
const NUM_INST = INSTRUMENTS.length;

let grid = Array.from({length: NUM_INST}, () => Array(STEPS).fill(0));
let velocities = Array.from({length: NUM_INST}, () => Array(STEPS).fill(0.8));
let muted = Array(NUM_INST).fill(false);
let soloed = Array(NUM_INST).fill(false);
let volumes = Array(NUM_INST).fill(0.8);

let tempo = 128;
let swing = 0;
let masterVol = 0.8;
let isPlaying = false;
let currentStep = -1;
let schedulerTimer = null;
let nextNoteTime = 0;
let scheduleAheadTime = 0.1;
let lookAhead = 25; // ms
let currentPattern = 0;
let patterns = Array(8).fill(null);
let clipboard = null;

// ============== SEQUENCER LOGIC ==============
function getStepDuration() {
  return 60 / tempo / 4; // 16th notes
}

function getSwungTime(step) {
  const stepDur = getStepDuration();
  let time = step * stepDur;
  if (step % 2 === 1) {
    time += stepDur * (swing / 100) * 0.7;
  }
  return time;
}

function scheduler() {
  while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
    scheduleStep(currentStep, nextNoteTime);
    advanceStep();
  }
  schedulerTimer = setTimeout(scheduler, lookAhead);
}

function scheduleStep(step, time) {
  // Update UI on the main thread
  const displayStep = step;
  setTimeout(() => updateStepDisplay(displayStep), (time - audioCtx.currentTime) * 1000);

  const hasSolo = soloed.some(s => s);

  for (let i = 0; i < NUM_INST; i++) {
    if (grid[i][step]) {
      if (muted[i]) continue;
      if (hasSolo && !soloed[i]) continue;

      const vel = velocities[i][step] * volumes[i];
      synthDrum(INSTRUMENTS[i].id, time, vel, audioCtx, masterGain);
    }
  }
}

function advanceStep() {
  const stepDur = getStepDuration();
  currentStep = (currentStep + 1) % STEPS;

  // Account for swing
  let nextStepDur = stepDur;
  if (currentStep % 2 === 1) {
    nextStepDur = stepDur * (1 + (swing / 100) * 0.7);
  } else if (currentStep % 2 === 0 && currentStep > 0) {
    nextStepDur = stepDur * (1 - (swing / 100) * 0.7);
  }
  if (nextStepDur < stepDur * 0.3) nextStepDur = stepDur * 0.3;

  nextNoteTime += nextStepDur;
}

function togglePlay() {
  initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();

  if (isPlaying) {
    stopSequencer();
  } else {
    isPlaying = true;
    currentStep = 0;
    nextNoteTime = audioCtx.currentTime + 0.05;
    scheduler();
    document.getElementById('playBtn').classList.add('playing');
    document.getElementById('playBtn').innerHTML = '&#10074;&#10074; PAUSE';
  }
}

function stopSequencer() {
  isPlaying = false;
  currentStep = -1;
  if (schedulerTimer) {
    clearTimeout(schedulerTimer);
    schedulerTimer = null;
  }
  document.getElementById('playBtn').classList.remove('playing');
  document.getElementById('playBtn').innerHTML = '&#9654; PLAY';
  updateStepDisplay(-1);
}

function updateStepDisplay(step) {
  // Update cell highlights
  document.querySelectorAll('.cell.current-step').forEach(c => c.classList.remove('current-step'));
  if (step >= 0) {
    document.querySelectorAll(`.cell[data-step="${step}"]`).forEach(c => {
      c.classList.add('current-step');
      if (grid[parseInt(c.dataset.inst)][step]) {
        c.classList.add('flash');
        setTimeout(() => c.classList.remove('flash'), 150);
      }
    });
  }

  // Update step bar
  document.querySelectorAll('.step-indicator').forEach((el, i) => {
    el.classList.toggle('active', i === step);
  });
}

// ============== UI BUILDING ==============
function buildGrid() {
  const gridEl = document.getElementById('grid');
  const beatInd = document.getElementById('beatIndicators');
  const stepBar = document.getElementById('stepBar');

  // Beat indicators
  let beatHTML = '<div></div>';
  for (let s = 0; s < STEPS; s++) {
    const isDownbeat = s % 4 === 0;
    beatHTML += `<div class="beat-num ${isDownbeat ? 'downbeat' : ''}">${s + 1}</div>`;
  }
  beatInd.innerHTML = beatHTML;

  // Grid rows
  let gridHTML = '';
  for (let i = 0; i < NUM_INST; i++) {
    const inst = INSTRUMENTS[i];
    gridHTML += `<div class="grid-row" data-inst="${i}">`;
    gridHTML += `<div class="row-label">
      <div class="row-icon" style="background:${inst.color}22;color:${inst.color};border:1px solid ${inst.color}44">${inst.icon}</div>
      <div class="row-info">
        <div class="row-name" style="color:${inst.color}">${inst.name}</div>
        <div class="row-controls">
          <button class="row-btn" data-mute="${i}" onclick="toggleMute(${i})">M</button>
          <button class="row-btn" data-solo="${i}" onclick="toggleSolo(${i})">S</button>
          <input type="range" class="vol-slider" min="0" max="100" value="80" oninput="setRowVol(${i}, this.value)">
        </div>
      </div>
    </div>`;

    for (let s = 0; s < STEPS; s++) {
      const beatStart = s % 4 === 0 && s > 0 ? ' beat-start' : '';
      gridHTML += `<div class="cell${beatStart}" data-inst="${i}" data-step="${s}"
        onmousedown="cellMouseDown(event,${i},${s})"
        onmouseenter="cellMouseEnter(event,${i},${s})"
        oncontextmenu="event.preventDefault();cellRightClick(${i},${s})">
      </div>`;
    }
    gridHTML += '</div>';
  }
  gridEl.innerHTML = gridHTML;

  // Step bar
  let barHTML = '<div></div>';
  for (let s = 0; s < STEPS; s++) {
    barHTML += `<div class="step-indicator"></div>`;
  }
  stepBar.innerHTML = barHTML;

  updateGridDisplay();
}

let isDragging = false;
let dragValue = 0;

function cellMouseDown(e, inst, step) {
  e.preventDefault();
  initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  isDragging = true;
  dragValue = grid[inst][step] ? 0 : 1;
  grid[inst][step] = dragValue;
  if (dragValue) {
    velocities[inst][step] = 0.8;
    synthDrum(INSTRUMENTS[inst].id, audioCtx.currentTime, 0.8 * volumes[inst], audioCtx, masterGain);
  }
  updateCellDisplay(inst, step);
}

function cellMouseEnter(e, inst, step) {
  if (!isDragging) return;
  grid[inst][step] = dragValue;
  if (dragValue) velocities[inst][step] = 0.8;
  updateCellDisplay(inst, step);
}

document.addEventListener('mouseup', () => { isDragging = false; });

function cellRightClick(inst, step) {
  if (!grid[inst][step]) return;
  // Cycle velocity: 0.4 -> 0.6 -> 0.8 -> 1.0
  let v = velocities[inst][step];
  if (v >= 1.0) v = 0.4;
  else if (v >= 0.8) v = 1.0;
  else if (v >= 0.6) v = 0.8;
  else v = 0.6;
  velocities[inst][step] = v;
  updateCellDisplay(inst, step);
  if (audioCtx) synthDrum(INSTRUMENTS[inst].id, audioCtx.currentTime, v * volumes[inst], audioCtx, masterGain);
}

function updateCellDisplay(inst, step) {
  const cell = document.querySelector(`.cell[data-inst="${inst}"][data-step="${step}"]`);
  if (!cell) return;
  const color = INSTRUMENTS[inst].color;
  const active = grid[inst][step];
  cell.classList.toggle('active', !!active);

  if (active) {
    const v = velocities[inst][step];
    const alpha = 0.2 + v * 0.6;
    cell.style.background = `${color}${Math.round(alpha * 255).toString(16).padStart(2, '0')}`;
    cell.style.boxShadow = `inset 0 0 12px ${color}${Math.round(v * 80).toString(16).padStart(2, '0')}, 0 0 ${v * 8}px ${color}44`;
    cell.innerHTML = `<div class="velocity-bar" style="background:${color};opacity:${v}"></div>`;
  } else {
    cell.style.background = '';
    cell.style.boxShadow = '';
    cell.innerHTML = '';
  }
}

function updateGridDisplay() {
  for (let i = 0; i < NUM_INST; i++) {
    for (let s = 0; s < STEPS; s++) {
      updateCellDisplay(i, s);
    }
    // Update mute/solo buttons
    const muteBtn = document.querySelector(`[data-mute="${i}"]`);
    const soloBtn = document.querySelector(`[data-solo="${i}"]`);
    if (muteBtn) muteBtn.classList.toggle('muted', muted[i]);
    if (soloBtn) soloBtn.classList.toggle('solo-active', soloed[i]);
  }
}

// ============== CONTROLS ==============
function setTempo(val) {
  tempo = parseInt(val);
  document.getElementById('tempoValue').textContent = tempo;
}

function setSwing(val) {
  swing = parseInt(val);
  document.getElementById('swingValue').textContent = swing;
}

function setMasterVol(val) {
  masterVol = parseInt(val) / 100;
  document.getElementById('volValue').textContent = parseInt(val);
  if (masterGain) masterGain.gain.value = masterVol;
}

function setRowVol(inst, val) {
  volumes[inst] = parseInt(val) / 100;
}

function toggleMute(inst) {
  muted[inst] = !muted[inst];
  document.querySelector(`[data-mute="${inst}"]`).classList.toggle('muted', muted[inst]);
}

function toggleSolo(inst) {
  soloed[inst] = !soloed[inst];
  document.querySelector(`[data-solo="${inst}"]`).classList.toggle('solo-active', soloed[inst]);
}

function changeKit(kit) {
  currentKit = kit;
  notify(`Kit: ${kit.toUpperCase()}`);
}

// ============== PATTERNS ==============
function buildPatternSlots() {
  const el = document.getElementById('patternSlots');
  let html = '';
  for (let i = 0; i < 8; i++) {
    html += `<div class="pattern-slot ${i === currentPattern ? 'current' : ''} ${patterns[i] ? 'has-data' : ''}"
      onclick="selectPattern(${i})"
      ondblclick="saveToSlot(${i})">
      ${i + 1}
      ${patterns[i] ? '<div class="dot"></div>' : ''}
    </div>`;
  }
  el.innerHTML = html;
}

function selectPattern(idx) {
  if (patterns[idx]) {
    loadFromSlot(idx);
  }
  currentPattern = idx;
  buildPatternSlots();
}

function saveToSlot(idx) {
  patterns[idx] = {
    grid: grid.map(r => [...r]),
    velocities: velocities.map(r => [...r]),
    tempo, swing, kit: currentKit
  };
  currentPattern = idx;
  buildPatternSlots();
  saveToLocalStorage();
  notify(`Pattern ${idx + 1} saved`);
}

function loadFromSlot(idx) {
  const p = patterns[idx];
  if (!p) return;
  grid = p.grid.map(r => [...r]);
  velocities = p.velocities.map(r => [...r]);
  tempo = p.tempo;
  swing = p.swing;
  currentKit = p.kit || 'electronic';

  document.getElementById('tempoSlider').value = tempo;
  document.getElementById('tempoValue').textContent = tempo;
  document.getElementById('swingSlider').value = swing;
  document.getElementById('swingValue').textContent = swing;
  document.getElementById('kitSelect').value = currentKit;

  updateGridDisplay();
  notify(`Pattern ${idx + 1} loaded`);
}

function clearPattern() {
  grid = Array.from({length: NUM_INST}, () => Array(STEPS).fill(0));
  velocities = Array.from({length: NUM_INST}, () => Array(STEPS).fill(0.8));
  updateGridDisplay();
  notify('Pattern cleared');
}

function randomizePattern() {
  const densities = [0.5, 0.25, 0.35, 0.15, 0.2, 0.15, 0.12, 0.18];
  for (let i = 0; i < NUM_INST; i++) {
    for (let s = 0; s < STEPS; s++) {
      // Higher chance on downbeats
      let prob = densities[i] || 0.2;
      if (s % 4 === 0) prob *= 1.5;
      if (s % 8 === 0) prob *= 1.3;
      grid[i][s] = Math.random() < prob ? 1 : 0;
      velocities[i][s] = 0.5 + Math.random() * 0.5;
    }
  }
  // Always put kick on 0 and 8
  grid[0][0] = 1; grid[0][8] = 1;
  // Snare on 4 and 12
  grid[1][4] = 1; grid[1][12] = 1;

  updateGridDisplay();
  notify('Random pattern generated');
}

function copyPattern() {
  clipboard = {
    grid: grid.map(r => [...r]),
    velocities: velocities.map(r => [...r])
  };
  notify('Pattern copied');
}

function pastePattern() {
  if (!clipboard) { notify('Nothing to paste'); return; }
  grid = clipboard.grid.map(r => [...r]);
  velocities = clipboard.velocities.map(r => [...r]);
  updateGridDisplay();
  notify('Pattern pasted');
}

// ============== SAVE/LOAD FILE ==============
function savePatternToFile() {
  const data = {
    grid, velocities, tempo, swing, kit: currentKit,
    patterns: patterns,
    version: 1
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `step-seq-pattern-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  notify('Pattern saved to file');
}

function loadPatternFromFile() {
  document.getElementById('fileInput').click();
}

function handleFileLoad(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      const data = JSON.parse(ev.target.result);
      if (data.grid) grid = data.grid;
      if (data.velocities) velocities = data.velocities;
      if (data.tempo) { tempo = data.tempo; document.getElementById('tempoSlider').value = tempo; document.getElementById('tempoValue').textContent = tempo; }
      if (data.swing !== undefined) { swing = data.swing; document.getElementById('swingSlider').value = swing; document.getElementById('swingValue').textContent = swing; }
      if (data.kit) { currentKit = data.kit; document.getElementById('kitSelect').value = currentKit; }
      if (data.patterns) patterns = data.patterns;
      updateGridDisplay();
      buildPatternSlots();
      notify('Pattern loaded from file');
    } catch(err) {
      notify('Error loading file');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
}

// ============== LOCAL STORAGE ==============
function saveToLocalStorage() {
  try {
    localStorage.setItem('stepSeq', JSON.stringify({
      grid, velocities, tempo, swing, kit: currentKit, patterns, currentPattern, muted, soloed, volumes, masterVol
    }));
  } catch(e) {}
}

function loadFromLocalStorage() {
  try {
    const data = JSON.parse(localStorage.getItem('stepSeq'));
    if (!data) return;
    if (data.grid) grid = data.grid;
    if (data.velocities) velocities = data.velocities;
    if (data.tempo) tempo = data.tempo;
    if (data.swing !== undefined) swing = data.swing;
    if (data.kit) currentKit = data.kit;
    if (data.patterns) patterns = data.patterns;
    if (data.currentPattern !== undefined) currentPattern = data.currentPattern;
    if (data.muted) muted = data.muted;
    if (data.soloed) soloed = data.soloed;
    if (data.volumes) volumes = data.volumes;
    if (data.masterVol !== undefined) masterVol = data.masterVol;

    document.getElementById('tempoSlider').value = tempo;
    document.getElementById('tempoValue').textContent = tempo;
    document.getElementById('swingSlider').value = swing;
    document.getElementById('swingValue').textContent = swing;
    document.getElementById('volSlider').value = Math.round(masterVol * 100);
    document.getElementById('volValue').textContent = Math.round(masterVol * 100);
    document.getElementById('kitSelect').value = currentKit;
  } catch(e) {}
}

// Auto-save periodically
setInterval(saveToLocalStorage, 5000);

// ============== EXPORT WAV ==============
async function exportWAV() {
  initAudio();
  const overlay = document.createElement('div');
  overlay.className = 'export-overlay';
  overlay.innerHTML = '<div class="msg">Rendering WAV...</div>';
  document.body.appendChild(overlay);

  try {
    // Calculate duration: 2 bars (32 steps)
    const numBars = 2;
    const totalSteps = STEPS * numBars;
    const stepDur = 60 / tempo / 4;
    const totalDuration = totalSteps * stepDur + 1; // +1 for tail

    const offlineCtx = new OfflineAudioContext(2, Math.ceil(44100 * totalDuration), 44100);
    const offGain = offlineCtx.createGain();
    offGain.gain.value = masterVol;
    offGain.connect(offlineCtx.destination);

    const hasSolo = soloed.some(s => s);

    for (let bar = 0; bar < numBars; bar++) {
      for (let step = 0; step < STEPS; step++) {
        const globalStep = bar * STEPS + step;
        let time = globalStep * stepDur;
        // Add swing
        if (step % 2 === 1) {
          time += stepDur * (swing / 100) * 0.7;
        }

        for (let i = 0; i < NUM_INST; i++) {
          if (!grid[i][step]) continue;
          if (muted[i]) continue;
          if (hasSolo && !soloed[i]) continue;
          const vel = velocities[i][step] * volumes[i];
          synthDrum(INSTRUMENTS[i].id, time, vel, offlineCtx, offGain);
        }
      }
    }

    const rendered = await offlineCtx.startRendering();
    const wavBlob = audioBufferToWav(rendered);
    const url = URL.createObjectURL(wavBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `step-seq-export-${Date.now()}.wav`;
    a.click();
    URL.revokeObjectURL(url);

    document.body.removeChild(overlay);
    notify('WAV exported successfully');
  } catch(err) {
    document.body.removeChild(overlay);
    notify('Export failed: ' + err.message);
    console.error(err);
  }
}

function audioBufferToWav(buffer) {
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const format = 1; // PCM
  const bitsPerSample = 16;
  const bytesPerSample = bitsPerSample / 8;
  const blockAlign = numChannels * bytesPerSample;
  const numFrames = buffer.length;
  const dataSize = numFrames * blockAlign;

  const bufferLength = 44 + dataSize;
  const wav = new ArrayBuffer(bufferLength);
  const view = new DataView(wav);

  function writeStr(offset, str) {
    for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
  }

  writeStr(0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeStr(8, 'WAVE');
  writeStr(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitsPerSample, true);
  writeStr(36, 'data');
  view.setUint32(40, dataSize, true);

  const channels = [];
  for (let ch = 0; ch < numChannels; ch++) {
    channels.push(buffer.getChannelData(ch));
  }

  let offset = 44;
  for (let i = 0; i < numFrames; i++) {
    for (let ch = 0; ch < numChannels; ch++) {
      let sample = channels[ch][i];
      sample = Math.max(-1, Math.min(1, sample));
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }

  return new Blob([wav], {type: 'audio/wav'});
}

// ============== VISUALIZER ==============
const canvas = document.getElementById('visualizer');
const canvasCtx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = canvas.parentElement.clientWidth - 16;
  canvas.height = canvas.parentElement.clientHeight - 16;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

function drawVisualizer() {
  requestAnimationFrame(drawVisualizer);

  const w = canvas.width;
  const h = canvas.height;
  canvasCtx.clearRect(0, 0, w, h);

  if (!analyser) {
    // Draw idle state
    canvasCtx.strokeStyle = 'rgba(0,240,255,0.15)';
    canvasCtx.lineWidth = 1;
    canvasCtx.beginPath();
    canvasCtx.moveTo(0, h / 2);
    const t = Date.now() / 1000;
    for (let x = 0; x < w; x++) {
      const y = h / 2 + Math.sin(x / 30 + t * 2) * 5 * Math.sin(x / w * Math.PI);
      canvasCtx.lineTo(x, y);
    }
    canvasCtx.stroke();
    return;
  }

  // Frequency bars
  const freqData = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(freqData);

  const barCount = 64;
  const barWidth = w / barCount;
  const step = Math.floor(freqData.length / barCount);

  for (let i = 0; i < barCount; i++) {
    const val = freqData[i * step] / 255;
    const barH = val * h * 0.85;

    const hue = 180 + (i / barCount) * 120; // cyan to magenta
    const sat = 80 + val * 20;
    const light = 40 + val * 30;

    // Bar glow
    canvasCtx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${0.3 + val * 0.4})`;
    canvasCtx.shadowColor = `hsl(${hue}, ${sat}%, ${light}%)`;
    canvasCtx.shadowBlur = val * 15;
    canvasCtx.fillRect(i * barWidth + 1, h - barH, barWidth - 2, barH);
    canvasCtx.shadowBlur = 0;

    // Reflection
    canvasCtx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${val * 0.1})`;
    canvasCtx.fillRect(i * barWidth + 1, h - barH - 2, barWidth - 2, 2);
  }

  // Waveform overlay
  const timeData = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteTimeDomainData(timeData);

  canvasCtx.strokeStyle = 'rgba(0,240,255,0.4)';
  canvasCtx.lineWidth = 1.5;
  canvasCtx.beginPath();
  const sliceWidth = w / timeData.length;
  let x = 0;
  for (let i = 0; i < timeData.length; i++) {
    const v = timeData[i] / 128.0;
    const y = v * h / 2;
    if (i === 0) canvasCtx.moveTo(x, y);
    else canvasCtx.lineTo(x, y);
    x += sliceWidth;
  }
  canvasCtx.stroke();
}

drawVisualizer();

// ============== NOTIFICATIONS ==============
function notify(msg) {
  const el = document.createElement('div');
  el.className = 'notification';
  el.textContent = msg;
  document.body.appendChild(el);
  setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 2200);
}

// ============== KEYBOARD SHORTCUTS ==============
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  switch(e.code) {
    case 'Space':
      e.preventDefault();
      togglePlay();
      break;
    case 'Escape':
      stopSequencer();
      break;
    case 'KeyC':
      if (e.ctrlKey || e.metaKey) copyPattern();
      break;
    case 'KeyV':
      if (e.ctrlKey || e.metaKey) pastePattern();
      break;
    case 'Delete':
    case 'Backspace':
      if (!e.ctrlKey && !e.metaKey) clearPattern();
      break;
    case 'KeyR':
      if (!e.ctrlKey && !e.metaKey) randomizePattern();
      break;
    default:
      // 1-8 for pattern slots
      const num = parseInt(e.key);
      if (num >= 1 && num <= 8) {
        if (e.shiftKey) saveToSlot(num - 1);
        else selectPattern(num - 1);
      }
  }
});

// ============== INIT ==============
function init() {
  loadFromLocalStorage();
  buildGrid();
  buildPatternSlots();

  // Save initial pattern to slot 1 if empty
  if (!patterns[0]) {
    // Set a default pattern
    grid[0][0] = 1; grid[0][4] = 1; grid[0][8] = 1; grid[0][12] = 1; // kick
    grid[1][4] = 1; grid[1][12] = 1; // snare
    grid[2][0] = 1; grid[2][2] = 1; grid[2][4] = 1; grid[2][6] = 1; // hihat
    grid[2][8] = 1; grid[2][10] = 1; grid[2][12] = 1; grid[2][14] = 1;
    grid[3][6] = 1; grid[3][14] = 1; // open hat

    // Set some velocities for groove
    velocities[2][0] = 1.0;
    velocities[2][4] = 1.0;
    velocities[2][8] = 1.0;
    velocities[2][12] = 1.0;
    velocities[2][2] = 0.5;
    velocities[2][6] = 0.5;
    velocities[2][10] = 0.5;
    velocities[2][14] = 0.5;

    updateGridDisplay();
    saveToSlot(0);
  }
}

init();
</script>
</body>
</html>
