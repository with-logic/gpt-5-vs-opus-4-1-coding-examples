<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Custom QR Code Generator</title>
<script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
<style>
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}

  :root {
    --bg: #0a0a0f;
    --surface: #13131a;
    --surface-2: #1c1c28;
    --border: #2a2a3a;
    --border-hover: #3a3a50;
    --text: #e8e8f0;
    --text-secondary: #8888a0;
    --accent: #7c5cfc;
    --accent-glow: rgba(124, 92, 252, 0.25);
    --radius: 14px;
    --radius-sm: 10px;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
  }

  /* Subtle animated gradient background */
  body::before {
    content: '';
    position: fixed;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(ellipse at 30% 20%, rgba(124, 92, 252, 0.06) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(92, 160, 252, 0.04) 0%, transparent 50%);
    animation: bgShift 20s ease-in-out infinite alternate;
    z-index: -1;
    pointer-events: none;
  }

  @keyframes bgShift {
    0% { transform: translate(0, 0) rotate(0deg); }
    100% { transform: translate(-5%, 3%) rotate(3deg); }
  }

  header {
    width: 100%;
    padding: 28px 32px 0;
    text-align: center;
  }

  header h1 {
    font-size: 1.5rem;
    font-weight: 700;
    letter-spacing: -0.03em;
    background: linear-gradient(135deg, #e8e8f0 30%, #7c5cfc 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  header p {
    color: var(--text-secondary);
    font-size: 0.875rem;
    margin-top: 6px;
    font-weight: 400;
  }

  .app {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 520px;
    padding: 28px 20px 40px;
    gap: 24px;
  }

  /* QR Preview Card */
  .preview-card {
    width: 100%;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 32px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    position: relative;
    overflow: hidden;
    transition: border-color 0.3s ease;
  }

  .preview-card:hover {
    border-color: var(--border-hover);
  }

  .preview-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(124, 92, 252, 0.3), transparent);
  }

  .qr-container {
    width: 280px;
    height: 280px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-sm);
    position: relative;
    transition: transform 0.3s ease;
  }

  .qr-container canvas {
    border-radius: 8px;
    image-rendering: pixelated;
  }

  .qr-placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    color: var(--text-secondary);
    width: 280px;
    height: 280px;
    border: 2px dashed var(--border);
    border-radius: var(--radius-sm);
  }

  .qr-placeholder svg {
    opacity: 0.3;
  }

  .qr-placeholder span {
    font-size: 0.8125rem;
  }

  /* Input area */
  .input-group {
    width: 100%;
  }

  .input-wrapper {
    position: relative;
    width: 100%;
  }

  .input-wrapper textarea {
    width: 100%;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 14px 16px;
    color: var(--text);
    font-size: 0.9375rem;
    font-family: inherit;
    resize: none;
    outline: none;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
    line-height: 1.5;
    min-height: 52px;
    max-height: 120px;
  }

  .input-wrapper textarea::placeholder {
    color: var(--text-secondary);
    opacity: 0.6;
  }

  .input-wrapper textarea:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-glow);
  }

  .char-count {
    position: absolute;
    right: 12px;
    bottom: 10px;
    font-size: 0.6875rem;
    color: var(--text-secondary);
    opacity: 0.5;
    pointer-events: none;
  }

  /* Controls panel */
  .controls {
    width: 100%;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    overflow: hidden;
  }

  .controls-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 14px 18px;
    cursor: pointer;
    user-select: none;
    transition: background 0.15s ease;
  }

  .controls-header:hover {
    background: var(--surface-2);
  }

  .controls-header svg {
    transition: transform 0.25s ease;
    color: var(--text-secondary);
    flex-shrink: 0;
  }

  .controls-header.open svg {
    transform: rotate(90deg);
  }

  .controls-header span {
    font-size: 0.8125rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    color: var(--text-secondary);
    text-transform: uppercase;
  }

  .controls-body {
    display: none;
    padding: 4px 18px 20px;
    gap: 18px;
    flex-direction: column;
  }

  .controls-body.open {
    display: flex;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
  }

  .control-row label {
    font-size: 0.8125rem;
    color: var(--text-secondary);
    white-space: nowrap;
    font-weight: 500;
  }

  .color-input-wrapper {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .color-swatch {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    border: 2px solid var(--border);
    cursor: pointer;
    padding: 0;
    overflow: hidden;
    position: relative;
    transition: border-color 0.2s;
  }

  .color-swatch:hover {
    border-color: var(--border-hover);
  }

  .color-swatch input[type="color"] {
    position: absolute;
    top: -8px;
    left: -8px;
    width: calc(100% + 16px);
    height: calc(100% + 16px);
    border: none;
    cursor: pointer;
    background: none;
  }

  .color-hex {
    width: 80px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 7px 10px;
    color: var(--text);
    font-size: 0.8125rem;
    font-family: 'SF Mono', 'Fira Code', monospace;
    outline: none;
    text-transform: uppercase;
    transition: border-color 0.2s;
  }

  .color-hex:focus {
    border-color: var(--accent);
  }

  /* Size slider */
  .size-slider {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .size-slider input[type="range"] {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
  }

  .size-slider input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--bg);
    box-shadow: 0 0 0 1px var(--accent);
    transition: transform 0.15s ease;
  }

  .size-slider input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.15);
  }

  .size-slider input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--bg);
    box-shadow: 0 0 0 1px var(--accent);
  }

  .size-value {
    font-size: 0.75rem;
    color: var(--text-secondary);
    font-family: 'SF Mono', 'Fira Code', monospace;
    min-width: 36px;
    text-align: right;
  }

  /* Error correction */
  .ec-group {
    display: flex;
    gap: 6px;
  }

  .ec-btn {
    padding: 6px 12px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-secondary);
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .ec-btn:hover {
    border-color: var(--border-hover);
    color: var(--text);
  }

  .ec-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }

  /* Download button */
  .download-btn {
    width: 100%;
    padding: 14px;
    background: var(--accent);
    border: none;
    border-radius: var(--radius-sm);
    color: #fff;
    font-size: 0.9375rem;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    transition: all 0.2s ease;
    letter-spacing: 0.01em;
    position: relative;
    overflow: hidden;
  }

  .download-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(255,255,255,0.1), transparent);
    opacity: 0;
    transition: opacity 0.2s;
  }

  .download-btn:hover::before {
    opacity: 1;
  }

  .download-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 24px var(--accent-glow);
  }

  .download-btn:active {
    transform: translateY(0);
  }

  .download-btn:disabled {
    opacity: 0.35;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  .download-btn:disabled::before {
    display: none;
  }

  /* Toast notification */
  .toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(80px);
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px 20px;
    font-size: 0.8125rem;
    color: var(--text);
    opacity: 0;
    transition: all 0.35s cubic-bezier(0.16, 1, 0.3, 1);
    pointer-events: none;
    z-index: 100;
    backdrop-filter: blur(12px);
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  }

  .toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  /* Responsive */
  @media (max-width: 480px) {
    .app { padding: 20px 16px 32px; }
    .preview-card { padding: 24px 20px; }
    .qr-container, .qr-placeholder { width: 240px; height: 240px; }
    header h1 { font-size: 1.25rem; }
  }

  /* Animations */
  @keyframes fadeInUp {
    from { opacity: 0; transform: translateY(12px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .app > * {
    animation: fadeInUp 0.5s ease backwards;
  }

  .app > *:nth-child(1) { animation-delay: 0.05s; }
  .app > *:nth-child(2) { animation-delay: 0.1s; }
  .app > *:nth-child(3) { animation-delay: 0.15s; }
  .app > *:nth-child(4) { animation-delay: 0.2s; }

  /* QR generation animation */
  @keyframes qrPop {
    0% { transform: scale(0.9); opacity: 0.5; }
    50% { transform: scale(1.02); }
    100% { transform: scale(1); opacity: 1; }
  }

  .qr-animate {
    animation: qrPop 0.3s cubic-bezier(0.16, 1, 0.3, 1);
  }

  /* Style select */
  .style-group {
    display: flex;
    gap: 6px;
  }

  .style-btn {
    padding: 6px 12px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-secondary);
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .style-btn:hover {
    border-color: var(--border-hover);
    color: var(--text);
  }

  .style-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }

  /* Margin toggle */
  .toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .toggle {
    width: 40px;
    height: 22px;
    background: var(--border);
    border-radius: 11px;
    position: relative;
    cursor: pointer;
    transition: background 0.2s;
    border: none;
    padding: 0;
  }

  .toggle.active {
    background: var(--accent);
  }

  .toggle::after {
    content: '';
    position: absolute;
    top: 3px;
    left: 3px;
    width: 16px;
    height: 16px;
    background: #fff;
    border-radius: 50%;
    transition: transform 0.2s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .toggle.active::after {
    transform: translateX(18px);
  }
</style>
</head>
<body>

<header>
  <h1>Custom QR Code Generator</h1>
  <p>Generate, customize, and download QR codes instantly</p>
</header>

<main class="app">
  <!-- Preview -->
  <div class="preview-card">
    <div id="qrPreview">
      <div class="qr-placeholder">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <rect x="2" y="2" width="8" height="8" rx="1"/>
          <rect x="14" y="2" width="8" height="8" rx="1"/>
          <rect x="2" y="14" width="8" height="8" rx="1"/>
          <rect x="14" y="14" width="4" height="4" rx="0.5"/>
          <line x1="22" y1="14" x2="22" y2="14.01"/>
          <line x1="22" y1="18" x2="22" y2="22"/>
          <line x1="18" y1="22" x2="18" y2="22.01"/>
        </svg>
        <span>Enter text or URL to generate</span>
      </div>
    </div>
  </div>

  <!-- Input -->
  <div class="input-group">
    <div class="input-wrapper">
      <textarea id="textInput" rows="1" placeholder="Enter text or URL..." spellcheck="false"></textarea>
      <span class="char-count" id="charCount">0</span>
    </div>
  </div>

  <!-- Customization -->
  <div class="controls">
    <div class="controls-header open" id="controlsToggle">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="9 18 15 12 9 6"/>
      </svg>
      <span>Customize</span>
    </div>
    <div class="controls-body open" id="controlsBody">
      <!-- Foreground color -->
      <div class="control-row">
        <label>Foreground</label>
        <div class="color-input-wrapper">
          <div class="color-swatch">
            <input type="color" id="fgColor" value="#7c5cfc">
          </div>
          <input type="text" class="color-hex" id="fgHex" value="#7C5CFC" maxlength="7">
        </div>
      </div>

      <!-- Background color -->
      <div class="control-row">
        <label>Background</label>
        <div class="color-input-wrapper">
          <div class="color-swatch">
            <input type="color" id="bgColor" value="#0a0a0f">
          </div>
          <input type="text" class="color-hex" id="bgHex" value="#0A0A0F" maxlength="7">
        </div>
      </div>

      <!-- Style -->
      <div class="control-row">
        <label>Style</label>
        <div class="style-group">
          <button class="style-btn active" data-style="square">Square</button>
          <button class="style-btn" data-style="rounded">Rounded</button>
          <button class="style-btn" data-style="dots">Dots</button>
        </div>
      </div>

      <!-- Error correction -->
      <div class="control-row">
        <label>Error Correction</label>
        <div class="ec-group">
          <button class="ec-btn" data-ec="L">L</button>
          <button class="ec-btn active" data-ec="M">M</button>
          <button class="ec-btn" data-ec="Q">Q</button>
          <button class="ec-btn" data-ec="H">H</button>
        </div>
      </div>

      <!-- Quiet zone / margin -->
      <div class="control-row">
        <label>Quiet Zone</label>
        <div class="toggle-wrapper">
          <button class="toggle active" id="marginToggle"></button>
        </div>
      </div>

      <!-- Size -->
      <div class="control-row">
        <label>Download Size</label>
        <div class="size-slider">
          <input type="range" id="sizeSlider" min="256" max="2048" value="1024" step="64">
          <span class="size-value" id="sizeValue">1024px</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Download -->
  <button class="download-btn" id="downloadBtn" disabled>
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
      <polyline points="7 10 12 15 17 10"/>
      <line x1="12" y1="15" x2="12" y2="3"/>
    </svg>
    Download PNG
  </button>
</main>

<div class="toast" id="toast"></div>

<script>
(function() {
  // Elements
  const textInput = document.getElementById('textInput');
  const charCount = document.getElementById('charCount');
  const qrPreview = document.getElementById('qrPreview');
  const fgColor = document.getElementById('fgColor');
  const fgHex = document.getElementById('fgHex');
  const bgColor = document.getElementById('bgColor');
  const bgHex = document.getElementById('bgHex');
  const sizeSlider = document.getElementById('sizeSlider');
  const sizeValue = document.getElementById('sizeValue');
  const downloadBtn = document.getElementById('downloadBtn');
  const controlsToggle = document.getElementById('controlsToggle');
  const controlsBody = document.getElementById('controlsBody');
  const marginToggle = document.getElementById('marginToggle');
  const toast = document.getElementById('toast');

  // State
  let state = {
    text: '',
    fgColor: '#7c5cfc',
    bgColor: '#0a0a0f',
    ecLevel: 'M',
    downloadSize: 1024,
    style: 'square',
    margin: true
  };

  let debounceTimer = null;
  let currentCanvas = null;

  // Error correction map
  const ecMap = { L: 1, M: 0, Q: 3, H: 2 };

  // Controls toggle
  controlsToggle.addEventListener('click', () => {
    controlsToggle.classList.toggle('open');
    controlsBody.classList.toggle('open');
  });

  // Margin toggle
  marginToggle.addEventListener('click', () => {
    marginToggle.classList.toggle('active');
    state.margin = marginToggle.classList.contains('active');
    generateQR();
  });

  // Text input with auto-resize
  textInput.addEventListener('input', () => {
    state.text = textInput.value;
    charCount.textContent = textInput.value.length;

    // Auto-resize
    textInput.style.height = 'auto';
    textInput.style.height = Math.min(textInput.scrollHeight, 120) + 'px';

    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(generateQR, 150);
  });

  // Color syncing
  function syncColors(picker, hex, stateKey) {
    picker.addEventListener('input', () => {
      hex.value = picker.value.toUpperCase();
      state[stateKey] = picker.value;
      generateQR();
    });

    hex.addEventListener('input', () => {
      let val = hex.value;
      if (!val.startsWith('#')) val = '#' + val;
      if (/^#[0-9A-Fa-f]{6}$/.test(val)) {
        picker.value = val;
        state[stateKey] = val;
        generateQR();
      }
    });

    hex.addEventListener('blur', () => {
      hex.value = picker.value.toUpperCase();
    });
  }

  syncColors(fgColor, fgHex, 'fgColor');
  syncColors(bgColor, bgHex, 'bgColor');

  // Error correction buttons
  document.querySelectorAll('.ec-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.ec-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      state.ecLevel = btn.dataset.ec;
      generateQR();
    });
  });

  // Style buttons
  document.querySelectorAll('.style-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.style-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      state.style = btn.dataset.style;
      generateQR();
    });
  });

  // Size slider
  sizeSlider.addEventListener('input', () => {
    state.downloadSize = parseInt(sizeSlider.value);
    sizeValue.textContent = sizeSlider.value + 'px';
  });

  // QR Generation
  function generateQR() {
    if (!state.text.trim()) {
      qrPreview.innerHTML = `
        <div class="qr-placeholder">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <rect x="2" y="2" width="8" height="8" rx="1"/>
            <rect x="14" y="2" width="8" height="8" rx="1"/>
            <rect x="2" y="14" width="8" height="8" rx="1"/>
            <rect x="14" y="14" width="4" height="4" rx="0.5"/>
            <line x1="22" y1="14" x2="22" y2="14.01"/>
            <line x1="22" y1="18" x2="22" y2="22"/>
            <line x1="18" y1="22" x2="18" y2="22.01"/>
          </svg>
          <span>Enter text or URL to generate</span>
        </div>`;
      downloadBtn.disabled = true;
      currentCanvas = null;
      return;
    }

    try {
      const typeNumber = 0; // auto
      const errorCorrection = ecMap[state.ecLevel];
      const qr = qrcode(typeNumber, errorCorrection);
      qr.addData(state.text);
      qr.make();

      const moduleCount = qr.getModuleCount();
      const margin = state.margin ? 4 : 0;
      const totalModules = moduleCount + margin * 2;

      // Preview size
      const previewSize = 280;
      const cellSize = previewSize / totalModules;

      const canvas = document.createElement('canvas');
      canvas.width = previewSize;
      canvas.height = previewSize;
      canvas.style.width = '280px';
      canvas.style.height = '280px';

      const ctx = canvas.getContext('2d');

      // Background
      ctx.fillStyle = state.bgColor;
      ctx.fillRect(0, 0, previewSize, previewSize);

      // Draw modules
      ctx.fillStyle = state.fgColor;

      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          if (qr.isDark(row, col)) {
            const x = (col + margin) * cellSize;
            const y = (row + margin) * cellSize;

            if (state.style === 'rounded') {
              drawRoundedModule(ctx, x, y, cellSize, cellSize * 0.35, qr, row, col, moduleCount);
            } else if (state.style === 'dots') {
              const cx = x + cellSize / 2;
              const cy = y + cellSize / 2;
              const r = cellSize * 0.42;
              ctx.beginPath();
              ctx.arc(cx, cy, r, 0, Math.PI * 2);
              ctx.fill();
            } else {
              ctx.fillRect(x, y, cellSize + 0.5, cellSize + 0.5);
            }
          }
        }
      }

      // Animate
      qrPreview.innerHTML = '';
      const container = document.createElement('div');
      container.className = 'qr-container qr-animate';
      container.appendChild(canvas);
      qrPreview.appendChild(container);

      downloadBtn.disabled = false;
      currentCanvas = { qr, moduleCount, margin: margin };
    } catch (e) {
      showToast('Input too long for current error correction level');
    }
  }

  // Rounded module drawing with neighbor awareness
  function drawRoundedModule(ctx, x, y, size, radius, qr, row, col, moduleCount) {
    const isDarkAt = (r, c) => {
      if (r < 0 || c < 0 || r >= moduleCount || c >= moduleCount) return false;
      return qr.isDark(r, c);
    };

    const top = isDarkAt(row - 1, col);
    const bottom = isDarkAt(row + 1, col);
    const left = isDarkAt(row, col - 1);
    const right = isDarkAt(row, col + 1);

    const rTL = (!top && !left) ? radius : 0;
    const rTR = (!top && !right) ? radius : 0;
    const rBR = (!bottom && !right) ? radius : 0;
    const rBL = (!bottom && !left) ? radius : 0;

    const s = size + 0.5;

    ctx.beginPath();
    ctx.moveTo(x + rTL, y);
    ctx.lineTo(x + s - rTR, y);
    if (rTR) ctx.arcTo(x + s, y, x + s, y + rTR, rTR);
    else ctx.lineTo(x + s, y);
    ctx.lineTo(x + s, y + s - rBR);
    if (rBR) ctx.arcTo(x + s, y + s, x + s - rBR, y + s, rBR);
    else ctx.lineTo(x + s, y + s);
    ctx.lineTo(x + rBL, y + s);
    if (rBL) ctx.arcTo(x, y + s, x, y + s - rBL, rBL);
    else ctx.lineTo(x, y + s);
    ctx.lineTo(x, y + rTL);
    if (rTL) ctx.arcTo(x, y, x + rTL, y, rTL);
    else ctx.lineTo(x, y);
    ctx.closePath();
    ctx.fill();
  }

  // Download
  downloadBtn.addEventListener('click', () => {
    if (!currentCanvas) return;

    const { qr, moduleCount, margin } = currentCanvas;
    const size = state.downloadSize;
    const totalModules = moduleCount + margin * 2;
    const cellSize = size / totalModules;

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // Background
    ctx.fillStyle = state.bgColor;
    ctx.fillRect(0, 0, size, size);

    // Modules
    ctx.fillStyle = state.fgColor;

    for (let row = 0; row < moduleCount; row++) {
      for (let col = 0; col < moduleCount; col++) {
        if (qr.isDark(row, col)) {
          const x = (col + margin) * cellSize;
          const y = (row + margin) * cellSize;

          if (state.style === 'rounded') {
            drawRoundedModuleHD(ctx, x, y, cellSize, cellSize * 0.35, qr, row, col, moduleCount);
          } else if (state.style === 'dots') {
            const cx = x + cellSize / 2;
            const cy = y + cellSize / 2;
            const r = cellSize * 0.42;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(cellSize) + 1, Math.ceil(cellSize) + 1);
          }
        }
      }
    }

    // Download
    const link = document.createElement('a');
    link.download = 'qrcode.png';
    link.href = canvas.toDataURL('image/png');
    link.click();

    showToast('QR code downloaded!');
  });

  function drawRoundedModuleHD(ctx, x, y, size, radius, qr, row, col, moduleCount) {
    const isDarkAt = (r, c) => {
      if (r < 0 || c < 0 || r >= moduleCount || c >= moduleCount) return false;
      return qr.isDark(r, c);
    };

    const top = isDarkAt(row - 1, col);
    const bottom = isDarkAt(row + 1, col);
    const left = isDarkAt(row, col - 1);
    const right = isDarkAt(row, col + 1);

    const rTL = (!top && !left) ? radius : 0;
    const rTR = (!top && !right) ? radius : 0;
    const rBR = (!bottom && !right) ? radius : 0;
    const rBL = (!bottom && !left) ? radius : 0;

    const s = size;

    ctx.beginPath();
    ctx.moveTo(x + rTL, y);
    ctx.lineTo(x + s - rTR, y);
    if (rTR) ctx.arcTo(x + s, y, x + s, y + rTR, rTR);
    else ctx.lineTo(x + s, y);
    ctx.lineTo(x + s, y + s - rBR);
    if (rBR) ctx.arcTo(x + s, y + s, x + s - rBR, y + s, rBR);
    else ctx.lineTo(x + s, y + s);
    ctx.lineTo(x + rBL, y + s);
    if (rBL) ctx.arcTo(x, y + s, x, y + s - rBL, rBL);
    else ctx.lineTo(x, y + s);
    ctx.lineTo(x, y + rTL);
    if (rTL) ctx.arcTo(x, y, x + rTL, y, rTL);
    else ctx.lineTo(x, y);
    ctx.closePath();
    ctx.fill();
  }

  // Toast
  function showToast(message) {
    toast.textContent = message;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2200);
  }

  // Focus input on load
  setTimeout(() => textInput.focus(), 300);
})();
</script>
</body>
</html>
