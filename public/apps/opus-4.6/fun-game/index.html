<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fun Game - Endless Runner</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    background: #1a0a2e;
    font-family: 'Fredoka One', 'Nunito', sans-serif;
    user-select: none;
    -webkit-user-select: none;
  }

  canvas {
    display: block;
    cursor: pointer;
  }

  #ui-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  #score-display {
    position: absolute;
    top: 20px; right: 30px;
    color: #fff;
    font-size: 28px;
    text-shadow: 3px 3px 0 #ff6b35, -1px -1px 0 #ff6b35;
    letter-spacing: 2px;
  }

  #high-score-display {
    position: absolute;
    top: 58px; right: 30px;
    color: #ffd700;
    font-size: 16px;
    text-shadow: 2px 2px 0 #b8860b;
    letter-spacing: 1px;
  }

  #speed-display {
    position: absolute;
    top: 20px; left: 30px;
    color: #7df9ff;
    font-size: 16px;
    text-shadow: 2px 2px 0 #0077b6;
  }

  #start-screen, #game-over-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    transition: opacity 0.4s;
  }

  #start-screen {
    background: radial-gradient(ellipse at center, rgba(40,10,80,0.85) 0%, rgba(10,5,30,0.95) 100%);
  }

  #game-over-screen {
    background: radial-gradient(ellipse at center, rgba(80,10,10,0.85) 0%, rgba(10,5,30,0.95) 100%);
    display: none;
  }

  .title {
    font-size: clamp(48px, 10vw, 100px);
    color: #ff6b35;
    text-shadow: 4px 4px 0 #ffd700, 8px 8px 0 rgba(0,0,0,0.3);
    margin-bottom: 10px;
    animation: titleBounce 2s ease-in-out infinite;
    text-align: center;
  }

  .subtitle {
    font-size: clamp(16px, 3vw, 24px);
    color: #7df9ff;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    margin-bottom: 40px;
    text-align: center;
    padding: 0 20px;
  }

  .game-over-title {
    font-size: clamp(40px, 8vw, 80px);
    color: #ff4444;
    text-shadow: 4px 4px 0 #880000, 8px 8px 0 rgba(0,0,0,0.3);
    margin-bottom: 10px;
    animation: shake 0.5s ease-in-out;
  }

  .final-score {
    font-size: clamp(24px, 5vw, 40px);
    color: #ffd700;
    text-shadow: 2px 2px 0 #b8860b;
    margin-bottom: 8px;
  }

  .new-high-score {
    font-size: clamp(18px, 3vw, 28px);
    color: #ff6b35;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    animation: pulse 0.8s ease-in-out infinite;
    margin-bottom: 20px;
    display: none;
  }

  .btn {
    font-family: 'Fredoka One', sans-serif;
    font-size: clamp(20px, 4vw, 32px);
    padding: 15px 50px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
    pointer-events: auto;
    margin: 8px;
  }

  .btn:hover { transform: scale(1.08); }
  .btn:active { transform: scale(0.95); }

  .btn-play {
    background: linear-gradient(180deg, #ff6b35 0%, #e04e1a 100%);
    color: #fff;
    box-shadow: 0 6px 0 #a83610, 0 8px 20px rgba(0,0,0,0.4);
    text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
  }

  .btn-retry {
    background: linear-gradient(180deg, #4ecdc4 0%, #2ea89f 100%);
    color: #fff;
    box-shadow: 0 6px 0 #1d7a73, 0 8px 20px rgba(0,0,0,0.4);
    text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
  }

  .instructions {
    color: rgba(255,255,255,0.6);
    font-size: clamp(12px, 2vw, 16px);
    margin-top: 20px;
    text-align: center;
    font-family: 'Nunito', sans-serif;
  }

  .combo-display {
    position: absolute;
    top: 95px; right: 30px;
    color: #ff6b35;
    font-size: 20px;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    opacity: 0;
    transition: opacity 0.3s;
  }

  @keyframes titleBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-12px); }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.1); }
  }

  .particle-text {
    position: absolute;
    color: #ffd700;
    font-size: 24px;
    font-family: 'Fredoka One', sans-serif;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    pointer-events: none;
    z-index: 20;
    animation: floatUp 1s ease-out forwards;
  }

  @keyframes floatUp {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-60px) scale(1.5); }
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="ui-overlay">
  <div id="score-display">SCORE: 0</div>
  <div id="high-score-display">BEST: 0</div>
  <div id="speed-display">SPEED: 1x</div>
  <div class="combo-display" id="combo-display">COMBO x1</div>

  <div id="start-screen">
    <div class="title">FUN GAME</div>
    <div class="subtitle">Jump over obstacles &amp; survive as long as you can!</div>
    <button class="btn btn-play" id="startBtn">PLAY!</button>
    <div class="instructions">
      Press SPACE, UP, W, or TAP to jump<br>
      Double-jump in mid-air for extra height!
    </div>
  </div>

  <div id="game-over-screen">
    <div class="game-over-title">WIPEOUT!</div>
    <div class="final-score" id="final-score">Score: 0</div>
    <div class="new-high-score" id="new-high-score">NEW HIGH SCORE!</div>
    <button class="btn btn-retry" id="retryBtn">TRY AGAIN</button>
    <div class="instructions">Don't give up - you've got this!</div>
  </div>
</div>

<script>
// ─── AUDIO ENGINE (Web Audio API synthesized sounds) ───
class SoundEngine {
  constructor() {
    this.ctx = null;
    this.initialized = false;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.initialized = true;
    } catch(e) { console.warn('No audio'); }
  }

  play(type) {
    if (!this.ctx) return;
    try {
      switch(type) {
        case 'jump': this._jump(); break;
        case 'doubleJump': this._doubleJump(); break;
        case 'land': this._land(); break;
        case 'hit': this._hit(); break;
        case 'score': this._scoreMilestone(); break;
        case 'speedUp': this._speedUp(); break;
        case 'nearMiss': this._nearMiss(); break;
        case 'start': this._gameStart(); break;
        case 'combo': this._combo(); break;
      }
    } catch(e) {}
  }

  _createOsc(freq, type, duration, gainVal=0.3) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(gainVal, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + duration);
    return { osc, gain };
  }

  _jump() {
    // Cartoon "boing" sound
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(200, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.12);
    osc.frequency.exponentialRampToValueAtTime(500, this.ctx.currentTime + 0.2);
    gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.25);
    // Add a "pop" noise layer
    this._createOsc(1200, 'triangle', 0.06, 0.1);
  }

  _doubleJump() {
    // Higher pitched whimsical boing
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(400, t);
    osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
    osc.frequency.exponentialRampToValueAtTime(900, t + 0.18);
    gain.gain.setValueAtTime(0.2, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(t);
    osc.stop(t + 0.25);
    // Sparkle
    setTimeout(() => {
      this._createOsc(1800, 'sine', 0.08, 0.08);
      setTimeout(() => this._createOsc(2200, 'sine', 0.06, 0.06), 30);
    }, 50);
  }

  _land() {
    // Soft thud
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(120, t);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
    gain.gain.setValueAtTime(0.15, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(t);
    osc.stop(t + 0.15);
  }

  _hit() {
    // Comical crash - descending buzz + noise
    const t = this.ctx.currentTime;
    // Descending buzz
    const osc1 = this.ctx.createOscillator();
    const gain1 = this.ctx.createGain();
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(400, t);
    osc1.frequency.exponentialRampToValueAtTime(60, t + 0.5);
    gain1.gain.setValueAtTime(0.2, t);
    gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
    osc1.connect(gain1);
    gain1.connect(this.ctx.destination);
    osc1.start(t);
    osc1.stop(t + 0.5);
    // Noise burst
    const bufferSize = this.ctx.sampleRate * 0.15;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.4;
    const noise = this.ctx.createBufferSource();
    const noiseGain = this.ctx.createGain();
    noise.buffer = buffer;
    noiseGain.gain.setValueAtTime(0.25, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    noise.connect(noiseGain);
    noiseGain.connect(this.ctx.destination);
    noise.start(t);
    // Sad trombone notes
    const notes = [350, 330, 310, 260];
    notes.forEach((f, i) => {
      setTimeout(() => this._createOsc(f, 'triangle', 0.25, 0.12), 200 + i * 200);
    });
  }

  _scoreMilestone() {
    // Cheerful ascending arpeggio
    const notes = [523, 659, 784, 1047];
    notes.forEach((f, i) => {
      setTimeout(() => {
        this._createOsc(f, 'sine', 0.2, 0.12);
        this._createOsc(f * 1.5, 'triangle', 0.15, 0.05);
      }, i * 80);
    });
  }

  _speedUp() {
    // Whoosh + ascending tone
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, t);
    osc.frequency.exponentialRampToValueAtTime(1000, t + 0.3);
    gain.gain.setValueAtTime(0.08, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(t);
    osc.stop(t + 0.4);
  }

  _nearMiss() {
    // Quick "whew!" swoosh
    this._createOsc(600, 'sine', 0.1, 0.08);
    setTimeout(() => this._createOsc(900, 'sine', 0.08, 0.06), 40);
  }

  _gameStart() {
    // Fanfare
    const notes = [392, 523, 659, 784];
    notes.forEach((f, i) => {
      setTimeout(() => {
        this._createOsc(f, 'square', 0.18, 0.08);
        this._createOsc(f, 'sine', 0.25, 0.1);
      }, i * 100);
    });
  }

  _combo() {
    this._createOsc(880, 'sine', 0.1, 0.1);
    setTimeout(() => this._createOsc(1100, 'sine', 0.1, 0.08), 60);
    setTimeout(() => this._createOsc(1320, 'sine', 0.15, 0.06), 120);
  }
}

// ─── GAME STATE ───
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const sound = new SoundEngine();

let W, H, groundY;
let gameState = 'menu'; // menu, playing, dead
let score = 0;
let highScore = parseInt(localStorage.getItem('funGameHighScore') || '0');
let speedMultiplier = 1;
let baseSpeed = 5;
let frameCount = 0;
let lastTime = 0;
let deltaTime = 0;
let nearMissCombo = 0;
let nearMissTimer = 0;
let screenShake = 0;
let screenShakeX = 0;
let screenShakeY = 0;
let particles = [];
let floatingTexts = [];
let clouds = [];
let obstacles = [];
let bgStars = [];
let mountains1 = [];
let mountains2 = [];
let groundTiles = [];
let dustParticles = [];
let lastObstacleSpawn = 0;
let minObstacleGap = 90;
let difficultyTimer = 0;
let invincibleTimer = 0;

// Update UI
document.getElementById('high-score-display').textContent = `BEST: ${highScore}`;

// ─── PLAYER ───
const player = {
  x: 120,
  y: 0,
  w: 50,
  h: 60,
  vy: 0,
  grounded: true,
  jumps: 0,
  maxJumps: 2,
  jumpForce: -16,
  gravity: 0.65,
  squash: 1,
  stretch: 1,
  rotation: 0,
  blinkTimer: 0,
  mouthOpen: 0,
  armAngle: 0,
  legAngle: 0,
  runFrame: 0,
  trail: [],
  color: '#ff6b35',
  eyeColor: '#fff',
  alive: true,
  hatBounce: 0,
};

// ─── RESIZE ───
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  groundY = H - 80;
  player.y = groundY - player.h;

  // Regenerate backgrounds
  generateBgElements();
}

function generateBgElements() {
  // Stars
  bgStars = [];
  for (let i = 0; i < 80; i++) {
    bgStars.push({
      x: Math.random() * W * 2,
      y: Math.random() * (H * 0.5),
      size: Math.random() * 3 + 0.5,
      twinkle: Math.random() * Math.PI * 2,
      speed: Math.random() * 0.3 + 0.1,
    });
  }

  // Mountains back layer
  mountains1 = [];
  for (let x = -200; x < W * 2 + 200; x += 180 + Math.random() * 100) {
    mountains1.push({
      x,
      h: 100 + Math.random() * 150,
      w: 160 + Math.random() * 120,
      color: `hsl(${260 + Math.random() * 30}, 40%, ${15 + Math.random() * 8}%)`
    });
  }

  // Mountains front layer
  mountains2 = [];
  for (let x = -100; x < W * 2 + 100; x += 120 + Math.random() * 80) {
    mountains2.push({
      x,
      h: 60 + Math.random() * 100,
      w: 100 + Math.random() * 80,
      color: `hsl(${270 + Math.random() * 30}, 35%, ${20 + Math.random() * 8}%)`
    });
  }

  // Clouds
  clouds = [];
  for (let i = 0; i < 8; i++) {
    clouds.push({
      x: Math.random() * W * 2,
      y: 40 + Math.random() * (H * 0.25),
      w: 80 + Math.random() * 120,
      h: 30 + Math.random() * 30,
      speed: 0.2 + Math.random() * 0.4,
      opacity: 0.15 + Math.random() * 0.15,
    });
  }
}

window.addEventListener('resize', resize);
resize();

// ─── OBSTACLE TYPES ───
function createObstacle() {
  const types = ['cactus', 'rock', 'bird', 'spring', 'barrel'];
  const weights = [30, 25, 20, 15, 10];
  // Increase bird/spring chance at higher speeds
  if (speedMultiplier > 1.5) { weights[2] += 10; weights[3] += 5; }

  const totalWeight = weights.reduce((a, b) => a + b, 0);
  let rand = Math.random() * totalWeight;
  let type = types[0];
  for (let i = 0; i < weights.length; i++) {
    rand -= weights[i];
    if (rand <= 0) { type = types[i]; break; }
  }

  const obs = {
    x: W + 50,
    type,
    passed: false,
    bobPhase: Math.random() * Math.PI * 2,
    rotation: 0,
    squash: 1,
  };

  switch(type) {
    case 'cactus':
      obs.y = groundY;
      obs.w = 30 + Math.random() * 15;
      obs.h = 50 + Math.random() * 30;
      obs.y -= obs.h;
      obs.color = '#2d8a4e';
      obs.arms = Math.random() > 0.4;
      break;
    case 'rock':
      obs.w = 35 + Math.random() * 25;
      obs.h = 30 + Math.random() * 20;
      obs.y = groundY - obs.h;
      obs.color = '#7a6b5d';
      break;
    case 'bird':
      obs.w = 40;
      obs.h = 30;
      obs.y = groundY - 80 - Math.random() * 60;
      obs.color = '#e74c3c';
      obs.wingPhase = 0;
      break;
    case 'spring':
      obs.w = 25;
      obs.h = 55 + Math.random() * 20;
      obs.y = groundY - obs.h;
      obs.color = '#e67e22';
      obs.springPhase = 0;
      break;
    case 'barrel':
      obs.w = 40;
      obs.h = 45;
      obs.y = groundY - obs.h;
      obs.color = '#8b5e3c';
      obs.rollAngle = 0;
      break;
  }

  return obs;
}

// ─── PARTICLES ───
function spawnParticles(x, y, count, color, spread=3, life=30) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * spread * 2,
      vy: (Math.random() - 1) * spread,
      life,
      maxLife: life,
      size: 2 + Math.random() * 4,
      color,
      gravity: 0.15,
    });
  }
}

function spawnDust(x, y) {
  for (let i = 0; i < 3; i++) {
    dustParticles.push({
      x: x + Math.random() * 10 - 5,
      y: y,
      vx: -Math.random() * 2 - 1,
      vy: -Math.random() * 1.5,
      life: 20 + Math.random() * 10,
      maxLife: 30,
      size: 3 + Math.random() * 4,
    });
  }
}

function addFloatingText(text, x, y, color='#ffd700') {
  const el = document.createElement('div');
  el.className = 'particle-text';
  el.textContent = text;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.color = color;
  document.getElementById('ui-overlay').appendChild(el);
  setTimeout(() => el.remove(), 1000);
}

// ─── INPUT ───
let jumpPressed = false;

function doJump() {
  if (gameState !== 'playing') return;
  if (player.jumps < player.maxJumps) {
    if (player.jumps === 0) {
      player.vy = player.jumpForce;
      sound.play('jump');
      player.squash = 0.7;
      player.stretch = 1.3;
      spawnDust(player.x + player.w/2, groundY);
      spawnParticles(player.x + player.w/2, groundY, 5, '#d4a574', 2, 15);
    } else {
      player.vy = player.jumpForce * 0.85;
      sound.play('doubleJump');
      player.squash = 0.6;
      player.stretch = 1.4;
      spawnParticles(player.x + player.w/2, player.y + player.h, 8, '#7df9ff', 3, 20);
      addFloatingText('DOUBLE!', player.x + 30, player.y - 20, '#7df9ff');
    }
    player.grounded = false;
    player.jumps++;
    player.mouthOpen = 1;
  }
}

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
    e.preventDefault();
    if (!jumpPressed) {
      jumpPressed = true;
      handleInput();
    }
  }
});

document.addEventListener('keyup', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
    jumpPressed = false;
  }
});

canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  handleInput();
});

document.getElementById('startBtn').addEventListener('click', () => startGame());
document.getElementById('retryBtn').addEventListener('click', () => startGame());

function handleInput() {
  sound.init();
  if (gameState === 'menu') {
    startGame();
  } else if (gameState === 'playing') {
    doJump();
  } else if (gameState === 'dead') {
    startGame();
  }
}

// ─── GAME CONTROL ───
function startGame() {
  sound.init();
  sound.play('start');
  gameState = 'playing';
  score = 0;
  speedMultiplier = 1;
  frameCount = 0;
  nearMissCombo = 0;
  nearMissTimer = 0;
  difficultyTimer = 0;
  obstacles = [];
  particles = [];
  dustParticles = [];
  lastObstacleSpawn = 0;
  invincibleTimer = 60; // Brief invincibility at start

  player.y = groundY - player.h;
  player.vy = 0;
  player.grounded = true;
  player.jumps = 0;
  player.alive = true;
  player.squash = 1;
  player.stretch = 1;
  player.rotation = 0;
  player.trail = [];
  player.runFrame = 0;

  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('game-over-screen').style.display = 'none';
  document.getElementById('combo-display').style.opacity = '0';
}

function gameOver() {
  if (gameState !== 'playing') return;
  gameState = 'dead';
  player.alive = false;
  sound.play('hit');
  screenShake = 15;

  // Explosion particles
  spawnParticles(player.x + player.w/2, player.y + player.h/2, 25, '#ff6b35', 6, 40);
  spawnParticles(player.x + player.w/2, player.y + player.h/2, 15, '#ffd700', 4, 35);

  const isNewHigh = score > highScore;
  if (isNewHigh) {
    highScore = score;
    localStorage.setItem('funGameHighScore', highScore.toString());
    document.getElementById('high-score-display').textContent = `BEST: ${highScore}`;
  }

  setTimeout(() => {
    document.getElementById('final-score').textContent = `Score: ${score}`;
    document.getElementById('new-high-score').style.display = isNewHigh ? 'block' : 'none';
    document.getElementById('game-over-screen').style.display = 'flex';
  }, 800);
}

// ─── COLLISION ───
function checkCollision(a, b) {
  // Shrink hitboxes for forgiving gameplay
  const pad = 8;
  return (
    a.x + pad < b.x + b.w - pad &&
    a.x + a.w - pad > b.x + pad &&
    a.y + pad < b.y + b.h - pad &&
    a.y + a.h - pad > b.y + pad
  );
}

function checkNearMiss(obs) {
  const nearDist = 20;
  const px = player.x + player.w;
  const ox = obs.x;
  return Math.abs(px - ox) < nearDist && !obs.passed;
}

// ─── DRAWING FUNCTIONS ───
function drawSky() {
  // Gradient sky
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0a0520');
  grad.addColorStop(0.3, '#1a0a3e');
  grad.addColorStop(0.6, '#2d1b69');
  grad.addColorStop(0.85, '#4a2c8a');
  grad.addColorStop(1, '#6b3fa0');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

function drawStars() {
  bgStars.forEach(star => {
    star.twinkle += 0.03;
    const alpha = 0.4 + Math.sin(star.twinkle) * 0.3;
    const size = star.size * (0.8 + Math.sin(star.twinkle * 1.5) * 0.2);
    ctx.beginPath();
    ctx.arc(((star.x - frameCount * star.speed * 0.3) % (W * 2) + W * 2) % (W * 2), star.y, size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255, 255, 230, ${alpha})`;
    ctx.fill();
  });
}

function drawMoon() {
  const moonX = W * 0.8 - frameCount * 0.05;
  const moonY = H * 0.12;
  // Glow
  const glow = ctx.createRadialGradient(moonX, moonY, 20, moonX, moonY, 80);
  glow.addColorStop(0, 'rgba(255,250,200,0.15)');
  glow.addColorStop(1, 'rgba(255,250,200,0)');
  ctx.fillStyle = glow;
  ctx.fillRect(moonX - 80, moonY - 80, 160, 160);
  // Moon body
  ctx.beginPath();
  ctx.arc(moonX, moonY, 30, 0, Math.PI * 2);
  ctx.fillStyle = '#ffeebb';
  ctx.fill();
  // Craters
  ctx.beginPath();
  ctx.arc(moonX - 8, moonY - 5, 6, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(200,180,140,0.4)';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(moonX + 10, moonY + 8, 4, 0, Math.PI * 2);
  ctx.fill();
  // Face on moon
  ctx.beginPath();
  ctx.arc(moonX - 6, moonY - 2, 2, 0, Math.PI * 2);
  ctx.arc(moonX + 6, moonY - 2, 2, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(150,130,100,0.4)';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(moonX, moonY + 6, 5, 0, Math.PI);
  ctx.strokeStyle = 'rgba(150,130,100,0.3)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

function drawMountains(mts, offsetFactor, baseY) {
  mts.forEach(m => {
    const x = ((m.x - frameCount * offsetFactor) % (W * 2) + W * 2) % (W * 2) - 200;
    ctx.beginPath();
    ctx.moveTo(x - m.w/2, baseY);
    ctx.quadraticCurveTo(x - m.w/4, baseY - m.h * 0.6, x, baseY - m.h);
    ctx.quadraticCurveTo(x + m.w/4, baseY - m.h * 0.6, x + m.w/2, baseY);
    ctx.closePath();
    ctx.fillStyle = m.color;
    ctx.fill();
    // Snow cap
    if (m.h > 120) {
      ctx.beginPath();
      ctx.moveTo(x - m.w * 0.08, baseY - m.h * 0.85);
      ctx.lineTo(x, baseY - m.h);
      ctx.lineTo(x + m.w * 0.08, baseY - m.h * 0.85);
      ctx.closePath();
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fill();
    }
  });
}

function drawClouds() {
  clouds.forEach(c => {
    const x = ((c.x - frameCount * c.speed * 0.5) % (W * 2) + W * 2) % (W * 2) - 150;
    ctx.save();
    ctx.globalAlpha = c.opacity;
    ctx.fillStyle = '#c8b8e8';
    // Fluffy cloud shape
    const cx = x, cy = c.y;
    ctx.beginPath();
    ctx.ellipse(cx, cy, c.w * 0.5, c.h * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx - c.w * 0.25, cy + 5, c.w * 0.3, c.h * 0.35, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + c.w * 0.28, cy + 3, c.w * 0.35, c.h * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

function drawGround() {
  // Ground body
  const grad = ctx.createLinearGradient(0, groundY, 0, H);
  grad.addColorStop(0, '#5a3d2b');
  grad.addColorStop(0.15, '#4a3020');
  grad.addColorStop(1, '#2a1a10');
  ctx.fillStyle = grad;
  ctx.fillRect(0, groundY, W, H - groundY);

  // Grass on top
  const grassGrad = ctx.createLinearGradient(0, groundY - 8, 0, groundY + 5);
  grassGrad.addColorStop(0, '#4ecdc4');
  grassGrad.addColorStop(0.5, '#2d9a93');
  grassGrad.addColorStop(1, '#5a3d2b');
  ctx.fillStyle = grassGrad;
  ctx.fillRect(0, groundY - 4, W, 12);

  // Grass blades
  const offset = (frameCount * baseSpeed * speedMultiplier) % 20;
  ctx.strokeStyle = '#4ecdc4';
  ctx.lineWidth = 2;
  for (let x = -offset; x < W + 20; x += 18) {
    const h = 6 + Math.sin(x * 0.1 + frameCount * 0.05) * 3;
    ctx.beginPath();
    ctx.moveTo(x, groundY - 3);
    ctx.quadraticCurveTo(x + 3, groundY - 3 - h, x + 6, groundY - 3);
    ctx.stroke();
  }

  // Ground details (pebbles, etc.)
  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  for (let x = -(offset * 2) % 40; x < W + 20; x += 40) {
    ctx.beginPath();
    ctx.ellipse(x, groundY + 15, 4, 2, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawPlayer() {
  if (!player.alive && frameCount % 4 < 2) return; // Blink when dead

  const p = player;
  ctx.save();

  // Position with squash/stretch
  const cx = p.x + p.w / 2;
  const cy = p.y + p.h;
  ctx.translate(cx + screenShakeX, cy + screenShakeY);
  ctx.rotate(p.rotation);
  ctx.scale(p.squash, p.stretch);

  const bw = p.w;
  const bh = p.h;

  // Shadow
  ctx.save();
  ctx.scale(1, 0.3);
  ctx.beginPath();
  const shadowY = (groundY - cy) / 0.3;
  ctx.ellipse(0, shadowY, bw * 0.6, 8, 0, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fill();
  ctx.restore();

  // Trail / afterimage when jumping
  if (!p.grounded) {
    p.trail.forEach((t, i) => {
      const alpha = (i / p.trail.length) * 0.15;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(t.x - cx, t.y - cy);
      drawPlayerBody(bw, bh, true);
      ctx.restore();
    });
  }

  drawPlayerBody(bw, bh, false);

  ctx.restore();
}

function drawPlayerBody(bw, bh, isTrail) {
  const p = player;

  // Legs
  const legAngle = p.grounded ? Math.sin(p.runFrame * 0.3) * 0.4 : 0.2;
  ctx.save();
  ctx.fillStyle = '#e8572a';

  // Left leg
  ctx.save();
  ctx.translate(-bw * 0.2, -bh * 0.15);
  ctx.rotate(legAngle);
  ctx.fillRect(-5, 0, 10, bh * 0.2);
  // Shoe
  ctx.fillStyle = '#ffd700';
  roundRect(-7, bh * 0.15, 14, 8, 4);
  ctx.restore();

  // Right leg
  ctx.save();
  ctx.fillStyle = '#e8572a';
  ctx.translate(bw * 0.2, -bh * 0.15);
  ctx.rotate(-legAngle);
  ctx.fillRect(-5, 0, 10, bh * 0.2);
  ctx.fillStyle = '#ffd700';
  roundRect(-7, bh * 0.15, 14, 8, 4);
  ctx.restore();

  ctx.restore();

  // Body
  ctx.fillStyle = isTrail ? 'rgba(255,107,53,0.3)' : p.color;
  roundRect(-bw/2, -bh, bw, bh * 0.75, 12);

  // Belly highlight
  if (!isTrail) {
    ctx.fillStyle = '#ff8c5a';
    ctx.beginPath();
    ctx.ellipse(0, -bh * 0.45, bw * 0.28, bh * 0.2, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  if (isTrail) return;

  // Arms
  const armSwing = p.grounded ? Math.sin(p.runFrame * 0.3 + Math.PI) * 0.5 : -0.8;
  ctx.fillStyle = '#e8572a';

  // Left arm
  ctx.save();
  ctx.translate(-bw/2 - 2, -bh * 0.6);
  ctx.rotate(armSwing);
  ctx.fillRect(-4, 0, 8, bh * 0.25);
  // Hand
  ctx.fillStyle = '#ffcc88';
  ctx.beginPath();
  ctx.arc(0, bh * 0.25, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Right arm
  ctx.save();
  ctx.fillStyle = '#e8572a';
  ctx.translate(bw/2 + 2, -bh * 0.6);
  ctx.rotate(-armSwing);
  ctx.fillRect(-4, 0, 8, bh * 0.25);
  ctx.fillStyle = '#ffcc88';
  ctx.beginPath();
  ctx.arc(0, bh * 0.25, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Face
  // Eyes
  p.blinkTimer += 0.05;
  const blinkOpen = Math.sin(p.blinkTimer) > -0.95;
  const eyeH = blinkOpen ? 8 : 1.5;
  const eyeY = -bh * 0.72;

  // Eye whites
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(-8, eyeY, 8, eyeH, 0, 0, Math.PI * 2);
  ctx.ellipse(8, eyeY, 8, eyeH, 0, 0, Math.PI * 2);
  ctx.fill();

  if (blinkOpen) {
    // Pupils - look in movement direction
    const lookX = p.grounded ? 2 : 0;
    const lookY = p.vy < 0 ? -2 : (p.vy > 0 ? 2 : 0);
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(-8 + lookX, eyeY + lookY, 3.5, 0, Math.PI * 2);
    ctx.arc(8 + lookX, eyeY + lookY, 3.5, 0, Math.PI * 2);
    ctx.fill();

    // Pupil highlights
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-6 + lookX, eyeY + lookY - 1.5, 1.5, 0, Math.PI * 2);
    ctx.arc(10 + lookX, eyeY + lookY - 1.5, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Eyebrows
  ctx.strokeStyle = '#c44020';
  ctx.lineWidth = 2.5;
  ctx.lineCap = 'round';
  const browLift = p.vy < -5 ? -4 : 0;
  ctx.beginPath();
  ctx.moveTo(-14, eyeY - 10 + browLift);
  ctx.lineTo(-3, eyeY - 12 + browLift);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(3, eyeY - 12 + browLift);
  ctx.lineTo(14, eyeY - 10 + browLift);
  ctx.stroke();

  // Mouth
  p.mouthOpen *= 0.92;
  const mouthY = -bh * 0.52;
  const mouthWidth = 8 + p.mouthOpen * 5;
  const mouthHeight = 3 + p.mouthOpen * 8;

  if (p.mouthOpen > 0.1) {
    // Open mouth
    ctx.fillStyle = '#8b0000';
    ctx.beginPath();
    ctx.ellipse(0, mouthY, mouthWidth, mouthHeight, 0, 0, Math.PI * 2);
    ctx.fill();
    // Tongue
    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.ellipse(2, mouthY + mouthHeight * 0.4, mouthWidth * 0.4, mouthHeight * 0.3, 0, 0, Math.PI);
    ctx.fill();
  } else {
    // Smile
    ctx.beginPath();
    ctx.arc(0, mouthY - 2, 8, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.strokeStyle = '#c44020';
    ctx.lineWidth = 2.5;
    ctx.stroke();
    // Rosy cheeks
    ctx.fillStyle = 'rgba(255,150,150,0.3)';
    ctx.beginPath();
    ctx.ellipse(-15, mouthY, 6, 4, 0, 0, Math.PI * 2);
    ctx.ellipse(15, mouthY, 6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Hat (propeller beanie!)
  const hatY = -bh - 2;
  ctx.fillStyle = '#4169E1';
  ctx.beginPath();
  ctx.moveTo(-bw * 0.4, hatY + 12);
  ctx.lineTo(-bw * 0.25, hatY);
  ctx.lineTo(bw * 0.25, hatY);
  ctx.lineTo(bw * 0.4, hatY + 12);
  ctx.closePath();
  ctx.fill();

  // Hat brim
  ctx.fillStyle = '#3158c9';
  ctx.fillRect(-bw * 0.45, hatY + 10, bw * 0.9, 5);

  // Hat band
  ctx.fillStyle = '#ffd700';
  ctx.fillRect(-bw * 0.3, hatY + 5, bw * 0.6, 4);

  // Propeller
  const propSpin = frameCount * (p.grounded ? 0.15 : 0.4);
  const propY = hatY - 3;
  ctx.save();
  ctx.translate(0, propY);
  ctx.rotate(propSpin);
  // Blades
  ctx.fillStyle = '#ff4444';
  ctx.fillRect(-15, -2, 30, 4);
  ctx.fillStyle = '#44ff44';
  ctx.save();
  ctx.rotate(Math.PI / 2);
  ctx.fillRect(-15, -2, 30, 4);
  ctx.restore();
  // Center
  ctx.fillStyle = '#ffd700';
  ctx.beginPath();
  ctx.arc(0, 0, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();
}

function drawObstacle(obs) {
  ctx.save();
  ctx.translate(obs.x + obs.w/2 + screenShakeX, obs.y + obs.h/2 + screenShakeY);

  switch(obs.type) {
    case 'cactus': drawCactus(obs); break;
    case 'rock': drawRock(obs); break;
    case 'bird': drawBird(obs); break;
    case 'spring': drawSpring(obs); break;
    case 'barrel': drawBarrel(obs); break;
  }

  ctx.restore();
}

function drawCactus(obs) {
  const w = obs.w, h = obs.h;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(0, h/2 + 2, w * 0.5, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Main trunk
  ctx.fillStyle = '#2d8a4e';
  roundRect(-w * 0.3, -h/2, w * 0.6, h, 8);

  // Highlight
  ctx.fillStyle = '#3daa5e';
  roundRect(-w * 0.15, -h/2 + 5, w * 0.15, h - 10, 4);

  if (obs.arms) {
    // Left arm
    ctx.fillStyle = '#2d8a4e';
    ctx.save();
    ctx.translate(-w * 0.3, -h * 0.1);
    ctx.fillRect(-w * 0.35, -4, w * 0.35, 8);
    ctx.fillRect(-w * 0.35 - 4, -4 - h * 0.2, 8, h * 0.2 + 4);
    ctx.restore();

    // Right arm
    ctx.save();
    ctx.translate(w * 0.3, -h * 0.25);
    ctx.fillRect(0, -4, w * 0.3, 8);
    ctx.fillRect(w * 0.3 - 4, -4 - h * 0.15, 8, h * 0.15 + 4);
    ctx.restore();
  }

  // Spikes
  ctx.strokeStyle = '#1a6b34';
  ctx.lineWidth = 1.5;
  for (let i = 0; i < 5; i++) {
    const sy = -h/2 + 8 + i * (h - 16) / 4;
    ctx.beginPath();
    ctx.moveTo(-w * 0.3, sy);
    ctx.lineTo(-w * 0.3 - 6, sy - 3);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w * 0.3, sy);
    ctx.lineTo(w * 0.3 + 6, sy - 3);
    ctx.stroke();
  }

  // Funny face
  const faceY = -h * 0.2;
  // Eyes (X X dead plant look - but cute)
  ctx.fillStyle = '#1a5530';
  ctx.beginPath();
  ctx.arc(-6, faceY, 3, 0, Math.PI * 2);
  ctx.arc(6, faceY, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(-5, faceY - 1, 1, 0, Math.PI * 2);
  ctx.arc(7, faceY - 1, 1, 0, Math.PI * 2);
  ctx.fill();
  // Grumpy mouth
  ctx.strokeStyle = '#1a5530';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, faceY + 10, 5, Math.PI * 1.1, Math.PI * 1.9);
  ctx.stroke();

  // Flower on top
  const petalColors = ['#ff69b4', '#ff4444', '#ffaa00'];
  const pc = petalColors[Math.floor(obs.x / 100) % 3];
  for (let i = 0; i < 5; i++) {
    const a = (i / 5) * Math.PI * 2 + frameCount * 0.02;
    ctx.beginPath();
    ctx.ellipse(
      Math.cos(a) * 5, -h/2 - 5 + Math.sin(a) * 5,
      4, 3, a, 0, Math.PI * 2
    );
    ctx.fillStyle = pc;
    ctx.fill();
  }
  ctx.beginPath();
  ctx.arc(0, -h/2 - 5, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#ffd700';
  ctx.fill();
}

function drawRock(obs) {
  const w = obs.w, h = obs.h;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(0, h/2 + 2, w * 0.55, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Main rock shape
  ctx.fillStyle = obs.color;
  ctx.beginPath();
  ctx.moveTo(-w/2, h/2);
  ctx.lineTo(-w * 0.45, -h * 0.2);
  ctx.lineTo(-w * 0.15, -h/2);
  ctx.lineTo(w * 0.2, -h * 0.45);
  ctx.lineTo(w * 0.45, -h * 0.1);
  ctx.lineTo(w/2, h/2);
  ctx.closePath();
  ctx.fill();

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.beginPath();
  ctx.moveTo(-w * 0.3, -h * 0.1);
  ctx.lineTo(-w * 0.1, -h * 0.4);
  ctx.lineTo(w * 0.1, -h * 0.35);
  ctx.lineTo(0, 0);
  ctx.closePath();
  ctx.fill();

  // Face
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.arc(-5, -2, 2.5, 0, Math.PI * 2);
  ctx.arc(7, -2, 2.5, 0, Math.PI * 2);
  ctx.fill();
  // Sleeping Z's
  ctx.fillStyle = '#999';
  ctx.font = '10px Fredoka One';
  const bob = Math.sin(frameCount * 0.05) * 3;
  ctx.fillText('z', 12, -h * 0.3 + bob);
  ctx.font = '14px Fredoka One';
  ctx.fillText('Z', 18, -h * 0.4 + bob - 5);
}

function drawBird(obs) {
  const w = obs.w, h = obs.h;
  obs.wingPhase += 0.2;
  const wingAngle = Math.sin(obs.wingPhase) * 0.6;

  // Body
  ctx.fillStyle = obs.color;
  ctx.beginPath();
  ctx.ellipse(0, 0, w * 0.4, h * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();

  // Belly
  ctx.fillStyle = '#ffaa88';
  ctx.beginPath();
  ctx.ellipse(2, 3, w * 0.25, h * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();

  // Wings
  ctx.save();
  ctx.fillStyle = '#cc3333';
  // Left wing
  ctx.save();
  ctx.translate(-w * 0.2, -3);
  ctx.rotate(-wingAngle - 0.3);
  ctx.beginPath();
  ctx.ellipse(-10, 0, 15, 6, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  // Right wing
  ctx.save();
  ctx.translate(w * 0.2, -3);
  ctx.rotate(wingAngle + 0.3);
  ctx.beginPath();
  ctx.ellipse(10, 0, 15, 6, 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  ctx.restore();

  // Tail feathers
  ctx.fillStyle = '#aa2222';
  ctx.save();
  ctx.translate(-w * 0.35, 0);
  for (let i = -1; i <= 1; i++) {
    ctx.beginPath();
    ctx.ellipse(-6, i * 4, 8, 3, -0.3, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // Beak
  ctx.fillStyle = '#ffa500';
  ctx.beginPath();
  ctx.moveTo(w * 0.35, -3);
  ctx.lineTo(w * 0.55, 0);
  ctx.lineTo(w * 0.35, 3);
  ctx.closePath();
  ctx.fill();

  // Eye
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(w * 0.18, -5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(w * 0.2, -5, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(w * 0.22, -6, 1, 0, Math.PI * 2);
  ctx.fill();

  // Angry eyebrow
  ctx.strokeStyle = '#880000';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(w * 0.08, -11);
  ctx.lineTo(w * 0.28, -9);
  ctx.stroke();
}

function drawSpring(obs) {
  const w = obs.w, h = obs.h;
  obs.springPhase += 0.1;
  const bounce = Math.sin(obs.springPhase) * 3;

  // Base
  ctx.fillStyle = '#888';
  ctx.fillRect(-w * 0.6, h/2 - 6, w * 1.2, 6);

  // Spring coils
  ctx.strokeStyle = obs.color;
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  const coils = 6;
  ctx.beginPath();
  for (let i = 0; i <= coils * 10; i++) {
    const t = i / (coils * 10);
    const coilX = Math.sin(t * coils * Math.PI * 2) * w * 0.4;
    const coilY = h/2 - 6 - t * (h - 20) + bounce * t;
    if (i === 0) ctx.moveTo(coilX, coilY);
    else ctx.lineTo(coilX, coilY);
  }
  ctx.stroke();

  // Boxing glove on top!
  const topY = -h/2 + bounce + 5;
  ctx.fillStyle = '#ff4444';
  ctx.beginPath();
  ctx.arc(0, topY, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#cc2222';
  ctx.beginPath();
  ctx.arc(-3, topY + 4, 5, 0, Math.PI * 2);
  ctx.fill();
  // Wrist band
  ctx.fillStyle = '#fff';
  ctx.fillRect(-8, topY + 10, 16, 4);
}

function drawBarrel(obs) {
  const w = obs.w, h = obs.h;
  obs.rollAngle -= 0.1 * speedMultiplier;

  ctx.save();
  ctx.rotate(obs.rollAngle);

  // Barrel body
  ctx.fillStyle = obs.color;
  ctx.beginPath();
  ctx.ellipse(0, 0, w * 0.45, h * 0.45, 0, 0, Math.PI * 2);
  ctx.fill();

  // Barrel bands
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.ellipse(0, 0, w * 0.45, h * 0.45, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Cross bands
  ctx.strokeStyle = '#aaa';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-w * 0.45, 0);
  ctx.lineTo(w * 0.45, 0);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, -h * 0.45);
  ctx.lineTo(0, h * 0.45);
  ctx.stroke();

  // Skull & crossbones decal
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(0, -3, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.arc(-2, -4, 1.5, 0, Math.PI * 2);
  ctx.arc(2, -4, 1.5, 0, Math.PI * 2);
  ctx.fill();
  // Crossbones
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-7, 5);
  ctx.lineTo(7, 10);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(7, 5);
  ctx.lineTo(-7, 10);
  ctx.stroke();

  ctx.restore();
}

function drawParticles() {
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x + screenShakeX, p.y + screenShakeY, p.size * alpha, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  dustParticles.forEach(d => {
    const alpha = d.life / d.maxLife * 0.4;
    ctx.fillStyle = `rgba(210, 180, 140, ${alpha})`;
    ctx.beginPath();
    ctx.arc(d.x + screenShakeX, d.y + screenShakeY, d.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

// ─── DECORATIVE ELEMENTS ───
function drawDecorations() {
  // Moving flowers/bushes on ground
  const offset = (frameCount * baseSpeed * speedMultiplier);
  for (let i = 0; i < 10; i++) {
    const baseX = i * (W / 5) + 100;
    const x = ((baseX - offset * 0.8) % (W + 200) + W + 200) % (W + 200) - 100;
    const y = groundY - 2;

    // Small bush
    ctx.fillStyle = '#2d9a93';
    ctx.beginPath();
    ctx.ellipse(x, y, 12, 8, 0, Math.PI, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = '#4ecdc4';
    ctx.beginPath();
    ctx.ellipse(x, y - 3, 8, 6, 0, Math.PI, 2 * Math.PI);
    ctx.fill();

    // Tiny flower
    if (i % 2 === 0) {
      const colors = ['#ff69b4', '#ffd700', '#ff6b35', '#7df9ff'];
      ctx.fillStyle = colors[i % 4];
      for (let p = 0; p < 4; p++) {
        const a = (p / 4) * Math.PI * 2 + frameCount * 0.01;
        ctx.beginPath();
        ctx.arc(x + 15 + Math.cos(a) * 4, y - 8 + Math.sin(a) * 4, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x + 15, y - 8, 2, 0, Math.PI * 2);
      ctx.fill();
      // Stem
      ctx.strokeStyle = '#2d8a4e';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x + 15, y - 4);
      ctx.lineTo(x + 15, y);
      ctx.stroke();
    }
  }
}

// ─── UPDATE ───
function update(dt) {
  if (gameState !== 'playing') return;

  frameCount++;
  difficultyTimer++;

  // Invincibility countdown
  if (invincibleTimer > 0) invincibleTimer--;

  // Increase speed over time
  if (difficultyTimer % 600 === 0 && speedMultiplier < 3.0) {
    speedMultiplier += 0.12;
    sound.play('speedUp');
    addFloatingText('SPEED UP!', W / 2 - 60, H / 3, '#7df9ff');
  }

  const currentSpeed = baseSpeed * speedMultiplier;

  // Player physics
  if (!player.grounded) {
    player.vy += player.gravity;
    player.y += player.vy;

    // Trail
    if (frameCount % 2 === 0) {
      player.trail.push({ x: player.x + player.w/2, y: player.y + player.h });
      if (player.trail.length > 6) player.trail.shift();
    }

    // Rotation based on velocity
    player.rotation = player.vy * 0.02;

    if (player.y >= groundY - player.h) {
      player.y = groundY - player.h;
      player.vy = 0;
      player.grounded = true;
      player.jumps = 0;
      player.rotation = 0;
      player.squash = 1.3;
      player.stretch = 0.7;
      player.trail = [];
      sound.play('land');
      spawnDust(player.x + player.w/2, groundY);
    }
  }

  // Running animation
  if (player.grounded) {
    player.runFrame += currentSpeed * 0.15;
  }

  // Squash & stretch recovery
  player.squash += (1 - player.squash) * 0.15;
  player.stretch += (1 - player.stretch) * 0.15;

  // Spawn obstacles
  lastObstacleSpawn++;
  const gap = Math.max(40, minObstacleGap - speedMultiplier * 10);
  if (lastObstacleSpawn > gap && Math.random() < 0.03 * speedMultiplier) {
    // Check minimum distance from last obstacle
    const lastObs = obstacles[obstacles.length - 1];
    const minDist = 200 / speedMultiplier + 100;
    if (!lastObs || lastObs.x < W - minDist) {
      obstacles.push(createObstacle());
      lastObstacleSpawn = 0;
    }
  }

  // Update obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obs = obstacles[i];
    obs.x -= currentSpeed;

    if (obs.type === 'bird') {
      obs.y += Math.sin(obs.bobPhase) * 0.5;
      obs.bobPhase += 0.05;
    }

    // Check passed (scoring)
    if (!obs.passed && obs.x + obs.w < player.x) {
      obs.passed = true;
      score += Math.ceil(10 * speedMultiplier);

      // Near miss check
      if (Math.abs(player.y + player.h - obs.y) < 25 ||
          Math.abs(obs.x + obs.w - player.x) < 25) {
        nearMissCombo++;
        nearMissTimer = 120;
        const bonus = nearMissCombo * 5;
        score += bonus;
        sound.play('nearMiss');
        if (nearMissCombo > 1) {
          sound.play('combo');
          addFloatingText(`NEAR MISS x${nearMissCombo}! +${bonus}`, player.x + 60, player.y - 10, '#ff69b4');
        } else {
          addFloatingText(`CLOSE! +${bonus}`, player.x + 60, player.y - 10, '#ff69b4');
        }
      }
    }

    // Collision check
    if (invincibleTimer <= 0 && checkCollision(player, obs)) {
      gameOver();
    }

    // Remove off-screen
    if (obs.x + obs.w < -50) {
      obstacles.splice(i, 1);
    }
  }

  // Near miss combo timer
  if (nearMissTimer > 0) {
    nearMissTimer--;
    if (nearMissTimer === 0) nearMissCombo = 0;
  }

  // Score milestones
  if (score > 0 && score % 200 < 10 && frameCount % 60 < 2) {
    sound.play('score');
    addFloatingText(`${score} POINTS!`, W/2 - 50, H/3 + 40, '#ffd700');
  }

  // Screen shake
  if (screenShake > 0) {
    screenShake *= 0.85;
    screenShakeX = (Math.random() - 0.5) * screenShake;
    screenShakeY = (Math.random() - 0.5) * screenShake;
    if (screenShake < 0.5) { screenShake = 0; screenShakeX = 0; screenShakeY = 0; }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += p.gravity;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }

  for (let i = dustParticles.length - 1; i >= 0; i--) {
    const d = dustParticles[i];
    d.x += d.vx;
    d.y += d.vy;
    d.size *= 1.02;
    d.life--;
    if (d.life <= 0) dustParticles.splice(i, 1);
  }

  // Running dust
  if (player.grounded && frameCount % 4 === 0) {
    spawnDust(player.x + player.w/2, groundY);
  }

  // Update UI
  document.getElementById('score-display').textContent = `SCORE: ${score}`;
  document.getElementById('speed-display').textContent = `SPEED: ${speedMultiplier.toFixed(1)}x`;

  if (nearMissCombo > 0) {
    document.getElementById('combo-display').textContent = `COMBO x${nearMissCombo}`;
    document.getElementById('combo-display').style.opacity = '1';
  } else {
    document.getElementById('combo-display').style.opacity = '0';
  }
}

// ─── RENDER ───
function render() {
  ctx.clearRect(0, 0, W, H);

  drawSky();
  drawStars();
  drawMoon();
  drawMountains(mountains1, 0.3, groundY + 10);
  drawClouds();
  drawMountains(mountains2, 0.7, groundY + 5);
  drawDecorations();
  drawGround();

  // Draw obstacles
  obstacles.forEach(obs => drawObstacle(obs));

  // Draw particles behind player
  drawParticles();

  // Draw player
  drawPlayer();

  // Invincibility flash
  if (invincibleTimer > 0 && frameCount % 8 < 4) {
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#7df9ff';
    ctx.beginPath();
    ctx.ellipse(
      player.x + player.w/2 + screenShakeX,
      player.y + player.h/2 + screenShakeY,
      player.w * 0.8, player.h * 0.8, 0, 0, Math.PI * 2
    );
    ctx.fill();
    ctx.restore();
  }

  // Vignette
  const vignette = ctx.createRadialGradient(W/2, H/2, W * 0.3, W/2, H/2, W * 0.8);
  vignette.addColorStop(0, 'rgba(0,0,0,0)');
  vignette.addColorStop(1, 'rgba(0,0,0,0.35)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, W, H);
}

// ─── MENU / DEAD RENDER ───
function renderMenu() {
  ctx.clearRect(0, 0, W, H);
  drawSky();
  drawStars();
  drawMoon();
  drawMountains(mountains1, 0.3, groundY + 10);
  drawClouds();
  drawMountains(mountains2, 0.7, groundY + 5);
  drawGround();

  // Animate background slowly
  frameCount += 0.5;

  // Show idle player
  player.y = groundY - player.h;
  player.grounded = true;
  player.runFrame += 0.5;
  player.blinkTimer += 0.05;
  player.squash = 1;
  player.stretch = 1;
  player.rotation = 0;
  player.mouthOpen = 0;
  player.alive = true;
  drawPlayer();

  // Vignette
  const vignette = ctx.createRadialGradient(W/2, H/2, W * 0.3, W/2, H/2, W * 0.8);
  vignette.addColorStop(0, 'rgba(0,0,0,0)');
  vignette.addColorStop(1, 'rgba(0,0,0,0.35)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, W, H);
}

// ─── GAME LOOP ───
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  deltaTime = Math.min((timestamp - lastTime) / 16.667, 3); // Cap at 3x
  lastTime = timestamp;

  if (gameState === 'playing') {
    // Run multiple fixed steps if needed for consistent physics
    const steps = Math.max(1, Math.round(deltaTime));
    for (let i = 0; i < steps; i++) {
      update(1);
    }
    render();
  } else {
    renderMenu();
  }

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

// Preload font display
document.fonts.ready.then(() => {
  // Font loaded, ready to go
});
</script>
</body>
</html>
