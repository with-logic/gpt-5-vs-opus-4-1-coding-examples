<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ocean Wave Simulation</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    background: #0a1628;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    color: #e0e8f0;
    user-select: none;
  }

  #canvas-container {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 0;
  }

  canvas { display: block; }

  /* Controls Panel */
  #controls {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 100;
    width: 300px;
    max-height: calc(100vh - 40px);
    overflow-y: auto;
    background: rgba(8, 18, 38, 0.78);
    backdrop-filter: blur(24px);
    -webkit-backdrop-filter: blur(24px);
    border: 1px solid rgba(100, 160, 220, 0.15);
    border-radius: 16px;
    padding: 24px;
    transition: opacity 0.4s ease, transform 0.4s ease;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,160,220,0.15) transparent;
  }

  #controls::-webkit-scrollbar { width: 4px; }
  #controls::-webkit-scrollbar-thumb { background: rgba(100,160,220,0.2); border-radius: 2px; }
  #controls::-webkit-scrollbar-track { background: transparent; }

  #controls.collapsed {
    transform: translateX(calc(100% + 30px));
    opacity: 0;
    pointer-events: none;
  }

  #toggle-btn {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 101;
    width: 44px;
    height: 44px;
    border-radius: 12px;
    background: rgba(8, 18, 38, 0.78);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(100, 160, 220, 0.15);
    color: #8bb8e0;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
  }

  #toggle-btn:hover {
    background: rgba(20, 40, 70, 0.85);
    border-color: rgba(100, 160, 220, 0.3);
  }

  #toggle-btn.hidden { opacity: 0; pointer-events: none; }

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
  }

  .panel-title {
    font-size: 15px;
    font-weight: 600;
    letter-spacing: 0.5px;
    color: #a8c8e8;
  }

  .close-btn {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    background: rgba(100, 160, 220, 0.08);
    border: 1px solid rgba(100, 160, 220, 0.1);
    color: #6a9ec0;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
  }

  .close-btn:hover {
    background: rgba(100, 160, 220, 0.15);
    color: #a8c8e8;
  }

  .control-group { margin-bottom: 18px; }
  .control-group:last-child { margin-bottom: 0; }

  .control-label {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 8px;
  }

  .control-label span:first-child {
    font-size: 12px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #7a9ab8;
  }

  .control-value {
    font-size: 13px;
    font-weight: 400;
    color: #a8c8e8;
    font-variant-numeric: tabular-nums;
  }

  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(100, 160, 220, 0.12);
    outline: none;
    cursor: pointer;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 35%, #7ec4f0, #3a8cc7);
    box-shadow: 0 2px 8px rgba(60, 140, 200, 0.4), 0 0 0 3px rgba(60, 140, 200, 0.1);
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.15);
    box-shadow: 0 2px 12px rgba(60, 140, 200, 0.5), 0 0 0 4px rgba(60, 140, 200, 0.15);
  }

  input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 35%, #7ec4f0, #3a8cc7);
    box-shadow: 0 2px 8px rgba(60, 140, 200, 0.4);
    cursor: pointer;
    border: none;
  }

  .divider {
    height: 1px;
    background: rgba(100, 160, 220, 0.1);
    margin: 16px 0;
  }

  .presets { display: flex; gap: 8px; flex-wrap: wrap; }

  .preset-btn {
    flex: 1;
    min-width: 0;
    padding: 8px 4px;
    border-radius: 8px;
    background: rgba(100, 160, 220, 0.08);
    border: 1px solid rgba(100, 160, 220, 0.12);
    color: #8bb8d8;
    font-size: 11px;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.25s ease;
    text-align: center;
    letter-spacing: 0.3px;
  }

  .preset-btn:hover {
    background: rgba(100, 160, 220, 0.18);
    border-color: rgba(100, 160, 220, 0.25);
    color: #b0d4f0;
  }

  .preset-btn.active {
    background: rgba(60, 140, 200, 0.2);
    border-color: rgba(60, 140, 200, 0.35);
    color: #c0e0f8;
  }

  #title-overlay {
    position: fixed;
    bottom: 24px;
    left: 24px;
    z-index: 50;
    pointer-events: none;
  }

  #title-overlay h1 {
    font-size: 22px;
    font-weight: 300;
    color: rgba(160, 200, 230, 0.5);
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  #title-overlay p {
    font-size: 11px;
    color: rgba(120, 160, 200, 0.3);
    letter-spacing: 1px;
    margin-top: 4px;
  }

  .color-row { display: flex; gap: 10px; align-items: center; }

  .color-swatch {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    border: 2px solid rgba(100, 160, 220, 0.2);
    cursor: pointer;
    overflow: hidden;
    position: relative;
    flex-shrink: 0;
  }

  .color-swatch input[type="color"] {
    position: absolute;
    top: -4px; left: -4px;
    width: 40px; height: 40px;
    border: none;
    cursor: pointer;
    opacity: 0;
  }

  .color-swatch-inner { width: 100%; height: 100%; border-radius: 6px; }
  .color-label-text { font-size: 11px; color: #7a9ab8; }

  #fps-counter {
    position: fixed;
    bottom: 24px;
    right: 24px;
    z-index: 50;
    font-size: 11px;
    color: rgba(120, 160, 200, 0.25);
    font-variant-numeric: tabular-nums;
  }

  #loading {
    position: fixed;
    inset: 0;
    z-index: 9999;
    background: #0a1628;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: opacity 1.2s ease;
  }

  #loading.fade-out { opacity: 0; pointer-events: none; }

  #loading h2 {
    font-size: 18px;
    font-weight: 300;
    color: #6a9ec0;
    letter-spacing: 3px;
    text-transform: uppercase;
    margin-bottom: 30px;
  }

  .loading-wave { display: flex; gap: 6px; }

  .loading-wave span {
    width: 4px;
    height: 20px;
    background: #3a8cc7;
    border-radius: 2px;
    animation: loadWave 1.2s ease-in-out infinite;
  }

  .loading-wave span:nth-child(2) { animation-delay: 0.1s; }
  .loading-wave span:nth-child(3) { animation-delay: 0.2s; }
  .loading-wave span:nth-child(4) { animation-delay: 0.3s; }
  .loading-wave span:nth-child(5) { animation-delay: 0.4s; }

  @keyframes loadWave {
    0%, 100% { transform: scaleY(0.5); opacity: 0.5; }
    50% { transform: scaleY(1.5); opacity: 1; }
  }

  /* Hint text */
  #hint {
    position: fixed;
    bottom: 64px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 50;
    font-size: 12px;
    color: rgba(120, 160, 200, 0.35);
    letter-spacing: 0.5px;
    pointer-events: none;
    opacity: 1;
    transition: opacity 2s ease;
  }
  #hint.hidden { opacity: 0; }
</style>
</head>
<body>

<div id="loading">
  <h2>Ocean Wave Simulation</h2>
  <div class="loading-wave">
    <span></span><span></span><span></span><span></span><span></span>
  </div>
</div>

<div id="canvas-container"></div>

<button id="toggle-btn" class="hidden" title="Show Controls">&#9881;</button>

<div id="controls">
  <div class="panel-header">
    <span class="panel-title">Wave Controls</span>
    <button class="close-btn" id="close-panel" title="Hide Controls">&times;</button>
  </div>

  <div class="control-group">
    <div class="control-label">
      <span>Wind Speed</span>
      <span class="control-value" id="wind-val">12 knots</span>
    </div>
    <input type="range" id="wind-speed" min="0" max="50" value="12" step="0.5">
  </div>

  <div class="control-group">
    <div class="control-label">
      <span>Wave Height</span>
      <span class="control-value" id="height-val">1.5 m</span>
    </div>
    <input type="range" id="wave-height" min="0.1" max="5" value="1.5" step="0.1">
  </div>

  <div class="control-group">
    <div class="control-label">
      <span>Wave Choppiness</span>
      <span class="control-value" id="chop-val">0.80</span>
    </div>
    <input type="range" id="choppiness" min="0" max="2" value="0.8" step="0.05">
  </div>

  <div class="control-group">
    <div class="control-label">
      <span>Wave Speed</span>
      <span class="control-value" id="speed-val">1.0x</span>
    </div>
    <input type="range" id="wave-speed" min="0.1" max="3" value="1.0" step="0.1">
  </div>

  <div class="divider"></div>

  <div class="control-group">
    <div class="control-label">
      <span>Sun Elevation</span>
      <span class="control-value" id="sun-val">25&deg;</span>
    </div>
    <input type="range" id="sun-elevation" min="-5" max="90" value="25" step="1">
  </div>

  <div class="control-group">
    <div class="control-label">
      <span>Sun Direction</span>
      <span class="control-value" id="azimuth-val">180&deg;</span>
    </div>
    <input type="range" id="sun-azimuth" min="0" max="360" value="180" step="1">
  </div>

  <div class="control-group">
    <div class="control-label">
      <span>Light Intensity</span>
      <span class="control-value" id="intensity-val">1.00</span>
    </div>
    <input type="range" id="light-intensity" min="0.1" max="3" value="1.0" step="0.05">
  </div>

  <div class="control-group">
    <div class="control-label"><span>Water Color</span></div>
    <div class="color-row">
      <div class="color-swatch" id="swatch-deep">
        <div class="color-swatch-inner" id="swatch-deep-inner" style="background:#001e3c"></div>
        <input type="color" id="water-color-deep" value="#001e3c">
      </div>
      <span class="color-label-text">Deep</span>
      <div class="color-swatch" id="swatch-shallow" style="margin-left:auto">
        <div class="color-swatch-inner" id="swatch-shallow-inner" style="background:#006994"></div>
        <input type="color" id="water-color-shallow" value="#006994">
      </div>
      <span class="color-label-text">Shallow</span>
    </div>
  </div>

  <div class="divider"></div>

  <div class="control-group">
    <div class="control-label"><span>Presets</span></div>
    <div class="presets">
      <button class="preset-btn" data-preset="calm">Calm</button>
      <button class="preset-btn" data-preset="moderate">Moderate</button>
      <button class="preset-btn" data-preset="stormy">Stormy</button>
      <button class="preset-btn" data-preset="sunset">Sunset</button>
      <button class="preset-btn" data-preset="tropical">Tropical</button>
    </div>
  </div>
</div>

<div id="title-overlay">
  <h1>Ocean Waves</h1>
  <p>Interactive WebGL Simulation &mdash; Drag to orbit, scroll to zoom</p>
</div>

<div id="fps-counter">-- FPS</div>
<div id="hint">Click and drag to look around</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ==================== PARAMETERS ====================
const params = {
  windSpeed: 12,
  waveHeight: 1.5,
  choppiness: 0.8,
  waveSpeed: 1.0,
  sunElevation: 25,
  sunAzimuth: 180,
  lightIntensity: 1.0,
  waterColorDeep: new THREE.Color(0x001e3c),
  waterColorShallow: new THREE.Color(0x006994),
};

const presets = {
  calm:     { windSpeed: 6,  waveHeight: 0.6, choppiness: 0.3, waveSpeed: 0.6, sunElevation: 40, sunAzimuth: 200, lightIntensity: 1.2, deep: '#002244', shallow: '#0088aa' },
  moderate: { windSpeed: 18, waveHeight: 2.0, choppiness: 1.0, waveSpeed: 1.2, sunElevation: 30, sunAzimuth: 180, lightIntensity: 1.0, deep: '#001e3c', shallow: '#006994' },
  stormy:   { windSpeed: 45, waveHeight: 4.8, choppiness: 1.9, waveSpeed: 2.2, sunElevation: 3,  sunAzimuth: 160, lightIntensity: 0.35, deep: '#080e14', shallow: '#162430' },
  sunset:   { windSpeed: 8,  waveHeight: 1.0, choppiness: 0.4, waveSpeed: 0.7, sunElevation: 3,  sunAzimuth: 260, lightIntensity: 2.0, deep: '#0a1830', shallow: '#104060' },
  tropical: { windSpeed: 10, waveHeight: 0.9, choppiness: 0.5, waveSpeed: 0.8, sunElevation: 65, sunAzimuth: 150, lightIntensity: 1.4, deep: '#003344', shallow: '#00aacc' },
};

// ==================== NOISE GLSL ====================
const noiseGLSL = `
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  float snoise(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;
    i = mod289(i);
    vec4 p = permute(permute(permute(
      i.z + vec4(0.0, i1.z, i2.z, 1.0))
      + i.y + vec4(0.0, i1.y, i2.y, 1.0))
      + i.x + vec4(0.0, i1.x, i2.x, 1.0));
    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);
    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m * m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
  }
`;

const gerstnerGLSL = `
  vec3 gerstnerWave(vec2 pos, float steepness, float wavelength, vec2 direction, float speed, float t) {
    float k = 6.28318530718 / wavelength;
    float c = sqrt(9.81 / k) * speed;
    vec2 d = normalize(direction);
    float f = k * (dot(d, pos) - c * t);
    float a = steepness / k;
    return vec3(d.x * (a * cos(f)), a * sin(f), d.y * (a * cos(f)));
  }
`;

const waveCalcGLSL = `
  vec3 calcWaves(vec2 xz, float t, float windFactor, float heightScale, float chopScale, float noiseScale) {
    vec3 w = vec3(0.0);
    // Primary swell - large ocean waves
    w += gerstnerWave(xz, 0.15 * chopScale, 60.0 * (0.5 + windFactor), vec2(1.0, 0.3), 1.0, t) * heightScale;
    w += gerstnerWave(xz, 0.12 * chopScale, 45.0 * (0.4 + windFactor * 0.8), vec2(0.8, 0.6), 1.05, t) * heightScale;
    w += gerstnerWave(xz, 0.10 * chopScale, 30.0 * (0.3 + windFactor * 0.6), vec2(-0.3, 1.0), 0.9, t) * heightScale;
    // Secondary waves
    w += gerstnerWave(xz, 0.08 * chopScale, 18.0 * (0.3 + windFactor * 0.5), vec2(0.5, -0.4), 1.3, t) * heightScale * 0.8;
    w += gerstnerWave(xz, 0.06 * chopScale, 12.0 * (0.2 + windFactor * 0.4), vec2(-0.7, 0.7), 1.5, t) * heightScale * 0.6;
    w += gerstnerWave(xz, 0.05 * chopScale, 8.0 * (0.2 + windFactor * 0.3), vec2(0.9, 0.1), 1.7, t) * heightScale * 0.5;
    // Tertiary ripples
    w += gerstnerWave(xz, 0.03 * chopScale, 5.0 * (0.15 + windFactor * 0.2), vec2(-0.5, -0.8), 2.0, t) * heightScale * 0.3;
    w += gerstnerWave(xz, 0.02 * chopScale, 3.5 * (0.1 + windFactor * 0.15), vec2(0.3, 0.9), 2.3, t) * heightScale * 0.2;
    // Noise-based detail
    float n1 = snoise(vec3(xz * 0.025, t * 0.25)) * heightScale * noiseScale * 10.0;
    float n2 = snoise(vec3(xz * 0.07, t * 0.4)) * heightScale * noiseScale * 5.0;
    float n3 = snoise(vec3(xz * 0.18, t * 0.6)) * heightScale * noiseScale * 2.5;
    w.y += n1 + n2 + n3;
    return w;
  }
`;

// ==================== WATER VERTEX SHADER ====================
const waterVertexShader = `
  precision highp float;
  uniform float uTime;
  uniform float uWaveHeight;
  uniform float uWindSpeed;
  uniform float uChoppiness;

  varying vec3 vWorldPosition;
  varying vec3 vNormal;
  varying vec2 vUv;
  varying float vElevation;

  ${noiseGLSL}
  ${gerstnerGLSL}
  ${waveCalcGLSL}

  void main() {
    vUv = uv;
    vec3 pos = position;

    float t = uTime;
    float windFactor = uWindSpeed / 20.0;
    float heightScale = uWaveHeight;
    float chopScale = uChoppiness;
    float noiseScale = 0.04 * windFactor;

    vec3 wave = calcWaves(pos.xz, t, windFactor, heightScale, chopScale, noiseScale);
    pos += wave;

    // Normal via finite differences
    float eps = 0.4;
    vec3 posX = position + vec3(eps, 0.0, 0.0);
    vec3 posZ = position + vec3(0.0, 0.0, eps);
    posX += calcWaves(posX.xz, t, windFactor, heightScale, chopScale, noiseScale);
    posZ += calcWaves(posZ.xz, t, windFactor, heightScale, chopScale, noiseScale);

    vec3 tangent = normalize(posX - pos);
    vec3 bitangent = normalize(posZ - pos);
    vec3 normal = normalize(cross(bitangent, tangent));

    vNormal = normalize(normalMatrix * normal);
    vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
    vElevation = wave.y;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

// ==================== WATER FRAGMENT SHADER ====================
const waterFragmentShader = `
  precision highp float;
  uniform vec3 uSunDirection;
  uniform float uLightIntensity;
  uniform vec3 uWaterColorDeep;
  uniform vec3 uWaterColorShallow;
  uniform vec3 uCameraPosition;
  uniform float uTime;
  uniform float uWindSpeed;
  uniform float uWaveHeight;

  varying vec3 vWorldPosition;
  varying vec3 vNormal;
  varying vec2 vUv;
  varying float vElevation;

  ${noiseGLSL}

  float fresnel(vec3 V, vec3 N, float power) {
    float f0 = 0.02;
    return f0 + (1.0 - f0) * pow(clamp(1.0 - max(dot(V, N), 0.0), 0.0, 1.0), power);
  }

  float subsurfaceScatter(vec3 V, vec3 L, vec3 N) {
    vec3 H = normalize(L + N * 0.6);
    float VdotH = pow(clamp(dot(V, -H), 0.0, 1.0), 3.0);
    return VdotH * 0.5;
  }

  void main() {
    vec3 N = normalize(vNormal);
    vec3 V = normalize(uCameraPosition - vWorldPosition);
    vec3 L = normalize(uSunDirection);

    float F = fresnel(V, N, 5.0);
    float NdotL = max(dot(N, L), 0.0);
    float diffuse = NdotL * 0.6 + 0.4;

    // Dual specular lobes
    vec3 H = normalize(L + V);
    float NdotH = max(dot(N, H), 0.0);
    float specPrimary = pow(NdotH, 512.0) * 3.0;   // tight sun reflection
    float specSecondary = pow(NdotH, 64.0) * 0.35;  // broader glint
    float specTertiary = pow(NdotH, 8.0) * 0.08;    // very broad sheen

    // Water color
    float depthFactor = clamp(1.0 - F + vElevation * 0.12, 0.0, 1.0);
    vec3 waterColor = mix(uWaterColorShallow, uWaterColorDeep, depthFactor);

    // Reflection
    vec3 R = reflect(-V, N);
    float skyGrad = clamp(R.y * 0.5 + 0.5, 0.0, 1.0);

    float sunElev = L.y;
    vec3 sunColor = mix(
      vec3(1.0, 0.4, 0.12),
      vec3(1.0, 0.95, 0.85),
      clamp(sunElev * 2.5, 0.0, 1.0)
    );

    vec3 skyColor = mix(
      mix(vec3(0.75, 0.35, 0.18), vec3(0.15, 0.25, 0.5), clamp(sunElev * 3.0, 0.0, 1.0)),
      mix(vec3(0.4, 0.6, 0.9), vec3(0.18, 0.3, 0.65), skyGrad),
      clamp(sunElev * 2.0, 0.0, 1.0)
    );
    vec3 reflectedColor = skyColor * (0.7 + 0.3 * skyGrad);

    // SSS for translucent wave edges
    float sss = subsurfaceScatter(V, L, N);
    vec3 sssColor = uWaterColorShallow * 3.0 * sss * uLightIntensity;

    // Sun path on water (elongated reflection)
    vec3 sunReflDir = reflect(-L, vec3(0.0, 1.0, 0.0));
    float sunPathAngle = acos(clamp(dot(V, sunReflDir), -1.0, 1.0));
    float sunPath = exp(-sunPathAngle * sunPathAngle * 8.0) * 0.15 * uLightIntensity;

    // Combine
    vec3 color = waterColor * diffuse * uLightIntensity;
    color = mix(color, reflectedColor, F * 0.7);
    color += sunColor * (specPrimary + specSecondary + specTertiary) * uLightIntensity * F;
    color += sssColor;
    color += sunColor * sunPath * (1.0 - F * 0.3);

    // Foam
    float windFactor = uWindSpeed / 20.0;
    float foamThreshold = uWaveHeight * 0.5;
    float foam = smoothstep(foamThreshold, foamThreshold * 2.0, vElevation) * windFactor;
    // Noise-based foam pattern
    float foamNoise = snoise(vec3(vWorldPosition.xz * 0.15, uTime * 0.2));
    foam *= smoothstep(-0.2, 0.3, foamNoise);
    color = mix(color, vec3(0.82, 0.88, 0.92) * uLightIntensity * 0.8, foam * 0.55);

    // Atmospheric fog/haze
    float dist = length(uCameraPosition - vWorldPosition);
    float fogFactor = 1.0 - exp(-dist * 0.0007);
    vec3 fogColor = mix(
      vec3(0.55, 0.65, 0.8),
      vec3(0.8, 0.5, 0.3),
      clamp(1.0 - sunElev * 3.0, 0.0, 0.6)
    ) * uLightIntensity * 0.7;
    color = mix(color, fogColor, fogFactor);

    // ACES tonemap
    color *= 0.9;
    vec3 a = color * (color + 0.0245786) - 0.000090537;
    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;
    color = a / b;

    // Gamma
    color = pow(clamp(color, 0.0, 1.0), vec3(1.0 / 2.2));

    gl_FragColor = vec4(color, 0.96);
  }
`;

// ==================== SKY SHADER ====================
const skyVertexShader = `
  varying vec3 vWorldPosition;
  void main() {
    vec4 worldPos = modelMatrix * vec4(position, 1.0);
    vWorldPosition = worldPos.xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const skyFragmentShader = `
  precision highp float;
  uniform vec3 uSunDirection;
  uniform float uLightIntensity;
  varying vec3 vWorldPosition;

  // Simple hash for stars
  float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
  }

  void main() {
    vec3 dir = normalize(vWorldPosition);
    vec3 L = normalize(uSunDirection);
    float sunElev = L.y;

    float y = max(dir.y, 0.0);

    // Improved atmospheric scattering approximation
    vec3 zenith = mix(vec3(0.05, 0.08, 0.2), vec3(0.12, 0.32, 0.72), clamp(sunElev * 2.5, 0.0, 1.0));
    vec3 horizon = mix(vec3(0.65, 0.3, 0.15), vec3(0.5, 0.68, 0.88), clamp(sunElev * 2.5, 0.0, 1.0));

    vec3 skyColor = mix(horizon, zenith, pow(y, 0.45));

    // Rayleigh-like scattering near sun
    float sunAngle = acos(clamp(dot(dir, L), -1.0, 1.0));
    float rayleigh = pow(1.0 + dot(dir, L), 2.0) * 0.08;
    skyColor += vec3(0.3, 0.4, 0.6) * rayleigh * clamp(sunElev, 0.0, 1.0);

    // Sunset/sunrise coloring
    float horizonGlow = pow(max(1.0 - y, 0.0), 10.0) * clamp(1.0 - sunElev * 2.0, 0.0, 1.0);
    vec3 sunsetColor = mix(vec3(1.0, 0.3, 0.05), vec3(1.0, 0.55, 0.2), y * 4.0);
    skyColor = mix(skyColor, sunsetColor, horizonGlow * 0.7);

    // Mie-like sun glow
    float sunDisk = smoothstep(0.025, 0.008, sunAngle);
    float sunGlow = exp(-sunAngle * 5.0) * 0.6;
    float sunHalo = exp(-sunAngle * 1.8) * 0.18;

    vec3 sunCol = mix(vec3(1.0, 0.45, 0.15), vec3(1.0, 0.95, 0.85), clamp(sunElev * 3.0, 0.0, 1.0));
    skyColor += sunCol * (sunDisk * 4.0 + sunGlow + sunHalo) * uLightIntensity;

    // Stars at night/dusk
    if (sunElev < 0.15) {
      float night = smoothstep(0.15, -0.05, sunElev);
      skyColor *= (1.0 - night * 0.75);

      // Stars
      vec2 starUv = dir.xz / (dir.y + 0.01) * 100.0;
      float star = hash(floor(starUv));
      star = step(0.998, star) * smoothstep(0.0, 0.3, y);
      float twinkle = 0.7 + 0.3 * sin(star * 6283.0 + sunAngle * 10.0);
      skyColor += vec3(0.8, 0.85, 1.0) * star * night * twinkle * 0.6;
    }

    // Below horizon: dark ocean color
    if (dir.y < 0.0) {
      vec3 belowColor = mix(vec3(0.01, 0.03, 0.06), vec3(0.04, 0.07, 0.12), clamp(sunElev, 0.0, 1.0));
      skyColor = mix(skyColor, belowColor, smoothstep(0.0, -0.08, dir.y));
    }

    // ACES tonemap
    vec3 c = skyColor * 0.9;
    vec3 a = c * (c + 0.0245786) - 0.000090537;
    vec3 b = c * (0.983729 * c + 0.4329510) + 0.238081;
    skyColor = a / b;

    skyColor = pow(clamp(skyColor, 0.0, 1.0), vec3(1.0 / 2.2));

    gl_FragColor = vec4(skyColor, 1.0);
  }
`;

// ==================== SPRAY PARTICLE SHADER ====================
const sprayVertexShader = `
  attribute float size;
  attribute float opacity;
  varying float vOpacity;
  void main() {
    vOpacity = opacity;
    vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
    gl_PointSize = size * (200.0 / -mvPos.z);
    gl_Position = projectionMatrix * mvPos;
  }
`;

const sprayFragmentShader = `
  precision highp float;
  uniform vec3 uColor;
  varying float vOpacity;
  void main() {
    float d = length(gl_PointCoord - 0.5) * 2.0;
    float alpha = smoothstep(1.0, 0.3, d) * vOpacity;
    gl_FragColor = vec4(uColor, alpha);
  }
`;

// ==================== SCENE SETUP ====================
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: 'high-performance' });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.NoToneMapping;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.5, 10000);
camera.position.set(-25, 18, 55);

const orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.enableDamping = true;
orbitControls.dampingFactor = 0.04;
orbitControls.maxPolarAngle = Math.PI * 0.485;
orbitControls.minPolarAngle = Math.PI * 0.1;
orbitControls.minDistance = 8;
orbitControls.maxDistance = 200;
orbitControls.target.set(0, -2, 0);
orbitControls.autoRotate = true;
orbitControls.autoRotateSpeed = 0.25;

// Hide hint on interaction
let hintHidden = false;
renderer.domElement.addEventListener('pointerdown', () => {
  if (!hintHidden) {
    hintHidden = true;
    document.getElementById('hint').classList.add('hidden');
  }
}, { once: true });

// ==================== SKY DOME ====================
const skyGeo = new THREE.SphereGeometry(5000, 48, 24);
const skyMat = new THREE.ShaderMaterial({
  vertexShader: skyVertexShader,
  fragmentShader: skyFragmentShader,
  uniforms: {
    uSunDirection: { value: new THREE.Vector3() },
    uLightIntensity: { value: 1.0 },
  },
  side: THREE.BackSide,
  depthWrite: false,
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

// ==================== WATER ====================
const waterGeo = new THREE.PlaneGeometry(1000, 1000, 512, 512);
waterGeo.rotateX(-Math.PI / 2);

const waterMat = new THREE.ShaderMaterial({
  vertexShader: waterVertexShader,
  fragmentShader: waterFragmentShader,
  uniforms: {
    uTime: { value: 0 },
    uWaveHeight: { value: params.waveHeight },
    uWindSpeed: { value: params.windSpeed },
    uChoppiness: { value: params.choppiness },
    uSunDirection: { value: new THREE.Vector3() },
    uLightIntensity: { value: params.lightIntensity },
    uWaterColorDeep: { value: params.waterColorDeep },
    uWaterColorShallow: { value: params.waterColorShallow },
    uCameraPosition: { value: camera.position.clone() },
  },
  transparent: true,
  depthWrite: true,
});

scene.add(new THREE.Mesh(waterGeo, waterMat));

// ==================== SPRAY PARTICLES ====================
const SPRAY_COUNT = 2000;
const sprayPositions = new Float32Array(SPRAY_COUNT * 3);
const spraySizes = new Float32Array(SPRAY_COUNT);
const sprayOpacities = new Float32Array(SPRAY_COUNT);
const sprayVelocities = new Float32Array(SPRAY_COUNT * 3);
const sprayLife = new Float32Array(SPRAY_COUNT);

for (let i = 0; i < SPRAY_COUNT; i++) {
  sprayLife[i] = -1; // inactive
  spraySizes[i] = 0;
  sprayOpacities[i] = 0;
}

const sprayGeo = new THREE.BufferGeometry();
sprayGeo.setAttribute('position', new THREE.BufferAttribute(sprayPositions, 3));
sprayGeo.setAttribute('size', new THREE.BufferAttribute(spraySizes, 1));
sprayGeo.setAttribute('opacity', new THREE.BufferAttribute(sprayOpacities, 1));

const sprayMat = new THREE.ShaderMaterial({
  vertexShader: sprayVertexShader,
  fragmentShader: sprayFragmentShader,
  uniforms: { uColor: { value: new THREE.Color(0.85, 0.9, 0.95) } },
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
});

const sprayMesh = new THREE.Points(sprayGeo, sprayMat);
scene.add(sprayMesh);

function emitSpray(count) {
  let emitted = 0;
  for (let i = 0; i < SPRAY_COUNT && emitted < count; i++) {
    if (sprayLife[i] < 0) {
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * 80;
      sprayPositions[i * 3] = Math.cos(angle) * radius;
      sprayPositions[i * 3 + 1] = Math.random() * params.waveHeight * 0.5;
      sprayPositions[i * 3 + 2] = Math.sin(angle) * radius;

      const speed = 0.5 + Math.random() * 1.5;
      sprayVelocities[i * 3] = (Math.random() - 0.5) * speed;
      sprayVelocities[i * 3 + 1] = 1.0 + Math.random() * 3.0 * (params.windSpeed / 30);
      sprayVelocities[i * 3 + 2] = (Math.random() - 0.5) * speed;

      sprayLife[i] = 1.0 + Math.random() * 1.5;
      spraySizes[i] = 1.0 + Math.random() * 2.5;
      sprayOpacities[i] = 0.4 + Math.random() * 0.4;
      emitted++;
    }
  }
}

function updateSpray(delta) {
  const windEmitRate = Math.floor(params.windSpeed * 0.8);
  if (windEmitRate > 2) emitSpray(Math.min(windEmitRate, 20));

  for (let i = 0; i < SPRAY_COUNT; i++) {
    if (sprayLife[i] < 0) continue;
    sprayLife[i] -= delta;
    if (sprayLife[i] < 0) {
      sprayOpacities[i] = 0;
      continue;
    }

    sprayPositions[i * 3] += sprayVelocities[i * 3] * delta;
    sprayVelocities[i * 3 + 1] -= 4.0 * delta; // gravity
    sprayPositions[i * 3 + 1] += sprayVelocities[i * 3 + 1] * delta;
    sprayPositions[i * 3 + 2] += sprayVelocities[i * 3 + 2] * delta;

    // Wind drift
    sprayPositions[i * 3] += params.windSpeed * 0.02 * delta;

    // Fade out
    sprayOpacities[i] = Math.min(sprayLife[i] * 0.8, 0.5) * (params.windSpeed / 30);

    // Kill below water
    if (sprayPositions[i * 3 + 1] < -0.5) {
      sprayLife[i] = -1;
      sprayOpacities[i] = 0;
    }
  }

  sprayGeo.attributes.position.needsUpdate = true;
  sprayGeo.attributes.size.needsUpdate = true;
  sprayGeo.attributes.opacity.needsUpdate = true;
}

// ==================== LIGHTING HELPER ====================
function updateSunDirection() {
  const elevRad = (params.sunElevation * Math.PI) / 180;
  const azRad = (params.sunAzimuth * Math.PI) / 180;
  const dir = new THREE.Vector3(
    Math.cos(elevRad) * Math.sin(azRad),
    Math.sin(elevRad),
    Math.cos(elevRad) * Math.cos(azRad)
  ).normalize();

  waterMat.uniforms.uSunDirection.value.copy(dir);
  skyMat.uniforms.uSunDirection.value.copy(dir);
  waterMat.uniforms.uLightIntensity.value = params.lightIntensity;
  skyMat.uniforms.uLightIntensity.value = params.lightIntensity;

  const sunY = dir.y;
  const bgR = THREE.MathUtils.lerp(0.03, 0.06, Math.max(0, sunY));
  const bgG = THREE.MathUtils.lerp(0.04, 0.1, Math.max(0, sunY));
  const bgB = THREE.MathUtils.lerp(0.07, 0.18, Math.max(0, sunY));
  renderer.setClearColor(new THREE.Color(bgR, bgG, bgB));
}

// ==================== UI CONTROLS ====================
const els = {
  windSpeed: document.getElementById('wind-speed'),
  waveHeight: document.getElementById('wave-height'),
  choppiness: document.getElementById('choppiness'),
  waveSpeed: document.getElementById('wave-speed'),
  sunElevation: document.getElementById('sun-elevation'),
  sunAzimuth: document.getElementById('sun-azimuth'),
  lightIntensity: document.getElementById('light-intensity'),
  waterColorDeep: document.getElementById('water-color-deep'),
  waterColorShallow: document.getElementById('water-color-shallow'),
};

const vals = {
  wind: document.getElementById('wind-val'),
  height: document.getElementById('height-val'),
  chop: document.getElementById('chop-val'),
  speed: document.getElementById('speed-val'),
  sun: document.getElementById('sun-val'),
  azimuth: document.getElementById('azimuth-val'),
  intensity: document.getElementById('intensity-val'),
};

function updateUI() {
  els.windSpeed.value = params.windSpeed;
  els.waveHeight.value = params.waveHeight;
  els.choppiness.value = params.choppiness;
  els.waveSpeed.value = params.waveSpeed;
  els.sunElevation.value = params.sunElevation;
  els.sunAzimuth.value = params.sunAzimuth;
  els.lightIntensity.value = params.lightIntensity;

  vals.wind.textContent = params.windSpeed.toFixed(0) + ' knots';
  vals.height.textContent = params.waveHeight.toFixed(1) + ' m';
  vals.chop.textContent = params.choppiness.toFixed(2);
  vals.speed.textContent = params.waveSpeed.toFixed(1) + 'x';
  vals.sun.textContent = params.sunElevation.toFixed(0) + '\u00b0';
  vals.azimuth.textContent = params.sunAzimuth.toFixed(0) + '\u00b0';
  vals.intensity.textContent = params.lightIntensity.toFixed(2);
}

function syncUniforms() {
  waterMat.uniforms.uWaveHeight.value = params.waveHeight;
  waterMat.uniforms.uWindSpeed.value = params.windSpeed;
  waterMat.uniforms.uChoppiness.value = params.choppiness;
  updateSunDirection();
}

function clearActivePreset() {
  document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
}

els.windSpeed.addEventListener('input', e => { params.windSpeed = +e.target.value; vals.wind.textContent = params.windSpeed.toFixed(0) + ' knots'; syncUniforms(); clearActivePreset(); });
els.waveHeight.addEventListener('input', e => { params.waveHeight = +e.target.value; vals.height.textContent = params.waveHeight.toFixed(1) + ' m'; syncUniforms(); clearActivePreset(); });
els.choppiness.addEventListener('input', e => { params.choppiness = +e.target.value; vals.chop.textContent = params.choppiness.toFixed(2); syncUniforms(); clearActivePreset(); });
els.waveSpeed.addEventListener('input', e => { params.waveSpeed = +e.target.value; vals.speed.textContent = params.waveSpeed.toFixed(1) + 'x'; clearActivePreset(); });
els.sunElevation.addEventListener('input', e => { params.sunElevation = +e.target.value; vals.sun.textContent = params.sunElevation.toFixed(0) + '\u00b0'; updateSunDirection(); clearActivePreset(); });
els.sunAzimuth.addEventListener('input', e => { params.sunAzimuth = +e.target.value; vals.azimuth.textContent = params.sunAzimuth.toFixed(0) + '\u00b0'; updateSunDirection(); clearActivePreset(); });
els.lightIntensity.addEventListener('input', e => { params.lightIntensity = +e.target.value; vals.intensity.textContent = params.lightIntensity.toFixed(2); updateSunDirection(); clearActivePreset(); });

els.waterColorDeep.addEventListener('input', e => {
  params.waterColorDeep.set(e.target.value);
  document.getElementById('swatch-deep-inner').style.background = e.target.value;
  clearActivePreset();
});
els.waterColorShallow.addEventListener('input', e => {
  params.waterColorShallow.set(e.target.value);
  document.getElementById('swatch-shallow-inner').style.background = e.target.value;
  clearActivePreset();
});

// ==================== PRESETS ====================
let presetAnimId = null;

function applyPreset(name) {
  const p = presets[name];
  if (!p) return;

  if (presetAnimId) cancelAnimationFrame(presetAnimId);

  const start = {
    windSpeed: params.windSpeed,
    waveHeight: params.waveHeight,
    choppiness: params.choppiness,
    waveSpeed: params.waveSpeed,
    sunElevation: params.sunElevation,
    sunAzimuth: params.sunAzimuth,
    lightIntensity: params.lightIntensity,
  };
  const startTime = performance.now();
  const duration = 1800;

  function tick() {
    const t = Math.min((performance.now() - startTime) / duration, 1);
    const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

    params.windSpeed = THREE.MathUtils.lerp(start.windSpeed, p.windSpeed, ease);
    params.waveHeight = THREE.MathUtils.lerp(start.waveHeight, p.waveHeight, ease);
    params.choppiness = THREE.MathUtils.lerp(start.choppiness, p.choppiness, ease);
    params.waveSpeed = THREE.MathUtils.lerp(start.waveSpeed, p.waveSpeed, ease);
    params.sunElevation = THREE.MathUtils.lerp(start.sunElevation, p.sunElevation, ease);
    params.sunAzimuth = THREE.MathUtils.lerp(start.sunAzimuth, p.sunAzimuth, ease);
    params.lightIntensity = THREE.MathUtils.lerp(start.lightIntensity, p.lightIntensity, ease);

    syncUniforms();
    updateUI();

    if (t < 1) presetAnimId = requestAnimationFrame(tick);
    else presetAnimId = null;
  }
  presetAnimId = requestAnimationFrame(tick);

  params.waterColorDeep.set(p.deep);
  params.waterColorShallow.set(p.shallow);
  els.waterColorDeep.value = p.deep;
  els.waterColorShallow.value = p.shallow;
  document.getElementById('swatch-deep-inner').style.background = p.deep;
  document.getElementById('swatch-shallow-inner').style.background = p.shallow;

  document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
  document.querySelector(`[data-preset="${name}"]`)?.classList.add('active');
}

document.querySelectorAll('.preset-btn').forEach(btn => {
  btn.addEventListener('click', () => applyPreset(btn.dataset.preset));
});

// Panel toggle
const controlsPanel = document.getElementById('controls');
const toggleBtn = document.getElementById('toggle-btn');

document.getElementById('close-panel').addEventListener('click', () => {
  controlsPanel.classList.add('collapsed');
  setTimeout(() => toggleBtn.classList.remove('hidden'), 300);
});

toggleBtn.addEventListener('click', () => {
  toggleBtn.classList.add('hidden');
  controlsPanel.classList.remove('collapsed');
});

// ==================== RESIZE ====================
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ==================== ANIMATION LOOP ====================
let time = 0;
let lastFrameTime = performance.now();
let frameCount = 0;
let fpsAccum = 0;
const fpsEl = document.getElementById('fps-counter');

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now();
  const delta = Math.min((now - lastFrameTime) / 1000, 0.1); // cap delta
  lastFrameTime = now;

  // FPS
  frameCount++;
  fpsAccum += delta;
  if (fpsAccum >= 0.5) {
    fpsEl.textContent = Math.round(frameCount / fpsAccum) + ' FPS';
    frameCount = 0;
    fpsAccum = 0;
  }

  time += delta * params.waveSpeed;
  waterMat.uniforms.uTime.value = time;
  waterMat.uniforms.uCameraPosition.value.copy(camera.position);

  updateSpray(delta);

  orbitControls.update();
  renderer.render(scene, camera);
}

// ==================== INIT ====================
updateSunDirection();
updateUI();

// Auto-hide hint after 5 seconds
setTimeout(() => {
  if (!hintHidden) {
    document.getElementById('hint').classList.add('hidden');
    hintHidden = true;
  }
}, 6000);

// Fade in
setTimeout(() => {
  const loading = document.getElementById('loading');
  loading.classList.add('fade-out');
  setTimeout(() => loading.remove(), 1200);
}, 600);

animate();
</script>
</body>
</html>
