<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroid Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #000 100%);
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            font-size: 18px;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            text-shadow: 0 0 20px #f00;
            font-size: 48px;
            display: none;
            text-align: center;
        }
        #gameOver button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 24px;
            background: #f00;
            color: #000;
            border: 2px solid #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        #gameOver button:hover {
            background: #fff;
            color: #f00;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Enemies: <span id="enemies">0</span></div>
    </div>
    <div id="gameOver">
        <div>GAME OVER</div>
        <div style="font-size: 24px; margin-top: 10px;">Final Score: <span id="finalScore">0</span></div>
        <button onclick="location.reload()">RESTART</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game state
        let gameRunning = true;
        let score = 0;
        let keys = {};
        let particles = [];

        // Player
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            vx: 0,
            vy: 0,
            angle: 0,
            health: 100,
            maxHealth: 100,
            speed: 0.3,
            rotation: 0.05,
            bullets: [],
            lastShot: 0,
            shootCooldown: 200
        };

        // Enemies
        let enemies = [];
        const maxEnemies = 3;

        // Asteroids
        let asteroids = [];
        const maxAsteroids = 8;

        // Stars background
        const stars = Array.from({length: 200}, () => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2,
            alpha: Math.random()
        }));

        // Input handling
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        // Create particle
        function createParticle(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 1,
                    color
                });
            }
        }

        // Draw player ship (triangular with thrusters)
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);

            // Ship body
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(20, 0);
            ctx.lineTo(-15, -12);
            ctx.lineTo(-10, 0);
            ctx.lineTo(-15, 12);
            ctx.closePath();
            ctx.fill();

            // Cockpit
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(8, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            // Thruster effect
            if (keys['w'] || keys['ArrowUp']) {
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.moveTo(-10, -5);
                ctx.lineTo(-20 - Math.random() * 10, 0);
                ctx.lineTo(-10, 5);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        // Draw enemy ship
        function drawEnemy(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);

            // Enemy body (hexagonal)
            ctx.fillStyle = '#ff0066';
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * 12;
                const y = Math.sin(angle) * 12;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            // Center eye
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw asteroid
        function drawAsteroid(asteroid) {
            ctx.save();
            ctx.translate(asteroid.x, asteroid.y);
            ctx.rotate(asteroid.rotation);

            ctx.fillStyle = '#888888';
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const points = asteroid.points;
            for (let i = 0; i < points.length; i++) {
                const angle = (i / points.length) * Math.PI * 2;
                const radius = asteroid.size * points[i];
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        // Create asteroid
        function createAsteroid(size = 30) {
            const side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;

            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -50; break;
                case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                case 3: x = -50; y = Math.random() * canvas.height; break;
            }

            const angle = Math.atan2(canvas.height / 2 - y, canvas.width / 2 - x);
            const speed = 1 + Math.random() * 2;

            asteroids.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                points: Array.from({length: 8}, () => 0.8 + Math.random() * 0.4)
            });
        }

        // Create enemy
        function createEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -50; break;
                case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                case 3: x = -50; y = Math.random() * canvas.height; break;
            }

            enemies.push({
                x, y,
                vx: 0,
                vy: 0,
                angle: 0,
                health: 50,
                bullets: [],
                lastShot: Date.now(),
                shootCooldown: 1000 + Math.random() * 1000
            });
        }

        // Update player
        function updatePlayer() {
            // Rotation
            if (keys['a'] || keys['ArrowLeft']) player.angle -= player.rotation;
            if (keys['d'] || keys['ArrowRight']) player.angle += player.rotation;

            // Thrust
            if (keys['w'] || keys['ArrowUp']) {
                player.vx += Math.cos(player.angle) * player.speed;
                player.vy += Math.sin(player.angle) * player.speed;
            }

            // Apply drag
            player.vx *= 0.99;
            player.vy *= 0.99;

            // Update position
            player.x += player.vx;
            player.y += player.vy;

            // Wrap around screen
            if (player.x < 0) player.x = canvas.width;
            if (player.x > canvas.width) player.x = 0;
            if (player.y < 0) player.y = canvas.height;
            if (player.y > canvas.height) player.y = 0;

            // Shooting
            if (keys[' '] && Date.now() - player.lastShot > player.shootCooldown) {
                player.bullets.push({
                    x: player.x + Math.cos(player.angle) * 20,
                    y: player.y + Math.sin(player.angle) * 20,
                    vx: Math.cos(player.angle) * 8 + player.vx,
                    vy: Math.sin(player.angle) * 8 + player.vy,
                    life: 60
                });
                player.lastShot = Date.now();
            }

            // Update bullets
            player.bullets = player.bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life--;
                return bullet.life > 0;
            });
        }

        // Update enemies
        function updateEnemies() {
            enemies.forEach(enemy => {
                // AI: Move toward player
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                enemy.angle = Math.atan2(dy, dx);

                if (dist > 200) {
                    enemy.vx = Math.cos(enemy.angle) * 2;
                    enemy.vy = Math.sin(enemy.angle) * 2;
                } else {
                    enemy.vx *= 0.95;
                    enemy.vy *= 0.95;
                }

                enemy.x += enemy.vx;
                enemy.y += enemy.vy;

                // Wrap around
                if (enemy.x < -50) enemy.x = canvas.width + 50;
                if (enemy.x > canvas.width + 50) enemy.x = -50;
                if (enemy.y < -50) enemy.y = canvas.height + 50;
                if (enemy.y > canvas.height + 50) enemy.y = -50;

                // Shoot at player
                if (dist < 400 && Date.now() - enemy.lastShot > enemy.shootCooldown) {
                    enemy.bullets.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: Math.cos(enemy.angle) * 5,
                        vy: Math.sin(enemy.angle) * 5,
                        life: 80
                    });
                    enemy.lastShot = Date.now();
                }

                // Update bullets
                enemy.bullets = enemy.bullets.filter(bullet => {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    bullet.life--;

                    // Check collision with player
                    const dx = bullet.x - player.x;
                    const dy = bullet.y - player.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 20) {
                        player.health -= 10;
                        createParticle(bullet.x, bullet.y, '#00ffff', 10);
                        return false;
                    }

                    return bullet.life > 0;
                });
            });
        }

        // Update asteroids
        function updateAsteroids() {
            asteroids.forEach(asteroid => {
                asteroid.x += asteroid.vx;
                asteroid.y += asteroid.vy;
                asteroid.rotation += asteroid.rotationSpeed;

                // Wrap around
                if (asteroid.x < -100) asteroid.x = canvas.width + 100;
                if (asteroid.x > canvas.width + 100) asteroid.x = -100;
                if (asteroid.y < -100) asteroid.y = canvas.height + 100;
                if (asteroid.y > canvas.height + 100) asteroid.y = -100;
            });
        }

        // Check collisions
        function checkCollisions() {
            // Player bullets vs asteroids
            player.bullets.forEach((bullet, bi) => {
                asteroids.forEach((asteroid, ai) => {
                    const dx = bullet.x - asteroid.x;
                    const dy = bullet.y - asteroid.y;
                    if (Math.sqrt(dx * dx + dy * dy) < asteroid.size) {
                        player.bullets.splice(bi, 1);
                        createParticle(asteroid.x, asteroid.y, '#888888', 30);

                        if (asteroid.size > 15) {
                            // Split into smaller asteroids
                            const newSize = asteroid.size / 2;
                            for (let i = 0; i < 2; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                asteroids.push({
                                    x: asteroid.x,
                                    y: asteroid.y,
                                    vx: Math.cos(angle) * 2,
                                    vy: Math.sin(angle) * 2,
                                    size: newSize,
                                    rotation: 0,
                                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                                    points: Array.from({length: 8}, () => 0.8 + Math.random() * 0.4)
                                });
                            }
                        }

                        asteroids.splice(ai, 1);
                        score += 10;
                    }
                });
            });

            // Player bullets vs enemies
            player.bullets.forEach((bullet, bi) => {
                enemies.forEach((enemy, ei) => {
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 15) {
                        player.bullets.splice(bi, 1);
                        enemy.health -= 25;
                        createParticle(enemy.x, enemy.y, '#ff0066', 15);

                        if (enemy.health <= 0) {
                            createParticle(enemy.x, enemy.y, '#ff0066', 50);
                            enemies.splice(ei, 1);
                            score += 100;
                        }
                    }
                });
            });

            // Player vs asteroids
            asteroids.forEach(asteroid => {
                const dx = player.x - asteroid.x;
                const dy = player.y - asteroid.y;
                if (Math.sqrt(dx * dx + dy * dy) < asteroid.size + 15) {
                    player.health -= 20;
                    createParticle(player.x, player.y, '#00ffff', 20);
                    createParticle(asteroid.x, asteroid.y, '#888888', 20);
                    asteroids.splice(asteroids.indexOf(asteroid), 1);
                }
            });

            // Player vs enemies (collision)
            enemies.forEach(enemy => {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                if (Math.sqrt(dx * dx + dy * dy) < 25) {
                    player.health -= 15;
                    enemy.health -= 25;
                    createParticle(player.x, player.y, '#00ffff', 15);
                    createParticle(enemy.x, enemy.y, '#ff0066', 15);
                }
            });
        }

        // Update particles
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        // Draw everything
        function draw() {
            // Clear with fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
                star.alpha += (Math.random() - 0.5) * 0.1;
                star.alpha = Math.max(0.1, Math.min(1, star.alpha));
            });

            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, 3, 3);
            });
            ctx.globalAlpha = 1;

            // Draw asteroids
            asteroids.forEach(drawAsteroid);

            // Draw bullets
            ctx.fillStyle = '#00ff00';
            player.bullets.forEach(bullet => {
                ctx.fillRect(bullet.x - 2, bullet.y - 2, 4, 4);
            });

            // Draw enemies
            enemies.forEach(enemy => {
                drawEnemy(enemy);
                ctx.fillStyle = '#ffff00';
                enemy.bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x - 2, bullet.y - 2, 4, 4);
                });
            });

            // Draw player
            drawPlayer();
        }

        // Game loop
        function gameLoop() {
            if (!gameRunning) return;

            updatePlayer();
            updateEnemies();
            updateAsteroids();
            updateParticles();
            checkCollisions();
            draw();

            // Spawn asteroids
            while (asteroids.length < maxAsteroids) {
                createAsteroid(20 + Math.random() * 20);
            }

            // Spawn enemies
            if (enemies.length < maxEnemies && Math.random() < 0.01) {
                createEnemy();
            }

            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('health').textContent = Math.max(0, Math.floor(player.health));
            document.getElementById('enemies').textContent = enemies.length;

            // Check game over
            if (player.health <= 0) {
                gameRunning = false;
                document.getElementById('finalScore').textContent = score;
                document.getElementById('gameOver').style.display = 'block';
            }

            requestAnimationFrame(gameLoop);
        }

        // Start game
        for (let i = 0; i < 5; i++) {
            createAsteroid(20 + Math.random() * 20);
        }
        createEnemy();
        gameLoop();
    </script>
</body>
</html>