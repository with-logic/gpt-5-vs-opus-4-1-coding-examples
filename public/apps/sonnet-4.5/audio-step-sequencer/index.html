<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Step Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff88;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: rgba(10, 14, 39, 0.8);
            border: 2px solid #00ff88;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3),
                        inset 0 0 50px rgba(0, 255, 136, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 20px #00ff88,
                         0 0 40px #00ff88,
                         0 0 60px #00ff88;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .subtitle {
            text-align: center;
            color: #00ddff;
            margin-bottom: 30px;
            font-size: 0.9em;
            letter-spacing: 2px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 255, 136, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #00ddff;
        }

        .control-group input,
        .control-group select {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            transition: all 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            border-color: #00ddff;
        }

        .control-group input[type="range"] {
            cursor: pointer;
            accent-color: #00ff88;
        }

        .value-display {
            color: #00ff88;
            font-weight: bold;
            text-align: center;
            font-size: 1.1em;
        }

        .sequencer-grid {
            margin-bottom: 30px;
        }

        .track {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .track-label {
            width: 100px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 1px;
            color: #00ddff;
        }

        .steps {
            display: flex;
            gap: 8px;
            flex: 1;
        }

        .step {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .step::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, rgba(0, 255, 136, 0.3) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .step:hover::before {
            opacity: 1;
        }

        .step.active {
            background: linear-gradient(135deg, #00ff88 0%, #00ddff 100%);
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
        }

        .step.playing {
            animation: stepPlay 0.3s ease-out;
            border-color: #ff00ff;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        @keyframes stepPlay {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .step.current {
            border-color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }

        .step.beat-marker {
            border-color: #ffff00;
        }

        .buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        button {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 221, 255, 0.2) 100%);
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 12px 30px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            border-color: #00ddff;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button span {
            position: relative;
            z-index: 1;
        }

        button.playing {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.3) 0%, rgba(255, 0, 100, 0.3) 100%);
            border-color: #ff00ff;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pattern-manager {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .pattern-manager input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .status-message {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-message.success {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .status-message.error {
            background: rgba(255, 0, 136, 0.2);
            border: 1px solid #ff0088;
            color: #ff0088;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .step {
                width: 35px;
                height: 35px;
            }

            .track-label {
                width: 70px;
                font-size: 0.75em;
            }

            .steps {
                gap: 4px;
            }

            .controls {
                grid-template-columns: 1fr;
            }
        }

        .visualizer {
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .visualizer-bar {
            position: absolute;
            bottom: 0;
            width: 4px;
            background: linear-gradient(to top, #00ff88, #00ddff);
            transition: height 0.1s;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° SEQUENCER ‚ö°</h1>
        <div class="subtitle">16-Step Audio Matrix</div>

        <div class="visualizer" id="visualizer"></div>

        <div class="controls">
            <div class="control-group">
                <label for="tempo">Tempo (BPM)</label>
                <input type="range" id="tempo" min="60" max="200" value="120" step="1">
                <div class="value-display" id="tempoValue">120</div>
            </div>

            <div class="control-group">
                <label for="swing">Swing (%)</label>
                <input type="range" id="swing" min="0" max="100" value="0" step="5">
                <div class="value-display" id="swingValue">0</div>
            </div>

            <div class="control-group">
                <label for="masterVolume">Master Volume</label>
                <input type="range" id="masterVolume" min="0" max="100" value="70" step="1">
                <div class="value-display" id="volumeValue">70</div>
            </div>
        </div>

        <div class="sequencer-grid" id="sequencerGrid"></div>

        <div class="buttons">
            <button id="playBtn"><span>‚ñ∂ PLAY</span></button>
            <button id="stopBtn"><span>‚ñ† STOP</span></button>
            <button id="clearBtn"><span>‚úï CLEAR</span></button>
            <button id="randomBtn"><span>‚óà RANDOM</span></button>
            <button id="exportBtn"><span>‚¨á EXPORT WAV</span></button>
        </div>

        <div class="pattern-manager">
            <input type="text" id="patternName" placeholder="Pattern name...">
            <button id="saveBtn"><span>üíæ SAVE</span></button>
            <button id="loadBtn"><span>üìÅ LOAD</span></button>
            <select id="patternSelect">
                <option value="">Select pattern...</option>
            </select>
        </div>

        <div class="status-message" id="statusMessage"></div>
    </div>

    <script>
        // Audio Context and Global Variables
        let audioContext;
        let masterGain;
        let isPlaying = false;
        let currentStep = 0;
        let tempo = 120;
        let swing = 0;
        let intervalId;
        let nextNoteTime = 0;
        let scheduleAheadTime = 0.1;
        let lookahead = 25.0;

        const tracks = [
            { name: 'Kick', frequency: 60, type: 'kick' },
            { name: 'Snare', frequency: 200, type: 'snare' },
            { name: 'Hi-Hat', frequency: 8000, type: 'hihat' },
            { name: 'Tom', frequency: 150, type: 'tom' },
            { name: 'Clap', frequency: 1000, type: 'clap' },
            { name: 'Rim', frequency: 3000, type: 'rim' }
        ];

        const grid = Array(tracks.length).fill(null).map(() => Array(16).fill(false));

        // Initialize Audio Context
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.7;
                masterGain.connect(audioContext.destination);
                updateVisualizerBars();
            }
        }

        // Drum Synthesizers
        function playKick(time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(40, time + 0.5);

            filter.type = 'lowpass';
            filter.frequency.value = 200;

            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);

            osc.start(time);
            osc.stop(time + 0.5);
        }

        function playSnare(time) {
            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < output.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            noise.buffer = noiseBuffer;

            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 1000;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(1, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

            const osc = audioContext.createOscillator();
            osc.frequency.value = 200;

            const oscGain = audioContext.createGain();
            oscGain.gain.setValueAtTime(0.7, time);
            oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(masterGain);

            osc.connect(oscGain);
            oscGain.connect(masterGain);

            noise.start(time);
            noise.stop(time + 0.2);
            osc.start(time);
            osc.stop(time + 0.1);
        }

        function playHiHat(time) {
            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < output.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            noise.buffer = noiseBuffer;

            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 7000;

            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);

            noise.start(time);
            noise.stop(time + 0.05);
        }

        function playTom(time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(60, time + 0.3);

            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

            osc.connect(gain);
            gain.connect(masterGain);

            osc.start(time);
            osc.stop(time + 0.3);
        }

        function playClap(time) {
            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < output.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            noise.buffer = noiseBuffer;

            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1000;
            filter.Q.value = 1;

            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.7, time);
            gain.gain.setValueAtTime(0.5, time + 0.01);
            gain.gain.setValueAtTime(0.7, time + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);

            noise.start(time);
            noise.stop(time + 0.1);
        }

        function playRim(time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.frequency.value = 3000;
            filter.type = 'highpass';
            filter.frequency.value = 2000;

            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.03);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);

            osc.start(time);
            osc.stop(time + 0.03);
        }

        function playSound(trackIndex, time) {
            const track = tracks[trackIndex];

            switch(track.type) {
                case 'kick':
                    playKick(time);
                    break;
                case 'snare':
                    playSnare(time);
                    break;
                case 'hihat':
                    playHiHat(time);
                    break;
                case 'tom':
                    playTom(time);
                    break;
                case 'clap':
                    playClap(time);
                    break;
                case 'rim':
                    playRim(time);
                    break;
            }
        }

        // Sequencer Logic
        function getStepDelay(stepIndex) {
            const sixteenthNote = 60 / tempo / 4;
            const swingAmount = (swing / 100) * sixteenthNote * 0.5;

            if (stepIndex % 2 === 1) {
                return sixteenthNote + swingAmount;
            }
            return sixteenthNote - swingAmount;
        }

        function scheduleNote(stepIndex, time) {
            for (let trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
                if (grid[trackIndex][stepIndex]) {
                    playSound(trackIndex, time);
                }
            }

            setTimeout(() => {
                updateStepVisuals(stepIndex);
            }, (time - audioContext.currentTime) * 1000);
        }

        function scheduler() {
            while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
                scheduleNote(currentStep, nextNoteTime);
                nextNoteTime += getStepDelay(currentStep);
                currentStep = (currentStep + 1) % 16;
            }
        }

        function play() {
            if (isPlaying) return;

            initAudio();
            isPlaying = true;
            currentStep = 0;
            nextNoteTime = audioContext.currentTime;

            document.getElementById('playBtn').classList.add('playing');

            intervalId = setInterval(scheduler, lookahead);
        }

        function stop() {
            if (!isPlaying) return;

            isPlaying = false;
            clearInterval(intervalId);

            document.getElementById('playBtn').classList.remove('playing');

            document.querySelectorAll('.step.current').forEach(step => {
                step.classList.remove('current');
            });
        }

        function updateStepVisuals(stepIndex) {
            document.querySelectorAll('.step.current').forEach(step => {
                step.classList.remove('current');
            });

            document.querySelectorAll(`.step[data-step="${stepIndex}"]`).forEach(step => {
                step.classList.add('current');

                if (step.classList.contains('active')) {
                    step.classList.add('playing');
                    setTimeout(() => step.classList.remove('playing'), 300);
                }
            });
        }

        // UI Functions
        function createGrid() {
            const gridElement = document.getElementById('sequencerGrid');
            gridElement.innerHTML = '';

            tracks.forEach((track, trackIndex) => {
                const trackDiv = document.createElement('div');
                trackDiv.className = 'track';

                const label = document.createElement('div');
                label.className = 'track-label';
                label.textContent = track.name;
                trackDiv.appendChild(label);

                const stepsDiv = document.createElement('div');
                stepsDiv.className = 'steps';

                for (let stepIndex = 0; stepIndex < 16; stepIndex++) {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'step';
                    stepDiv.dataset.track = trackIndex;
                    stepDiv.dataset.step = stepIndex;

                    if (stepIndex % 4 === 0) {
                        stepDiv.classList.add('beat-marker');
                    }

                    stepDiv.addEventListener('click', () => {
                        grid[trackIndex][stepIndex] = !grid[trackIndex][stepIndex];
                        stepDiv.classList.toggle('active');
                    });

                    stepsDiv.appendChild(stepDiv);
                }

                trackDiv.appendChild(stepsDiv);
                gridElement.appendChild(trackDiv);
            });
        }

        function clearGrid() {
            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    grid[i][j] = false;
                }
            }
            document.querySelectorAll('.step.active').forEach(step => {
                step.classList.remove('active');
            });
            showStatus('Grid cleared', 'success');
        }

        function randomizeGrid() {
            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    grid[i][j] = Math.random() > 0.7;
                }
            }

            document.querySelectorAll('.step').forEach(step => {
                const trackIndex = parseInt(step.dataset.track);
                const stepIndex = parseInt(step.dataset.step);

                if (grid[trackIndex][stepIndex]) {
                    step.classList.add('active');
                } else {
                    step.classList.remove('active');
                }
            });

            showStatus('Random pattern generated', 'success');
        }

        // Pattern Save/Load
        function savePattern() {
            const patternName = document.getElementById('patternName').value.trim();

            if (!patternName) {
                showStatus('Please enter a pattern name', 'error');
                return;
            }

            const pattern = {
                grid: grid.map(row => [...row]),
                tempo: tempo,
                swing: swing
            };

            localStorage.setItem(`pattern_${patternName}`, JSON.stringify(pattern));
            updatePatternList();
            showStatus(`Pattern "${patternName}" saved`, 'success');
            document.getElementById('patternName').value = '';
        }

        function loadPattern() {
            const patternSelect = document.getElementById('patternSelect');
            const patternName = patternSelect.value;

            if (!patternName) {
                showStatus('Please select a pattern', 'error');
                return;
            }

            const patternData = localStorage.getItem(`pattern_${patternName}`);

            if (!patternData) {
                showStatus('Pattern not found', 'error');
                return;
            }

            const pattern = JSON.parse(patternData);

            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    grid[i][j] = pattern.grid[i][j];
                }
            }

            document.querySelectorAll('.step').forEach(step => {
                const trackIndex = parseInt(step.dataset.track);
                const stepIndex = parseInt(step.dataset.step);

                if (grid[trackIndex][stepIndex]) {
                    step.classList.add('active');
                } else {
                    step.classList.remove('active');
                }
            });

            document.getElementById('tempo').value = pattern.tempo;
            document.getElementById('swing').value = pattern.swing;
            tempo = pattern.tempo;
            swing = pattern.swing;
            document.getElementById('tempoValue').textContent = tempo;
            document.getElementById('swingValue').textContent = swing;

            showStatus(`Pattern "${patternName}" loaded`, 'success');
        }

        function updatePatternList() {
            const patternSelect = document.getElementById('patternSelect');
            patternSelect.innerHTML = '<option value="">Select pattern...</option>';

            const patterns = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('pattern_')) {
                    patterns.push(key.substring(8));
                }
            }

            patterns.sort().forEach(pattern => {
                const option = document.createElement('option');
                option.value = pattern;
                option.textContent = pattern;
                patternSelect.appendChild(option);
            });
        }

        // WAV Export
        function exportWAV() {
            if (!audioContext) {
                initAudio();
            }

            showStatus('Rendering WAV...', 'success');

            const duration = (60 / tempo) * 4 * 2;
            const offlineContext = new OfflineAudioContext(2, audioContext.sampleRate * duration, audioContext.sampleRate);
            const offlineGain = offlineContext.createGain();
            offlineGain.gain.value = 0.7;
            offlineGain.connect(offlineContext.destination);

            let currentTime = 0;

            for (let loop = 0; loop < 2; loop++) {
                for (let stepIndex = 0; stepIndex < 16; stepIndex++) {
                    for (let trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
                        if (grid[trackIndex][stepIndex]) {
                            renderSound(offlineContext, offlineGain, trackIndex, currentTime);
                        }
                    }
                    currentTime += getStepDelay(stepIndex);
                }
            }

            offlineContext.startRendering().then(buffer => {
                const wav = bufferToWave(buffer);
                const blob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'sequencer_export.wav';
                a.click();

                URL.revokeObjectURL(url);
                showStatus('WAV exported successfully', 'success');
            }).catch(err => {
                showStatus('Export failed: ' + err.message, 'error');
            });
        }

        function renderSound(context, gainNode, trackIndex, time) {
            const track = tracks[trackIndex];

            switch(track.type) {
                case 'kick':
                    renderKick(context, gainNode, time);
                    break;
                case 'snare':
                    renderSnare(context, gainNode, time);
                    break;
                case 'hihat':
                    renderHiHat(context, gainNode, time);
                    break;
                case 'tom':
                    renderTom(context, gainNode, time);
                    break;
                case 'clap':
                    renderClap(context, gainNode, time);
                    break;
                case 'rim':
                    renderRim(context, gainNode, time);
                    break;
            }
        }

        function renderKick(context, gainNode, time) {
            const osc = context.createOscillator();
            const gain = context.createGain();
            const filter = context.createBiquadFilter();

            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(40, time + 0.5);

            filter.type = 'lowpass';
            filter.frequency.value = 200;

            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(gainNode);

            osc.start(time);
            osc.stop(time + 0.5);
        }

        function renderSnare(context, gainNode, time) {
            const noise = context.createBufferSource();
            const noiseBuffer = context.createBuffer(1, context.sampleRate * 0.2, context.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < output.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            noise.buffer = noiseBuffer;

            const noiseFilter = context.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 1000;

            const noiseGain = context.createGain();
            noiseGain.gain.setValueAtTime(1, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

            const osc = context.createOscillator();
            osc.frequency.value = 200;

            const oscGain = context.createGain();
            oscGain.gain.setValueAtTime(0.7, time);
            oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(gainNode);

            osc.connect(oscGain);
            oscGain.connect(gainNode);

            noise.start(time);
            noise.stop(time + 0.2);
            osc.start(time);
            osc.stop(time + 0.1);
        }

        function renderHiHat(context, gainNode, time) {
            const noise = context.createBufferSource();
            const noiseBuffer = context.createBuffer(1, context.sampleRate * 0.05, context.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < output.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            noise.buffer = noiseBuffer;

            const filter = context.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 7000;

            const gain = context.createGain();
            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(gainNode);

            noise.start(time);
            noise.stop(time + 0.05);
        }

        function renderTom(context, gainNode, time) {
            const osc = context.createOscillator();
            const gain = context.createGain();

            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(60, time + 0.3);

            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

            osc.connect(gain);
            gain.connect(gainNode);

            osc.start(time);
            osc.stop(time + 0.3);
        }

        function renderClap(context, gainNode, time) {
            const noise = context.createBufferSource();
            const noiseBuffer = context.createBuffer(1, context.sampleRate * 0.1, context.sampleRate);
            const output = noiseBuffer.getChannelData(0);

            for (let i = 0; i < output.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            noise.buffer = noiseBuffer;

            const filter = context.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1000;
            filter.Q.value = 1;

            const gain = context.createGain();
            gain.gain.setValueAtTime(0.7, time);
            gain.gain.setValueAtTime(0.5, time + 0.01);
            gain.gain.setValueAtTime(0.7, time + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(gainNode);

            noise.start(time);
            noise.stop(time + 0.1);
        }

        function renderRim(context, gainNode, time) {
            const osc = context.createOscillator();
            const gain = context.createGain();
            const filter = context.createBiquadFilter();

            osc.frequency.value = 3000;
            filter.type = 'highpass';
            filter.frequency.value = 2000;

            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.03);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(gainNode);

            osc.start(time);
            osc.stop(time + 0.03);
        }

        function bufferToWave(buffer) {
            const numberOfChannels = buffer.numberOfChannels;
            const length = buffer.length * numberOfChannels * 2;
            const arrayBuffer = new ArrayBuffer(44 + length);
            const view = new DataView(arrayBuffer);

            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * numberOfChannels * 2, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length, true);

            const channels = [];
            for (let i = 0; i < numberOfChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, channels[channel][i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return arrayBuffer;
        }

        function showStatus(message, type) {
            const statusElement = document.getElementById('statusMessage');
            statusElement.textContent = message;
            statusElement.className = `status-message ${type}`;

            setTimeout(() => {
                statusElement.textContent = '';
                statusElement.className = 'status-message';
            }, 3000);
        }

        // Visualizer
        function updateVisualizerBars() {
            const visualizer = document.getElementById('visualizer');
            visualizer.innerHTML = '';

            for (let i = 0; i < 64; i++) {
                const bar = document.createElement('div');
                bar.className = 'visualizer-bar';
                bar.style.left = `${i * (100 / 64)}%`;
                visualizer.appendChild(bar);
            }

            animateVisualizer();
        }

        function animateVisualizer() {
            const bars = document.querySelectorAll('.visualizer-bar');

            setInterval(() => {
                bars.forEach((bar, index) => {
                    let height;

                    if (isPlaying) {
                        const step = currentStep;
                        const trackActivity = grid.map(row => row[step]).filter(Boolean).length;
                        const baseHeight = (trackActivity / tracks.length) * 60;
                        const random = Math.random() * 20;
                        height = baseHeight + random + (Math.sin(index * 0.5 + Date.now() * 0.01) * 10);
                    } else {
                        height = Math.random() * 15 + 5;
                    }

                    bar.style.height = `${Math.max(2, height)}px`;
                });
            }, 50);
        }

        // Event Listeners
        document.getElementById('playBtn').addEventListener('click', play);
        document.getElementById('stopBtn').addEventListener('click', stop);
        document.getElementById('clearBtn').addEventListener('click', clearGrid);
        document.getElementById('randomBtn').addEventListener('click', randomizeGrid);
        document.getElementById('exportBtn').addEventListener('click', exportWAV);
        document.getElementById('saveBtn').addEventListener('click', savePattern);
        document.getElementById('loadBtn').addEventListener('click', loadPattern);

        document.getElementById('tempo').addEventListener('input', (e) => {
            tempo = parseInt(e.target.value);
            document.getElementById('tempoValue').textContent = tempo;
        });

        document.getElementById('swing').addEventListener('input', (e) => {
            swing = parseInt(e.target.value);
            document.getElementById('swingValue').textContent = swing;
        });

        document.getElementById('masterVolume').addEventListener('input', (e) => {
            const volume = parseInt(e.target.value) / 100;
            document.getElementById('volumeValue').textContent = e.target.value;

            if (masterGain) {
                masterGain.gain.value = volume;
            }
        });

        // Initialize
        createGrid();
        updatePatternList();
        initAudio();
    </script>
</body>
</html>
