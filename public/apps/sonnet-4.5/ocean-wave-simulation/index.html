<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean Wave Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #4A90A4 100%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 280px;
            z-index: 100;
        }

        #controls h2 {
            color: white;
            font-size: 22px;
            margin-bottom: 20px;
            font-weight: 300;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: white;
            font-size: 13px;
            margin-bottom: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        .control-group input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.15);
        }

        .value-display {
            display: inline-block;
            color: white;
            font-size: 12px;
            margin-left: 8px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #title {
            position: absolute;
            top: 30px;
            left: 30px;
            color: white;
            font-size: 32px;
            font-weight: 200;
            letter-spacing: 2px;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .info {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        @media (max-width: 768px) {
            #controls {
                top: auto;
                bottom: 20px;
                right: 20px;
                left: 20px;
                min-width: auto;
                padding: 20px;
            }

            #title {
                font-size: 24px;
                top: 20px;
                left: 20px;
            }

            .info {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="title">OCEAN WAVES</div>
    <div id="controls">
        <h2>Controls</h2>
        <div class="control-group">
            <label>
                Wind Speed
                <span class="value-display" id="wind-value">5</span>
            </label>
            <input type="range" id="wind-speed" min="0" max="10" step="0.1" value="5">
        </div>
        <div class="control-group">
            <label>
                Wave Height
                <span class="value-display" id="height-value">3.0</span>
            </label>
            <input type="range" id="wave-height" min="0.5" max="8" step="0.1" value="3">
        </div>
        <div class="control-group">
            <label>
                Sun Intensity
                <span class="value-display" id="light-value">1.0</span>
            </label>
            <input type="range" id="lighting" min="0.2" max="2" step="0.1" value="1">
        </div>
    </div>
    <div class="info">Use controls to adjust wave parameters â€¢ Drag to rotate view</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            2000
        );
        camera.position.set(0, 15, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.far = 500;
        scene.add(directionalLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x006994, 0.5);
        scene.add(hemisphereLight);

        // Ocean parameters
        const params = {
            windSpeed: 5,
            waveHeight: 3,
            lightIntensity: 1.0
        };

        // Create ocean geometry
        const oceanGeometry = new THREE.PlaneGeometry(400, 400, 256, 256);

        // Custom shader material for realistic water
        const oceanMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                waveHeight: { value: params.waveHeight },
                windSpeed: { value: params.windSpeed },
                lightIntensity: { value: params.lightIntensity },
                lightPosition: { value: directionalLight.position }
            },
            vertexShader: `
                uniform float time;
                uniform float waveHeight;
                uniform float windSpeed;

                varying vec3 vNormal;
                varying vec3 vPosition;
                varying float vElevation;

                // Improved wave function with multiple octaves
                float wave(vec2 pos, float freq, float speed, float amplitude) {
                    return amplitude * sin(pos.x * freq + time * speed) * cos(pos.y * freq * 0.8 + time * speed * 0.9);
                }

                vec3 calculateNormal(vec3 pos) {
                    float offset = 0.1;
                    float speed = windSpeed * 0.3;

                    float hL = wave(pos.xz - vec2(offset, 0.0), 0.08, speed, waveHeight);
                    float hR = wave(pos.xz + vec2(offset, 0.0), 0.08, speed, waveHeight);
                    float hD = wave(pos.xz - vec2(0.0, offset), 0.08, speed, waveHeight);
                    float hU = wave(pos.xz + vec2(0.0, offset), 0.08, speed, waveHeight);

                    vec3 tangent = normalize(vec3(2.0 * offset, hR - hL, 0.0));
                    vec3 bitangent = normalize(vec3(0.0, hU - hD, 2.0 * offset));

                    return normalize(cross(tangent, bitangent));
                }

                void main() {
                    vPosition = position;

                    float speed = windSpeed * 0.3;

                    // Multiple wave layers for realistic ocean
                    float elevation = 0.0;
                    elevation += wave(position.xy, 0.08, speed, waveHeight);
                    elevation += wave(position.xy * 1.3, 0.12, speed * 1.2, waveHeight * 0.5);
                    elevation += wave(position.xy * 2.1, 0.18, speed * 1.5, waveHeight * 0.25);
                    elevation += wave(position.xy * 3.7, 0.25, speed * 2.0, waveHeight * 0.12);
                    elevation += wave(position.xy * 5.3, 0.35, speed * 2.5, waveHeight * 0.08);

                    vElevation = elevation;

                    vec3 newPosition = position;
                    newPosition.z = elevation;

                    vNormal = calculateNormal(newPosition);

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `,
            fragmentShader: `
                uniform float lightIntensity;
                uniform vec3 lightPosition;

                varying vec3 vNormal;
                varying vec3 vPosition;
                varying float vElevation;

                void main() {
                    vec3 normal = normalize(vNormal);
                    vec3 lightDir = normalize(lightPosition);

                    // Lighting calculations
                    float diffuse = max(dot(normal, lightDir), 0.0);

                    // Specular highlights
                    vec3 viewDir = normalize(cameraPosition - vPosition);
                    vec3 reflectDir = reflect(-lightDir, normal);
                    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 128.0);

                    // Ocean color gradient based on depth
                    vec3 deepColor = vec3(0.0, 0.2, 0.4);
                    vec3 shallowColor = vec3(0.0, 0.5, 0.7);
                    vec3 foamColor = vec3(0.7, 0.9, 1.0);

                    float depthFactor = clamp(vElevation * 0.15 + 0.5, 0.0, 1.0);
                    vec3 waterColor = mix(deepColor, shallowColor, depthFactor);

                    // Add foam to wave peaks
                    float foam = smoothstep(1.5, 3.0, vElevation);
                    waterColor = mix(waterColor, foamColor, foam * 0.4);

                    // Combine lighting
                    vec3 ambient = waterColor * 0.6;
                    vec3 diffuseColor = waterColor * diffuse * lightIntensity;
                    vec3 specularColor = vec3(1.0, 1.0, 1.0) * specular * lightIntensity * 0.8;

                    vec3 finalColor = ambient + diffuseColor + specularColor;

                    // Add atmospheric perspective
                    float distance = length(vPosition.xy);
                    float fogFactor = exp(-distance * 0.0015);
                    vec3 fogColor = vec3(0.53, 0.81, 0.92);
                    finalColor = mix(fogColor, finalColor, fogFactor);

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            side: THREE.DoubleSide
        });

        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        scene.add(ocean);

        // Add sky dome
        const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0077be) },
                bottomColor: { value: new THREE.Color(0x87CEEB) },
                offset: { value: 100 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Mouse interaction for camera rotation
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = { theta: 0, phi: 0.4 };
        const cameraDistance = 35;

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngle.theta += deltaX * 0.005;
                cameraAngle.phi += deltaY * 0.005;
                cameraAngle.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraAngle.phi));

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch support
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;

                cameraAngle.theta += deltaX * 0.005;
                cameraAngle.phi += deltaY * 0.005;
                cameraAngle.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraAngle.phi));

                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                e.preventDefault();
            }
        });

        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Control handlers
        const windSpeedInput = document.getElementById('wind-speed');
        const waveHeightInput = document.getElementById('wave-height');
        const lightingInput = document.getElementById('lighting');

        const windValue = document.getElementById('wind-value');
        const heightValue = document.getElementById('height-value');
        const lightValue = document.getElementById('light-value');

        windSpeedInput.addEventListener('input', (e) => {
            params.windSpeed = parseFloat(e.target.value);
            oceanMaterial.uniforms.windSpeed.value = params.windSpeed;
            windValue.textContent = params.windSpeed.toFixed(1);
        });

        waveHeightInput.addEventListener('input', (e) => {
            params.waveHeight = parseFloat(e.target.value);
            oceanMaterial.uniforms.waveHeight.value = params.waveHeight;
            heightValue.textContent = params.waveHeight.toFixed(1);
        });

        lightingInput.addEventListener('input', (e) => {
            params.lightIntensity = parseFloat(e.target.value);
            oceanMaterial.uniforms.lightIntensity.value = params.lightIntensity;
            directionalLight.intensity = params.lightIntensity;
            lightValue.textContent = params.lightIntensity.toFixed(1);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            oceanMaterial.uniforms.time.value = elapsedTime;

            // Update camera position based on angles
            camera.position.x = cameraDistance * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta);
            camera.position.y = cameraDistance * Math.cos(cameraAngle.phi);
            camera.position.z = cameraDistance * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta);
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
