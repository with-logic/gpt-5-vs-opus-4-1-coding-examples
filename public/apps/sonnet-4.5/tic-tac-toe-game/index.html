<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe - Roman Empire Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Marble Day Theme */
            --bg-primary: #f5f0e8;
            --bg-secondary: #e8dfd0;
            --bg-board: #ffffff;
            --text-primary: #2c2416;
            --text-secondary: #5a4f3f;
            --accent-gold: #d4af37;
            --accent-gold-dark: #b8941f;
            --accent-gold-light: #f4d77e;
            --shadow-color: rgba(0, 0, 0, 0.15);
            --cell-hover: rgba(212, 175, 55, 0.1);
            --cell-active: rgba(212, 175, 55, 0.2);
            --win-highlight: rgba(212, 175, 55, 0.3);
            --border-color: rgba(44, 36, 22, 0.2);
        }

        body.theme-night {
            --bg-primary: #1a1612;
            --bg-secondary: #2a241f;
            --bg-board: #3a342f;
            --text-primary: #e8dfd0;
            --text-secondary: #b8a88f;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --cell-hover: rgba(212, 175, 55, 0.15);
            --cell-active: rgba(212, 175, 55, 0.25);
            --win-highlight: rgba(212, 175, 55, 0.35);
            --border-color: rgba(212, 175, 55, 0.3);
        }

        body {
            font-family: 'Crimson Text', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            transition: background 0.3s ease, color 0.3s ease;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(212, 175, 55, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .app-container {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Header */
        header {
            background: var(--bg-secondary);
            padding: 1.5rem 2rem;
            box-shadow: 0 2px 8px var(--shadow-color);
            border-bottom: 2px solid var(--accent-gold);
            position: relative;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .title-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .spqr-crest {
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 2rem;
            color: var(--accent-gold);
            text-shadow: 2px 2px 4px var(--shadow-color);
            letter-spacing: 0.2em;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .controls {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        button {
            font-family: 'Cinzel', serif;
            padding: 0.6rem 1.2rem;
            background: var(--accent-gold);
            color: var(--text-primary);
            border: 2px solid var(--accent-gold-dark);
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px var(--shadow-color);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        button:hover {
            background: var(--accent-gold-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        button:focus-visible {
            outline: 3px solid var(--accent-gold);
            outline-offset: 2px;
        }

        /* Victory Banner */
        .victory-banner {
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-gold-dark) 100%);
            color: var(--bg-primary);
            padding: 1rem 2rem;
            text-align: center;
            font-family: 'Cinzel', serif;
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            box-shadow: 0 4px 12px var(--shadow-color);
            display: none;
            animation: bannerSlide 0.5s ease-out;
        }

        .victory-banner.show {
            display: block;
        }

        @keyframes bannerSlide {
            from {
                opacity: 0;
                transform: translateY(-100%);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Main Content */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            gap: 2rem;
        }

        /* Scoreboard */
        .scoreboard {
            display: flex;
            gap: 2rem;
            background: var(--bg-secondary);
            padding: 1.5rem 2.5rem;
            border-radius: 16px;
            box-shadow: 0 4px 12px var(--shadow-color);
            border: 2px solid var(--border-color);
        }

        .score-item {
            text-align: center;
            min-width: 80px;
        }

        .score-label {
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }

        .score-value {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-gold);
            text-shadow: 1px 1px 2px var(--shadow-color);
        }

        /* Status */
        .status {
            font-family: 'Cinzel', serif;
            font-size: clamp(1.1rem, 2.5vw, 1.3rem);
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            padding: 0.75rem 1.5rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: 0 2px 8px var(--shadow-color);
            min-height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Game Board */
        .game-container {
            width: min(90vmin, 600px);
            aspect-ratio: 1;
        }

        .game-board {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: clamp(8px, 1.5vmin, 16px);
            background: var(--bg-secondary);
            padding: clamp(8px, 1.5vmin, 16px);
            border-radius: 16px;
            box-shadow: 0 8px 24px var(--shadow-color);
            border: 3px solid var(--accent-gold);
        }

        .cell {
            background: var(--bg-board);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cinzel', serif;
            font-size: clamp(2rem, 12vmin, 5rem);
            font-weight: 700;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px var(--shadow-color);
            position: relative;
            user-select: none;
        }

        .cell:hover:not(.filled) {
            background: var(--cell-hover);
            border-color: var(--accent-gold);
            transform: scale(1.05);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .cell:active:not(.filled) {
            background: var(--cell-active);
            transform: scale(0.98);
        }

        .cell.filled {
            cursor: not-allowed;
        }

        .cell.win-cell {
            background: var(--win-highlight);
            border-color: var(--accent-gold);
            animation: winPulse 1s ease-in-out infinite;
        }

        @keyframes winPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 12px var(--shadow-color);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 8px 24px var(--accent-gold);
            }
        }

        .cell:focus-visible {
            outline: 4px solid var(--accent-gold);
            outline-offset: 2px;
            z-index: 10;
        }

        /* Dialog/Modal */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
            backdrop-filter: blur(4px);
        }

        .dialog-overlay.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .dialog {
            background: var(--bg-secondary);
            border: 3px solid var(--accent-gold);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
            animation: dialogSlide 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes dialogSlide {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .dialog h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-gold);
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
        }

        .dialog-section {
            margin-bottom: 1.5rem;
        }

        .dialog-section:last-of-type {
            margin-bottom: 2rem;
        }

        .dialog-label {
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            display: block;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .option-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .option-btn {
            flex: 1;
            min-width: 120px;
            padding: 0.75rem 1rem;
            background: var(--bg-board);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: 'Crimson Text', serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: none;
            letter-spacing: normal;
        }

        .option-btn:hover {
            background: var(--cell-hover);
            border-color: var(--accent-gold);
            transform: translateY(-2px);
        }

        .option-btn.active {
            background: var(--accent-gold);
            border-color: var(--accent-gold-dark);
            color: var(--bg-primary);
        }

        .dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .dialog-actions button {
            min-width: 120px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            header {
                padding: 1rem 1rem;
            }

            .header-content {
                flex-direction: column;
                align-items: stretch;
            }

            .title-section {
                justify-content: center;
            }

            .controls {
                justify-content: center;
            }

            .spqr-crest {
                font-size: 1.5rem;
            }

            .scoreboard {
                gap: 1rem;
                padding: 1rem 1.5rem;
            }

            .score-item {
                min-width: 60px;
            }

            .score-value {
                font-size: 1.5rem;
            }

            main {
                padding: 1rem;
            }

            .dialog {
                padding: 1.5rem;
            }

            .option-btn {
                min-width: 100px;
            }
        }

        @media (max-width: 480px) {
            .scoreboard {
                flex-direction: column;
                gap: 0.75rem;
                padding: 1rem;
            }

            .score-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                width: 100%;
            }

            .score-label {
                margin-bottom: 0;
            }

            .score-value {
                font-size: 1.5rem;
            }
        }

        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <canvas id="confetti-canvas"></canvas>

    <div class="app-container">
        <header>
            <div class="header-content">
                <div class="title-section">
                    <div class="spqr-crest" aria-hidden="true">SPQR</div>
                    <h1>Tic Tac Toe</h1>
                </div>
                <div class="controls">
                    <button id="new-round-btn" type="button">New Round</button>
                    <button id="customize-btn" type="button">Customize</button>
                    <button id="reset-scores-btn" type="button">Reset Scores</button>
                </div>
            </div>
        </header>

        <div class="victory-banner" id="victory-banner" role="status" aria-live="polite"></div>

        <main>
            <div class="scoreboard">
                <div class="score-item">
                    <div class="score-label">Player X</div>
                    <div class="score-value" id="score-x">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Draws</div>
                    <div class="score-value" id="score-draws">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Player O</div>
                    <div class="score-value" id="score-o">0</div>
                </div>
            </div>

            <div class="status" id="status" role="status" aria-live="polite" aria-atomic="true">
                Player X's Turn
            </div>

            <div class="game-container">
                <div
                    class="game-board"
                    id="game-board"
                    role="grid"
                    aria-label="Tic Tac Toe game board"
                >
                    <!-- Cells will be generated by JavaScript -->
                </div>
            </div>
        </main>
    </div>

    <!-- Customize Dialog -->
    <div class="dialog-overlay" id="customize-dialog" role="dialog" aria-modal="true" aria-labelledby="dialog-title">
        <div class="dialog">
            <h2 id="dialog-title">Customize Game</h2>

            <div class="dialog-section">
                <label class="dialog-label">Theme</label>
                <div class="option-group">
                    <button type="button" class="option-btn active" data-option="theme" data-value="day">Marble Day</button>
                    <button type="button" class="option-btn" data-option="theme" data-value="night">Night Legion</button>
                </div>
            </div>

            <div class="dialog-section">
                <label class="dialog-label">Glyphs</label>
                <div class="option-group">
                    <button type="button" class="option-btn active" data-option="glyphs" data-value="standard">Standard X/O</button>
                    <button type="button" class="option-btn" data-option="glyphs" data-value="roman">Gladius/Laurel</button>
                </div>
            </div>

            <div class="dialog-section">
                <label class="dialog-label">Game Mode</label>
                <div class="option-group">
                    <button type="button" class="option-btn active" data-option="mode" data-value="2player">2-Player</button>
                    <button type="button" class="option-btn" data-option="mode" data-value="ai">vs AI</button>
                </div>
            </div>

            <div class="dialog-section">
                <label class="dialog-label">First Move</label>
                <div class="option-group">
                    <button type="button" class="option-btn active" data-option="firstmove" data-value="X">X Starts</button>
                    <button type="button" class="option-btn" data-option="firstmove" data-value="O">O Starts</button>
                </div>
            </div>

            <div class="dialog-section" id="ai-difficulty-section">
                <label class="dialog-label">AI Discipline</label>
                <div class="option-group">
                    <button type="button" class="option-btn active" data-option="difficulty" data-value="perfect">Perfect</button>
                    <button type="button" class="option-btn" data-option="difficulty" data-value="pragmatic">Pragmatic</button>
                    <button type="button" class="option-btn" data-option="difficulty" data-value="reckless">Reckless</button>
                </div>
            </div>

            <div class="dialog-actions">
                <button type="button" id="dialog-close-btn">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Game State
        const state = {
            board: ['', '', '', '', '', '', '', '', ''],
            currentPlayer: 'X',
            gameActive: true,
            scores: { X: 0, O: 0, draws: 0 },
            settings: {
                theme: 'day',
                glyphs: 'standard',
                mode: '2player',
                firstMove: 'X',
                difficulty: 'perfect'
            }
        };

        // DOM Elements
        const gameBoard = document.getElementById('game-board');
        const statusEl = document.getElementById('status');
        const victoryBanner = document.getElementById('victory-banner');
        const scoreXEl = document.getElementById('score-x');
        const scoreOEl = document.getElementById('score-o');
        const scoreDrawsEl = document.getElementById('score-draws');
        const customizeDialog = document.getElementById('customize-dialog');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const confettiCtx = confettiCanvas.getContext('2d');

        // Glyph mappings
        const glyphs = {
            standard: { X: 'X', O: 'O' },
            roman: { X: '‚öî', O: 'üèÜ' }
        };

        // Initialize
        function init() {
            createBoard();
            setupEventListeners();
            updateStatus();
            loadScores();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        // Create game board
        function createBoard() {
            gameBoard.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                cell.setAttribute('role', 'gridcell');
                cell.setAttribute('aria-label', `Cell ${i + 1}`);
                cell.setAttribute('tabindex', state.gameActive && !state.board[i] ? '0' : '-1');
                gameBoard.appendChild(cell);
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Game board clicks
            gameBoard.addEventListener('click', handleCellClick);
            gameBoard.addEventListener('keydown', handleKeyDown);

            // Header buttons
            document.getElementById('new-round-btn').addEventListener('click', newRound);
            document.getElementById('customize-btn').addEventListener('click', openCustomize);
            document.getElementById('reset-scores-btn').addEventListener('click', resetScores);

            // Dialog
            document.getElementById('dialog-close-btn').addEventListener('click', closeCustomize);
            customizeDialog.addEventListener('click', (e) => {
                if (e.target === customizeDialog) closeCustomize();
            });

            // Option buttons
            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.addEventListener('click', handleOptionClick);
            });

            // Escape key to close dialog
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && customizeDialog.classList.contains('show')) {
                    closeCustomize();
                }
            });
        }

        // Handle cell click
        function handleCellClick(e) {
            const cell = e.target.closest('.cell');
            if (!cell) return;

            const index = parseInt(cell.dataset.index);
            makeMove(index);
        }

        // Handle keyboard navigation
        function handleKeyDown(e) {
            if (!e.target.classList.contains('cell')) return;

            const index = parseInt(e.target.dataset.index);
            let newIndex = index;

            switch(e.key) {
                case 'Enter':
                case ' ':
                    e.preventDefault();
                    makeMove(index);
                    return;
                case 'ArrowLeft':
                    newIndex = index % 3 === 0 ? index + 2 : index - 1;
                    break;
                case 'ArrowRight':
                    newIndex = index % 3 === 2 ? index - 2 : index + 1;
                    break;
                case 'ArrowUp':
                    newIndex = index < 3 ? index + 6 : index - 3;
                    break;
                case 'ArrowDown':
                    newIndex = index > 5 ? index - 6 : index + 3;
                    break;
                default:
                    return;
            }

            e.preventDefault();
            const cells = gameBoard.querySelectorAll('.cell');
            cells[newIndex].focus();
        }

        // Make a move
        function makeMove(index) {
            if (!state.gameActive || state.board[index]) return;

            // Human move
            state.board[index] = state.currentPlayer;
            updateBoard();

            const result = checkWinner();
            if (result) {
                handleGameEnd(result);
                return;
            }

            // Switch player
            state.currentPlayer = state.currentPlayer === 'X' ? 'O' : 'X';
            updateStatus();

            // AI move
            if (state.settings.mode === 'ai' && state.gameActive && state.currentPlayer === 'O') {
                setTimeout(makeAIMove, 300);
            }
        }

        // AI Move with minimax
        function makeAIMove() {
            const move = getBestMove();
            if (move !== -1) {
                state.board[move] = 'O';
                updateBoard();

                const result = checkWinner();
                if (result) {
                    handleGameEnd(result);
                    return;
                }

                state.currentPlayer = 'X';
                updateStatus();
            }
        }

        // Get best move using minimax
        function getBestMove() {
            const difficulty = state.settings.difficulty;
            const emptyIndices = state.board.map((val, idx) => val === '' ? idx : null).filter(val => val !== null);

            if (emptyIndices.length === 0) return -1;

            // Reckless: random move
            if (difficulty === 'reckless') {
                return emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
            }

            // Pragmatic: 70% optimal, 30% random
            if (difficulty === 'pragmatic' && Math.random() < 0.3) {
                return emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
            }

            // Perfect: minimax
            let bestScore = -Infinity;
            let bestMove = -1;

            for (let i = 0; i < emptyIndices.length; i++) {
                const idx = emptyIndices[i];
                state.board[idx] = 'O';
                const score = minimax(state.board, 0, false);
                state.board[idx] = '';

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = idx;
                }
            }

            return bestMove;
        }

        // Minimax algorithm
        function minimax(board, depth, isMaximizing) {
            const result = checkWinnerForBoard(board);

            if (result === 'O') return 10 - depth;
            if (result === 'X') return depth - 10;
            if (result === 'draw') return 0;

            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'O';
                        const score = minimax(board, depth + 1, false);
                        board[i] = '';
                        bestScore = Math.max(score, bestScore);
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'X';
                        const score = minimax(board, depth + 1, true);
                        board[i] = '';
                        bestScore = Math.min(score, bestScore);
                    }
                }
                return bestScore;
            }
        }

        // Check winner for a given board state
        function checkWinnerForBoard(board) {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                [0, 4, 8], [2, 4, 6]              // diagonals
            ];

            for (let pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a];
                }
            }

            if (board.every(cell => cell !== '')) {
                return 'draw';
            }

            return null;
        }

        // Check winner
        function checkWinner() {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                [0, 4, 8], [2, 4, 6]              // diagonals
            ];

            for (let pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (state.board[a] && state.board[a] === state.board[b] && state.board[a] === state.board[c]) {
                    return { winner: state.board[a], pattern };
                }
            }

            if (state.board.every(cell => cell !== '')) {
                return { winner: 'draw' };
            }

            return null;
        }

        // Handle game end
        function handleGameEnd(result) {
            state.gameActive = false;

            if (result.winner === 'draw') {
                state.scores.draws++;
                statusEl.textContent = "It's a Draw!";
                victoryBanner.textContent = "‚öî Honorable Draw ‚öî";
            } else {
                state.scores[result.winner]++;
                const glyph = glyphs[state.settings.glyphs][result.winner];
                statusEl.textContent = `Player ${result.winner} Wins!`;
                victoryBanner.textContent = `‚öî Victory for ${glyph} ‚öî`;

                // Highlight winning cells
                result.pattern.forEach(index => {
                    gameBoard.children[index].classList.add('win-cell');
                });

                // Confetti
                if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    launchConfetti();
                }
            }

            victoryBanner.classList.add('show');
            updateScores();
            saveScores();

            // Update cell tabindex
            const cells = gameBoard.querySelectorAll('.cell');
            cells.forEach(cell => cell.setAttribute('tabindex', '-1'));
        }

        // Update board display
        function updateBoard() {
            const cells = gameBoard.querySelectorAll('.cell');
            const currentGlyphs = glyphs[state.settings.glyphs];

            cells.forEach((cell, index) => {
                const value = state.board[index];
                if (value) {
                    cell.textContent = currentGlyphs[value];
                    cell.classList.add('filled');
                    cell.setAttribute('aria-label', `Cell ${index + 1}, ${value}`);
                    cell.setAttribute('tabindex', '-1');
                } else {
                    cell.textContent = '';
                    cell.classList.remove('filled');
                    cell.setAttribute('aria-label', `Cell ${index + 1}, empty`);
                    cell.setAttribute('tabindex', state.gameActive ? '0' : '-1');
                }
            });
        }

        // Update status
        function updateStatus() {
            if (state.gameActive) {
                const glyph = glyphs[state.settings.glyphs][state.currentPlayer];
                statusEl.textContent = `Player ${state.currentPlayer}'s Turn`;
            }
        }

        // Update scores display
        function updateScores() {
            scoreXEl.textContent = state.scores.X;
            scoreOEl.textContent = state.scores.O;
            scoreDrawsEl.textContent = state.scores.draws;
        }

        // New round
        function newRound() {
            state.board = ['', '', '', '', '', '', '', '', ''];
            state.currentPlayer = state.settings.firstMove;
            state.gameActive = true;
            victoryBanner.classList.remove('show');

            // Clear win highlights
            const cells = gameBoard.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('win-cell');
                cell.setAttribute('tabindex', '0');
            });

            updateBoard();
            updateStatus();

            // AI first move if configured
            if (state.settings.mode === 'ai' && state.currentPlayer === 'O') {
                setTimeout(makeAIMove, 500);
            }
        }

        // Reset scores
        function resetScores() {
            if (confirm('Reset all scores to zero?')) {
                state.scores = { X: 0, O: 0, draws: 0 };
                updateScores();
                saveScores();
            }
        }

        // Save scores to localStorage
        function saveScores() {
            localStorage.setItem('tictactoe-scores', JSON.stringify(state.scores));
        }

        // Load scores from localStorage
        function loadScores() {
            const saved = localStorage.getItem('tictactoe-scores');
            if (saved) {
                try {
                    state.scores = JSON.parse(saved);
                    updateScores();
                } catch (e) {
                    console.error('Failed to load scores', e);
                }
            }
        }

        // Open customize dialog
        function openCustomize() {
            customizeDialog.classList.add('show');
            updateAIDifficultyVisibility();
            document.getElementById('dialog-close-btn').focus();
        }

        // Close customize dialog
        function closeCustomize() {
            customizeDialog.classList.remove('show');
            document.getElementById('customize-btn').focus();
        }

        // Handle option button clicks
        function handleOptionClick(e) {
            const btn = e.target;
            const option = btn.dataset.option;
            const value = btn.dataset.value;

            // Update active state
            const group = btn.parentElement;
            group.querySelectorAll('.option-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Update settings
            state.settings[option] = value;

            // Apply changes
            if (option === 'theme') {
                document.body.className = value === 'night' ? 'theme-night' : '';
            } else if (option === 'glyphs') {
                updateBoard();
            } else if (option === 'mode') {
                updateAIDifficultyVisibility();
            }
        }

        // Show/hide AI difficulty based on mode
        function updateAIDifficultyVisibility() {
            const aiSection = document.getElementById('ai-difficulty-section');
            aiSection.style.display = state.settings.mode === 'ai' ? 'block' : 'none';
        }

        // Confetti system
        let confettiParticles = [];
        let confettiAnimationId = null;

        function resizeCanvas() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }

        function launchConfetti() {
            const colors = ['#d4af37', '#f4d77e', '#b8941f', '#e8dfd0'];
            const particleCount = 150;

            for (let i = 0; i < particleCount; i++) {
                confettiParticles.push({
                    x: Math.random() * confettiCanvas.width,
                    y: -20,
                    vx: (Math.random() - 0.5) * 4,
                    vy: Math.random() * 3 + 2,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 8 + 4,
                    opacity: 1,
                    shape: Math.random() > 0.5 ? 'circle' : 'square'
                });
            }

            if (!confettiAnimationId) {
                animateConfetti();
            }
        }

        function animateConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

            confettiParticles = confettiParticles.filter(p => {
                // Update position
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1; // gravity
                p.rotation += p.rotationSpeed;

                // Fade out near bottom
                if (p.y > confettiCanvas.height - 200) {
                    p.opacity -= 0.01;
                }

                // Draw particle
                confettiCtx.save();
                confettiCtx.translate(p.x, p.y);
                confettiCtx.rotate((p.rotation * Math.PI) / 180);
                confettiCtx.globalAlpha = p.opacity;
                confettiCtx.fillStyle = p.color;

                if (p.shape === 'circle') {
                    confettiCtx.beginPath();
                    confettiCtx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                    confettiCtx.fill();
                } else {
                    confettiCtx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                }

                confettiCtx.restore();

                // Remove if off screen or invisible
                return p.y < confettiCanvas.height && p.opacity > 0;
            });

            if (confettiParticles.length > 0) {
                confettiAnimationId = requestAnimationFrame(animateConfetti);
            } else {
                confettiAnimationId = null;
            }
        }

        // Start the game
        init();
    </script>
</body>
</html>