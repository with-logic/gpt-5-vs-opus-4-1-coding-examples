<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape the Maze</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 25px;
        }

        h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stat-box {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 150px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
        }

        .stat-box:hover {
            transform: translateY(-3px);
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
        }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        canvas {
            border: 3px solid #667eea;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background: #2a2a2a;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        select {
            padding: 8px 15px;
            border-radius: 10px;
            border: 2px solid #667eea;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        select:focus {
            outline: none;
            border-color: #764ba2;
        }

        .instructions {
            text-align: center;
            color: #666;
            margin-top: 20px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .victory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .victory-modal {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .victory-title {
            font-size: 2.5em;
            color: #667eea;
            margin-bottom: 20px;
        }

        .victory-stats {
            margin: 20px 0;
            font-size: 1.2em;
            color: #333;
        }

        .star-rating {
            font-size: 2em;
            color: #ffd700;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
            }

            h1 {
                font-size: 2em;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>üèÉ Escape the Maze üèÅ</h1>
        </div>

        <div class="game-stats">
            <div class="stat-box">
                <div class="stat-label">Time</div>
                <div class="stat-value" id="timer">00:00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Moves</div>
                <div class="stat-value" id="moves">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Best Time</div>
                <div class="stat-value" id="bestTime">--:--</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Level</div>
                <div class="stat-value" id="level">1</div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="controls">
            <button id="newMazeBtn">New Maze</button>
            <button id="showPathBtn">Show Path (‚àí10s)</button>
            <button id="toggleMusicBtn">üéµ Music</button>
            <div class="difficulty-selector">
                <label for="difficulty">Difficulty:</label>
                <select id="difficulty">
                    <option value="easy">Easy (15x15)</option>
                    <option value="medium" selected>Medium (21x21)</option>
                    <option value="hard">Hard (31x31)</option>
                    <option value="extreme">Extreme (41x41)</option>
                </select>
            </div>
        </div>

        <div class="instructions">
            <p><strong>How to Play:</strong> Use arrow keys (‚Üë‚Üì‚Üê‚Üí) or WASD to navigate through the maze.
            Find the green exit as quickly as possible! Press H to toggle hint path (adds time penalty).</p>
        </div>
    </div>

    <div class="victory-overlay" id="victoryOverlay">
        <div class="victory-modal">
            <div class="victory-title">üéâ Victory! üéâ</div>
            <div class="star-rating" id="starRating">‚≠ê‚≠ê‚≠ê</div>
            <div class="victory-stats" id="victoryStats"></div>
            <button onclick="closeVictoryModal()">Play Again</button>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let maze = [];
        let mazeSize = 21;
        let cellSize = 20;
        let player = { x: 1, y: 1 };
        let exit = { x: 0, y: 0 };
        let moves = 0;
        let startTime = null;
        let timerInterval = null;
        let showingPath = false;
        let shortestPath = [];
        let level = 1;
        let musicEnabled = false;
        let gameWon = false;
        let pathPenaltyApplied = false;

        // Best times for each difficulty
        let bestTimes = {
            easy: localStorage.getItem('bestTimeEasy') || null,
            medium: localStorage.getItem('bestTimeMedium') || null,
            hard: localStorage.getItem('bestTimeHard') || null,
            extreme: localStorage.getItem('bestTimeExtreme') || null
        };

        // Initialize game
        function init() {
            const difficulty = document.getElementById('difficulty').value;
            switch(difficulty) {
                case 'easy':
                    mazeSize = 15;
                    cellSize = 30;
                    break;
                case 'medium':
                    mazeSize = 21;
                    cellSize = 20;
                    break;
                case 'hard':
                    mazeSize = 31;
                    cellSize = 15;
                    break;
                case 'extreme':
                    mazeSize = 41;
                    cellSize = 12;
                    break;
            }

            canvas.width = mazeSize * cellSize;
            canvas.height = mazeSize * cellSize;

            generateMaze();
            findShortestPath();
            resetGame();
            draw();
            updateBestTime();
        }

        // Generate maze using recursive backtracking
        function generateMaze() {
            // Initialize maze with walls
            maze = Array(mazeSize).fill(null).map(() => Array(mazeSize).fill(1));

            // Carve out paths
            const stack = [];
            const start = { x: 1, y: 1 };
            maze[start.y][start.x] = 0;
            stack.push(start);

            const directions = [
                { dx: 0, dy: -2 }, // Up
                { dx: 2, dy: 0 },  // Right
                { dx: 0, dy: 2 },  // Down
                { dx: -2, dy: 0 }  // Left
            ];

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;

                    if (nx > 0 && nx < mazeSize - 1 && ny > 0 && ny < mazeSize - 1 && maze[ny][nx] === 1) {
                        neighbors.push({ x: nx, y: ny, dx: dir.dx, dy: dir.dy });
                    }
                }

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[next.y][next.x] = 0;
                    maze[current.y + next.dy / 2][current.x + next.dx / 2] = 0;
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }

            // Set player start and exit
            player = { x: 1, y: 1 };
            exit = { x: mazeSize - 2, y: mazeSize - 2 };
            maze[exit.y][exit.x] = 0;
        }

        // Find shortest path using BFS
        function findShortestPath() {
            const queue = [{ x: player.x, y: player.y, path: [] }];
            const visited = new Set();
            visited.add(`${player.x},${player.y}`);

            const directions = [
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }
            ];

            while (queue.length > 0) {
                const current = queue.shift();

                if (current.x === exit.x && current.y === exit.y) {
                    shortestPath = current.path;
                    return;
                }

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    const key = `${nx},${ny}`;

                    if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize &&
                        maze[ny][nx] === 0 && !visited.has(key)) {
                        visited.add(key);
                        queue.push({
                            x: nx,
                            y: ny,
                            path: [...current.path, { x: nx, y: ny }]
                        });
                    }
                }
            }
        }

        // Draw the game
        function draw() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    if (maze[y][x] === 1) {
                        // Draw walls with gradient
                        const gradient = ctx.createLinearGradient(
                            x * cellSize, y * cellSize,
                            (x + 1) * cellSize, (y + 1) * cellSize
                        );
                        gradient.addColorStop(0, '#4a4a4a');
                        gradient.addColorStop(1, '#2a2a2a');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);

                        // Add subtle border
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    } else {
                        // Draw floor
                        ctx.fillStyle = '#3a3a3a';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw shortest path if showing
            if (showingPath && shortestPath.length > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 100, 0.3)';
                ctx.lineWidth = cellSize / 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
                for (const point of shortestPath) {
                    ctx.lineTo(point.x * cellSize + cellSize / 2, point.y * cellSize + cellSize / 2);
                }
                ctx.stroke();
            }

            // Draw exit with animation
            const time = Date.now() / 1000;
            const pulse = Math.sin(time * 3) * 0.2 + 0.8;
            ctx.fillStyle = `rgba(46, 204, 113, ${pulse})`;
            ctx.fillRect(exit.x * cellSize + 2, exit.y * cellSize + 2, cellSize - 4, cellSize - 4);

            // Draw exit flag
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(exit.x * cellSize + cellSize/3, exit.y * cellSize + cellSize/4, 2, cellSize/2);
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.moveTo(exit.x * cellSize + cellSize/3 + 2, exit.y * cellSize + cellSize/4);
            ctx.lineTo(exit.x * cellSize + cellSize/3 + cellSize/3, exit.y * cellSize + cellSize/3);
            ctx.lineTo(exit.x * cellSize + cellSize/3 + 2, exit.y * cellSize + cellSize/2.5);
            ctx.fill();

            // Draw player with animation
            const playerCenterX = player.x * cellSize + cellSize / 2;
            const playerCenterY = player.y * cellSize + cellSize / 2;

            // Player shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(playerCenterX, playerCenterY + cellSize/4, cellSize/3, cellSize/6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Player body
            const gradient = ctx.createRadialGradient(playerCenterX, playerCenterY, 0, playerCenterX, playerCenterY, cellSize/2);
            gradient.addColorStop(0, '#ffd700');
            gradient.addColorStop(1, '#ffaa00');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(playerCenterX, playerCenterY, cellSize / 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Player eye
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(playerCenterX + cellSize/6, playerCenterY - cellSize/8, cellSize/8, 0, Math.PI * 2);
            ctx.fill();

            requestAnimationFrame(draw);
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (gameWon) return;

            let newX = player.x;
            let newY = player.y;

            switch(e.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    newY--;
                    e.preventDefault();
                    break;
                case 'arrowdown':
                case 's':
                    newY++;
                    e.preventDefault();
                    break;
                case 'arrowleft':
                case 'a':
                    newX--;
                    e.preventDefault();
                    break;
                case 'arrowright':
                case 'd':
                    newX++;
                    e.preventDefault();
                    break;
                case 'h':
                    togglePath();
                    break;
                default:
                    return;
            }

            // Check if move is valid
            if (newX >= 0 && newX < mazeSize && newY >= 0 && newY < mazeSize && maze[newY][newX] === 0) {
                player.x = newX;
                player.y = newY;
                moves++;
                document.getElementById('moves').textContent = moves;

                // Start timer on first move
                if (!startTime) {
                    startTimer();
                }

                // Recalculate shortest path from new position
                findShortestPath();

                // Check for victory
                if (player.x === exit.x && player.y === exit.y) {
                    victory();
                }
            }
        });

        // Timer functions
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 100);
        }

        function updateTimer() {
            if (!startTime) return;

            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Victory handler
        function victory() {
            gameWon = true;
            stopTimer();

            const totalTime = Math.floor((Date.now() - startTime) / 1000);
            const difficulty = document.getElementById('difficulty').value;

            // Calculate score and stars
            let stars = 3;
            const optimalMoves = shortestPath.length + 1;
            const movePenalty = moves - optimalMoves;

            if (movePenalty > optimalMoves * 0.5) stars--;
            if (movePenalty > optimalMoves) stars--;
            if (pathPenaltyApplied) stars = Math.max(1, stars - 1);

            // Update best time
            if (!bestTimes[difficulty] || totalTime < parseInt(bestTimes[difficulty])) {
                bestTimes[difficulty] = totalTime;
                localStorage.setItem(`bestTime${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`, totalTime);
            }

            // Show victory modal
            const starDisplay = '‚≠ê'.repeat(stars) + '‚òÜ'.repeat(3 - stars);
            document.getElementById('starRating').innerHTML = starDisplay;

            const minutes = Math.floor(totalTime / 60);
            const seconds = totalTime % 60;
            const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            document.getElementById('victoryStats').innerHTML = `
                <p><strong>Time:</strong> ${timeStr}</p>
                <p><strong>Moves:</strong> ${moves} (Optimal: ${optimalMoves})</p>
                <p><strong>Efficiency:</strong> ${Math.round((optimalMoves / moves) * 100)}%</p>
                <p><strong>Level:</strong> ${level}</p>
            `;

            document.getElementById('victoryOverlay').style.display = 'flex';

            // Level up
            level++;
            document.getElementById('level').textContent = level;
        }

        function closeVictoryModal() {
            document.getElementById('victoryOverlay').style.display = 'none';
            newMaze();
        }

        // Reset game state
        function resetGame() {
            player = { x: 1, y: 1 };
            moves = 0;
            startTime = null;
            gameWon = false;
            showingPath = false;
            pathPenaltyApplied = false;
            document.getElementById('moves').textContent = '0';
            document.getElementById('timer').textContent = '00:00';
            stopTimer();
        }

        // New maze button handler
        function newMaze() {
            init();
        }

        // Show path button handler
        function togglePath() {
            showingPath = !showingPath;
            if (showingPath && startTime && !pathPenaltyApplied) {
                // Add 10 second penalty
                startTime -= 10000;
                pathPenaltyApplied = true;
            }
        }

        function updateBestTime() {
            const difficulty = document.getElementById('difficulty').value;
            const bestTime = bestTimes[difficulty];
            if (bestTime) {
                const minutes = Math.floor(bestTime / 60);
                const seconds = bestTime % 60;
                document.getElementById('bestTime').textContent =
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                document.getElementById('bestTime').textContent = '--:--';
            }
        }

        // Event listeners
        document.getElementById('newMazeBtn').addEventListener('click', newMaze);
        document.getElementById('showPathBtn').addEventListener('click', togglePath);
        document.getElementById('difficulty').addEventListener('change', init);

        document.getElementById('toggleMusicBtn').addEventListener('click', () => {
            musicEnabled = !musicEnabled;
            document.getElementById('toggleMusicBtn').textContent = musicEnabled ? 'üîá Music' : 'üéµ Music';
        });

        // Initialize game on load
        init();
    </script>
</body>
</html>