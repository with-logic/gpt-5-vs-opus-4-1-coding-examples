<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Theatre</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Courier+Prime&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Playfair Display', serif;
            overflow: hidden;
            background: #0a0a0a;
        }

        .typewriter {
            font-family: 'Courier Prime', monospace;
            overflow: hidden;
            white-space: nowrap;
            letter-spacing: .1em;
            animation: typing 3s steps(40, end);
        }

        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }

        .curtain-left {
            background: linear-gradient(90deg, #4a0000, #8b0000, #4a0000);
            box-shadow: inset -30px 0 40px rgba(0,0,0,0.5);
        }

        .curtain-right {
            background: linear-gradient(90deg, #4a0000, #8b0000, #4a0000);
            box-shadow: inset 30px 0 40px rgba(0,0,0,0.5);
        }

        .spotlight {
            background: radial-gradient(ellipse at center, rgba(255,255,200,0.3) 0%, transparent 70%);
            mix-blend-mode: soft-light;
            pointer-events: none;
        }

        .stage-floor {
            background: linear-gradient(180deg, #2a1810 0%, #1a0f08 100%);
            box-shadow: 0 -20px 40px rgba(0,0,0,0.8);
        }

        .slider-track {
            background: linear-gradient(90deg, #1a1a1a, #2a2a2a);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        .slider-thumb {
            background: radial-gradient(circle, #ffd700, #b8860b);
            box-shadow: 0 2px 8px rgba(255,215,0,0.5);
        }

        canvas {
            image-rendering: optimizeSpeed;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const WeatherTheatre = () => {
            const canvasRef = useRef(null);
            const animationRef = useRef(null);
            const [cosy, setCosy] = useState(0.5);
            const [eerie, setEerie] = useState(0.5);
            const [heroic, setHeroic] = useState(0.5);
            const [isNight, setIsNight] = useState(false);
            const [curtainOpen, setCurtainOpen] = useState(false);
            const [subtitle, setSubtitle] = useState('');
            const [spotlightAngle, setSpotlightAngle] = useState(0);
            const particlesRef = useRef([]);
            const cloudsRef = useRef([]);
            const lightningRef = useRef({ active: false, x: 0, y: 0, branches: [] });

            // Mock forecast data
            const baseForecast = {
                temperature: 72,
                conditions: 'Partly Cloudy',
                humidity: 65,
                windSpeed: 8,
                precipitation: 30
            };

            // Generate scene description based on sliders
            const sceneDescription = useMemo(() => {
                if (cosy > 0.7 && heroic < 0.3) {
                    return "A warm embrace of golden sunshine and gentle breezes";
                } else if (eerie > 0.7) {
                    return "Shadows dance as storm clouds gather with ominous intent";
                } else if (heroic > 0.7) {
                    return "Epic winds herald the arrival of nature's grand spectacle";
                } else if (cosy > 0.5 && eerie > 0.5) {
                    return "A mysteriously comfortable twilight settles over the land";
                } else if (heroic > 0.5 && eerie > 0.5) {
                    return "Thunder rolls across dramatic skies in symphonic grandeur";
                } else {
                    return "The weather performs its daily theatrical display";
                }
            }, [cosy, eerie, heroic]);

            // Remix forecast based on mood
            const remixedForecast = useMemo(() => {
                const temp = Math.round(baseForecast.temperature + (cosy * 10) - (eerie * 15) + (heroic * 5));
                const conditions = eerie > 0.7 ? 'Thunderstorm' :
                                  heroic > 0.7 ? 'Dramatic Winds' :
                                  cosy > 0.7 ? 'Clear Skies' : 'Variable Clouds';
                const humidity = Math.round(baseForecast.humidity + (eerie * 20) - (cosy * 10));
                const windSpeed = Math.round(baseForecast.windSpeed + (heroic * 25) + (eerie * 10));
                const precipitation = Math.round(baseForecast.precipitation + (eerie * 40) - (cosy * 20));

                return { temp, conditions, humidity, windSpeed, precipitation };
            }, [cosy, eerie, heroic]);

            // Initialize particles and clouds
            useEffect(() => {
                particlesRef.current = Array(100).fill().map(() => ({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2 + 1,
                    size: Math.random() * 3 + 1,
                    opacity: Math.random() * 0.5 + 0.5
                }));

                cloudsRef.current = Array(5).fill().map((_, i) => ({
                    x: Math.random() * window.innerWidth,
                    y: 50 + i * 60,
                    width: 150 + Math.random() * 100,
                    height: 40 + Math.random() * 30,
                    speed: 0.5 + Math.random() * 0.5,
                    opacity: 0.3 + Math.random() * 0.3
                }));
            }, []);

            // Canvas animation
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight * 0.6;

                const animate = (time) => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Sky gradient based on time and mood
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    if (isNight) {
                        gradient.addColorStop(0, `rgba(${10 + eerie * 20}, ${10 + heroic * 20}, ${30 + cosy * 20}, 1)`);
                        gradient.addColorStop(1, `rgba(${5 + eerie * 10}, ${5 + heroic * 10}, ${15 + cosy * 10}, 1)`);
                    } else {
                        gradient.addColorStop(0, `rgba(${135 - eerie * 50}, ${206 - eerie * 100}, ${235 - eerie * 100}, 1)`);
                        gradient.addColorStop(1, `rgba(${255 - eerie * 100}, ${255 - eerie * 50}, ${200 - eerie * 100}, 1)`);
                    }
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Parallax mountains/hills
                    const drawMountain = (baseY, amplitude, color, speed) => {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height);
                        for (let x = 0; x <= canvas.width; x += 10) {
                            const y = baseY + Math.sin((x + time * speed) * 0.002) * amplitude * (1 + heroic * 0.5);
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(canvas.width, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                    };

                    // Background mountains
                    drawMountain(
                        canvas.height * 0.5,
                        50,
                        `rgba(${40 + cosy * 20}, ${40 + heroic * 20}, ${60 + eerie * 20}, 0.6)`,
                        0.1
                    );
                    drawMountain(
                        canvas.height * 0.6,
                        30,
                        `rgba(${60 + cosy * 30}, ${60 + heroic * 30}, ${80 + eerie * 30}, 0.8)`,
                        0.2
                    );

                    // Clouds
                    cloudsRef.current.forEach(cloud => {
                        cloud.x += cloud.speed * (1 + heroic * 2);
                        if (cloud.x > canvas.width + cloud.width) {
                            cloud.x = -cloud.width;
                        }

                        ctx.fillStyle = `rgba(${isNight ? 100 : 255}, ${isNight ? 100 : 255}, ${isNight ? 120 : 255}, ${cloud.opacity * (0.5 + eerie * 0.5)})`;

                        // Draw cloud with multiple circles for fluffy effect
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.arc(
                                cloud.x + (i * cloud.width / 5),
                                cloud.y + Math.sin(i) * 10,
                                cloud.height * (0.5 + Math.random() * 0.2),
                                0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                    });

                    // Sun or Moon
                    const celestialX = canvas.width * 0.8;
                    const celestialY = canvas.height * 0.2;
                    const celestialRadius = 40 + cosy * 20;

                    if (!isNight) {
                        // Sun with rays
                        const sunGradient = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, celestialRadius * 2);
                        sunGradient.addColorStop(0, `rgba(255, ${255 - eerie * 100}, ${100 - eerie * 50}, 1)`);
                        sunGradient.addColorStop(0.5, `rgba(255, ${200 - eerie * 100}, ${50 - eerie * 50}, 0.5)`);
                        sunGradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = sunGradient;
                        ctx.fillRect(celestialX - celestialRadius * 2, celestialY - celestialRadius * 2, celestialRadius * 4, celestialRadius * 4);

                        // Sun core
                        ctx.fillStyle = `rgb(255, ${255 - eerie * 100}, ${150 - eerie * 100})`;
                        ctx.beginPath();
                        ctx.arc(celestialX, celestialY, celestialRadius, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Moon with glow
                        const moonGradient = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, celestialRadius * 1.5);
                        moonGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                        moonGradient.addColorStop(0.5, 'rgba(150, 150, 200, 0.3)');
                        moonGradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = moonGradient;
                        ctx.fillRect(celestialX - celestialRadius * 1.5, celestialY - celestialRadius * 1.5, celestialRadius * 3, celestialRadius * 3);

                        // Moon craters
                        ctx.fillStyle = 'rgba(150, 150, 180, 0.5)';
                        ctx.beginPath();
                        ctx.arc(celestialX - 10, celestialY - 5, 5, 0, Math.PI * 2);
                        ctx.arc(celestialX + 8, celestialY + 8, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Weather particles (rain/snow based on conditions)
                    particlesRef.current.forEach(particle => {
                        particle.x += particle.vx * (1 + heroic * 2);
                        particle.y += particle.vy * (1 + eerie * 2);

                        if (particle.y > canvas.height) {
                            particle.y = -10;
                            particle.x = Math.random() * canvas.width;
                        }
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;

                        ctx.fillStyle = `rgba(${cosy > 0.5 ? 255 : 200}, ${cosy > 0.5 ? 255 : 200}, 255, ${particle.opacity * (eerie * 0.8)})`;

                        if (eerie > 0.5) {
                            // Rain
                            ctx.beginPath();
                            ctx.moveTo(particle.x, particle.y);
                            ctx.lineTo(particle.x - particle.vx * 2, particle.y - particle.vy * 2);
                            ctx.strokeStyle = ctx.fillStyle;
                            ctx.lineWidth = particle.size * 0.5;
                            ctx.stroke();
                        } else if (cosy > 0.6) {
                            // Sparkles/pollen
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });

                    // Lightning effect for high eerie
                    if (eerie > 0.7 && Math.random() < 0.02) {
                        lightningRef.current.active = true;
                        lightningRef.current.x = Math.random() * canvas.width;
                        lightningRef.current.y = 0;

                        // Generate lightning branches
                        lightningRef.current.branches = [];
                        let currentX = lightningRef.current.x;
                        let currentY = 0;

                        while (currentY < canvas.height * 0.7) {
                            const nextX = currentX + (Math.random() - 0.5) * 50;
                            const nextY = currentY + Math.random() * 50 + 20;
                            lightningRef.current.branches.push({ x1: currentX, y1: currentY, x2: nextX, y2: nextY });

                            // Side branches
                            if (Math.random() < 0.3) {
                                const branchX = nextX + (Math.random() - 0.5) * 30;
                                const branchY = nextY + Math.random() * 30;
                                lightningRef.current.branches.push({ x1: nextX, y1: nextY, x2: branchX, y2: branchY });
                            }

                            currentX = nextX;
                            currentY = nextY;
                        }
                    }

                    if (lightningRef.current.active) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = 'rgba(200, 200, 255, 1)';

                        lightningRef.current.branches.forEach(branch => {
                            ctx.beginPath();
                            ctx.moveTo(branch.x1, branch.y1);
                            ctx.lineTo(branch.x2, branch.y2);
                            ctx.stroke();
                        });

                        ctx.shadowBlur = 0;
                        lightningRef.current.active = false;
                    }

                    animationRef.current = requestAnimationFrame(animate);
                };

                animate(0);

                return () => {
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                };
            }, [cosy, eerie, heroic, isNight]);

            // Spotlight animation
            useEffect(() => {
                const interval = setInterval(() => {
                    setSpotlightAngle(prev => (prev + 1) % 360);
                }, 50);
                return () => clearInterval(interval);
            }, []);

            // Update subtitle when scene changes
            useEffect(() => {
                setSubtitle('');
                setTimeout(() => setSubtitle(sceneDescription), 500);
            }, [sceneDescription]);

            // Open curtain after mount
            useEffect(() => {
                setTimeout(() => setCurtainOpen(true), 500);
            }, []);

            return (
                <div className="relative w-full h-screen bg-black flex flex-col">
                    {/* Stage area */}
                    <div className="relative flex-1 overflow-hidden">
                        {/* Canvas backdrop */}
                        <canvas
                            ref={canvasRef}
                            className="absolute inset-0 w-full h-full"
                        />

                        {/* Spotlights */}
                        <div
                            className="spotlight absolute w-96 h-96 rounded-full"
                            style={{
                                left: `${30 + Math.sin(spotlightAngle * Math.PI / 180) * 20}%`,
                                top: '-10%',
                                transform: `rotate(${spotlightAngle}deg)`,
                                opacity: 0.3 + heroic * 0.4
                            }}
                        />
                        <div
                            className="spotlight absolute w-96 h-96 rounded-full"
                            style={{
                                right: `${30 + Math.cos(spotlightAngle * Math.PI / 180) * 20}%`,
                                top: '-10%',
                                transform: `rotate(${-spotlightAngle}deg)`,
                                opacity: 0.3 + heroic * 0.4
                            }}
                        />

                        {/* Weather display */}
                        <div className="absolute top-8 left-1/2 transform -translate-x-1/2 text-white text-center z-20">
                            <div className="bg-black bg-opacity-50 backdrop-blur-sm rounded-lg p-6 border border-gold border-opacity-30">
                                <h1 className="text-4xl font-bold mb-4 text-yellow-200">Weather Theatre</h1>
                                <div className="grid grid-cols-2 gap-4 text-lg">
                                    <div className="text-left">
                                        <p className="text-yellow-100">Temperature:</p>
                                        <p className="text-yellow-100">Conditions:</p>
                                        <p className="text-yellow-100">Humidity:</p>
                                    </div>
                                    <div className="text-right">
                                        <p className="text-white">{remixedForecast.temp}¬∞F</p>
                                        <p className="text-white">{remixedForecast.conditions}</p>
                                        <p className="text-white">{remixedForecast.humidity}%</p>
                                    </div>
                                    <div className="text-left">
                                        <p className="text-yellow-100">Wind:</p>
                                        <p className="text-yellow-100">Precipitation:</p>
                                    </div>
                                    <div className="text-right">
                                        <p className="text-white">{remixedForecast.windSpeed} mph</p>
                                        <p className="text-white">{remixedForecast.precipitation}%</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Curtains */}
                        <div
                            className="curtain-left absolute top-0 left-0 h-full z-30 transition-all duration-3000 ease-in-out"
                            style={{
                                width: curtainOpen ? '5%' : '50%',
                                transform: curtainOpen ? 'translateX(-20px)' : 'translateX(0)'
                            }}
                        >
                            {Array(10).fill().map((_, i) => (
                                <div
                                    key={i}
                                    className="absolute h-full bg-gradient-to-b from-red-900 to-red-800"
                                    style={{
                                        width: '20%',
                                        left: `${i * 10}%`,
                                        opacity: 0.9 - i * 0.05
                                    }}
                                />
                            ))}
                        </div>
                        <div
                            className="curtain-right absolute top-0 right-0 h-full z-30 transition-all duration-3000 ease-in-out"
                            style={{
                                width: curtainOpen ? '5%' : '50%',
                                transform: curtainOpen ? 'translateX(20px)' : 'translateX(0)'
                            }}
                        >
                            {Array(10).fill().map((_, i) => (
                                <div
                                    key={i}
                                    className="absolute h-full bg-gradient-to-b from-red-900 to-red-800"
                                    style={{
                                        width: '20%',
                                        right: `${i * 10}%`,
                                        opacity: 0.9 - i * 0.05
                                    }}
                                />
                            ))}
                        </div>

                        {/* Stage floor */}
                        <div className="stage-floor absolute bottom-0 w-full h-20 z-10" />

                        {/* Subtitle */}
                        <div className="absolute bottom-24 left-1/2 transform -translate-x-1/2 z-20 bg-black bg-opacity-70 px-6 py-3 rounded">
                            <p className="typewriter text-yellow-100 text-lg tracking-wide">
                                {subtitle}
                            </p>
                        </div>
                    </div>

                    {/* Control panel */}
                    <div className="bg-gradient-to-b from-gray-900 to-black p-6 border-t border-yellow-900 border-opacity-50">
                        <div className="max-w-4xl mx-auto">
                            {/* Mood sliders */}
                            <div className="grid grid-cols-3 gap-6 mb-4">
                                <div>
                                    <label className="text-yellow-200 text-sm font-semibold">COSY</label>
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.01"
                                        value={cosy}
                                        onChange={(e) => setCosy(parseFloat(e.target.value))}
                                        className="w-full h-3 rounded-lg appearance-none cursor-pointer slider-track"
                                        style={{
                                            background: `linear-gradient(90deg, #8B4513 0%, #FFD700 ${cosy * 100}%, #2a2a2a ${cosy * 100}%, #2a2a2a 100%)`
                                        }}
                                    />
                                    <div className="text-center text-yellow-100 mt-1">{Math.round(cosy * 100)}%</div>
                                </div>
                                <div>
                                    <label className="text-purple-300 text-sm font-semibold">EERIE</label>
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.01"
                                        value={eerie}
                                        onChange={(e) => setEerie(parseFloat(e.target.value))}
                                        className="w-full h-3 rounded-lg appearance-none cursor-pointer slider-track"
                                        style={{
                                            background: `linear-gradient(90deg, #4B0082 0%, #9400D3 ${eerie * 100}%, #2a2a2a ${eerie * 100}%, #2a2a2a 100%)`
                                        }}
                                    />
                                    <div className="text-center text-purple-200 mt-1">{Math.round(eerie * 100)}%</div>
                                </div>
                                <div>
                                    <label className="text-red-300 text-sm font-semibold">HEROIC</label>
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.01"
                                        value={heroic}
                                        onChange={(e) => setHeroic(parseFloat(e.target.value))}
                                        className="w-full h-3 rounded-lg appearance-none cursor-pointer slider-track"
                                        style={{
                                            background: `linear-gradient(90deg, #8B0000 0%, #FF4500 ${heroic * 100}%, #2a2a2a ${heroic * 100}%, #2a2a2a 100%)`
                                        }}
                                    />
                                    <div className="text-center text-red-200 mt-1">{Math.round(heroic * 100)}%</div>
                                </div>
                            </div>

                            {/* Time toggle */}
                            <div className="flex justify-center">
                                <button
                                    onClick={() => setIsNight(!isNight)}
                                    className="bg-gradient-to-r from-yellow-600 to-yellow-800 hover:from-yellow-700 hover:to-yellow-900 text-white px-8 py-3 rounded-full font-bold text-lg shadow-lg transform transition-all hover:scale-105"
                                >
                                    {isNight ? 'üåô Night Show' : '‚òÄÔ∏è Matin√©e'}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<WeatherTheatre />, document.getElementById('root'));
    </script>
</body>
</html>