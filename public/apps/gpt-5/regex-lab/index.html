<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Regex Lab â€” Singleâ€‘File Playground</title>
  <meta name="description" content="Learn and test JavaScript regular expressions with live matches, colored capture groups, match tables, and pattern explanations. Single-file, no build tools." />
  <style>
    :root {
      --bg: #0f1115;
      --bg-soft: #141821;
      --panel: #12151d;
      --panel-2: #0c0f16;
      --text: #e7eaf1;
      --muted: #aab2c0;
      --accent: #7aa2ff;
      --accent-2: #5eead4;
      --danger: #ff6b6b;
      --warn: #fbbf24;
      --ok: #7dd3fc;
      --border: #222838;
      --chip: #1b2130;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --code: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    }
    [data-theme="light"] {
      --bg: #f7f8fb;
      --bg-soft: #ffffff;
      --panel: #ffffff;
      --panel-2: #f3f5f9;
      --text: #111827;
      --muted: #4b5563;
      --accent: #2b6ef7;
      --accent-2: #06b6d4;
      --danger: #dc2626;
      --warn: #d97706;
      --ok: #2563eb;
      --border: #e5e7eb;
      --chip: #eef2ff;
      --shadow: 0 10px 30px rgba(0,0,0,.08);
    }

    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: var(--sans); line-height: 1.4;
    }

    .container { max-width: 1200px; margin: 28px auto; padding: 0 16px; }

    /* Terminal window shell */
    .term {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px; box-shadow: var(--shadow);
      overflow: hidden;
    }
    .term-header {
      display: flex; align-items: center; gap: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,0));
      padding: 10px 14px; border-bottom: 1px solid var(--border);
    }
    .btns { display: inline-flex; gap: 8px; }
    .dot { width: 12px; height: 12px; border-radius: 999px; display: inline-block; }
    .dot.red { background: #ff5f56; box-shadow: 0 0 0 1px #e0443e inset; }
    .dot.yellow { background: #ffbd2e; box-shadow: 0 0 0 1px #dea123 inset; }
    .dot.green { background: #27c93f; box-shadow: 0 0 0 1px #1ca532 inset; }

    .title { font-weight: 700; letter-spacing: .2px; }
    .spacer { flex: 1; }

    .mini-btn {
      color: var(--text); background: var(--chip); border: 1px solid var(--border);
      padding: 6px 10px; border-radius: 8px; font-size: 12px; cursor: pointer; user-select: none;
    }
    .mini-btn:hover { filter: brightness(1.06); }
    .mini-btn[aria-pressed="true"] { outline: 2px solid var(--accent); }

    .grid {
      display: grid; grid-template-columns: 1.1fr .9fr; gap: 14px; padding: 14px;
    }
    @media (max-width: 1000px) {
      .grid { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--panel-2); border: 1px solid var(--border); border-radius: 12px; padding: 12px;
    }

    label { font-weight: 600; font-size: 13px; color: var(--muted); }
    input[type="text"], textarea {
      width: 100%; box-sizing: border-box; padding: 10px 12px; color: var(--text);
      background: var(--bg-soft); border: 1px solid var(--border); border-radius: 10px;
      font-family: var(--code); font-size: 14px;
    }
    textarea { min-height: 160px; resize: vertical; }

    .row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
    .flags { display: flex; flex-wrap: wrap; gap: 6px; }

    .chips { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    .chip { font-family: var(--code); background: var(--chip); border: 1px solid var(--border); color: var(--text);
      padding: 4px 8px; border-radius: 8px; font-size: 12px; cursor: pointer; }
    .chip:hover { filter: brightness(1.06); }

    .error {
      background: color-mix(in oklab, var(--danger) 14%, transparent);
      border: 1px solid color-mix(in oklab, var(--danger) 40%, var(--border));
      color: var(--text); padding: 10px 12px; border-radius: 10px; margin-top: 8px;
      font-family: var(--code);
    }
    .error strong { color: var(--danger); }
    .caret-line { white-space: pre; font-family: var(--code); color: var(--muted); }

    /* Output panes */
    .outputs { display: grid; grid-template-columns: 1.2fr .8fr; gap: 14px; }
    @media (max-width: 1000px) { .outputs { grid-template-columns: 1fr; } }

    .preview {
      min-height: 160px; font-family: var(--code); font-size: 14px; white-space: pre-wrap; word-break: break-word;
      padding: 10px; background: var(--bg-soft); border: 1px dashed var(--border); border-radius: 10px;
    }

    /* Match and group highlighting */
    .seg { background: color-mix(in oklab, var(--accent) 16%, transparent); border-radius: 4px; }
    .seg.zero { background: color-mix(in oklab, var(--warn) 26%, transparent); }
    .gseg { border-bottom: 2px solid; padding-bottom: 1px; }

    .legend { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 6px; }
    .legend .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border: 1px solid var(--border);
      border-radius: 999px; font-size: 12px; background: var(--chip); }
    .swatch { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }

    table { width: 100%; border-collapse: collapse; font-family: var(--code); font-size: 13px; }
    th, td { text-align: left; padding: 8px 10px; border-bottom: 1px solid var(--border); vertical-align: top; }
    th { color: var(--muted); font-weight: 700; background: rgba(255,255,255,0.02); position: sticky; top: 0; }
    .table-wrap { max-height: 290px; overflow: auto; border: 1px solid var(--border); border-radius: 10px; }
    .badge { font-size: 11px; padding: 2px 6px; background: var(--chip); border: 1px solid var(--border); border-radius: 999px; color: var(--muted); }

    .footer-note { color: var(--muted); font-size: 12px; margin-top: 8px; }
    .linky { color: var(--accent); cursor: pointer; text-decoration: underline dotted; }
    .right { text-align: right; }
  </style>
</head>
<body>
  <div class="container">
    <div class="term" id="app">
      <div class="term-header">
        <div class="btns"><span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span></div>
        <div class="title">Regex Lab</div>
        <div class="spacer"></div>
        <button id="themeBtn" class="mini-btn" title="Toggle light/dark">ðŸŒ— Theme</button>
        <button id="shareBtn" class="mini-btn" title="Copy permalink with pattern + flags">ðŸ”— Share</button>
        <button id="clearBtn" class="mini-btn" title="Clear test text">ðŸ§¹ Clear</button>
      </div>

      <div class="grid">
        <!-- Inputs column -->
        <div class="panel">
          <div class="row" style="margin-bottom:8px;">
            <div>
              <label for="pattern">Pattern</label>
              <input type="text" id="pattern" placeholder="Enter regex pattern (without / /)" spellcheck="false" />
            </div>
            <div>
              <label>Flags</label>
              <div class="flags">
                <button class="mini-btn flag" data-flag="g" aria-pressed="true" title="g â€” global (find all)">g</button>
                <button class="mini-btn flag" data-flag="i" title="i â€” ignore case">i</button>
                <button class="mini-btn flag" data-flag="m" title="m â€” multiline (^ and $ match line boundaries)">m</button>
                <button class="mini-btn flag" data-flag="s" title="s â€” dotAll (. matches newlines)">s</button>
                <button class="mini-btn flag" data-flag="u" aria-pressed="true" title="u â€” unicode mode">u</button>
                <button class="mini-btn flag" data-flag="y" title="y â€” sticky (match at lastIndex)">y</button>
              </div>
            </div>
          </div>

          <div class="chips" id="inserts">
            <!-- quick insert chips will be injected -->
          </div>

          <div id="errorBox" class="error" style="display:none"></div>
          <div id="caretBox" class="caret-line" style="display:none"></div>

          <div style="margin-top:10px;">
            <label for="testText">Test Text</label>
            <textarea id="testText" placeholder="Paste text to test againstâ€¦"></textarea>
          </div>
          <div class="footer-note">Preview scans all matches using global search for clarity. Your selected flags (i, m, s, u) affect matching; sticky (y) is ignored for preview scanning.</div>
        </div>

        <!-- Outputs column (right) -->
        <div class="panel">
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
            <div style="font-weight:700;">Matches Preview</div>
            <span class="badge" id="countBadge">0 matches</span>
            <div class="spacer"></div>
            <span class="badge" title="Uses hasIndices â€˜dâ€™ flag when available in your browser">indices: auto</span>
          </div>
          <div id="preview" class="preview" aria-live="polite"></div>
          <div id="legend" class="legend"></div>
        </div>
      </div>

      <div class="grid" style="border-top:1px solid var(--border); padding-top:0;">
        <div class="panel">
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
            <div style="font-weight:700;">Matches Table</div>
            <div class="spacer"></div>
            <span class="badge" id="engineBadge">JS RegExp</span>
          </div>
          <div class="table-wrap"><table id="matchesTable"></table></div>
        </div>
        <div class="panel">
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
            <div style="font-weight:700;">Pattern Explanation</div>
          </div>
          <div id="explain" class="preview" style="min-height: 290px;"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function() {
      const qs = (s, el=document) => el.querySelector(s);
      const qsa = (s, el=document) => Array.from(el.querySelectorAll(s));
      const patternEl = qs('#pattern');
      const testEl = qs('#testText');
      const errorBox = qs('#errorBox');
      const caretBox = qs('#caretBox');
      const countBadge = qs('#countBadge');
      const preview = qs('#preview');
      const legendEl = qs('#legend');
      const tableEl = qs('#matchesTable');
      const themeBtn = qs('#themeBtn');
      const shareBtn = qs('#shareBtn');
      const clearBtn = qs('#clearBtn');

      const flagButtons = qsa('.flag');

      const defaultState = {
        pattern: '(?<word>[A-Za-z]+)(?:\\s+(?<digits>\\d+))?',
        flags: 'gu',
        text: 'Hello world 123!\\nRegex Lab highlights matches and capture groups.\\nHELLO World 456.'
      };

      // Theme
      const root = document.documentElement;
      function setTheme(t){ root.setAttribute('data-theme', t); localStorage.setItem('regexlab:theme', t); }
      const savedTheme = localStorage.getItem('regexlab:theme');
      setTheme(savedTheme || 'dark');
      themeBtn.addEventListener('click', () => setTheme(root.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'));

      // Quick inserts
      const inserts = [
        { label: '\\d', value: '\\d', tip: 'digit' },
        { label: '\\w', value: '\\w', tip: 'word char' },
        { label: '\\s', value: '\\s', tip: 'whitespace' },
        { label: '.', value: '.', tip: 'any char' },
        { label: '[A-Z]', value: '[A-Z]', tip: 'range Aâ€“Z' },
        { label: '[a-z]', value: '[a-z]', tip: 'range aâ€“z' },
        { label: '[0-9]', value: '[0-9]', tip: 'digits' },
        { label: '\\b', value: '\\b', tip: 'word boundary' },
        { label: '^', value: '^', tip: 'start' },
        { label: '$', value: '$', tip: 'end' },
        { label: '(group)', value: '($SEL$)', tip: 'capturing group', surround: true },
        { label: '(?: )', value: '(?:$SEL$)', tip: 'non-capturing', surround: true },
        { label: '(?= )', value: '(?=$SEL$)', tip: 'lookahead', surround: true },
        { label: '(?! )', value: '(?!$SEL$)', tip: 'neg lookahead', surround: true },
        { label: '(?<= )', value: '(?<=$SEL$)', tip: 'lookbehind', surround: true },
        { label: '(?<! )', value: '(?<!$SEL$)', tip: 'neg lookbehind', surround: true },
        { label: '{n}', value: '{$SEL$}', tip: 'exactly n' },
        { label: '{n,}', value: '{$SEL$,}', tip: 'n or more' },
        { label: '{n,m}', value: '{$SEL$,$SEL$}', tip: 'between n,m' },
        { label: '+', value: '+', tip: 'one or more' },
        { label: '*', value: '*', tip: 'zero or more' },
        { label: '?', value: '?', tip: 'optional' },
        { label: '|', value: '|', tip: 'alternation' }
      ];
      const insertsWrap = qs('#inserts');
      inserts.forEach(i => {
        const b = document.createElement('button');
        b.className = 'chip'; b.textContent = i.label; b.title = i.tip;
        b.addEventListener('click', () => insertToken(i));
        insertsWrap.appendChild(b);
      });
      function insertToken(ins) {
        const el = patternEl; el.focus();
        const start = el.selectionStart ?? el.value.length; const end = el.selectionEnd ?? start;
        const selected = el.value.slice(start, end);
        const templ = ins.value.includes('$SEL$') ? ins.value.replaceAll('$SEL$', selected || '') : ins.value;
        const newVal = el.value.slice(0, start) + templ + el.value.slice(end);
        el.value = newVal;
        const caret = start + templ.length;
        el.setSelectionRange(caret, caret);
        scheduleUpdate();
      }

      // Flags
      function getFlags() {
        return flagButtons.filter(b => b.getAttribute('aria-pressed') === 'true').map(b => b.dataset.flag).join('');
      }
      flagButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const pressed = btn.getAttribute('aria-pressed') === 'true';
          btn.setAttribute('aria-pressed', pressed ? 'false' : 'true');
          scheduleUpdate();
        });
      });

      // Share
      function setHashFromState(p, f, t){
        const params = new URLSearchParams();
        params.set('p', p); params.set('f', f);
        // keep hash small: include text only if short
        if (t && t.length <= 300) params.set('t', t);
        location.hash = '#' + params.toString();
      }
      function parseHash(){
        if (!location.hash) return null;
        try {
          const q = new URLSearchParams(location.hash.slice(1));
          const p = q.get('p'); const f = q.get('f'); const t = q.get('t');
          if (!p) return null; return { pattern: p, flags: f || '', text: t || '' };
        } catch { return null; }
      }
      shareBtn.addEventListener('click', async () => {
        setHashFromState(patternEl.value, getFlags(), testEl.value);
        try {
          await navigator.clipboard.writeText(location.href);
          shareBtn.textContent = 'âœ… Copied';
          setTimeout(() => shareBtn.textContent = 'ðŸ”— Share', 1000);
        } catch {
          shareBtn.textContent = 'ðŸ“Ž Link set';
          setTimeout(() => shareBtn.textContent = 'ðŸ”— Share', 1000);
        }
      });

      clearBtn.addEventListener('click', () => { testEl.value = ''; scheduleUpdate(); });

      // Debounce
      let raf = 0;
      function scheduleUpdate(){ cancelAnimationFrame(raf); raf = requestAnimationFrame(updateAll); }

      patternEl.addEventListener('input', scheduleUpdate);
      testEl.addEventListener('input', scheduleUpdate);

      // Initialize from hash or defaults
      (function init(){
        const h = parseHash();
        const state = h || defaultState;
        patternEl.value = state.pattern;
        testEl.value = state.text || defaultState.text;
        const flagsSet = new Set((state.flags || 'gu').split(''));
        flagButtons.forEach(b => b.setAttribute('aria-pressed', flagsSet.has(b.dataset.flag) ? 'true' : 'false'));
        scheduleUpdate();
        patternEl.focus();
      })();

      // Regex engine helpers
      const supportsIndices = (() => { try { new RegExp('a', 'd'); return true; } catch { return false; }})();
      const colorForGroup = (i) => {
        const hues = [200, 148, 26, 330, 4, 260, 90, 0];
        const hue = hues[(i-1) % hues.length];
        return `hsl(${hue} 85% 60%)`;
      };

      function compile(pattern, flags){
        // For preview scanning, force global, drop sticky; preserve i m s u
        const core = (flags || '').replace(/g|y/g, '');
        const scanFlags = core + 'g' + (supportsIndices ? 'd' : '');
        try {
          const re = new RegExp(pattern, scanFlags);
          errorBox.style.display = 'none';
          caretBox.style.display = 'none';
          qs('#pattern').style.borderColor = 'var(--border)';
          return { ok: true, re };
        } catch (e) {
          showError(e, pattern);
          return { ok: false, re: null };
        }
      }

      function showError(e, pattern){
        const msg = String(e && e.message || e);
        errorBox.style.display = 'block';
        errorBox.innerHTML = `<strong>Error:</strong> ${escapeHtml(msg)}`;
        qs('#pattern').style.borderColor = 'var(--danger)';
        // Try to find position
        let pos = null;
        const m = msg.match(/position (\\d+)/i) || msg.match(/index (\\d+)/i);
        if (m) pos = parseInt(m[1], 10);
        if (pos == null) pos = bracketHeuristic(pattern);
        if (pos != null && Number.isFinite(pos)) {
          caretBox.style.display = 'block';
          caretBox.textContent = pattern + "\n" + ' '.repeat(Math.max(0, pos)) + '^';
        } else {
          caretBox.style.display = 'none';
        }
        countBadge.textContent = '0 matches';
        preview.textContent = '';
        legendEl.innerHTML = '';
        tableEl.innerHTML = '';
      }

      function bracketHeuristic(p){
        // Simple balance finder for (, [, { â€” returns first likely problematic index
        const stacks = { '(': [], '[': [], '{': [] };
        for (let i=0; i<p.length; i++){
          const c = p[i];
          if (c === '\\') { i++; continue; }
          if (c==='('||c==='['||c==='{') stacks[c].push(i);
          if (c===')' && stacks['('].length) stacks['('].pop();
          else if (c===')' && !stacks['('].length) return i;
          if (c===']' && stacks['['].length) stacks['['].pop();
          else if (c===']' && !stacks['['].length) return i;
          if (c==='}' && stacks['{'].length) stacks['{'].pop();
          else if (c==='}' && !stacks['{'].length) return i;
        }
        for (const k of ['(', '[', '{']) if (stacks[k].length) return stacks[k][stacks[k].length-1];
        return null;
      }

      function escapeHtml(s){ return s.replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

      function updateAll(){
        const flags = getFlags();
        const pattern = patternEl.value;
        const text = testEl.value ?? '';
        setHashFromState(pattern, flags, text.length<=300?text:'');

        const { ok, re } = compile(pattern, flags);
        if (!ok) return;

        // Collect matches (global scan always)
        const matches = [];
        if (!text) {
          countBadge.textContent = '0 matches';
          preview.textContent = '';
          legendEl.innerHTML = '';
          tableEl.innerHTML = '';
          qs('#explain').innerHTML = explainRegex(pattern);
          return;
        }

        let m; let safety = 0; const maxIter = 20000;
        re.lastIndex = 0;
        while ((m = re.exec(text)) && safety++ < maxIter) {
          // Guard zero-length infinite loops
          if (m[0] === '') {
            matches.push({ m, idx: re.lastIndex, indices: supportsIndices ? m.indices : null });
            re.lastIndex = Math.min(text.length, re.lastIndex + 1);
          } else {
            matches.push({ m, idx: m.index, indices: supportsIndices ? m.indices : null });
          }
          if (re.lastIndex >= text.length) break;
        }

        renderPreview(text, matches);
        renderTable(text, matches);
        qs('#explain').innerHTML = explainRegex(pattern);
        countBadge.textContent = `${matches.length} match${matches.length===1?'':'es'}`;
      }

      function renderPreview(text, matches){
        if (!matches.length) { preview.textContent = 'No matches.'; legendEl.innerHTML = ''; return; }
        const events = [];
        const len = text.length;
        // Create events for full matches and groups
        matches.forEach((obj, mi) => {
          const ind = obj.indices;
          if (ind && ind[0]) {
            const [s,e] = ind[0]; if (s==null || e==null) return;
            events.push({ at: s, type: 'start', group: 0, mi });
            events.push({ at: e, type: 'end', group: 0, mi });
            for (let gi=1; gi<ind.length; gi++) {
              const seg = ind[gi]; if (!seg || seg[0]==null) continue;
              const [gs, ge] = seg; if (gs===ge) continue; // zero-length groups skip in preview
              events.push({ at: gs, type: 'start', group: gi, mi });
              events.push({ at: ge, type: 'end', group: gi, mi });
            }
          } else {
            // Fallback without indices: only whole match
            const s = obj.idx; const e = s + (obj.m[0]?.length || 0);
            events.push({ at: s, type: 'start', group: 0, mi });
            events.push({ at: e, type: 'end', group: 0, mi });
          }
        });
        events.sort((a,b)=> a.at===b.at ? (a.type==='end'? -1:1) : a.at-b.at);
        const points = Array.from(new Set([0, ...events.map(e=>e.at), len])).sort((a,b)=>a-b);

        const active = [];
        let out = '';
        let ptr = 0; let ei = 0;
        function pushChunk(from, to){
          if (to<=from) return;
          const textSeg = escapeHtml(text.slice(from, to));
          // Topmost non-zero group has priority; otherwise if match active, use seg
          const topGroup = [...active].reverse().find(g => g.group>0);
          const hasMatch = active.some(g => g.group===0);
          if (topGroup) {
            const color = colorForGroup(topGroup.group);
            out += `<span class="gseg" style="border-bottom-color:${color}">${textSeg}</span>`;
          } else if (hasMatch) {
            out += `<span class="seg">${textSeg}</span>`;
          } else {
            out += textSeg;
          }
        }
        for (let pi=0; pi<points.length; pi++){
          const p = points[pi];
          pushChunk(ptr, p);
          // Process all events at p
          while (ei < events.length && events[ei].at === p) {
            const ev = events[ei++];
            if (ev.type === 'end') {
              const idx = active.findIndex(x => x.group===ev.group && x.mi===ev.mi);
              if (idx>=0) active.splice(idx,1);
            } else {
              active.push({ group: ev.group, mi: ev.mi });
            }
          }
          ptr = p;
        }
        pushChunk(ptr, len);
        preview.innerHTML = out;

        // Legend for groups present
        const present = new Set();
        matches.forEach(o => {
          if (o.indices) for (let gi=1; gi<o.indices.length; gi++) if (o.indices[gi] && o.indices[gi][0]!=null) present.add(gi);
        });
        legendEl.innerHTML = Array.from(present).sort((a,b)=>a-b).map(i => {
          const sw = `<span class="swatch" style="background:${colorForGroup(i)}"></span>`;
          return `<span class="pill">${sw}<span>Group ${i}</span></span>`;
        }).join('');
      }

      function renderTable(text, matches){
        if (!matches.length) { tableEl.innerHTML = ''; return; }
        // Find max groups and names
        let maxG = 0; const names = new Map();
        for (const o of matches){
          maxG = Math.max(maxG, o.m.length-1);
          if (o.m.groups) for (const [k,v] of Object.entries(o.m.groups)) names.set(k, v);
        }
        let header = '<thead><tr><th>#</th><th>span</th><th>match</th>';
        for (let i=1;i<=maxG;i++) header += `<th>g${i}</th>`;
        header += '</tr></thead>';

        const rows = matches.map((o, idx) => {
          const span = o.indices && o.indices[0] ? `[${o.indices[0][0]}..${o.indices[0][1]})` : `[${o.idx}..${o.idx + (o.m[0]?.length||0)})`;
          let tds = `<td>${idx+1}</td><td>${span}</td><td>${escapeHtml(String(o.m[0]))}</td>`;
          for (let i=1;i<=maxG;i++){
            const val = o.m[i] == null ? '' : String(o.m[i]);
            const color = colorForGroup(i);
            tds += `<td style="color:${val?color:'inherit'}">${escapeHtml(val)}</td>`;
          }
          return `<tr>${tds}</tr>`;
        }).join('');
        tableEl.innerHTML = header + '<tbody>' + rows + '</tbody>';
      }

      // Explanation
      function explainRegex(p){
        try {
          const tokens = tokenizeRegex(p);
          return tokens.map(tok => {
            const d = escapeHtml(tok.display);
            const ex = escapeHtml(tok.explain);
            const cls = tok.kind === 'group' ? 'seg' : tok.kind==='class' ? 'gseg' : '';
            return `<span class="badge" style="margin-right:6px;">${tok.kind}</span><code class="${cls}">/${d}/</code> â€” ${ex}<br/>`;
          }).join('');
        } catch (e) {
          return `<span style="color:var(--muted)">Could not parse pattern.</span>`;
        }
      }

      function tokenizeRegex(p){
        const toks = [];
        let i = 0;
        function push(display, explain, kind){ toks.push({ display, explain, kind }); }
        function readUntil(end, allowEscape=true){
          let j=i, out='';
          while (j < p.length){
            const c = p[j++];
            if (allowEscape && c==='\\' && j<p.length) { out += c + p[j++]; continue; }
            if (c===end) break; out += c;
          }
          i = j; return out;
        }
        function quantExplain(q){
          if (q==='*') return 'zero or more';
          if (q==='+') return 'one or more';
          if (q==='?') return 'optional (zero or one)';
          const m = q.match(/^\{(\d+)(,(\d+)?)?\}$/);
          if (!m) return 'quantifier';
          if (!m[2]) return `exactly ${m[1]}`;
          if (m[2] && !m[3]) return `${m[1]} or more`;
          return `between ${m[1]} and ${m[3]}`;
        }
        const dict = {
          '\\d':'digit', '\\D':'non-digit', '\\w':'word char [A-Za-z0-9_]', '\\W':'non-word char', '\\s':'whitespace', '\\S':'non-whitespace',
          '.':'any char (except newline unless s)', '^':'start of string/line (m)', '$':'end of string/line (m)', '\\b':'word boundary', '\\B':'non-boundary'
        };
        while (i < p.length){
          const c = p[i++];
          if (c==='\\') {
            const esc = '\\' + (p[i++]||'');
            push(esc, dict[esc] || 'escape', 'escape');
            continue;
          }
          if (c==='(') {
            if (p.slice(i,i+2)==='?:') { i+=2; const inside=readUntil(')'); push('(?:'+inside+')','non-capturing group','group'); continue; }
            if (p.slice(i,i+2)==='?=') { i+=2; const inside=readUntil(')'); push('(?='+inside+')','positive lookahead','group'); continue; }
            if (p.slice(i,i+2)==='?!') { i+=2; const inside=readUntil(')'); push('(?!'+inside+')','negative lookahead','group'); continue; }
            if (p.slice(i,i+3)==='?<=') { i+=3; const inside=readUntil(')'); push('(?<='+inside+')','positive lookbehind','group'); continue; }
            if (p.slice(i,i+3)==='?<!') { i+=3; const inside=readUntil(')'); push('(?<!'+inside+')','negative lookbehind','group'); continue; }
            if (p.slice(i,i+2)==='?<') {
              // named group (?<name>...)
              i+=2; const name = readUntil('>'); const inside = readUntil(')');
              push('(?<'+name+'>'+inside+')', `named capturing group "${name}"`, 'group');
              continue;
            }
            const inside = readUntil(')');
            push('(' + inside + ')', 'capturing group', 'group');
            continue;
          }
          if (c==='['){
            const negate = p[i]==='^'; if (negate) i++;
            let cls = '';
            while (i < p.length && p[i]!==']'){
              const ch = p[i++];
              if (ch==='\\' && i<p.length) { cls += ch + p[i++]; }
              else cls += ch;
            }
            i++; // skip ]
            push('['+(negate?'^':'')+cls+']', (negate?'negated ':'')+'character class', 'class');
            continue;
          }
          if (c==='|' ) { push('|', 'alternation', 'operator'); continue; }
          if (c==='*'||c==='+'||c==='?') { push(c, quantExplain(c), 'quant'); continue; }
          if (c==='{' ){
            // read until '}'
            let j=i; while (j<p.length && p[j]!=='}') j++; const q='{'+p.slice(i,j)+'}'; i = Math.min(j+1, p.length);
            push(q, quantExplain(q), 'quant'); continue;
          }
          // literal
          push(c, 'literal', 'lit');
        }
        return toks;
      }

      // Run once on load to ensure everything is painted
      updateAll();
    })();
  </script>
</body>
</html>
