<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Falling Fruit Catcher</title>
  <style>
    :root {
      --pink: #ff4d6d;
      --orange: #ff9f1c;
      --yellow: #ffd166;
      --lime: #2dd36f;
      --cyan: #36e0ff;
      --blue: #4d7cfe;
      --grape: #7c4dff;
      --bg1: #8be9fd;
      --bg2: #ffb6c1;
      --shadow: rgba(0,0,0,0.2);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      overflow: hidden;
      font-family: ui-rounded, system-ui, "Segoe UI", "Trebuchet MS", -apple-system, Roboto, Helvetica, Arial, sans-serif;
      color: #103;
      -webkit-tap-highlight-color: transparent;
      background: radial-gradient(1200px 800px at 10% 10%, #ffffff 0%, #fff0 60%),
                  radial-gradient(1200px 800px at 90% 0%, #ffffff 0%, #fff0 60%),
                  linear-gradient(160deg, var(--bg1), var(--bg2));
      touch-action: none;
    }
    canvas { display: block; width: 100vw; height: 100vh; }

    .hud {
      position: fixed; inset: 16px 16px auto 16px; display: flex; gap: 10px; align-items: center; z-index: 5;
      pointer-events: none;
    }
    .hud .spacer { flex: 1; }
    .badge {
      pointer-events: auto;
      padding: 10px 14px; border-radius: 14px; font-weight: 800; letter-spacing: 0.5px;
      background: rgba(255,255,255,0.8); backdrop-filter: blur(6px);
      box-shadow: 0 8px 18px var(--shadow);
      color: #222;
      user-select: none;
    }
    .badge.pop { animation: pop 260ms ease; }
    @keyframes pop { 0%{transform:scale(1)} 50%{transform:scale(1.12)} 100%{transform:scale(1)} }

    .hearts { font-size: 20px; }
    .best { margin-left: auto; }

    .overlay {
      position: fixed; inset: 0; display: grid; place-items: center; z-index: 10;
      background: linear-gradient(180deg, rgba(255,255,255,0.75), rgba(255,255,255,0.55));
      opacity: 0; pointer-events: none; transition: opacity .25s ease;
    }
    .overlay.show { opacity: 1; pointer-events: auto; }

    .card {
      width: min(680px, 92vw); border-radius: 24px; padding: 26px 28px; text-align: center;
      background: radial-gradient(160% 120% at 10% 0%, rgba(255,255,255,.95), rgba(255,255,255,.85));
      box-shadow: 0 18px 40px rgba(0,0,0,.18), inset 0 0 0 2px rgba(255,255,255,.9);
    }
    h1 { margin: 8px 0 6px; font-size: clamp(28px, 5vw, 46px); letter-spacing: .5px; }
    p { margin: 8px 0 14px; font-size: clamp(14px, 2.6vw, 18px); color: #333; }

    .controls { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin: 10px 0 16px; }
    .pill { background: #fff; padding: 10px 12px; border-radius: 999px; box-shadow: 0 8px 18px var(--shadow); font-weight: 700; }

    .btn {
      --c1: var(--pink); --c2: var(--orange);
      appearance: none; border: 0; border-radius: 14px; padding: 14px 22px; cursor: pointer;
      font-weight: 900; letter-spacing: .6px; color: #fff; text-shadow: 0 2px 0 rgba(0,0,0,.12);
      background: linear-gradient(135deg, var(--c1), var(--c2)); box-shadow: 0 10px 22px rgba(0,0,0,.22);
      transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); box-shadow: 0 6px 14px rgba(0,0,0,.22); }

    .pause-badge {
      position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,.5); color: #fff; padding: 6px 12px; border-radius: 999px;
      font-weight: 800; letter-spacing: .8px; z-index: 6; box-shadow: 0 8px 18px var(--shadow);
    }
    .hidden { display: none; }

    .footer-tip { margin-top: 10px; font-size: 12px; color: #333; opacity: .8; }
  </style>
</head>
<body>
  <canvas id="game" aria-label="Falling Fruit Catcher game area" role="img"></canvas>

  <div class="hud">
    <div class="badge" id="score">Score: 0</div>
    <div class="badge hearts" id="lives" aria-live="polite">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
    <div class="badge best" id="best">Best: 0</div>
  </div>

  <div id="pauseBadge" class="pause-badge hidden">PAUSED</div>

  <div id="overlay" class="overlay show" aria-modal="true" role="dialog">
    <div class="card">
      <h1>Falling Fruit Catcher üçéüçåüçì</h1>
      <p>Catch the fruits with your basket. Miss 3 and the game ends! Big, bright, and bouncy ‚Äî perfect for kids.</p>
      <div class="controls">
        <div class="pill">Move: ‚óÄ ‚ñ∂ arrows</div>
        <div class="pill">Mouse or touch to steer</div>
        <div class="pill">Pause: P</div>
        <div class="pill">Restart: R</div>
      </div>
      <button id="startBtn" class="btn">Play</button>
      <div class="footer-tip">Tip: Try catching the shiny starfruit for bonus points!</div>
    </div>
  </div>

  <script>
  (() => {
    'use strict';

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // HUD elements
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const bestEl  = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const pauseBadge = document.getElementById('pauseBadge');

    // Device pixel ratio scaling for crisp graphics
    const DPR = Math.max(1, window.devicePixelRatio || 1);

    // Game state
    let W = 0, H = 0;
    let running = false;
    let paused = false;
    let gameOver = false;
    let score = 0;
    let best = parseInt(localStorage.getItem('ffc_best') || '0', 10);
    let lives = 3;

    // Entities
    const fruits = [];
    const particles = [];
    const floaters = []; // floating +1 texts

    // Basket
    const basket = { x: 0, y: 0, w: 280, h: 36, speed: 0 };

    // Spawn/difficulty
    let spawnTimer = 0;
    let spawnInterval = 800; // ms; will reduce with score

    // Input
    const keys = { left: false, right: false };
    let pointerX = null; // canvas-space x in CSS pixels

    // Sizing helpers
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const rand = (a, b) => a + Math.random() * (b - a);
    const pick = arr => arr[(Math.random() * arr.length) | 0];

    let baseFruitSize = 64 * DPR;

    function resize() {
      const cssW = window.innerWidth;
      const cssH = window.innerHeight;
      W = Math.floor(cssW * DPR);
      H = Math.floor(cssH * DPR);
      canvas.width = W;
      canvas.height = H;
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';

      baseFruitSize = clamp(Math.floor(W * 0.05), 48 * DPR, 110 * DPR);
      basket.y = H - Math.max(96 * DPR, Math.floor(cssH * 0.12));
      basket.w = clamp(Math.floor(W * 0.18), 220 * DPR, 420 * DPR);
      basket.h = Math.floor(40 * DPR);
      if (!Number.isFinite(basket.x) || basket.x === 0) basket.x = W / 2;
    }
    resize();
    window.addEventListener('resize', () => { resize(); });

    // AUDIO: lightweight WebAudio beeps ‚Äî no external assets
    const Audio = (() => {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      let unlocked = false;
      function unlock() { if (!unlocked) { const o = ctx.createOscillator(); const g = ctx.createGain(); o.connect(g).connect(ctx.destination); g.gain.value = 0; o.start(); o.stop(ctx.currentTime + 0.01); unlocked = true; } }
      function tone(freq=440, dur=0.09, type='sine', vol=0.2) {
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = type; o.frequency.value = freq;
        o.connect(g).connect(ctx.destination);
        const v = vol; g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(v, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
        o.start(now);
        o.stop(now + dur + 0.02);
      }
      function catchChime() { tone(740, 0.07, 'square', 0.12); tone(980, 0.08, 'triangle', 0.12); }
      function missThud() { tone(180, 0.12, 'sawtooth', 0.08); }
      function gameOverJingle() { setTimeout(()=>tone(392,0.12,'sine',0.12), 0); setTimeout(()=>tone(330,0.12,'sine',0.12), 120); setTimeout(()=>tone(262,0.20,'sine',0.12), 240); }
      return { ctx, unlock, tone, catchChime, missThud, gameOverJingle };
    })();

    // Fruit definitions and drawing
    const FruitKinds = ['apple','orange','banana','strawberry','grape','star'];

    function makeFruit() {
      // Weighted pick: starfruit is rarer
      const r = Math.random();
      let kind = 'apple';
      if (r < 0.18) kind = 'orange';
      else if (r < 0.36) kind = 'banana';
      else if (r < 0.55) kind = 'strawberry';
      else if (r < 0.90) kind = 'grape';
      else kind = 'star';

      const size = baseFruitSize * rand(0.9, 1.15);
      const x = rand(size * 0.8, W - size * 0.8);
      const y = -rand(size * 0.6, size * 1.6);
      const speed = clamp((H * 0.45) + score * 3 * DPR + rand(-40,40), 280 * DPR, 1200 * DPR);
      const drift = rand(-60, 60) * DPR;
      const spin = rand(-1.4, 1.4) * (Math.random() < 0.5 ? 1 : -1);
      const points = kind === 'star' ? 3 : 1;
      const rads = size * 0.45; // collision radius approx
      return { kind, x, y, size, r: rads, speed, drift, rot: rand(0, Math.PI*2), spin, points, prevY: y };
    }

    function drawFruit(f) {
      const s = f.size;
      const cx = f.x, cy = f.y;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(f.rot);

      switch (f.kind) {
        case 'apple': drawApple(s); break;
        case 'orange': drawOrange(s); break;
        case 'banana': drawBanana(s); break;
        case 'strawberry': drawStrawberry(s); break;
        case 'grape': drawGrapes(s); break;
        case 'star': drawStarfruit(s); break;
      }
      ctx.restore();
    }

    function gradientCircle(r, c1, c2) {
      const g = ctx.createRadialGradient(-r*0.3, -r*0.3, r*0.2, 0, 0, r);
      g.addColorStop(0, c1);
      g.addColorStop(1, c2);
      return g;
    }

    function drawApple(s) {
      const r = s * 0.45;
      ctx.fillStyle = gradientCircle(r, '#ff7b87', '#e11d48');
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
      // stem
      ctx.strokeStyle = '#6b3f1d'; ctx.lineWidth = Math.max(3, s*0.04);
      ctx.beginPath(); ctx.moveTo(0, -r*0.9); ctx.bezierCurveTo(r*0.1, -r*1.3, r*0.3, -r*1.1, r*0.2, -r*0.8); ctx.stroke();
      // leaf
      ctx.fillStyle = '#22c55e';
      ctx.beginPath(); ctx.ellipse(r*0.25, -r*0.95, r*0.35, r*0.18, 0.5, 0, Math.PI*2); ctx.fill();
      // highlight
      ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.ellipse(-r*0.35, -r*0.25, r*0.28, r*0.18, -0.6, 0, Math.PI*2); ctx.fill();
    }

    function drawOrange(s) {
      const r = s * 0.46;
      ctx.fillStyle = gradientCircle(r, '#ffd08a', '#ff9f1c');
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      // pores
      ctx.globalAlpha = 0.25; ctx.fillStyle = '#fff';
      for (let i=0;i<10;i++){ const a = Math.random()*Math.PI*2; const rr = rand(r*0.1,r*0.45); ctx.beginPath(); ctx.arc(Math.cos(a)*rr, Math.sin(a)*rr, r*0.04, 0, Math.PI*2); ctx.fill(); }
      ctx.globalAlpha = 1;
      // leaf
      ctx.fillStyle = '#2dd36f'; ctx.beginPath(); ctx.ellipse(r*0.25, -r*0.9, r*0.32, r*0.16, 0.2, 0, Math.PI*2); ctx.fill();
    }

    function drawBanana(s) {
      const w = s * 0.95, h = s * 0.40; // curved banana
      const r = h * 0.6;
      ctx.fillStyle = '#ffd54f'; ctx.strokeStyle = '#e6a700'; ctx.lineWidth = Math.max(3, s*0.035);
      ctx.beginPath();
      ctx.moveTo(-w*0.48, 0);
      ctx.quadraticCurveTo(-w*0.1, -h*1.0, w*0.45, -h*0.1);
      ctx.quadraticCurveTo(w*0.1, h*1.0, -w*0.48, 0);
      ctx.fill(); ctx.stroke();
      // tips
      ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.arc(-w*0.48, 0, r*0.18, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(w*0.45, -h*0.1, r*0.12, 0, Math.PI*2); ctx.fill();
      // highlight
      ctx.fillStyle = 'rgba(255,255,255,.6)'; ctx.beginPath(); ctx.ellipse(-w*0.15, -h*0.2, w*0.25, h*0.25, -0.2, 0, Math.PI*2); ctx.fill();
    }

    function drawStrawberry(s) {
      const r = s * 0.44;
      // body
      ctx.fillStyle = gradientCircle(r, '#ff8aa3', '#e11d48');
      ctx.beginPath();
      ctx.moveTo(0, -r*0.7);
      ctx.bezierCurveTo(r*0.9, -r*0.9, r*0.9, r*0.3, 0, r);
      ctx.bezierCurveTo(-r*0.9, r*0.3, -r*0.9, -r*0.9, 0, -r*0.7);
      ctx.fill();
      // seeds
      ctx.fillStyle = '#fff59d';
      for (let i=0;i<18;i++){ const a = Math.random()*Math.PI*2; const rr = rand(r*0.15,r*0.6); ctx.beginPath(); ctx.ellipse(Math.cos(a)*rr*0.9, Math.sin(a)*rr*0.7, r*0.06, r*0.035, rand(0,Math.PI), 0, Math.PI*2); ctx.fill(); }
      // leaves
      ctx.fillStyle = '#22c55e';
      for (let i=0;i<6;i++){ const ang = (i/6)*Math.PI*2; ctx.beginPath(); ctx.ellipse(Math.cos(ang)*r*0.2, -r*0.9 + Math.sin(ang)*r*0.06, r*0.22, r*0.10, ang*0.7, 0, Math.PI*2); ctx.fill(); }
    }

    function drawGrapes(s) {
      const r = s * 0.18;
      const cols = ['#b388ff','#a56eff','#8e5cff','#7c4dff'];
      const spots = [ [-r*2.2, -r*1.6], [-r*0.8, -r*1.6], [r*0.6, -r*1.6], [r*2.0, -r*1.6],
                      [-r*1.5, 0], [0, 0], [r*1.5, 0], [-r*0.8, r*1.6], [r*0.8, r*1.6] ];
      // stem
      ctx.strokeStyle = '#6b3f1d'; ctx.lineWidth = Math.max(3, s*0.04);
      ctx.beginPath(); ctx.moveTo(-r*0.5, -r*2.6); ctx.quadraticCurveTo(0, -r*3.2, r*0.5, -r*2.8); ctx.stroke();
      // leaf
      ctx.fillStyle = '#2dd36f'; ctx.beginPath(); ctx.ellipse(r*0.8, -r*2.8, r*0.9, r*0.45, 0.3, 0, Math.PI*2); ctx.fill();
      // grapes
      for (let i=0;i<spots.length;i++){
        const [x,y] = spots[i];
        const g = ctx.createRadialGradient(x-r*0.3, y-r*0.3, r*0.2, x, y, r*1.1);
        const c = cols[i%cols.length];
        g.addColorStop(0, '#fff'); g.addColorStop(0.05, '#fff'); g.addColorStop(0.2, c);
        g.addColorStop(1, '#5e35b1');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      }
    }

    function drawStar(ctxLocal, spikes, outerR, innerR) {
      let rot = Math.PI / 2 * 3;
      let x = 0, y = 0;
      const step = Math.PI / spikes;
      ctxLocal.beginPath();
      ctxLocal.moveTo(0, -outerR);
      for (let i=0; i<spikes; i++){
        x = Math.cos(rot) * outerR; y = Math.sin(rot) * outerR; ctxLocal.lineTo(x, y); rot += step;
        x = Math.cos(rot) * innerR; y = Math.sin(rot) * innerR; ctxLocal.lineTo(x, y); rot += step;
      }
      ctxLocal.lineTo(0, -outerR); ctxLocal.closePath();
    }

    function drawStarfruit(s) {
      const r = s * 0.38; // star radius
      const g = ctx.createRadialGradient(-r*0.2, -r*0.2, r*0.1, 0, 0, r*1.1);
      g.addColorStop(0, '#fff7a8'); g.addColorStop(1, '#ffd166');
      ctx.fillStyle = g; ctx.strokeStyle = '#f0b429'; ctx.lineWidth = Math.max(2, s*0.03);
      drawStar(ctx, 5, r, r*0.48); ctx.fill(); ctx.stroke();
      // sparkle
      ctx.globalAlpha = 0.8; ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(-r*0.3, -r*0.1, r*0.12, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Basket drawing
    function drawBasket(b) {
      const w = b.w, h = b.h;
      ctx.save();
      ctx.translate(b.x, b.y);
      // shadow
      ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.beginPath(); ctx.ellipse(0, h*0.9, w*0.42, h*0.5, 0, 0, Math.PI*2); ctx.fill();
      // body
      const grd = ctx.createLinearGradient(0, -h, 0, h);
      grd.addColorStop(0, '#ffb79c'); grd.addColorStop(1, '#ff7aa2');
      ctx.fillStyle = grd; ctx.strokeStyle = '#e64b7d'; ctx.lineWidth = Math.max(3, h*0.12);
      ctx.beginPath();
      ctx.moveTo(-w*0.5, 0);
      ctx.quadraticCurveTo(-w*0.4, -h*0.8, -w*0.2, -h);
      ctx.lineTo(w*0.2, -h);
      ctx.quadraticCurveTo(w*0.4, -h*0.8, w*0.5, 0);
      ctx.quadraticCurveTo(0, h*0.4, -w*0.5, 0);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
      // weave stripes
      ctx.strokeStyle = 'rgba(255,255,255,.45)'; ctx.lineWidth = Math.max(2, h*0.08);
      for (let i=-5;i<=5;i++) { ctx.beginPath(); ctx.moveTo(-w*0.46, i* h*0.16); ctx.quadraticCurveTo(0, i*h*0.16 + (i%2? -h*0.08 : h*0.08), w*0.46, i*h*0.16); ctx.stroke(); }
      ctx.restore();
    }

    // Particles and floaters
    function spawnStars(x, y, color='#fff', count=12) {
      for (let i=0;i<count;i++) {
        const a = Math.random()*Math.PI*2;
        const sp = rand(120*DPR, 360*DPR);
        particles.push({ x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp - 100*DPR, life: 0.8, age: 0, r: rand(3*DPR, 6*DPR), color });
      }
    }

    function spawnFloater(text, x, y, color) {
      floaters.push({ text, x, y, vy: -60*DPR, age: 0, life: 0.9, color });
    }

    // HUD updates
    function updateHUD(popScore=false) {
      scoreEl.textContent = 'Score: ' + score;
      if (popScore) { scoreEl.classList.remove('pop'); void scoreEl.offsetWidth; scoreEl.classList.add('pop'); }
      livesEl.textContent = '‚ù§'.repeat(lives).replace(/‚ù§/g, '‚ù§Ô∏è') + 'üñ§'.repeat(3 - lives);
      bestEl.textContent = 'Best: ' + best;
    }

    // Collision helper (circle vs. basket mouth)
    function fruitCaught(f) {
      const mouthY = basket.y - basket.h * 0.9;
      const withinY = (f.prevY + f.r < mouthY) && (f.y + f.r >= mouthY - 4*DPR);
      const dx = Math.abs(f.x - basket.x);
      const mouthW = basket.w * 0.86;
      const withinX = (dx < mouthW * 0.5);
      return withinX && withinY;
    }

    // Game control
    function resetGame() {
      score = 0; lives = 3; gameOver = false; paused = false; running = true;
      spawnTimer = 0; spawnInterval = 800;
      fruits.length = 0; particles.length = 0; floaters.length = 0;
      basket.x = W/2;
      updateHUD(true);
    }

    function startGame() {
      overlay.classList.remove('show');
      Audio.unlock();
      resetGame();
    }

    function endGame() {
      gameOver = true; running = false; paused = false;
      if (score > best) { best = score; localStorage.setItem('ffc_best', String(best)); }
      updateHUD();
      setTimeout(()=> Audio.gameOverJingle(), 80);
      // Show overlay with summary
      overlay.querySelector('h1').textContent = 'Game Over!';
      const p = overlay.querySelector('p');
      p.textContent = `You scored ${score} point${score===1?'':'s'}. Best: ${best}.`;
      startBtn.textContent = 'Play Again';
      overlay.classList.add('show');
    }

    function togglePause(forceState) {
      if (gameOver || !running) return;
      paused = typeof forceState === 'boolean' ? forceState : !paused;
      pauseBadge.classList.toggle('hidden', !paused);
    }

    // Input handlers
    window.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') { keys.left = true; e.preventDefault(); }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') { keys.right = true; e.preventDefault(); }
      if (e.code === 'KeyP') { togglePause(); }
      if (e.code === 'KeyR') { startGame(); }
      if ((e.code === 'Space' || e.code === 'Enter') && overlay.classList.contains('show')) { startGame(); }
    }, {passive: false});
    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    });

    const updatePointer = (clientX) => {
      const rect = canvas.getBoundingClientRect();
      pointerX = (clientX - rect.left) * DPR;
    };
    window.addEventListener('mousemove', (e) => updatePointer(e.clientX), {passive: true});
    window.addEventListener('touchstart', (e) => { if (e.touches[0]) updatePointer(e.touches[0].clientX); }, {passive: true});
    window.addEventListener('touchmove', (e) => { if (e.touches[0]) updatePointer(e.touches[0].clientX); }, {passive: true});

    document.addEventListener('visibilitychange', () => { if (document.hidden) togglePause(true); });

    startBtn.addEventListener('click', startGame);

    // Main loop
    let last = performance.now();
    function loop(now) {
      requestAnimationFrame(loop);
      const dt = Math.min(0.033, (now - last) / 1000); // cap dt to ~30ms
      last = now;

      // Background sky gradient waves
      drawBackground(now);

      if (!running || paused) {
        // draw basket idle
        drawBasket(basket);
        particles.forEach(p => drawParticle(p, 0));
        return;
      }

      // Move basket
      const maxSpeed = Math.max(700 * DPR, W * 0.8);
      if (keys.left && !keys.right) basket.x -= maxSpeed * dt;
      else if (keys.right && !keys.left) basket.x += maxSpeed * dt;
      else if (pointerX != null) {
        const dir = clamp(pointerX - basket.x, -maxSpeed*dt, maxSpeed*dt);
        basket.x += dir;
      }
      basket.x = clamp(basket.x, basket.w*0.5, W - basket.w*0.5);

      // Spawn logic: ramp with score
      spawnTimer += dt * 1000;
      const targetInterval = clamp(800 - score * 4, 420, 800);
      spawnInterval += (targetInterval - spawnInterval) * 0.05; // smooth towards target
      if (spawnTimer >= spawnInterval) { spawnTimer = 0; fruits.push(makeFruit()); }

      // Update fruits
      for (let i = fruits.length - 1; i >= 0; i--) {
        const f = fruits[i];
        f.prevY = f.y;
        f.y += (f.speed) * dt;
        f.x += f.drift * dt;
        f.rot += f.spin * dt * 0.9;
        if (f.x < f.size*0.5 || f.x > W - f.size*0.5) f.drift *= -1; // bounce off sides gently

        // Caught?
        if (fruitCaught(f)) {
          score += f.points;
          updateHUD(true);
          spawnStars(f.x, basket.y - basket.h*1.1, f.kind==='star'?'#fff7a8':'#ffffff', f.kind==='star'?18:12);
          spawnFloater('+'+f.points, f.x, basket.y - basket.h*1.4, f.kind==='star' ? '#ffef7a' : '#ffffff');
          Audio.catchChime();
          fruits.splice(i,1);
          continue;
        }

        // Missed?
        if (f.y - f.r > H) {
          fruits.splice(i,1);
          lives -= 1; updateHUD();
          Audio.missThud();
          // splat particles
          spawnStars(clamp(f.x, basket.w*0.4, W-basket.w*0.4), H - 18*DPR, 'rgba(0,0,0,0.12)', 10);
          if (lives <= 0) {
            endGame();
            return;
          }
        }
      }

      // Draw fruits
      for (let i=0;i<fruits.length;i++) drawFruit(fruits[i]);

      // Draw basket on top
      drawBasket(basket);

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.age += dt; if (p.age >= p.life) { particles.splice(i,1); continue; }
        p.vy += 420 * DPR * dt * 0.8; // gravity
        p.x += p.vx * dt; p.y += p.vy * dt;
        drawParticle(p, p.age / p.life);
      }

      // Floaters
      for (let i = floaters.length - 1; i >= 0; i--) {
        const ft = floaters[i];
        ft.age += dt; if (ft.age >= ft.life) { floaters.splice(i,1); continue; }
        ft.y += ft.vy * dt; drawFloater(ft);
      }
    }
    requestAnimationFrame(loop);

    function drawBackground(now) {
      // Soft sky with drifting bands
      ctx.clearRect(0,0,W,H);
      const t = now * 0.0002;
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, '#c8f7ff');
      g.addColorStop(1, '#ffe0ee');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

      // Wavy bands
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = '#ffffff';
      const bandH = Math.max(80*DPR, H*0.06);
      for (let i=0;i<4;i++) {
        const y = (H * 0.15) + i * bandH * 1.2 + Math.sin(t*2 + i)*20*DPR;
        ctx.beginPath(); ctx.moveTo(0, y);
        for (let x=0; x<=W; x+= 40*DPR) {
          const yy = y + Math.sin(t*6 + x*0.01 + i)*10*DPR;
          ctx.lineTo(x, yy);
        }
        ctx.lineTo(W, y + bandH); ctx.lineTo(0, y + bandH); ctx.closePath(); ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawParticle(p, t) {
      const alpha = 1 - t;
      ctx.save(); ctx.translate(p.x, p.y); ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      // small star
      ctx.beginPath();
      const r = p.r;
      drawStar(ctx, 5, r, r*0.5);
      ctx.fill();
      ctx.restore();
    }

    function drawFloater(ft) {
      const t = ft.age / ft.life;
      ctx.save(); ctx.globalAlpha = 1 - t; ctx.fillStyle = ft.color || '#fff';
      ctx.font = `${Math.floor(26*DPR)}px ui-rounded, system-ui, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 3; ctx.strokeText(ft.text, ft.x, ft.y);
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.restore();
    }

    // Initialize HUD
    updateHUD();

    // Start with overlay visible; user clicks Play
  })();
  </script>
</body>
</html>
