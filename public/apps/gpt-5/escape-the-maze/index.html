<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Escape the Maze</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111936cc;
      --panel-strong:#0f1426ee;
      --text:#e6ecff;
      --muted:#9fb0ff;
      --accent:#7cA3ff;
      --accent-2:#14b8a6;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --wall:#a8b1ff;
      --start:#7c3aed;
      --goal:#16a34a;
      --player:#38bdf8;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text); font:15px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 10% -10%, #1a245a, #0b1020 60%),
                  radial-gradient(1200px 800px at 110% 110%, #082a32, #0b1020 60%);
      overflow:hidden;
    }
    .app{
      height:100%; display:grid; grid-template-rows:auto 1fr auto; gap:10px; padding:14px; max-width:1100px; margin:0 auto;
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .brand{display:flex; align-items:center; gap:10px}
    .logo{width:28px; height:28px; border-radius:7px; background:conic-gradient(from 45deg, var(--accent), var(--good)); box-shadow:0 0 0 2px #ffffff22 inset, 0 8px 24px #0008}
    h1{font-size:18px; margin:0; letter-spacing:.3px}

    .hud{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .chip{background:var(--panel); border:1px solid #ffffff1a; padding:8px 10px; border-radius:10px; display:flex; gap:8px; align-items:baseline; box-shadow:0 6px 18px #0006}
    .chip label{color:var(--muted); font-size:12px}
    .chip .value{font-variant-numeric:tabular-nums; font-weight:600}

    .actions{margin-left:auto; display:flex; gap:8px; align-items:center}
    select, button{appearance:none; background:var(--panel-strong); border:1px solid #ffffff22; color:var(--text); border-radius:10px; padding:8px 12px; font-weight:600; cursor:pointer; box-shadow:0 6px 18px #0008}
    select:focus, button:focus{outline:2px solid #4f46e5bb; outline-offset:2px}
    button.primary{background:linear-gradient(180deg,#4254ff,#3946e7); border-color:#6270ff}
    button.ghost{background:var(--panel)}

    .board-wrap{position:relative; border-radius:14px; overflow:hidden; background:linear-gradient(180deg,#0e1330,#0a0f24); border:1px solid #ffffff1a; box-shadow:0 20px 60px #000c inset, 0 20px 40px #0008}
    canvas{display:block; width:100%; height:100%}
    #maze{filter:drop-shadow(0 3px 0 #000a) contrast(1.05)}
    #fx{position:absolute; inset:0; pointer-events:none}

    .help{display:flex; gap:12px; flex-wrap:wrap; align-items:center; color:#cbd5ff}
    .kbd{background:#11183a; border:1px solid #2a3370; padding:4px 8px; border-radius:6px; font-weight:700; box-shadow:0 4px 14px #0008}

    .pad{position:absolute; bottom:14px; right:14px; display:grid; grid-template:repeat(3,54px)/repeat(3,54px); gap:6px; opacity:.95}
    .pad button{width:54px; height:54px; border-radius:12px; background:#0f183a88; border:1px solid #5a6cff88; color:#cfe1ff; font-size:18px; backdrop-filter:blur(6px)}
    .pad .empty{visibility:hidden}

    .toast{position:absolute; top:14px; right:14px; background:#0d142f; border:1px solid #2a3a7a; padding:10px 12px; border-radius:10px; color:#e5eeffbb}

    .win{position:absolute; inset:0; display:none; place-items:center; background:#0008}
    .win.show{display:grid}
    .dialog{background:linear-gradient(180deg,#0f1737,#0d1430); border:1px solid #3a4bdd; padding:20px; border-radius:14px; width:min(520px,90vw); text-align:center; box-shadow:0 30px 80px #000f}
    .dialog h2{margin:0 0 8px; font-size:22px}
    .dialog p{margin:4px 0; color:#d6dcffcc}
    .badge{display:inline-block; margin-left:8px; padding:2px 8px; border-radius:999px; background:#132734; color:#8cf3ff; border:1px solid #1aa6b8; font-weight:700}

    @media (max-width: 840px){
      .actions{width:100%; margin-left:0}
      .pad{bottom:10px; right:10px}
      .chip{padding:6px 8px}
      select, button{padding:8px 10px}
    }
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Escape the Maze game">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <h1>Escape the Maze</h1>
      </div>
      <div class="hud" aria-live="polite">
        <div class="chip"><label>Time</label><div class="value" id="time">00:00.00</div></div>
        <div class="chip"><label>Steps</label><div class="value" id="steps">0</div></div>
        <div class="chip"><label>Shortest</label><div class="value" id="shortest">…</div></div>
        <div class="actions">
          <select id="difficulty" title="Difficulty">
            <option value="cozy">Cozy (15×9)</option>
            <option value="classic" selected>Classic (25×15)</option>
            <option value="epic">Epic (37×23)</option>
          </select>
          <button id="new" class="ghost" title="Generate new maze">New Maze</button>
          <button id="replay" class="primary" title="Replay">Replay</button>
        </div>
      </div>
    </header>

    <div class="board-wrap" id="board" tabindex="0" aria-label="Maze board. Use arrow keys to move." role="region">
      <canvas id="maze"></canvas>
      <canvas id="fx"></canvas>
      <div class="pad" id="pad" aria-hidden="true">
        <button data-dir="up" aria-label="Up">▲</button>
        <button class="empty" tabindex="-1"></button>
        <button data-dir="right" aria-label="Right">►</button>
        <button data-dir="left" aria-label="Left">◄</button>
        <button class="empty" tabindex="-1"></button>
        <button data-dir="down" aria-label="Down">▼</button>
      </div>
      <div class="toast" id="toast" style="display:none"></div>
      <div class="win" id="win">
        <div class="dialog">
          <h2 id="winTitle">You escaped!</h2>
          <p><strong>Time:</strong> <span id="finalTime">—</span></p>
          <p><strong>Steps:</strong> <span id="finalSteps">—</span> · <strong>Shortest:</strong> <span id="finalShortest">—</span> <span id="bonus" class="badge" style="display:none">Shortest Path Bonus</span></p>
          <p id="bestWrap" style="display:none"><strong>Best (this difficulty):</strong> <span id="bestTime">—</span></p>
          <div style="margin-top:12px; display:flex; gap:8px; justify-content:center">
            <button id="again" class="primary">Play Again</button>
            <button id="same" class="ghost">Same Size, New Maze</button>
          </div>
        </div>
      </div>
    </div>

    <div class="help" aria-hidden="false">
      <div>Reach the <span style="color:var(--goal); font-weight:700">green goal</span> from the <span style="color:var(--start); font-weight:700">purple start</span>.</div>
      <div>Move with <span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">←</span><span class="kbd">→</span> or tap the pad.</div>
      <div>Timer starts on first move; match the shortest path for a bonus.</div>
    </div>
  </div>

  <script>
  ;(() => {
    const $ = (sel) => document.querySelector(sel)
    const $$ = (sel) => Array.from(document.querySelectorAll(sel))

    const board = $('#board')
    const mazeCanvas = $('#maze')
    const fxCanvas = $('#fx')
    const timeEl = $('#time'), stepsEl = $('#steps'), shortestEl = $('#shortest')
    const diffSel = $('#difficulty')
    const btnNew = $('#new'), btnReplay = $('#replay')
    const toast = $('#toast')
    const win = $('#win'), winTitle = $('#winTitle'), finalTime = $('#finalTime'), finalSteps = $('#finalSteps'), finalShortest = $('#finalShortest'), bestWrap = $('#bestWrap'), bestTime = $('#bestTime'), bonusBadge = $('#bonus')
    const btnAgain = $('#again'), btnSame = $('#same')

    const ctx = mazeCanvas.getContext('2d')
    const fctx = fxCanvas.getContext('2d')
    let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1))

    const DIFF = {
      cozy:   {cols:15, rows:9,  cell:44},
      classic:{cols:25, rows:15, cell:36},
      epic:   {cols:37, rows:23, cell:28},
    }

    // Maze data structures
    class Maze {
      constructor(cols, rows){
        this.cols = cols; this.rows = rows
        this.grid = Array.from({length:rows}, (_,r)=>Array.from({length:cols}, (_,c)=>({r, c, w:{t:1,r:1,b:1,l:1}, v:false})))
        this.start = this.grid[0][0]
        this.goal = this.grid[rows-1][cols-1]
      }
      generate(){
        const stack = []
        const cur = this.grid[0][0]
        cur.v = true
        stack.push(cur)
        while(stack.length){
          const a = stack[stack.length-1]
          const n = this._neighbors(a).filter(n=>!n.v)
          if(n.length){
            const b = n[Math.floor(Math.random()*n.length)]
            this._carve(a, b)
            b.v = true
            stack.push(b)
          } else {
            stack.pop()
          }
        }
        // reset visited flags for gameplay
        for(const row of this.grid) for(const c of row) c.v = false
      }
      _neighbors(cell){
        const n=[]; const {r,c}=cell
        if(r>0) n.push(this.grid[r-1][c])
        if(c<this.cols-1) n.push(this.grid[r][c+1])
        if(r<this.rows-1) n.push(this.grid[r+1][c])
        if(c>0) n.push(this.grid[r][c-1])
        return n
      }
      _carve(a,b){
        const dr = b.r - a.r, dc = b.c - a.c
        if(dr===-1){a.w.t=0; b.w.b=0}
        else if(dr===1){a.w.b=0; b.w.t=0}
        else if(dc===1){a.w.r=0; b.w.l=0}
        else if(dc===-1){a.w.l=0; b.w.r=0}
      }
      passable(a,b){
        const dr=b.r-a.r, dc=b.c-a.c
        if(dr===-1) return a.w.t===0
        if(dr===1)  return a.w.b===0
        if(dc===1)  return a.w.r===0
        if(dc===-1) return a.w.l===0
        return false
      }
      shortestLength(){
        // BFS on cell graph to compute shortest path length in steps
        const q=[]; const seen=new Set
        const key=(x)=>x.r+','+x.c
        q.push({cell:this.start, d:0}); seen.add(key(this.start))
        while(q.length){
          const {cell,d}=q.shift()
          if(cell===this.goal) return d
          for(const n of this._neighbors(cell)){
            if(seen.has(key(n))) continue
            if(this.passable(cell,n)){
              seen.add(key(n)); q.push({cell:n, d:d+1})
            }
          }
        }
        return Infinity
      }
    }

    // Renderer + game state
    const Game = {
      maze:null,
      size: DIFF.classic,
      cell: 36,
      steps:0,
      shortest:0,
      started:false,
      startTs:0,
      win:false,
      player:{r:0,c:0, x:0,y:0, tx:0,ty:0, t:1}, // t=1 means resting at target
      resize(){
        const pad = 16
        const w = board.clientWidth - pad*2
        const h = Math.max(320, board.clientHeight - pad*2)
        mazeCanvas.width = Math.floor(w*dpr)
        mazeCanvas.height = Math.floor(h*dpr)
        mazeCanvas.style.width = w+'px'; mazeCanvas.style.height = h+'px'
        fxCanvas.width=mazeCanvas.width; fxCanvas.height=mazeCanvas.height
        fxCanvas.style.width=mazeCanvas.style.width; fxCanvas.style.height=mazeCanvas.style.height
        ctx.setTransform(dpr,0,0,dpr,0,0)
        fctx.setTransform(dpr,0,0,dpr,0,0)
        this.render()
      },
      new(sizeKey){
        this.size = DIFF[sizeKey] || this.size
        this.cell = this.size.cell
        this.maze = new Maze(this.size.cols, this.size.rows)
        this.maze.generate()
        this.shortest = this.maze.shortestLength()
        this.steps = 0
        this.started=false; this.startTs=0; this.win=false
        this.player = {r:0,c:0, x:0,y:0, tx:0,ty:0, t:1}
        updateHUD()
        this.resize()
        flash(`New ${sizeKey} maze ready!`)
      },
      replay(){
        this.new(diffSel.value)
      },
      move(dir){
        if(this.win) return
        const p=this.player
        if(p.t<1) return // already moving
        const {r,c}=p
        let nr=r, nc=c
        if(dir==='up') nr--
        if(dir==='down') nr++
        if(dir==='left') nc--
        if(dir==='right') nc++
        if(nr<0||nc<0||nr>=this.size.rows||nc>=this.size.cols) return
        const a=this.maze.grid[r][c], b=this.maze.grid[nr][nc]
        if(!this.maze.passable(a,b)) return
        // commit move
        if(!this.started){ this.started=true; this.startTs=performance.now() }
        this.steps++
        p.r=nr; p.c=nc; p.t=0; p.x=c; p.y=r; p.tx=nc; p.ty=nr
        // victory?
        if(nr===this.size.rows-1 && nc===this.size.cols-1){
          // let animation finish then win
          setTimeout(()=>this.finish(), 120)
        }
        updateHUD()
      },
      finish(){
        if(this.win) return
        this.win=true
        const t = timeNow()
        const shortestBonus = (this.steps===this.shortest)
        showWin(t, this.steps, this.shortest, shortestBonus)
        confettiBurst()
      },
      tick(dt){
        // animate player sliding between cells
        const p=this.player
        if(p.t<1){
          const speed = 14 // cells per second
          p.t = Math.min(1, p.t + dt*speed)
        }
      },
      render(){
        const {cols,rows} = this.size
        const W = mazeCanvas.width/dpr, H = mazeCanvas.height/dpr
        const pad = 24
        const cw = Math.min(this.cell, Math.floor((W - pad*2)/cols), Math.floor((H - pad*2)/rows))
        const offX = Math.floor((W - cols*cw)/2)
        const offY = Math.floor((H - rows*cw)/2)
        this._screen = {cw, offX, offY}

        ctx.clearRect(0,0,W,H)
        // background grid subtle glow
        ctx.fillStyle = '#0b122e'
        ctx.fillRect(0,0,W,H)

        // cells decorations (start/goal)
        const start = this.maze.start, goal = this.maze.goal
        ctx.fillStyle = hexWithAlpha(getCss('--start'), .85)
        ctx.fillRect(offX + start.c*cw + 3, offY + start.r*cw + 3, cw-6, cw-6)
        ctx.fillStyle = hexWithAlpha(getCss('--goal'), .92)
        ctx.fillRect(offX + goal.c*cw + 3, offY + goal.r*cw + 3, cw-6, cw-6)

        // draw walls
        ctx.strokeStyle = hexWithAlpha(getCss('--wall'), .95)
        ctx.lineWidth = Math.max(2, Math.floor(cw*0.12))
        ctx.lineCap = 'square'
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const cell=this.maze.grid[r][c]
            const x = offX + c*cw, y = offY + r*cw
            if(cell.w.t) drawLine(x, y, x+cw, y)
            if(cell.w.r) drawLine(x+cw, y, x+cw, y+cw)
            if(cell.w.b) drawLine(x, y+cw, x+cw, y+cw)
            if(cell.w.l) drawLine(x, y, x, y+cw)
          }
        }

        // player
        const p=this.player
        const cx = lerp(p.x, p.tx, p.t)
        const cy = lerp(p.y, p.ty, p.t)
        const px = offX + (cx+0.5)*cw
        const py = offY + (cy+0.5)*cw
        const rad = Math.max(6, cw*0.28)
        const grad = ctx.createRadialGradient(px-rad*0.35, py-rad*0.25, rad*0.1, px,py, rad)
        grad.addColorStop(0, hexWithAlpha(getCss('--player'), 1))
        grad.addColorStop(1, hexWithAlpha(getCss('--player'), .12))
        ctx.fillStyle = grad
        ctx.beginPath(); ctx.arc(px,py,rad,0,Math.PI*2); ctx.fill()

        function drawLine(x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1+.5,y1+.5); ctx.lineTo(x2+.5,y2+.5); ctx.stroke() }
      }
    }

    // Utility helpers
    const lerp = (a,b,t)=>a+(b-a)*t
    function timeNow(){
      if(!Game.started) return 0
      const t = (Game.win ? Game._winTs : performance.now()) - Game.startTs
      return Math.max(0, t)
    }
    function fmtTime(ms){
      const s = Math.floor(ms/1000)
      const cs = Math.floor((ms%1000)/10)
      const m = Math.floor(s/60)
      const ss = (s%60).toString().padStart(2,'0')
      return `${m}:${ss}.${cs.toString().padStart(2,'0')}`
    }
    function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() }
    function hexWithAlpha(hex, a){
      const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex)
      if(!m) return hex
      const [r,g,b] = m.slice(1).map(x=>parseInt(x,16))
      return `rgba(${r},${g},${b},${a})`
    }

    // HUD + win dialog
    function updateHUD(){
      stepsEl.textContent = Game.steps
      shortestEl.textContent = Game.shortest
    }
    function flash(msg){
      toast.textContent = msg
      toast.style.display='block'
      toast.style.opacity='1'
      setTimeout(()=>toast.style.opacity='0', 1200)
      setTimeout(()=>toast.style.display='none', 1700)
    }
    function showWin(ms, steps, shortest, bonus){
      Game._winTs = performance.now() // lock time
      finalTime.textContent = fmtTime(ms)
      finalSteps.textContent = steps
      finalShortest.textContent = shortest
      bonusBadge.style.display = bonus ? 'inline-block' : 'none'
      const key = 'maze-best-'+diffSel.value
      const best = localStorage.getItem(key)
      if(!best || (+best > ms)) localStorage.setItem(key, String(ms))
      const bestVal = localStorage.getItem(key)
      bestWrap.style.display = bestVal ? 'block' : 'none'
      if(bestVal) bestTime.textContent = fmtTime(+bestVal)
      win.classList.add('show')
      winTitle.textContent = bonus ? 'Perfect escape!' : 'You escaped!'
    }

    // Confetti FX
    const confetti = []
    function confettiBurst(){
      const W=fxCanvas.width/dpr, H=fxCanvas.height/dpr
      confetti.length=0
      for(let i=0;i<180;i++){
        confetti.push({
          x: Math.random()*W, y: -20 - Math.random()*H*0.2,
          vx:(Math.random()-0.5)*2.2, vy: Math.random()*2 + 1,
          w:6+Math.random()*6, h:8+Math.random()*10,
          rot: Math.random()*Math.PI, vr: (Math.random()-0.5)*0.2,
          c: `hsl(${Math.floor(180+Math.random()*180)}, 80%, 60%)`, life: 0, max: 2200+Math.random()*1200
        })
      }
      const started = performance.now()
      ;(function step(){
        const now = performance.now(); const dt = now - started
        drawConfetti(16/1000)
        if(dt < 2600) requestAnimationFrame(step)
        else fctx.clearRect(0,0,fxCanvas.width/dpr, fxCanvas.height/dpr)
      })()
    }
    function drawConfetti(_dt){
      const W=fxCanvas.width/dpr, H=fxCanvas.height/dpr
      fctx.clearRect(0,0,W,H)
      for(const p of confetti){
        p.x += p.vx; p.y += p.vy; p.rot += p.vr; p.life += 16
        fctx.save(); fctx.translate(p.x,p.y); fctx.rotate(p.rot)
        fctx.fillStyle = p.c; fctx.fillRect(-p.w/2,-p.h/2,p.w,p.h)
        fctx.restore()
      }
      for(let i=confetti.length-1;i>=0;i--) if(confetti[i].life>confetti[i].max) confetti.splice(i,1)
    }

    // Input handling
    const DIRS = {ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', s:'down', a:'left', d:'right'}
    window.addEventListener('keydown', (e)=>{
      const dir = DIRS[e.key]
      if(dir){ e.preventDefault(); Game.move(dir) }
    })
    $$('#pad button[data-dir]').forEach(b=>b.addEventListener('click', ()=>Game.move(b.dataset.dir)))
    let touchStart=null
    board.addEventListener('touchstart', (e)=>{
      const t=e.changedTouches[0]; touchStart={x:t.clientX,y:t.clientY}
    }, {passive:true})
    board.addEventListener('touchend', (e)=>{
      if(!touchStart) return; const t=e.changedTouches[0]
      const dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y
      const adx=Math.abs(dx), ady=Math.abs(dy)
      if(Math.max(adx,ady) > 24){
        if(adx>ady) Game.move(dx>0?'right':'left')
        else Game.move(dy>0?'down':'up')
      }
      touchStart=null
    })

    // Buttons
    diffSel.addEventListener('change', ()=>{ Game.new(diffSel.value) })
    btnNew.addEventListener('click', ()=>{ Game.new(diffSel.value) })
    btnReplay.addEventListener('click', ()=>{ Game.replay() })
    btnAgain.addEventListener('click', ()=>{ win.classList.remove('show'); Game.replay() })
    btnSame.addEventListener('click', ()=>{ win.classList.remove('show'); Game.new(diffSel.value) })

    // Main loop
    let last=performance.now()
    function loop(){
      const now=performance.now(); const dt=(now-last)/1000; last=now
      Game.tick(dt)
      Game.render()
      if(Game.started && !Game.win){ timeEl.textContent = fmtTime(timeNow()) }
      requestAnimationFrame(loop)
    }

    // Init
    function init(){
      Game.new(diffSel.value)
      window.addEventListener('resize', ()=>Game.resize())
      board.focus()
    }

    init(); loop()
  })()
  </script>
</body>
</html>
