<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kinetic Typography Studio</title>
  <meta name="color-scheme" content="dark light" />
  <!-- Fonts (CDN allowed) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Playfair+Display:wght@400;600;700&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Optional libs (CDN) -->
  <script defer src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.7/dist/ffmpeg.min.js"></script>
  <style>
    :root {
      --bg: #0b0d11;
      --panel: #12151b;
      --panel-2: #171b22;
      --text: #e8eefb;
      --muted: #a9b3c7;
      --accent: #7aa2f7;
      --accent-2: #00d1b2;
      --danger: #ff6b6b;
      --warn: #ffcf5c;
      --ok: #3ddc97;
      --border: #243044;
      --key: #66d9ef;
    }
    @media (prefers-color-scheme: light) {
      :root { --bg:#f7f8fb; --panel:#ffffff; --panel-2:#f2f5fb; --text:#0b0d11; --muted:#475569; --border:#d5dbe7; --accent:#3b82f6; --accent-2:#0ea5e9; }
    }
    * { box-sizing: border-box }
    html, body { height:100%; }
    body {
      margin:0; background:var(--bg); color:var(--text);
      font: 14px/1.4 Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow:hidden;
    }
    .app {
      display:grid; grid-template-rows: 48px 1fr 220px; grid-template-columns: 320px 1fr 320px; gap:0; height:100vh;
      grid-template-areas:
        "topbar topbar topbar"
        "sidebar stage rightbar"
        "timeline timeline timeline";
    }
    header {
      grid-area: topbar; display:flex; align-items:center; justify-content:space-between;
      padding:6px 10px; background:var(--panel); border-bottom:1px solid var(--border);
    }
    header .title { display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.4px; }
    header .title .dot { width:10px; height:10px; border-radius:50%; background:var(--accent-2); box-shadow:0 0 16px var(--accent-2); }
    header .actions { display:flex; gap:8px; align-items:center; }
    button, .btn { 
      appearance:none; border:1px solid var(--border); background:linear-gradient(180deg, var(--panel-2), var(--panel)); color:var(--text); 
      border-radius:8px; padding:8px 10px; font-weight:600; cursor:pointer; transition:.15s transform, .15s background;
    }
    button:active { transform: translateY(1px); }
    button.primary { border-color: transparent; background: linear-gradient(180deg, var(--accent), #3467e6); color:white; }
    button.warn { border-color: transparent; background: linear-gradient(180deg, var(--warn), #e0b245); color:#241a00; }
    button.ghost { background: transparent; border-color: var(--border); }
    button.icon { padding:6px 8px; border-radius:6px; }
    .kbd { font: 12px/1 JetBrains Mono, ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:2px 6px; border-radius:5px; background:var(--panel-2); border:1px solid var(--border); color:var(--muted) }
    .sep { width:1px; height:24px; background:var(--border); margin:0 6px; }

    aside.left { grid-area: sidebar; overflow:auto; background:var(--panel); border-right:1px solid var(--border); }
    aside.right { grid-area: rightbar; overflow:auto; background:var(--panel); border-left:1px solid var(--border); }
    .section { padding:10px 12px; border-bottom:1px dashed var(--border); }
    .section h3 { margin:4px 0 8px; font-size:12px; letter-spacing:.12em; text-transform:uppercase; color:var(--muted); }
    .row { display:flex; align-items:center; gap:8px; margin:6px 0; }
    .row.grid { display:grid; grid-template-columns: 120px 1fr auto; gap:8px; align-items:center; }
    .row .label { color:var(--muted); font-size:12px; }
    input[type="text"], input[type="number"], input[type="range"], input[type="color"], select { width:100%; }
    input[type="text"], input[type="number"], select {
      background: var(--panel-2); border:1px solid var(--border); color:var(--text); border-radius:8px; padding:8px 10px; 
    }
    input[type="range"] { accent-color: var(--accent); }
    input[type="color"] { height:32px; border:1px solid var(--border); border-radius:8px; background:var(--panel-2); }
    .toggle { display:inline-flex; align-items:center; gap:6px; cursor:pointer; }

    .stage-wrap { grid-area: stage; display:grid; grid-template-rows: 1fr; place-items:center; position:relative; background:radial-gradient(1200px 1200px at 70% -10%, rgba(122,162,247,.16), transparent 40%), linear-gradient(180deg, var(--panel), var(--panel-2)); }
    .stage-toolbar { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; justify-content:space-between; pointer-events:none; }
    .stage-toolbar .left, .stage-toolbar .right { display:flex; gap:8px; pointer-events:auto; }
    canvas#stage { background:#111; border-radius:12px; box-shadow: 0 10px 40px rgba(0,0,0,.35), 0 1px 0 rgba(255,255,255,.03) inset; transform-origin:center center; }

    .timeline { grid-area: timeline; background: var(--panel); border-top:1px solid var(--border); display:grid; grid-template-rows: 32px 1fr; }
    .timebar { display:grid; grid-template-columns: 200px 1fr; border-bottom:1px solid var(--border); }
    .tracks-head { padding:6px 8px; color:var(--muted); font-size:12px; display:flex; align-items:center; gap:8px; border-right:1px solid var(--border); }
    .ruler { position:relative; }
    .ruler canvas { width:100%; height:100%; display:block; }
    .tracks { display:grid; grid-template-columns: 200px 1fr; height:100%; }
    .track-list { overflow:auto; border-right:1px solid var(--border); }
    .track { display:flex; align-items:center; gap:8px; padding:6px 8px; border-bottom:1px dashed var(--border); }
    .track .dot { width:8px; height:8px; border-radius:50%; background:var(--key); box-shadow: 0 0 8px rgba(102,217,239,.7); }
    .lane { position:relative; overflow:auto; }
    .lane canvas { width:100%; height:100%; display:block; }

    .playhead { position:absolute; top:32px; bottom:0; width:2px; background:var(--accent); pointer-events:none; }

    .chip { background: var(--panel-2); border:1px solid var(--border); padding:5px 8px; border-radius:999px; color:var(--muted); font-size:12px; }
    .badge { padding:3px 6px; background:rgba(122,162,247,.15); border:1px solid var(--accent); color:var(--accent); border-radius:6px; font-size:12px; }

    .help { position: fixed; right:10px; bottom:10px; z-index:99; }
    .help-panel { position: fixed; inset:auto 10px 50px auto; max-width:560px; background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; display:none; box-shadow:0 10px 40px rgba(0,0,0,.4); }
    .help-panel.show { display:block; }
    .help-panel h4 { margin:6px 0 8px; }
    .help-panel .grid { display:grid; grid-template-columns: 1fr 1fr; gap:6px 16px; }
    .help-panel .grid .kbd { justify-self:end; }

    .progress { height:8px; background:var(--panel-2); border:1px solid var(--border); border-radius:999px; overflow:hidden; }
    .progress > div { height:100%; background:linear-gradient(90deg, var(--accent), var(--accent-2)); width:0%; transition: width .2s ease; }

    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    @media (max-width: 1200px) {
      .app { grid-template-columns: 280px 1fr; grid-template-rows: 48px 1fr 200px; grid-template-areas:
        "topbar topbar"
        "sidebar stage"
        "timeline timeline";
      }
      aside.right { display:none; }
    }

    @media (max-width: 800px) {
      .app { grid-template-columns: 1fr; grid-template-rows: 48px auto 1fr auto; grid-template-areas:
        "topbar"
        "sidebar"
        "stage"
        "timeline";
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .prefers-reduced-motion .heavy { filter:none !important; opacity:1 !important; }
    }
  </style>
</head>
<body>
  <div class="app prefers-reduced-motion">
    <header aria-label="Top Bar">
      <div class="title" aria-label="App Title">
        <div class="dot" aria-hidden="true"></div>
        <span>Kinetic Typography Studio</span>
        <span class="chip" id="bpmChip" title="Detected BPM">BPM: —</span>
        <span class="chip" id="durationChip" title="Composition Duration">Dur: 08.0s</span>
        <span class="badge" id="snapBadge" title="Beat Snap">Beat Snap</span>
      </div>
      <div class="actions">
        <button class="icon ghost" id="btnUndo" aria-label="Undo (Ctrl/Cmd+Z)">⟲</button>
        <button class="icon ghost" id="btnRedo" aria-label="Redo (Ctrl/Cmd+Shift+Z)">⟳</button>
        <div class="sep"></div>
        <button id="btnPlay" class="primary" aria-label="Play/Pause (Space)">▶ Play</button>
        <button id="btnStop" class="ghost" aria-label="Stop (Shift+Space)">■ Stop</button>
        <div class="sep"></div>
        <button id="btnExport" class="warn" aria-label="Export (Ctrl/Cmd+E)">Export…</button>
      </div>
    </header>

    <!-- LEFT SIDEBAR -->
    <aside class="left" aria-label="Controls Sidebar">
      <div class="section" aria-labelledby="textHeading">
        <h3 id="textHeading">Text</h3>
        <div class="row">
          <input id="textInput" type="text" aria-label="Text content" placeholder="Your kinetic text goes here…" value="Kinetic Typography Studio" />
        </div>
        <div class="row grid">
          <div class="label">Font</div>
          <select id="fontFamily" aria-label="Font family">
            <option value="Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial">Inter (Sans)</option>
            <option value="Playfair Display, Georgia, Times, serif">Playfair (Serif)</option>
            <option value="JetBrains Mono, ui-monospace, SFMono-Regular, Menlo, Consolas, monospace">JetBrains Mono</option>
          </select>
          <div class="chip">Aa</div>
        </div>
        <div class="row">
          <label class="toggle"><input id="italic" type="checkbox" /> Italic</label>
        </div>
        <div class="row grid">
          <div class="label">Weight</div>
          <input id="fontWeight" type="range" min="200" max="900" step="100" value="700" aria-label="Font weight" />
          <span id="fontWeightVal" class="chip">700</span>
        </div>
        <div class="row grid">
          <div class="label">Size</div>
          <input id="fontSize" type="range" min="16" max="220" step="1" value="120" aria-label="Font size" />
          <span id="fontSizeVal" class="chip">120</span>
        </div>
        <div class="row grid">
          <div class="label">Tracking</div>
          <input id="tracking" type="range" min="-0.1" max="0.2" step="0.005" value="0" aria-label="Letter tracking" />
          <span id="trackingVal" class="chip">0.000</span>
        </div>
        <div class="row grid">
          <div class="label">Fill</div>
          <input id="fillColor" type="color" value="#e8eefb" aria-label="Fill color" />
          <button id="toggleGradient" class="ghost">Gradient</button>
        </div>
        <div id="gradientRow" class="row grid" style="display:none">
          <div class="label">Gradient</div>
          <div style="display:flex; gap:6px; width:100%">
            <input id="gradA" type="color" value="#7aa2f7" aria-label="Gradient color A" />
            <input id="gradB" type="color" value="#00d1b2" aria-label="Gradient color B" />
            <input id="gradAngle" type="range" min="0" max="360" value="0" aria-label="Gradient angle" />
          </div>
          <span class="chip" id="gradPreview">0°</span>
        </div>
        <div class="row grid">
          <div class="label">Outline</div>
          <input id="strokeColor" type="color" value="#0b0d11" aria-label="Outline color" />
          <input id="strokeWidth" type="range" min="0" max="16" step="1" value="0" aria-label="Outline width" />
        </div>
        <div class="row grid">
          <div class="label">Shadow</div>
          <input id="shadowColor" type="color" value="#000000" aria-label="Shadow color" />
          <input id="shadowBlur" type="range" min="0" max="40" step="1" value="0" aria-label="Shadow blur" />
        </div>
        <div class="row">
          <label class="toggle"><input id="motionBlur" type="checkbox" /> Motion Blur</label>
          <label class="toggle"><input id="perGlyph" type="checkbox" checked /> Per-Glyph</label>
        </div>
      </div>

      <div class="section" aria-labelledby="layoutHeading">
        <h3 id="layoutHeading">Layout</h3>
        <div class="row grid">
          <div class="label">Aspect</div>
          <select id="aspect" aria-label="Aspect ratio">
            <option value="16:9">16:9</option>
            <option value="9:16">9:16</option>
            <option value="1:1">1:1</option>
          </select>
          <span class="chip" id="aspectVal">16:9</span>
        </div>
        <div class="row grid">
          <div class="label">Resolution</div>
          <input id="resW" type="number" min="256" max="4096" step="2" value="1280" aria-label="Width" />
          <input id="resH" type="number" min="256" max="4096" step="2" value="720" aria-label="Height" />
        </div>
        <div class="row grid">
          <div class="label">Margins</div>
          <input id="margins" type="range" min="0" max="200" step="1" value="40" aria-label="Margins" />
          <span class="chip" id="marginsVal">40</span>
        </div>
        <div class="row grid">
          <div class="label">Background</div>
          <input id="bgColor" type="color" value="#0b0d11" aria-label="Background color" />
          <input id="bgImage" type="file" accept="image/*" aria-label="Background image" />
        </div>
        <div class="row">
          <label class="toggle"><input id="showGrid" type="checkbox" checked /> Grid</label>
          <label class="toggle"><input id="showSafe" type="checkbox" checked /> Safe Area</label>
        </div>
      </div>

      <div class="section" aria-labelledby="animHeading">
        <h3 id="animHeading">Animation</h3>
        <div class="row grid">
          <div class="label">Duration (s)</div>
          <input id="duration" type="range" min="1" max="60" step="0.1" value="8" aria-label="Duration seconds" />
          <span class="chip" id="durationVal">8.0</span>
        </div>
        <div class="row grid">
          <div class="label">FPS</div>
          <input id="fps" type="range" min="12" max="60" step="1" value="30" aria-label="Frames per second" />
          <span class="chip" id="fpsVal">30</span>
        </div>
        <div class="row grid">
          <div class="label">Easing</div>
          <select id="easingPreset" aria-label="Easing preset">
            <option value="linear">Linear</option>
            <option value="ease">Ease</option>
            <option value="ease-in">Ease-In</option>
            <option value="ease-out">Ease-Out</option>
            <option value="ease-in-out">Ease-In-Out</option>
            <option value="custom">Custom Bézier</option>
          </select>
          <button id="openBezier" class="ghost">Edit Curve</button>
        </div>
        <div class="row grid">
          <div class="label">Stagger (s)</div>
          <input id="stagger" type="range" min="0" max="0.2" step="0.005" value="0.04" aria-label="Stagger per glyph" />
          <span class="chip" id="staggerVal">0.040</span>
        </div>
        <div class="row" aria-label="Presets">
          <button class="icon" data-preset="typewriter">Typewriter</button>
          <button class="icon" data-preset="fadeup">Fade Up</button>
          <button class="icon" data-preset="bounce">Bounce</button>
          <button class="icon" data-preset="glitch">Glitch</button>
          <button class="icon" data-preset="liquid">Liquid</button>
          <button class="icon" data-preset="cascade-letters">Cascade Letters</button>
          <button class="icon" data-preset="cascade-words">Cascade Words</button>
          <button class="icon" data-preset="cascade-lines">Cascade Lines</button>
        </div>
      </div>

      <div class="section" aria-labelledby="audioHeading">
        <h3 id="audioHeading">Audio-Reactive</h3>
        <div class="row grid">
          <div class="label">Audio File</div>
          <input id="audioFile" type="file" accept="audio/*" aria-label="Audio file" />
          <button id="btnAnalyze" class="ghost">Analyze</button>
        </div>
        <div class="row grid">
          <div class="label">Beat Snap</div>
          <label class="toggle" style="width:100%"><input id="beatSnap" type="checkbox" /> Enable</label>
          <span class="chip" id="beatNote">—</span>
        </div>
        <div class="row grid">
          <div class="label">Bars/Beat</div>
          <select id="beatDiv" aria-label="Beat division">
            <option value="1">1/1</option>
            <option value="0.5">1/2</option>
            <option value="0.25">1/4</option>
            <option value="0.125">1/8</option>
          </select>
          <span class="chip">Quantize</span>
        </div>
      </div>
    </aside>

    <!-- STAGE -->
    <div class="stage-wrap">
      <div class="stage-toolbar">
        <div class="left">
          <button class="ghost icon" id="zoomOut" aria-label="Zoom out">−</button>
          <span class="chip" id="zoomVal">100%</span>
          <button class="ghost icon" id="zoomIn" aria-label="Zoom in">+</button>
        </div>
        <div class="right">
          <button class="ghost" id="toggleGuides" aria-label="Toggle guides (G)">Guides</button>
          <button class="ghost" id="toggleFull" aria-label="Toggle fullscreen (F)">Fullscreen</button>
        </div>
      </div>
      <canvas id="stage" width="1280" height="720" aria-label="Preview Canvas" role="img"></canvas>
    </div>

    <!-- RIGHT SIDEBAR (Keyframes quick controls) -->
    <aside class="right" aria-label="Animated Properties">
      <div class="section">
        <h3>Animated Tracks</h3>
        <div class="row"><button class="ghost" data-add-kf="position">Add Keyframe: Position</button></div>
        <div class="row"><button class="ghost" data-add-kf="scale">Add Keyframe: Scale</button></div>
        <div class="row"><button class="ghost" data-add-kf="rotation">Add Keyframe: Rotation</button></div>
        <div class="row"><button class="ghost" data-add-kf="opacity">Add Keyframe: Opacity</button></div>
        <div class="row"><button class="ghost" data-add-kf="offset">Add Keyframe: Offset (per-glyph)</button></div>
        <div class="row"><button class="ghost" data-add-kf="tracking">Add Keyframe: Tracking</button></div>
        <div class="row">
          <label class="toggle"><input id="autoEase" type="checkbox" checked /> Auto Ease</label>
        </div>
      </div>
      <div class="section">
        <h3>Export</h3>
        <div class="row grid">
          <div class="label">Format</div>
          <select id="exportFormat">
            <option value="webm">WebM (VP9)</option>
            <option value="gif">GIF</option>
            <option value="pngseq">PNG Sequence (ZIP)</option>
            <option value="mp4">MP4 (beta)</option>
          </select>
          <span class="chip">Render</span>
        </div>
        <div class="row grid">
          <div class="label">Quality</div>
          <input id="exportQuality" type="range" min="0.1" max="1" step="0.05" value="0.9" />
          <span id="qualityVal" class="chip">0.90</span>
        </div>
        <div class="row"><button id="btnRender" class="primary">Render Without UI</button></div>
        <div class="progress" aria-label="Render progress"><div id="renderProgress"></div></div>
        <div class="row"><a id="downloadLink" class="btn" href="#" download style="display:none">Download</a></div>
      </div>
    </aside>

    <!-- TIMELINE -->
    <div class="timeline" aria-label="Timeline">
      <div class="timebar">
        <div class="tracks-head">Track</div>
        <div class="ruler"><canvas id="ruler"></canvas></div>
      </div>
      <div class="tracks">
        <div class="track-list" id="trackList"></div>
        <div class="lane"><canvas id="lanes"></canvas></div>
      </div>
      <div class="playhead" id="playhead" aria-hidden="true"></div>
    </div>
  </div>

  <div class="help">
    <button id="helpBtn" class="ghost">? Help</button>
  </div>
  <div id="helpPanel" class="help-panel" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <h4 id="helpTitle">Keyboard Shortcuts</h4>
    <div class="grid">
      <div>Play/Pause</div><div class="kbd">Space</div>
      <div>Stop</div><div class="kbd">Shift+Space</div>
      <div>Add Keyframe</div><div class="kbd">A</div>
      <div>Snap to Beat</div><div class="kbd">B</div>
      <div>Guides Toggle</div><div class="kbd">G</div>
      <div>Fullscreen Stage</div><div class="kbd">F</div>
      <div>Nudge Frame</div><div class="kbd">← / →</div>
      <div>Nudge +10 Frames</div><div class="kbd">Shift+← / →</div>
      <div>Export</div><div class="kbd">Ctrl/Cmd+E</div>
      <div>Set Aspect 16:9 / 9:16 / 1:1</div><div class="kbd">1 / 2 / 3</div>
    </div>
  </div>

  <!-- Bézier Editor Modal -->
  <div id="bezierModal" class="help-panel" style="inset:auto auto 50px 50%; transform:translateX(-50%); max-width:480px" role="dialog" aria-modal="true" aria-labelledby="bezierTitle">
    <h4 id="bezierTitle">Custom Cubic Bézier</h4>
    <canvas id="bezierCanvas" width="420" height="200" style="background:var(--panel-2); border-radius:8px; border:1px solid var(--border);"></canvas>
    <div class="row" style="margin-top:8px">
      <label class="toggle">p1x <input id="p1x" type="number" step="0.01" min="-0.2" max="1.2" value="0.25"></label>
      <label class="toggle">p1y <input id="p1y" type="number" step="0.01" min="-0.2" max="1.2" value="0.1"></label>
      <label class="toggle">p2x <input id="p2x" type="number" step="0.01" min="-0.2" max="1.2" value="0.25"></label>
      <label class="toggle">p2y <input id="p2y" type="number" step="0.01" min="-0.2" max="1.2" value="1"></label>
    </div>
    <div class="row" style="justify-content:flex-end">
      <button id="bezierCancel" class="ghost">Cancel</button>
      <button id="bezierApply" class="primary">Apply</button>
    </div>
  </div>

  <script type="module">
  // ============= Helpers & Math ==================
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const easePresets = {
    linear: [0,0,1,1],
    ease: [0.25,0.1,0.25,1],
    'ease-in': [0.42,0,1,1],
    'ease-out': [0,0,0.58,1],
    'ease-in-out': [0.42,0,0.58,1]
  };
  function cubicBezier(p1x, p1y, p2x, p2y) {
    // Adapted from https://github.com/gre/bezier-easing (tiny inlined version)
    const NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = 0.001, SUBDIVISION_PRECISION = 0.0000001, SUBDIVISION_MAX_ITERATIONS = 10;
    const kSplineTableSize = 11, kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
    const float32ArraySupported = typeof Float32Array === 'function';
    if (p1x === p1y && p2x === p2y) return t => t;
    function A(a1, a2){ return 1.0 - 3.0 * a2 + 3.0 * a1 }
    function B(a1, a2){ return 3.0 * a2 - 6.0 * a1 }
    function C(a1){ return 3.0 * a1 }
    function calcBezier(t, a1, a2){ return ((A(a1, a2)*t + B(a1, a2))*t + C(a1))*t }
    function getSlope(t, a1, a2){ return 3.0*A(a1,a2)*t*t + 2.0*B(a1,a2)*t + C(a1) }
    function binarySubdivide(x, a, b, mX1, mX2){
      let currentX, currentT, i=0;
      do { currentT = a + (b - a)/2.0; currentX = calcBezier(currentT, mX1, mX2) - x; if (currentX>0.0) b = currentT; else a = currentT; } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }
    function newtonRaphsonIterate(x, guessT, mX1, mX2){ for (let i=0;i<NEWTON_ITERATIONS;i++){ const slope = getSlope(guessT, mX1, mX2); if (slope===0.0) return guessT; const currentX = calcBezier(guessT, mX1, mX2) - x; guessT -= currentX/slope; } return guessT }
    const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for (let i=0;i<kSplineTableSize;i++) sampleValues[i] = calcBezier(i*kSampleStepSize, p1x, p2x);
    function getTForX(x){ let intervalStart = 0.0; let currentSample = 1; const lastSample = kSplineTableSize - 1;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= x; currentSample++) intervalStart += kSampleStepSize;
      --currentSample; const dist = (x - sampleValues[currentSample]) / (sampleValues[currentSample+1] - sampleValues[currentSample]);
      const guessForT = intervalStart + dist * kSampleStepSize; const initialSlope = getSlope(guessForT, p1x, p2x);
      if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(x, guessForT, p1x, p2x);
      else if (initialSlope === 0.0) return guessForT; else return binarySubdivide(x, intervalStart, intervalStart + kSampleStepSize, p1x, p2x);
    }
    return function BezierEasing(x){ if (x === 0 || x === 1) return x; return calcBezier(getTForX(x), p1y, p2y) }
  }
  const fmt = (n, d=3) => (+n).toFixed(d);

  // ============= Global State ==================
  const state = {
    text: 'Kinetic Typography Studio',
    layout: { w: 1280, h: 720, aspect:'16:9', margins:40, bgColor:'#0b0d11', bgImage:null, showGrid:true, showSafe:true, zoom:1 },
    style: { font:"Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial", weight:700, size:120, tracking:0, fill:'#e8eefb', gradient:false, gradA:'#7aa2f7', gradB:'#00d1b2', gradAngle:0, stroke:'#0b0d11', strokeWidth:0, shadow:'#000000', shadowBlur:0, motionBlur:false, perGlyph:true, italic:false },
    anim: { duration:8, fps:30, ease: 'ease', custom:[0.25,0.1,0.25,1], stagger:0.04, autoEase:true },
    tracks: {
      position: [{time:0, value:{x:0,y:0}}, {time:8, value:{x:0,y:0}}],
      scale: [{time:0, value:1}, {time:8, value:1}],
      rotation: [{time:0, value:0}, {time:8, value:0}],
      opacity: [{time:0, value:1}, {time:8, value:1}],
      offset: [{time:0, value:{x:0,y:20}}, {time:8, value:{x:0,y:0}}],
      tracking: [{time:0, value:0}, {time:8, value:0}]
    },
    play: { t:0, playing:false, last:0 },
    audio: { buffer:null, beats:[], bpm:null, offset:0, div:1, snap:false, src:null, ctx:null, node:null },
    history: [],
    future: []
  };
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const ruler = document.getElementById('ruler');
  const lanes = document.getElementById('lanes');
  const playhead = document.getElementById('playhead');

  // ============= History for Undo/Redo =============
  const pushHistory = () => { state.history.push(JSON.stringify(state)); state.future.length = 0; };
  const undo = () => { if (!state.history.length) return; state.future.push(JSON.stringify(state)); Object.assign(state, JSON.parse(state.history.pop())); refreshUI(); };
  const redo = () => { if (!state.future.length) return; state.history.push(JSON.stringify(state)); Object.assign(state, JSON.parse(state.future.pop())); refreshUI(); };

  // ============= Text Layout =============
  function measureLines(text, maxWidth, fontSpec, tracking=0) {
    ctx.save(); ctx.font = fontSpec; const words = text.split(/\s+/g); const lines=[]; let line='';
    const spaceW = ctx.measureText(' ').width + tracking*16;
    for (let w of words){ const test = line? line + ' ' + w : w; const wWidth = textWidth(test, tracking);
      if (wWidth > maxWidth && line) { lines.push(line); line = w; } else { line = test; }
    }
    if (line) lines.push(line); ctx.restore(); return lines;
  }
  function textWidth(s, tracking=0){ let width=0; for (const ch of s){ width += ctx.measureText(ch).width + tracking*16; } return width; }

  function buildGlyphs(lines){
    const glyphs=[]; let lineIndex=0, charIndex=0; for (const line of lines){ const words=line.split(/(\s+)/);
      let x=0; for (const w of words){ for (const ch of w){ glyphs.push({ ch, line:lineIndex, char:charIndex++, xOffset:x }); x += ctx.measureText(ch).width + state.style.tracking*16; }
      }
      lineIndex++;
    }
    return glyphs;
  }

  function currentEaser(){
    let p = state.anim.ease==='custom' ? state.anim.custom : easePresets[state.anim.ease] || easePresets.ease;
    return cubicBezier(...p);
  }

  // ============= Tracks & Keyframes =============
  function getTrackValue(trackName, t){
    const track = state.tracks[trackName]; if (!track || !track.length) return null; const sorted = track.slice().sort((a,b)=>a.time-b.time);
    if (t <= sorted[0].time) return sorted[0].value; if (t >= sorted[sorted.length-1].time) return sorted[sorted.length-1].value;
    let a=sorted[0], b=sorted[1];
    for (let i=1;i<sorted.length;i++){ if (t < sorted[i].time){ a = sorted[i-1]; b = sorted[i]; break; } }
    const u = (t - a.time) / Math.max(1e-6, (b.time - a.time)); const e = currentEaser()(clamp(u,0,1));
    if (typeof a.value === 'number') return lerp(a.value, b.value, e);
    if (typeof a.value === 'object'){
      const out = {}; for (const k of Object.keys(a.value)) out[k] = lerp(a.value[k]??0, b.value[k]??0, e); return out;
    }
    return a.value;
  }

  function addKeyframe(trackName, t, value){
    // optional beat snap on add
    if (state.audio.snap) t = snapToBeat(t, state.audio.div||1);
    pushHistory(); const arr = state.tracks[trackName] || (state.tracks[trackName]=[]);
    arr.push({time:t, value});
  }

  // ============= Stage Drawing =============
  function resizeCanvas(){ canvas.width = state.layout.w; canvas.height = state.layout.h; draw(); }

  function drawGuides(ctx, w, h){
    if (state.layout.showGrid){ ctx.save(); ctx.lineWidth=1; ctx.strokeStyle = 'rgba(255,255,255,.06)';
      for (let x=0;x<w;x+=w/12){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
      for (let y=0;y<h;y+=h/12){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
      ctx.restore();
    }
    if (state.layout.showSafe){ ctx.save(); ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.setLineDash([6,4]); ctx.lineWidth=2; const m=state.layout.margins;
      ctx.strokeRect(m,m, w-2*m, h-2*m); ctx.restore(); }
  }

  function applyStyle(ctx){
    ctx.textBaseline='alphabetic'; ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.shadowColor = state.style.shadow; ctx.shadowBlur = +state.style.shadowBlur;
  }

  function drawBackground(){
    const {w,h,bgColor,bgImage} = state.layout; ctx.save(); ctx.fillStyle=bgColor; ctx.fillRect(0,0,w,h);
    if (bgImage){ const iw = bgImage.width, ih=bgImage.height; const r = Math.max(w/iw, h/ih); const nw=iw*r, nh=ih*r; ctx.globalAlpha=1; ctx.drawImage(bgImage, (w-nw)/2, (h-nh)/2, nw, nh); }
    ctx.restore();
  }

  function drawTextFrame(t){
    const {w,h,margins} = state.layout; const s = state.style; const txt = state.text;
    ctx.save();
    const fontSpec = `${s.italic? 'italic ':''} ${s.weight} ${s.size}px ${s.font}`; ctx.font = fontSpec;
    const areaW = w - margins*2; const lines = measureLines(txt, areaW, fontSpec, s.tracking);
    const glyphs = buildGlyphs(lines);

    let pos = getTrackValue('position', t) || {x:0,y:0};
    let scale = getTrackValue('scale', t) || 1; let rot = getTrackValue('rotation', t) || 0;
    let opacity = getTrackValue('opacity', t) || 1; let offs = getTrackValue('offset', t) || {x:0,y:0};
    let tracking = getTrackValue('tracking', t); if (tracking!=null) s.tracking = tracking;

    // compute text block metrics
    const lineHeight = s.size * 1.2; const blockH = lines.length * lineHeight; const x0 = margins + areaW/2 + pos.x; const y0 = (h - blockH)/2 + margins + pos.y;

    ctx.translate(x0, y0 + lineHeight*0.8); ctx.scale(scale, scale); ctx.rotate(rot * Math.PI/180);
    ctx.globalAlpha = opacity;

    // fill style
    if (s.gradient){ const rad = (s.gradAngle % 360) * Math.PI/180; const R = Math.max(w,h);
      const gx = Math.cos(rad), gy = Math.sin(rad); const g = ctx.createLinearGradient(-R*gx, -R*gy, R*gx, R*gy);
      g.addColorStop(0, s.gradA); g.addColorStop(1, s.gradB); ctx.fillStyle = g;
    } else { ctx.fillStyle = s.fill; }

    applyStyle(ctx);

    // optional poor-man motion blur by temporal supersampling
    const samples = s.motionBlur ? 3 : 1; const shutter = 0.5 / (state.anim.fps||30);
    for (let S=0; S<samples; S++){
      const ts = t + (S - (samples-1)/2) * shutter; // sample time
      drawGlyphsAt(ts);
    }

    ctx.restore();

    function drawGlyphsAt(ts){
      const easer = currentEaser();
      let gIndex = 0; let y=0;
      for (let i=0;i<lines.length;i++){
        const line = lines[i]; const chars = [...line]; let x = -textWidth(line)/2;
        for (let j=0;j<chars.length;j++){
          const ch = chars[j];
          const per = s.perGlyph ? gIndex : i; // per glyph or per line
          const delay = per * state.anim.stagger; const tt = clamp((ts - delay) / state.anim.duration, 0, 1);
          const e = easer(tt);
          const ox = offs.x * (1 - e); const oy = offs.y * (1 - e);
          ctx.save();
          ctx.translate(x + ox, i*lineHeight + oy);
          // draw outline
          if (s.strokeWidth>0){ ctx.lineWidth = s.strokeWidth; ctx.strokeStyle = s.stroke; ctx.strokeText(ch, 0, 0); }
          ctx.fillText(ch, 0, 0);
          ctx.restore();
          x += ctx.measureText(ch).width + s.tracking*16; gIndex++;
        }
      }
    }
  }

  function draw(){
    drawBackground(); drawGuides(ctx, canvas.width, canvas.height); drawTextFrame(state.play.t);
  }

  // ============= Ruler & Timeline Render =============
  const tl = { scroll:0, zoom:100, height:160 };
  function timeToX(t){ const pxPerSec = tl.zoom; return t * pxPerSec - tl.scroll; }
  function xToTime(x){ const pxPerSec = tl.zoom; return (x + tl.scroll) / pxPerSec; }

  function drawRuler(){ const dpr = devicePixelRatio||1; const r = ruler; const h=32; r.width = r.clientWidth*dpr; r.height = h*dpr; const cx = r.getContext('2d'); cx.scale(dpr, dpr);
    cx.clearRect(0,0,r.clientWidth,h); cx.fillStyle='rgba(255,255,255,.04)'; cx.fillRect(0,0,r.clientWidth,h);
    const dur = state.anim.duration; const step = tl.zoom>=200? 0.1 : tl.zoom>=120? 0.25 : tl.zoom>=80? 0.5 : 1;
    cx.fillStyle = '#a9b3c7'; cx.font = '12px Inter'; cx.textBaseline='top';
    cx.strokeStyle = 'rgba(255,255,255,.25)'; cx.lineWidth=1; for (let t=0; t<=dur+0.001; t+=step){ const x = timeToX(t);
      cx.beginPath(); const isSec = Math.abs(t - Math.round(t))<1e-6; cx.moveTo(x+.5,0); cx.lineTo(x+.5, isSec? 18:10); cx.stroke(); if (isSec) cx.fillText(`${t.toFixed(0)}s`, x+4, 2);
    }
    // beats
    if (state.audio.beats?.length){ cx.strokeStyle='rgba(122,162,247,.5)'; cx.lineWidth=1; for (const bt of state.audio.beats){ const x = timeToX(bt); if (x<-20||x>r.clientWidth+20) continue; cx.beginPath(); cx.moveTo(x+.5,0); cx.lineTo(x+.5,h); cx.stroke(); }
    }
  }

  function drawLanes(){ const dpr=devicePixelRatio||1; lanes.width = lanes.clientWidth*dpr; lanes.height = tl.height*dpr; const cx = lanes.getContext('2d'); cx.scale(dpr,dpr);
    cx.clearRect(0,0,lanes.clientWidth, tl.height); cx.fillStyle='rgba(255,255,255,.02)'; cx.fillRect(0,0,lanes.clientWidth, tl.height);
    const tracks = Object.keys(state.tracks); const rowH = 26; let row=0; cx.strokeStyle='rgba(255,255,255,.08)';
    for (const tr of tracks){ const arr=state.tracks[tr]; const y=row*rowH + 18; cx.beginPath(); cx.moveTo(0,y); cx.lineTo(lanes.clientWidth,y); cx.stroke();
      for (const kf of arr){ const x=timeToX(kf.time); if (x<-10||x>lanes.clientWidth+10) continue; cx.save(); cx.translate(x, y);
        cx.rotate(Math.PI/4); cx.fillStyle='#66d9ef'; cx.fillRect(-5,-5,10,10); cx.restore();
      }
      row++;
    }
  }
  function rebuildTrackList(){ const el = document.getElementById('trackList'); el.innerHTML=''; const tracks = Object.keys(state.tracks);
    for (const tr of tracks){ const d=document.createElement('div'); d.className='track'; d.innerHTML=`<div class="dot"></div><div style="flex:1">${tr}</div><button class="icon" data-add-kf="${tr}">＋</button>`; el.appendChild(d); }
  }

  function updatePlayhead(){ const x = timeToX(state.play.t); const pb = document.querySelector('.timeline'); const rect = pb.getBoundingClientRect(); const left = rect.left + x; playhead.style.left = `${x}px`; }

  // ============= Audio Analysis (Beats) =============
  async function analyzeBeats(file){
    const arrayBuf = await file.arrayBuffer(); const ctxA = new (window.AudioContext || window.webkitAudioContext)(); const audioBuf = await ctxA.decodeAudioData(arrayBuf);
    state.audio.buffer = audioBuf; state.audio.ctx = ctxA; const data = audioBuf.getChannelData(0);
    // Simple energy-based onset detection
    const sr = audioBuf.sampleRate; const hop = 1024; const win = 2048; const energies=[]; for (let i=0;i+win<data.length;i+=hop){ let e=0; for (let j=0;j<win;j++){ const s=data[i+j]; e += s*s; } energies.push(Math.sqrt(e/win)); }
    // Smooth and detect peaks
    const smooth = energies.map((e,i,arr)=>{ const k=4; let s=0,c=0; for (let j=-k;j<=k;j++){ const idx=i+j; if (arr[idx]!=null){ s+=arr[idx]; c++; } } return s/c; });
    const peaks=[]; for (let i=1;i<smooth.length-1;i++){ if (smooth[i]>smooth[i-1]&&smooth[i]>smooth[i+1]){ const avg = (smooth[i-1]+smooth[i+1])/2; if (smooth[i] > avg*1.2) peaks.push(i); } }
    const times = peaks.map(p=> (p*hop)/sr );
    // Estimate BPM using inter-onset intervals
    const ios = []; for (let i=1;i<times.length;i++){ ios.push(times[i]-times[i-1]); }
    const median = arr=>{ const a=[...arr].sort((x,y)=>x-y); return a.length? a[Math.floor(a.length/2)] : 0; };
    const med = median(ios) || 0.5; let bpm = Math.round(60 / med);
    // normalize bpm to 70-180 range
    while (bpm<70) bpm*=2; while (bpm>180) bpm=Math.round(bpm/2);
    state.audio.beats = times; state.audio.bpm = bpm; document.getElementById('bpmChip').textContent = `BPM: ${bpm}`;
    document.getElementById('beatNote').textContent = `${times.length} onsets`;
    drawRuler();
  }

  // ============= Exporters =============
  async function exportPNGSequence(progressCb){
    const frames = Math.round(state.anim.duration * state.anim.fps); const zip = new JSZip(); const off = document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height; const c=off.getContext('2d');
    for (let i=0;i<frames;i++){ const t=i/state.anim.fps; state.play.t=t; // draw into offscreen
      drawBackgroundTo(c); drawGuidesTo(c); drawTextTo(c,t);
      const blob = await new Promise(r=>off.toBlob(r, 'image/png')); const ab = await blob.arrayBuffer(); zip.file(`frame_${String(i).padStart(5,'0')}.png`, ab);
      progressCb(i/(frames-1));
    }
    const out = await zip.generateAsync({type:'blob', compression:'DEFLATE'}); return out;

    function drawBackgroundTo(cx){ cx.save(); cx.fillStyle=state.layout.bgColor; cx.fillRect(0,0,off.width,off.height); if (state.layout.bgImage){ const bi=state.layout.bgImage; const r=Math.max(off.width/bi.width, off.height/bi.height); const nw=bi.width*r, nh=bi.height*r; cx.drawImage(bi,(off.width-nw)/2,(off.height-nh)/2,nw,nh);} cx.restore(); }
    function drawGuidesTo(cx){ /* no guides in export */ }
    function drawTextTo(cx, tt){
      const {w,h} = {w:off.width,h:off.height}; const s = state.style; const txt = state.text; const margins=state.layout.margins;
      cx.save(); const fontSpec = `${s.italic? 'italic ':''} ${s.weight} ${s.size}px ${s.font}`; cx.font = fontSpec; cx.textBaseline='alphabetic'; cx.lineJoin='round'; cx.lineCap='round';
      const areaW = w - margins*2; const lines = measureLinesFor(cx, txt, areaW, fontSpec, s.tracking);
      const lineHeight = s.size*1.2; const blockH = lines.length*lineHeight; const x0 = margins + areaW/2; const y0 = (h-blockH)/2 + margins;
      const easer=currentEaser(); const offs=getTrackValue('offset',tt)||{x:0,y:0}; const pos=getTrackValue('position',tt)||{x:0,y:0}; const scale=getTrackValue('scale',tt)||1; const rot=getTrackValue('rotation',tt)||0; const opacity=getTrackValue('opacity',tt)||1; const samples=s.motionBlur?3:1; const shutter = 0.5/(state.anim.fps||30);
      cx.translate(x0+pos.x, y0+lineHeight*0.8+pos.y); cx.scale(scale,scale); cx.rotate(rot*Math.PI/180); cx.globalAlpha=opacity; if (s.gradient){ const R=Math.max(w,h); const rad=(s.gradAngle%360)*Math.PI/180; const gx=Math.cos(rad), gy=Math.sin(rad); const g=cx.createLinearGradient(-R*gx,-R*gy,R*gx,R*gy); g.addColorStop(0,s.gradA); g.addColorStop(1,s.gradB); cx.fillStyle=g; } else cx.fillStyle=s.fill; cx.shadowColor=s.shadow; cx.shadowBlur=+s.shadowBlur;
      for (let S=0; S<samples; S++){ const tts=tt+(S-(samples-1)/2)*shutter; drawGlyphs(cx, lines, tts, lineHeight, easer, offs, s); }
      cx.restore();
    }
    function measureLinesFor(cx, text, maxWidth, fontSpec, tracking){ cx.save(); cx.font=fontSpec; const words=text.split(/\s+/g); const lines=[]; let line=''; function tWidth(s){ let w=0; for (const ch of s) w += cx.measureText(ch).width + tracking*16; return w; }
      for (let w of words){ const test=line? line+' '+w : w; if (tWidth(test)>maxWidth && line){ lines.push(line); line=w; } else line=test; } if (line) lines.push(line); cx.restore(); return lines; }
    function drawGlyphs(cx, lines, tt, lineHeight, easer, offs, s){ let gIndex=0; for (let i=0;i<lines.length;i++){ const L=lines[i]; let x = - glyphWidth(cx, L, s.tracking)/2; for (const ch of L){ const per = s.perGlyph ? gIndex : i; const delay=per*state.anim.stagger; const u = clamp((tt-delay)/state.anim.duration,0,1); const e=easer(u); const ox=offs.x*(1-e), oy=offs.y*(1-e); cx.save(); cx.translate(x+ox, i*lineHeight+oy); if (s.strokeWidth>0){ cx.lineWidth=s.strokeWidth; cx.strokeStyle=s.stroke; cx.strokeText(ch,0,0);} cx.fillText(ch,0,0); cx.restore(); x += cx.measureText(ch).width + s.tracking*16; gIndex++; } }
    }
    function glyphWidth(cx, s, tracking){ let w=0; for (const ch of s) w += cx.measureText(ch).width + tracking*16; return w; }
  }

  async function exportWebM(progressCb){
    // Offscreen render using MediaRecorder; excludes guides/UI
    const fps = state.anim.fps; const off = document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height; const cx = off.getContext('2d');
    const stream = off.captureStream(fps); const rec = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'});
    const chunks=[]; rec.ondataavailable = e=>{ if (e.data.size) chunks.push(e.data); };
    const promise = new Promise(res=> rec.onstop = ()=> res(new Blob(chunks, {type:'video/webm'})));
    let i=0; const frames = Math.round(state.anim.duration * fps);
    rec.start();
    (function step(){ if (i>=frames){ rec.stop(); return; } const t=i/fps; render(t); progressCb(i/(frames-1)); i++; setTimeout(step, 0); })();
    return promise;

    function render(tt){
      cx.save(); cx.fillStyle=state.layout.bgColor; cx.fillRect(0,0,off.width,off.height); if (state.layout.bgImage){ const bi=state.layout.bgImage; const r=Math.max(off.width/bi.width, off.height/bi.height); const nw=bi.width*r, nh=bi.height*r; cx.drawImage(bi,(off.width-nw)/2,(off.height-nh)/2,nw,nh);} cx.restore();
      const w=off.width, h=off.height; const s=state.style; const margins=state.layout.margins; const txt=state.text; const fontSpec = `${s.italic? 'italic ':''} ${s.weight} ${s.size}px ${s.font}`; cx.font=fontSpec; cx.textBaseline='alphabetic'; cx.lineJoin='round'; cx.lineCap='round';
      const areaW = w - margins*2; const lines = measureLines(ttxt=>ttxt, txt, areaW, fontSpec, s.tracking);
      const lineHeight = s.size*1.2; const blockH = lines.length*lineHeight; const x0 = margins + areaW/2; const y0 = (h-blockH)/2 + margins;
      const easer=currentEaser(); const offs=getTrackValue('offset',tt)||{x:0,y:0}; const pos=getTrackValue('position',tt)||{x:0,y:0}; const scale=getTrackValue('scale',tt)||1; const rot=getTrackValue('rotation',tt)||0; const opacity=getTrackValue('opacity',tt)||1; const samples=s.motionBlur?3:1; const shutter = 0.5/(state.anim.fps||30);
      cx.save(); cx.translate(x0+pos.x, y0+lineHeight*0.8+pos.y); cx.scale(scale,scale); cx.rotate(rot*Math.PI/180); cx.globalAlpha=opacity; if (s.gradient){ const R=Math.max(w,h); const rad=(s.gradAngle%360)*Math.PI/180; const gx=Math.cos(rad), gy=Math.sin(rad); const g=cx.createLinearGradient(-R*gx,-R*gy,R*gx,R*gy); g.addColorStop(0,s.gradA); g.addColorStop(1,s.gradB); cx.fillStyle=g; } else cx.fillStyle=s.fill; cx.shadowColor=s.shadow; cx.shadowBlur=+s.shadowBlur;
      function glyphWidthStr(str){ let ww=0; for (const ch of str) ww += cx.measureText(ch).width + s.tracking*16; return ww; }
      function drawGlyphs(tts){ let gIndex=0; for (let i=0;i<lines.length;i++){ const L=lines[i]; let x=- glyphWidthStr(L)/2; for (const ch of L){ const per = s.perGlyph ? gIndex : i; const delay=per*state.anim.stagger; const u = clamp((tts-delay)/state.anim.duration,0,1); const e=easer(u); const ox=offs.x*(1-e), oy=offs.y*(1-e); cx.save(); cx.translate(x+ox, i*lineHeight+oy); if (s.strokeWidth>0){ cx.lineWidth=s.strokeWidth; cx.strokeStyle=s.stroke; cx.strokeText(ch,0,0);} cx.fillText(ch,0,0); cx.restore(); x += cx.measureText(ch).width + s.tracking*16; gIndex++; } } }
      for (let S=0; S<samples; S++){ const tts=tt+(S-(samples-1)/2)*shutter; drawGlyphs(tts); }
      cx.restore();
    }
    function measureLines(get, text, maxWidth, fontSpec, tracking){ cx.save(); cx.font=fontSpec; const words=text.split(/\s+/g); const lines=[]; let line=''; function tWidth(s){ let w=0; for (const ch of s) w += cx.measureText(ch).width + tracking*16; return w; } for (let w of words){ const test=line? line+' '+w:w; if (tWidth(test)>maxWidth && line){ lines.push(line); line=w; } else line=test; } if (line) lines.push(line); cx.restore(); return lines; }
  }

  async function exportGIF(progressCb){
    const frames = Math.round(state.anim.duration * state.anim.fps); const gif = new GIF({ workers: 2, quality: 10, workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js' });
    const off = document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height; const cx=off.getContext('2d');
    function render(tt){
      cx.save(); cx.fillStyle=state.layout.bgColor; cx.fillRect(0,0,off.width,off.height); if (state.layout.bgImage){ const bi=state.layout.bgImage; const r=Math.max(off.width/bi.width, off.height/bi.height); const nw=bi.width*r, nh=bi.height*r; cx.drawImage(bi,(off.width-nw)/2,(off.height-nh)/2,nw,nh);} cx.restore();
      const w=off.width, h=off.height; const s=state.style; const margins=state.layout.margins; const txt=state.text; const fontSpec = `${s.italic? 'italic ':''} ${s.weight} ${s.size}px ${s.font}`; cx.font=fontSpec; cx.textBaseline='alphabetic'; cx.lineJoin='round'; cx.lineCap='round';
      const areaW = w - margins*2; const lines = (function(){ const words=txt.split(/\s+/g); const out=[]; let line=''; function tWidth(str){ let ww=0; for (const ch of str) ww += cx.measureText(ch).width + s.tracking*16; return ww; } for (const wd of words){ const test=line? line+' '+wd:wd; if (tWidth(test)>areaW && line){ out.push(line); line=wd; } else line=test; } if (line) out.push(line); return out; })();
      const lineHeight = s.size*1.2; const blockH = lines.length*lineHeight; const x0 = margins + areaW/2; const y0 = (h-blockH)/2 + margins; const easer=currentEaser(); const offs=getTrackValue('offset',tt)||{x:0,y:0}; const pos=getTrackValue('position',tt)||{x:0,y:0}; const scale=getTrackValue('scale',tt)||1; const rot=getTrackValue('rotation',tt)||0; const opacity=getTrackValue('opacity',tt)||1; const samples=s.motionBlur?3:1; const shutter = 0.5/(state.anim.fps||30);
      cx.save(); cx.translate(x0+pos.x, y0+lineHeight*0.8+pos.y); cx.scale(scale,scale); cx.rotate(rot*Math.PI/180); cx.globalAlpha=opacity; if (s.gradient){ const R=Math.max(w,h); const rad=(s.gradAngle%360)*Math.PI/180; const gx=Math.cos(rad), gy=Math.sin(rad); const g=cx.createLinearGradient(-R*gx,-R*gy,R*gx,R*gy); g.addColorStop(0,s.gradA); g.addColorStop(1,s.gradB); cx.fillStyle=g; } else cx.fillStyle=s.fill; cx.shadowColor=s.shadow; cx.shadowBlur=+s.shadowBlur;
      function glyphWidthStr(str){ let ww=0; for (const ch of str) ww += cx.measureText(ch).width + s.tracking*16; return ww; }
      function drawGlyphs(tts){ let gIndex=0; for (let i=0;i<lines.length;i++){ const L=lines[i]; let x=- glyphWidthStr(L)/2; for (const ch of L){ const per = s.perGlyph ? gIndex : i; const delay=per*state.anim.stagger; const u = clamp((tts-delay)/state.anim.duration,0,1); const e=easer(u); const ox=offs.x*(1-e), oy=offs.y*(1-e); cx.save(); cx.translate(x+ox, i*lineHeight+oy); if (s.strokeWidth>0){ cx.lineWidth=s.strokeWidth; cx.strokeStyle=s.stroke; cx.strokeText(ch,0,0);} cx.fillText(ch,0,0); cx.restore(); x += cx.measureText(ch).width + s.tracking*16; gIndex++; } } }
      for (let S=0; S<samples; S++){ const tts=tt+(S-(samples-1)/2)*shutter; drawGlyphs(tts); }
      cx.restore();
    }
    for (let i=0;i<frames;i++){ const t=i/state.anim.fps; render(t); gif.addFrame(off, {copy:true, delay: 1000/state.anim.fps}); progressCb(i/(frames-1)); }
    const blob = await new Promise(res=>{ gif.on('finished', res); gif.render(); }); return blob;
  }

  async function exportMP4(progressCb){
    const { createFFmpeg } = FFmpeg; const ffmpeg = createFFmpeg({ log:false, corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.7/dist/ffmpeg-core.js' });
    await ffmpeg.load(); const frames = Math.round(state.anim.duration * state.anim.fps);
    const off = document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height; const c=off.getContext('2d');
    function render(tt){ c.save(); c.fillStyle=state.layout.bgColor; c.fillRect(0,0,off.width,off.height); if (state.layout.bgImage){ const bi=state.layout.bgImage; const r=Math.max(off.width/bi.width, off.height/bi.height); const nw=bi.width*r, nh=bi.height*r; c.drawImage(bi,(off.width-nw)/2,(off.height-nh)/2,nw,nh);} c.restore(); const w=off.width,h=off.height,s=state.style,margins=state.layout.margins,txt=state.text; const fontSpec=`${s.italic? 'italic ':''} ${s.weight} ${s.size}px ${s.font}`; c.font=fontSpec; c.textBaseline='alphabetic'; c.lineJoin='round'; c.lineCap='round'; const areaW=w-margins*2; const lines=(function(){ const words=txt.split(/\s+/g); const out=[]; let line=''; function tWidth(str){ let ww=0; for (const ch of str) ww+=c.measureText(ch).width + s.tracking*16; return ww; } for (const wd of words){ const test=line? line+' '+wd:wd; if (tWidth(test)>areaW && line){ out.push(line); line=wd; } else line=test; } if (line) out.push(line); return out; })(); const lineHeight=s.size*1.2; const blockH=lines.length*lineHeight; const x0=margins+areaW/2; const y0=(h-blockH)/2+margins; const easer=currentEaser(); const offs=getTrackValue('offset',tt)||{x:0,y:0}; const pos=getTrackValue('position',tt)||{x:0,y:0}; const scale=getTrackValue('scale',tt)||1; const rot=getTrackValue('rotation',tt)||0; const opacity=getTrackValue('opacity',tt)||1; const samples=s.motionBlur?3:1; const shutter=0.5/(state.anim.fps||30); c.save(); c.translate(x0+pos.x,y0+lineHeight*0.8+pos.y); c.scale(scale,scale); c.rotate(rot*Math.PI/180); c.globalAlpha=opacity; if (s.gradient){ const R=Math.max(w,h); const rad=(s.gradAngle%360)*Math.PI/180; const gx=Math.cos(rad), gy=Math.sin(rad); const g=c.createLinearGradient(-R*gx,-R*gy,R*gx,R*gy); g.addColorStop(0,s.gradA); g.addColorStop(1,s.gradB); c.fillStyle=g; } else c.fillStyle=s.fill; c.shadowColor=s.shadow; c.shadowBlur=+s.shadowBlur; function glyphWidthStr(str){ let ww=0; for (const ch of str) ww+=c.measureText(ch).width + s.tracking*16; return ww; } function drawGlyphs(tts){ let gIndex=0; for (let i=0;i<lines.length;i++){ const L=lines[i]; let x=-glyphWidthStr(L)/2; for (const ch of L){ const per=s.perGlyph? gIndex:i; const delay=per*state.anim.stagger; const u=clamp((tts-delay)/state.anim.duration,0,1); const e=easer(u); const ox=offs.x*(1-e), oy=offs.y*(1-e); c.save(); c.translate(x+ox,i*lineHeight+oy); if (s.strokeWidth>0){ c.lineWidth=s.strokeWidth; c.strokeStyle=s.stroke; c.strokeText(ch,0,0);} c.fillText(ch,0,0); c.restore(); x += c.measureText(ch).width + s.tracking*16; gIndex++; } } } for (let S=0; S<samples; S++){ const tts=tt+(S-(samples-1)/2)*shutter; drawGlyphs(tts); } c.restore(); }
    for (let i=0;i<frames;i++){ const t=i/state.anim.fps; render(t); const dataUrl = off.toDataURL('image/png'); const bin = atob(dataUrl.split(',')[1]); const u8 = new Uint8Array(bin.length); for (let j=0;j<bin.length;j++) u8[j] = bin.charCodeAt(j); const name=`frame_${String(i).padStart(5,'0')}.png`; ffmpeg.FS('writeFile', name, u8); progressCb(i/(frames-1)); }
    const fps=state.anim.fps; await ffmpeg.run('-framerate', String(fps), '-i', 'frame_%05d.png', '-pix_fmt','yuv420p','-c:v','libx264','-preset','veryfast','-crf','20','out.mp4');
    const mp4 = ffmpeg.FS('readFile','out.mp4'); return new Blob([mp4.buffer], {type:'video/mp4'});

    // removed per-frame helpers (unified render above)
  }

  // ============= Presets =============
  const presets = {
    typewriter(){
      state.style.perGlyph = true; state.anim.stagger = 0.06; state.tracks.opacity=[{time:0,value:0},{time:state.anim.duration,value:1}];
      state.tracks.offset=[{time:0,value:{x:0,y:0}},{time:state.anim.duration,value:{x:0,y:0}}];
    },
    fadeup(){ state.tracks.offset=[{time:0,value:{x:0,y:40}},{time:state.anim.duration,value:{x:0,y:0}}]; state.tracks.opacity=[{time:0,value:0},{time:state.anim.duration/3,value:1},{time:state.anim.duration,value:1}] },
    bounce(){ state.tracks.scale=[{time:0,value:0.6},{time:state.anim.duration*0.15,value:1.08},{time:state.anim.duration*0.3,value:0.96},{time:state.anim.duration*0.5,value:1.02},{time:state.anim.duration,value:1}] },
    glitch(){ state.tracks.offset=[{time:0,value:{x:0,y:0}},{time:state.anim.duration*0.1,value:{x:6,y:-4}},{time:state.anim.duration*0.11,value:{x:-5,y:4}},{time:state.anim.duration*0.12,value:{x:0,y:0}},{time:state.anim.duration,value:{x:0,y:0}}]; },
    liquid(){ state.tracks.scale=[{time:0,value:0.8},{time:state.anim.duration*0.25,value:1.15},{time:state.anim.duration*0.5,value:0.9},{time:state.anim.duration,value:1}] },
    'cascade-letters'(){ state.style.perGlyph=true; state.anim.stagger=0.04; },
    'cascade-words'(){ state.style.perGlyph=true; state.anim.stagger=0.12; },
    'cascade-lines'(){ state.style.perGlyph=false; state.anim.stagger=0.25; }
  };

  // ============= UI Wiring =============
  function $(id){ return document.getElementById(id) }
  function refreshUI(){
    $('textInput').value = state.text; $('fontFamily').value = state.style.font; $('fontWeight').value = state.style.weight; $('fontWeightVal').textContent = state.style.weight;
    $('fontSize').value = state.style.size; $('fontSizeVal').textContent = state.style.size; $('tracking').value = state.style.tracking; $('trackingVal').textContent = fmt(state.style.tracking);
    $('fillColor').value = state.style.fill; $('strokeColor').value = state.style.stroke; $('strokeWidth').value = state.style.strokeWidth; $('shadowColor').value = state.style.shadow; $('shadowBlur').value = state.style.shadowBlur;
    $('motionBlur').checked = !!state.style.motionBlur; $('perGlyph').checked = !!state.style.perGlyph;
    $('aspect').value = state.layout.aspect; $('aspectVal').textContent = state.layout.aspect; $('resW').value = state.layout.w; $('resH').value = state.layout.h; $('margins').value = state.layout.margins; $('marginsVal').textContent = state.layout.margins
    $('bgColor').value = state.layout.bgColor; $('showGrid').checked = state.layout.showGrid; $('showSafe').checked = state.layout.showSafe; $('zoomVal').textContent = Math.round(state.layout.zoom*100)+'%';
    $('duration').value = state.anim.duration; $('durationVal').textContent = fmt(state.anim.duration,1); $('fps').value = state.anim.fps; $('fpsVal').textContent = state.anim.fps; $('stagger').value = state.anim.stagger; $('staggerVal').textContent = fmt(state.anim.stagger);
    $('easingPreset').value = state.anim.ease; $('qualityVal').textContent = (+$('exportQuality').value).toFixed(2); $('durationChip').textContent = `Dur: ${state.anim.duration.toFixed(1)}s`;
    $('beatSnap').checked = !!state.audio.snap; $('beatDiv').value = state.audio.div || 1; $('snapBadge').style.display = state.audio.snap ? 'inline-block' : 'none';
    resizeCanvas(); drawRuler(); drawLanes(); updatePlayhead();
  }

  function bindControls(){
    $('textInput').addEventListener('input', e=>{ state.text = e.target.value; draw(); });
    $('fontFamily').addEventListener('change', e=>{ state.style.font = e.target.value; draw(); });
    $('fontWeight').addEventListener('input', e=>{ state.style.weight = +e.target.value; $('fontWeightVal').textContent = e.target.value; draw(); });
    $('fontSize').addEventListener('input', e=>{ state.style.size = +e.target.value; $('fontSizeVal').textContent = e.target.value; draw(); });
    $('tracking').addEventListener('input', e=>{ state.style.tracking = +e.target.value; $('trackingVal').textContent = fmt(state.style.tracking); draw(); });
    $('italic').addEventListener('change', e=>{ state.style.italic = e.target.checked; draw(); });
    $('fillColor').addEventListener('input', e=>{ state.style.fill = e.target.value; draw(); });
    $('strokeColor').addEventListener('input', e=>{ state.style.stroke = e.target.value; draw(); });
    $('strokeWidth').addEventListener('input', e=>{ state.style.strokeWidth = +e.target.value; draw(); });
    $('shadowColor').addEventListener('input', e=>{ state.style.shadow = e.target.value; draw(); });
    $('shadowBlur').addEventListener('input', e=>{ state.style.shadowBlur = +e.target.value; draw(); });
    $('motionBlur').addEventListener('change', e=>{ state.style.motionBlur = e.target.checked; draw(); });
    $('perGlyph').addEventListener('change', e=>{ state.style.perGlyph = e.target.checked; draw(); });

    $('aspect').addEventListener('change', e=>{ const v=e.target.value; state.layout.aspect=v; const [a,b]=v.split(':').map(Number); const h=state.layout.h; const w=Math.round(h*a/b); state.layout.w=w; $('resW').value=w; refreshUI(); });
    $('resW').addEventListener('change', e=>{ state.layout.w = +e.target.value; refreshUI(); });
    $('resH').addEventListener('change', e=>{ state.layout.h = +e.target.value; refreshUI(); });
    $('margins').addEventListener('input', e=>{ state.layout.margins = +e.target.value; $('marginsVal').textContent=e.target.value; draw(); });
    $('bgColor').addEventListener('input', e=>{ state.layout.bgColor = e.target.value; draw(); });
    $('bgImage').addEventListener('change', e=>{ const f=e.target.files[0]; if (!f) return; const url=URL.createObjectURL(f); const img=new Image(); img.onload=()=>{ URL.revokeObjectURL(url); state.layout.bgImage=img; draw(); }; img.src=url; });
    $('showGrid').addEventListener('change', e=>{ state.layout.showGrid = e.target.checked; draw(); });
    $('showSafe').addEventListener('change', e=>{ state.layout.showSafe = e.target.checked; draw(); });

    $('duration').addEventListener('input', e=>{ state.anim.duration = +e.target.value; $('durationVal').textContent = (+e.target.value).toFixed(1); drawRuler(); drawLanes(); });
    $('fps').addEventListener('input', e=>{ state.anim.fps = +e.target.value; $('fpsVal').textContent = e.target.value; });
    $('stagger').addEventListener('input', e=>{ state.anim.stagger = +e.target.value; $('staggerVal').textContent = fmt(state.anim.stagger); });
    $('easingPreset').addEventListener('change', e=>{ state.anim.ease = e.target.value; });
    $('openBezier').addEventListener('click', ()=>{ openBezierEditor(); });

    document.querySelectorAll('[data-preset]').forEach(btn=> btn.addEventListener('click', ()=>{ const name=btn.getAttribute('data-preset'); presets[name]?.(); draw(); drawLanes(); }));

    $('beatSnap').addEventListener('change', e=>{ state.audio.snap = e.target.checked; $('snapBadge').style.display = e.target.checked ? 'inline-block': 'none'; });
    $('beatDiv').addEventListener('change', e=>{ state.audio.div = +e.target.value; });
    $('btnAnalyze').addEventListener('click', async ()=>{ const f=$('audioFile').files[0]; if (f) await analyzeBeats(f); });

    $('zoomIn').addEventListener('click', ()=>{ state.layout.zoom = Math.min(2, state.layout.zoom+0.1); document.querySelector('#zoomVal').textContent = Math.round(state.layout.zoom*100)+'%'; canvas.style.transform = `scale(${state.layout.zoom})`; });
    $('zoomOut').addEventListener('click', ()=>{ state.layout.zoom = Math.max(0.4, state.layout.zoom-0.1); document.querySelector('#zoomVal').textContent = Math.round(state.layout.zoom*100)+'%'; canvas.style.transform = `scale(${state.layout.zoom})`; });

    $('toggleGuides').addEventListener('click', ()=>{ state.layout.showGrid = !state.layout.showGrid; state.layout.showSafe = !state.layout.showSafe; $('showGrid').checked=state.layout.showGrid; $('showSafe').checked=state.layout.showSafe; draw(); });
    $('toggleFull').addEventListener('click', ()=>{ canvas.requestFullscreen?.(); });

    $('btnPlay').addEventListener('click', togglePlay);
    $('btnStop').addEventListener('click', ()=>{ state.play.playing=false; state.play.t=0; draw(); updatePlayhead(); updatePlayButton(); });

    $('btnExport').addEventListener('click', ()=>{
      document.querySelector('aside.right').scrollIntoView({behavior:'smooth'});
      document.querySelector('#btnRender').focus();
    });
    $('btnRender').addEventListener('click', doExport);
    $('exportQuality').addEventListener('input', e=> $('qualityVal').textContent = (+e.target.value).toFixed(2));

    document.getElementById('trackList').addEventListener('click', e=>{ const tr=e.target.closest('[data-add-kf]')?.getAttribute('data-add-kf'); if (tr){ addKeyframe(tr, state.play.t, getTrackValue(tr, state.play.t)); drawLanes(); }});
    document.querySelectorAll('[data-add-kf]').forEach(b=> b.addEventListener('click', ()=>{ const tr=b.getAttribute('data-add-kf'); addKeyframe(tr, state.play.t, getTrackValue(tr, state.play.t)); drawLanes(); }));

    $('toggleGradient').addEventListener('click', ()=>{ state.style.gradient = !state.style.gradient; $('gradientRow').style.display = state.style.gradient? 'grid':'none'; draw(); });
    $('gradA').addEventListener('input', e=>{ state.style.gradA=e.target.value; draw(); });
    $('gradB').addEventListener('input', e=>{ state.style.gradB=e.target.value; draw(); });
    $('gradAngle').addEventListener('input', e=>{ state.style.gradAngle=+e.target.value; $('gradPreview').textContent = `${e.target.value}°`; draw(); });

    $('helpBtn').addEventListener('click', ()=>{ $('helpPanel').classList.toggle('show'); });
    $('btnUndo').addEventListener('click', undo); $('btnRedo').addEventListener('click', redo);

    // Timeline interactions
    lanes.addEventListener('pointerdown', e=>{ const rect=lanes.getBoundingClientRect(); const x=e.clientX-rect.left; const y=e.clientY-rect.top; const tracks = Object.keys(state.tracks); const rowH=26; const row=Math.floor(y/rowH); const tr = tracks[row]; const t = clamp(xToTime(x),0,state.anim.duration); if (tr){ addKeyframe(tr, t, getTrackValue(tr, t)); drawLanes(); } else { state.play.t=t; updatePlayhead(); draw(); } });
    lanes.addEventListener('pointermove', e=>{ if (e.buttons&1){ const rect=lanes.getBoundingClientRect(); const x=e.clientX-rect.left; let t = clamp(xToTime(x),0,state.anim.duration); if (state.audio.snap) t = snapToBeat(t, state.audio.div||1); state.play.t = t; updatePlayhead(); draw(); }});
    ruler.addEventListener('wheel', e=>{ e.preventDefault(); const delta = Math.sign(e.deltaY); tl.zoom = clamp(tl.zoom + (delta<0? 10:-10), 40, 400); drawRuler(); drawLanes(); });
  }

  function togglePlay(){ state.play.playing = !state.play.playing; updatePlayButton(); }
  function updatePlayButton(){ $('btnPlay').textContent = state.play.playing? '❚❚ Pause':'▶ Play'; }

  function snapToBeat(t, div=1){ if (!state.audio.beats?.length) return t; const grid = 1/(state.audio.bpm? (state.audio.bpm/60) : 2); // fallback 120bpm
    const q = grid*div; return Math.round(t/q)*q; }

  async function doExport(){ const fmtSel = $('exportFormat').value; const prog = p=> $('renderProgress').style.width = `${Math.round(p*100)}%`; prog(0);
    if (fmtSel==='pngseq'){
      const blob = await exportPNGSequence(prog); saveBlob(blob, 'kt-frames.zip');
    } else if (fmtSel==='gif'){
      const blob = await exportGIF(prog); saveBlob(blob, 'kt-animation.gif');
    } else if (fmtSel==='mp4'){
      const blob = await exportMP4(prog); saveBlob(blob, 'kt-animation.mp4');
    } else {
      const blob = await exportWebM(prog); saveBlob(blob, 'kt-animation.webm');
    }
    prog(1);
  }

  function saveBlob(blob, filename){ const url=URL.createObjectURL(blob); const a=$('downloadLink'); a.href=url; a.download=filename; a.style.display='inline-block'; a.textContent = `Download ${filename}`; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 5000); }

  // ============= Play Loop =============
  function loop(ts){ const now = ts/1000; if (state.play.playing){ if (!state.play.last) state.play.last = now; const dt = now - state.play.last; state.play.last = now; state.play.t += dt; if (state.play.t>state.anim.duration) state.play.t=0; if (state.audio.snap){ /* optional: align to audio clock */ } updatePlayhead(); draw(); } requestAnimationFrame(loop); }

  // ============= Bézier Editor =============
  function openBezierEditor(){ const modal=$('bezierModal'); modal.classList.add('show'); const cvs=$('bezierCanvas'); const cx=cvs.getContext('2d'); const pad=20; const W=cvs.width, H=cvs.height; const P = { p1x:$('p1x'), p1y:$('p1y'), p2x:$('p2x'), p2y:$('p2y') };
    function val(){ return [parseFloat(P.p1x.value), parseFloat(P.p1y.value), parseFloat(P.p2x.value), parseFloat(P.p2y.value)]; }
    function draw(){ cx.clearRect(0,0,W,H); cx.fillStyle='rgba(255,255,255,.03)'; cx.fillRect(0,0,W,H); cx.strokeStyle='rgba(255,255,255,.15)'; cx.lineWidth=1; for (let x=0;x<=1;x+=0.1){ cx.beginPath(); cx.moveTo(pad+x*(W-2*pad), pad); cx.lineTo(pad+x*(W-2*pad), H-pad); cx.stroke(); }
      for (let y=0;y<=1;y+=0.1){ cx.beginPath(); cx.moveTo(pad, pad+y*(H-2*pad)); cx.lineTo(W-pad, pad+y*(H-2*pad)); cx.stroke(); }
      const [x1,y1,x2,y2]=val(); const bez = cubicBezier(x1,y1,x2,y2); cx.strokeStyle='#7aa2f7'; cx.lineWidth=2; cx.beginPath(); for (let i=0;i<=100;i++){ const t=i/100; const x=pad + t*(W-2*pad); const y= pad + (1-bez(t))*(H-2*pad); if (i===0) cx.moveTo(x,y); else cx.lineTo(x,y); } cx.stroke();
      // control points
      cx.fillStyle='#00d1b2'; const C1={x:pad + x1*(W-2*pad), y: pad + (1-y1)*(H-2*pad)}; const C2={x:pad + x2*(W-2*pad), y: pad + (1-y2)*(H-2*pad)}; cx.beginPath(); cx.arc(C1.x, C1.y, 6, 0, Math.PI*2); cx.fill(); cx.beginPath(); cx.arc(C2.x, C2.y, 6, 0, Math.PI*2); cx.fill();
    }
    ['p1x','p1y','p2x','p2y'].forEach(id=> $(id).addEventListener('input', draw));
    draw();
    $('bezierApply').onclick = ()=>{ state.anim.custom = val(); state.anim.ease='custom'; $('easingPreset').value='custom'; modal.classList.remove('show'); };
    $('bezierCancel').onclick = ()=>{ modal.classList.remove('show'); };
  }

  // ============= Keyboard Shortcuts =============
  window.addEventListener('keydown', e=>{
    if (e.key===' '){ e.preventDefault(); if (e.shiftKey){ state.play.playing=false; state.play.t=0; updatePlayButton(); draw(); } else togglePlay(); }
    if ((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='e'){ e.preventDefault(); doExport(); }
    if (e.key.toLowerCase()==='g'){ state.layout.showGrid=!state.layout.showGrid; $('showGrid').checked=state.layout.showGrid; draw(); }
    if (e.key.toLowerCase()==='b'){ state.audio.snap=!state.audio.snap; $('beatSnap').checked=state.audio.snap; $('snapBadge').style.display = state.audio.snap? 'inline-block':'none'; }
    if (e.key==='ArrowRight'){ const step = (e.shiftKey? 10:1)/state.anim.fps; state.play.t = clamp(state.play.t+step,0,state.anim.duration); updatePlayhead(); draw(); }
    if (e.key==='ArrowLeft'){ const step = (e.shiftKey? 10:1)/state.anim.fps; state.play.t = clamp(state.play.t-step,0,state.anim.duration); updatePlayhead(); draw(); }
    if (e.key==='1'){ $('aspect').value='16:9'; $('aspect').dispatchEvent(new Event('change')); }
    if (e.key==='2'){ $('aspect').value='9:16'; $('aspect').dispatchEvent(new Event('change')); }
    if (e.key==='3'){ $('aspect').value='1:1'; $('aspect').dispatchEvent(new Event('change')); }
    if ((e.ctrlKey||e.metaKey)&&!e.shiftKey&&e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
    if ((e.ctrlKey||e.metaKey)&& e.shiftKey && e.key.toLowerCase()==='z'){ e.preventDefault(); redo(); }
    if (e.key.toLowerCase()==='a'){ addKeyframe('position', state.play.t, getTrackValue('position', state.play.t)); drawLanes(); }
    if (e.key.toLowerCase()==='f'){ canvas.requestFullscreen?.(); }
  });

  // ============= Init =============
  function init(){ rebuildTrackList(); bindControls(); refreshUI(); requestAnimationFrame(loop); document.fonts?.ready?.then(()=>draw()); }
  init();

  // Redraw on resize
  new ResizeObserver(()=>{ drawRuler(); drawLanes(); }).observe(document.querySelector('.timeline'));

  // honor prefers-reduced-motion by disabling heavy effects
  try { if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches){ state.style.motionBlur = false; state.style.shadowBlur = Math.min(state.style.shadowBlur, 6); } } catch {}

  </script>
</body>
</html>
