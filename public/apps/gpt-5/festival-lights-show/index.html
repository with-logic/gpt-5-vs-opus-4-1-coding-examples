<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Festival Lights Show</title>
  <meta name="description" content="Control a virtual light show with colors, patterns, and music sync."/>
  <!-- No external CSS; all styles inlined. Libraries allowed via CDN, but not required. -->
  <style>
    :root {
      --bg-1: #0a0014;
      --bg-2: #12002a;
      --accent-1: #ff00a8;
      --accent-2: #00e5ff;
      --panel: rgba(255,255,255,0.06);
      --panel-strong: rgba(255,255,255,0.12);
      --text: #e9ecff;
      --muted: #b9c0ff;
      --ok: #57ffa5;
      --warn: #ffd166;
      --danger: #ff5e7e;
      --shadow: 0 10px 40px rgba(0,0,0,0.45), inset 0 0 0 1px rgba(255,255,255,0.05);
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    html { background: radial-gradient(1200px 600px at 10% 10%, #2a0050 0%, transparent 60%),
                    radial-gradient(1200px 700px at 90% 20%, #003c68 0%, transparent 60%),
                    linear-gradient(160deg, var(--bg-1), var(--bg-2)); }
    body {
      margin: 0; color: var(--text); font: 500 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      background: conic-gradient(from 180deg at 50% 10%, rgba(255,0,168,0.08), rgba(0,229,255,0.06) 40%, transparent 60%) no-repeat fixed,
                  radial-gradient(1200px 600px at 50% 5%, rgba(255,0,168,0.12), transparent 70%) no-repeat fixed;
    }
    .app {
      display: grid; grid-template-rows: auto 1fr; min-height: 100%;
    }
    header {
      position: sticky; top: 0; z-index: 2; backdrop-filter: saturate(140%) blur(10px);
      background: linear-gradient(90deg, rgba(10,0,20,0.7), rgba(10,0,20,0.3), rgba(10,0,20,0.7));
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 14px 18px; display: flex; align-items: center; gap: 12px; }
    .brand { font-weight: 800; letter-spacing: 0.3px; font-size: 20px; position: relative; }
    .brand .glow {
      background: linear-gradient(90deg, var(--accent-1), var(--accent-2)); -webkit-background-clip: text; background-clip: text; color: transparent;
      text-shadow: 0 0 18px rgba(255,0,168,0.35), 0 0 24px rgba(0,229,255,0.25);
    }
    .badge { font-size: 11px; letter-spacing: 0.4px; color: var(--muted); opacity: 0.85; }

    main { display: grid; grid-template-columns: 320px 1fr; gap: 20px; max-width: 1200px; margin: 16px auto; padding: 0 18px 24px; width: 100%; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .panel { background: var(--panel); border: 1px solid rgba(255,255,255,0.08); box-shadow: var(--shadow); border-radius: var(--radius); }
    .controls { padding: 14px; display: grid; gap: 12px; }
    .section-title { font-weight: 700; font-size: 12px; letter-spacing: 1.1px; text-transform: uppercase; color: var(--muted); margin: 6px 4px 6px; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; }
    .row > label { color: var(--muted); font-size: 13px; }

    .btn { cursor: pointer; user-select: none; padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); color: var(--text); font-weight: 600;
      transition: transform .1s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease; box-shadow: 0 6px 20px rgba(0,0,0,0.25);
    }
    .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.2); }
    .btn:active { transform: translateY(0); }
    .btn.primary { background: linear-gradient(90deg, rgba(255,0,168,0.18), rgba(0,229,255,0.18)); border-color: rgba(255,255,255,0.18);
      box-shadow: 0 10px 34px rgba(255,0,168,0.22), 0 10px 34px rgba(0,229,255,0.22);
    }
    .btn.ghost { background: rgba(255,255,255,0.04); }

    .chipbar { display: flex; gap: 8px; flex-wrap: wrap; }
    .chip { padding: 8px 10px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); cursor: pointer; font-weight: 600; font-size: 12px; }
    .chip:hover { background: rgba(255,255,255,0.1); }

    select, input[type="color"], input[type="range"], input[type="file"] { width: 100%; }
    select, input[type="color"] { padding: 10px; border-radius: 10px; background: rgba(255,255,255,0.06); color: var(--text); border: 1px solid rgba(255,255,255,0.14); font-weight: 600; }
    input[type="color"] { height: 40px; }
    input[type="range"] { -webkit-appearance: none; height: 8px; background: rgba(255,255,255,0.08); border-radius: 999px; outline: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: linear-gradient(90deg, var(--accent-1), var(--accent-2)); box-shadow: 0 0 12px rgba(255,0,168,0.6), 0 0 12px rgba(0,229,255,0.5); border: 0; }
    input[type="file"] { padding: 8px; border-radius: 10px; background: rgba(255,255,255,0.06); color: var(--muted); border: 1px solid rgba(255,255,255,0.14); }

    .stage { position: relative; overflow: hidden; }
    #canvas { width: 100%; height: min(72vh, 720px); display: block; border-radius: var(--radius); }

    .hud { position: absolute; inset: 10px 10px auto auto; background: rgba(0,0,0,0.35); padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); font-size: 12px; color: var(--muted); }
    .legend { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
    .legend span { display: inline-flex; align-items: center; gap: 6px; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

    footer { color: var(--muted); text-align: center; padding: 6px 16px 18px; font-size: 12px; }

    .pulseborder { position: relative; }
    .pulseborder::before { content: ""; position: absolute; inset: -1px; border-radius: inherit; background: conic-gradient(from 140deg, rgba(255,0,168,0.7), rgba(0,229,255,0.7), transparent 60%);
      filter: blur(16px); opacity: 0.25; z-index: -1; animation: drift 8s linear infinite; }
    @keyframes drift { to { transform: rotate(360deg); } }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 1280px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="wrap">
        <div class="brand"><span class="glow">Festival Lights Show</span> <span class="badge">Color • Patterns • Music Sync</span></div>
        <div style="flex:1"></div>
        <button id="btn-randomize" class="btn ghost" title="Randomize show">Randomize</button>
        <button id="btn-fullscreen" class="btn primary" title="Toggle fullscreen">Fullscreen</button>
      </div>
    </header>

    <main>
      <aside class="panel pulseborder">
        <div class="controls">
          <div class="section-title">Pattern</div>
          <div class="row">
            <select id="pattern" title="Select pattern"></select>
            <button id="btn-blend" class="btn ghost" title="Crossfade to next pattern (B)">Blend</button>
          </div>
          <div class="grid">
            <div class="row"><label>Speed</label><span id="speedVal"></span></div>
            <input id="speed" type="range" min="0" max="3" step="0.01" value="1.0"/>
            <div class="row"><label>Intensity</label><span id="intensityVal"></span></div>
            <input id="intensity" type="range" min="0" max="1.5" step="0.01" value="1.0"/>
            <div class="row"><label>LED Size</label><span id="sizeVal"></span></div>
            <input id="size" type="range" min="10" max="42" step="1" value="26"/>
            <div class="row"><label>Hue Shift</label><span id="hueVal"></span></div>
            <input id="hue" type="range" min="-180" max="180" step="1" value="0"/>
          </div>

          <div class="section-title">Palette</div>
          <div class="grid">
            <div>
              <label>Accent A</label>
              <input id="colorA" type="color" value="#ff00a8"/>
            </div>
            <div>
              <label>Accent B</label>
              <input id="colorB" type="color" value="#00e5ff"/>
            </div>
          </div>
          <div class="chipbar" id="palettes"></div>

          <div class="section-title">Music Sync</div>
          <div class="grid">
            <button id="btn-mic" class="btn">Connect Microphone</button>
            <button id="btn-audio-toggle" class="btn ghost" disabled>Play/Pause</button>
            <div>
              <label>Load Audio File</label>
              <input id="file" type="file" accept="audio/*" />
            </div>
            <div class="row"><label>Sensitivity</label><span id="sensVal"></span></div>
            <input id="sensitivity" type="range" min="0.5" max="2.0" step="0.01" value="1.0"/>
          </div>

          <div class="section-title">Presets</div>
          <div class="chipbar">
            <div class="chip" data-preset="rave">Rave</div>
            <div class="chip" data-preset="chill">Chill</div>
            <div class="chip" data-preset="sunset">Sunset</div>
            <div class="chip" data-preset="cyber">Cyberpunk</div>
          </div>

          <div class="section-title">Shortcuts</div>
          <div style="color:var(--muted)">Space: Play/Pause • M: Mic • [ / ]: Speed • 1–9: Pattern • F: Fullscreen • B: Blend • Click stage: Ripples</div>
        </div>
      </aside>

      <section class="panel stage pulseborder">
        <canvas id="canvas" aria-label="Festival Lights Show canvas"></canvas>
        <div class="hud" id="hud">
          <div class="legend">
            <span><span class="dot" style="background:var(--ok)"></span>Audio <span id="hud-audio">idle</span></span>
            <span><span class="dot" style="background:#9ae6ff"></span>Pattern <span id="hud-pattern">-</span></span>
            <span><span class="dot" style="background:#ffd166"></span>FPS <span id="hud-fps">60</span></span>
            <span><span class="dot" style="background:#ff5e7e"></span>Beat <span id="hud-beat">—</span></span>
          </div>
        </div>
      </section>
    </main>

    <footer>Built with pure Canvas and Web Audio • All code in this page</footer>
  </div>

  <script>
  ;(() => {
    // ===== Utilities
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const lerp = (a, b, t) => a + (b - a) * t;
    const mix = (c1, c2, t) => [
      Math.round(lerp(c1[0], c2[0], t)),
      Math.round(lerp(c1[1], c2[1], t)),
      Math.round(lerp(c1[2], c2[2], t))
    ];
    const hexToRgb = h => {
      const s = h.replace('#','');
      const n = parseInt(s.length === 3 ? s.split('').map(x=>x+x).join('') : s, 16);
      return [(n>>16)&255, (n>>8)&255, n&255];
    };
    const rgbToCss = (r,g,b,a=1) => `rgba(${r|0},${g|0},${b|0},${a})`;
    const hsl = (h, s, l) => { // h:0-360 s,l:0-100
      h = ((h%360)+360)%360; s/=100; l/=100;
      const c = (1 - Math.abs(2*l - 1)) * s;
      const x = c * (1 - Math.abs(((h/60)%2) - 1));
      const m = l - c/2;
      let [r,g,b] = [0,0,0];
      if (h < 60) [r,g,b] = [c, x, 0];
      else if (h < 120) [r,g,b] = [x, c, 0];
      else if (h < 180) [r,g,b] = [0, c, x];
      else if (h < 240) [r,g,b] = [0, x, c];
      else if (h < 300) [r,g,b] = [x, 0, c];
      else [r,g,b] = [c, 0, x];
      return [(r+m)*255,(g+m)*255,(b+m)*255];
    };

    // Simple value noise for soft patterns
    function ValueNoise(seed=12345) {
      const rand = (n) => {
        const x = Math.sin(n*1e4 + seed) * 1e4; return x - Math.floor(x);
      };
      const smoothstep = (t)=>t*t*(3-2*t);
      this.noise2D = (x, y) => {
        const xi = Math.floor(x), yi = Math.floor(y);
        const xf = x - xi, yf = y - yi;
        const tl = rand(xi*374761393 + yi*668265263);
        const tr = rand((xi+1)*374761393 + yi*668265263);
        const bl = rand(xi*374761393 + (yi+1)*668265263);
        const br = rand((xi+1)*374761393 + (yi+1)*668265263);
        const u = smoothstep(xf), v = smoothstep(yf);
        const t = lerp(tl, tr, u), b = lerp(bl, br, u);
        return lerp(t, b, v);
      };
    }
    const vnoise = new ValueNoise(Math.random()*1e6|0);

    // ===== State
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0, DPR = Math.min(2, window.devicePixelRatio || 1);

    const options = {
      pattern: 'rainbow',
      speed: 1.0,
      intensity: 1.0,
      size: 26,
      hue: 0,
      colorA: '#ff00a8',
      colorB: '#00e5ff',
      blend: 0,
    };

    // UI bindings
    const el = id => document.getElementById(id);
    const $pattern = el('pattern');
    const $speed = el('speed');
    const $intensity = el('intensity');
    const $size = el('size');
    const $hue = el('hue');
    const $colorA = el('colorA');
    const $colorB = el('colorB');
    const $btnMic = el('btn-mic');
    const $btnAudioToggle = el('btn-audio-toggle');
    const $file = el('file');
    const $btnFullscreen = el('btn-fullscreen');
    const $btnRandomize = el('btn-randomize');
    const $btnBlend = el('btn-blend');

    const hud = { fps: el('hud-fps'), audio: el('hud-audio'), pattern: el('hud-pattern'), beat: el('hud-beat') };

    const labels = {
      speed: el('speedVal'), intensity: el('intensityVal'), size: el('sizeVal'), hue: el('hueVal'), sens: el('sensVal')
    };

    // ===== Grid
    let cols = 0, rows = 0, spacing = 26, margin = 18, ledRadius = 8;
    let grid = [];

    function resize() {
      const rect = canvas.getBoundingClientRect();
      W = Math.floor(rect.width * DPR); H = Math.floor(rect.height * DPR);
      canvas.width = W; canvas.height = H;
      spacing = +options.size * DPR; ledRadius = Math.max(4, Math.round(spacing*0.35));
      cols = Math.max(8, Math.floor((W - margin*DPR*2)/spacing));
      rows = Math.max(6, Math.floor((H - margin*DPR*2)/spacing));
      const offx = (W - cols*spacing)/2 + spacing/2;
      const offy = (H - rows*spacing)/2 + spacing/2;
      grid = [];
      for (let y=0; y<rows; y++) {
        for (let x=0; x<cols; x++) {
          grid.push({ x: offx + x*spacing, y: offy + y*spacing, i: y*cols + x, gx: x, gy: y });
        }
      }
    }

    window.addEventListener('resize', resize);

    // ===== Audio Engine
    const audio = {
      ctx: null,
      analyser: null,
      srcNode: null,
      element: null,
      dataF: null,
      dataT: null,
      active: false,
      using: 'none', // 'mic' | 'file' | 'none'
      playing: false,
      energy: 0,
      bass: 0, mid: 0, high: 0,
      beat: false,
      bpm: 0
    };

    function createAudio() {
      if (!audio.ctx) {
        audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (!audio.analyser) {
        audio.analyser = audio.ctx.createAnalyser();
        audio.analyser.fftSize = 2048;
        audio.analyser.smoothingTimeConstant = 0.85;
        audio.dataF = new Uint8Array(audio.analyser.frequencyBinCount);
        audio.dataT = new Uint8Array(audio.analyser.fftSize);
      }
    }

    async function useMic() {
      try {
        createAudio();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
        if (audio.srcNode) audio.srcNode.disconnect();
        audio.srcNode = audio.ctx.createMediaStreamSource(stream);
        audio.srcNode.connect(audio.analyser);
        audio.active = true; audio.using = 'mic'; audio.playing = true; $btnAudioToggle.disabled = false;
        hud.audio.textContent = 'mic';
      } catch (err) {
        alert('Microphone permission failed. You can also load an audio file.');
      }
    }

    function useFile(file) {
      createAudio();
      const url = URL.createObjectURL(file);
      if (audio.element) { audio.element.pause(); }
      const el = new Audio();
      el.src = url; el.loop = true; el.crossOrigin = 'anonymous';
      el.addEventListener('canplay', () => { el.play(); });
      const src = audio.ctx.createMediaElementSource(el);
      if (audio.srcNode) audio.srcNode.disconnect();
      src.connect(audio.analyser); audio.analyser.connect(audio.ctx.destination);
      audio.srcNode = src; audio.element = el; audio.active = true; audio.using = 'file'; audio.playing = true; $btnAudioToggle.disabled = false;
      hud.audio.textContent = 'file';
    }

    $btnMic.addEventListener('click', async () => {
      await useMic(); if (audio.ctx.state === 'suspended') await audio.ctx.resume();
    });
    $file.addEventListener('change', (e) => {
      const f = e.target.files?.[0]; if (f) useFile(f);
    });
    $btnAudioToggle.addEventListener('click', async () => {
      if (!audio.active) return;
      if (audio.using === 'file') {
        if (audio.element.paused) { await audio.element.play(); audio.playing = true; } else { audio.element.pause(); audio.playing = false; }
      } else if (audio.using === 'mic') {
        if (audio.ctx.state === 'running') { await audio.ctx.suspend(); audio.playing = false; } else { await audio.ctx.resume(); audio.playing = true; }
      }
      hud.audio.textContent = audio.playing ? audio.using : 'paused';
    });

    // Beat detection (simple adaptive threshold on low band)
    const beat = { history: new Array(120).fill(0), idx: 0, last: 0, cool: 0 };
    function updateAudioMetrics(dt) {
      if (!audio.analyser) { audio.energy = 0; audio.bass = audio.mid = audio.high = 0; audio.beat = false; return; }
      audio.analyser.getByteFrequencyData(audio.dataF);
      audio.analyser.getByteTimeDomainData(audio.dataT);

      // Aggregate bands
      const n = audio.dataF.length;
      const band = (lo, hi) => {
        lo = Math.floor(lo*n), hi = Math.floor(hi*n); hi = Math.min(n-1, Math.max(0, hi)); lo = Math.max(0, lo);
        let s=0,c=0; for (let i=lo;i<=hi;i++){ s+=audio.dataF[i]; c++; } return c? s/c/255 : 0;
      };
      audio.bass = band(0.0, 0.08); // ~0-170Hz depending on sample rate
      audio.mid  = band(0.08, 0.35);
      audio.high = band(0.35, 0.9);

      // RMS energy from time domain
      let acc=0; for (let i=0;i<audio.dataT.length;i++){ const v=(audio.dataT[i]-128)/128; acc+=v*v; }
      audio.energy = Math.sqrt(acc/audio.dataT.length);

      // Beat detection on bass energy
      const sens = +$sensitivity.value; // 0.5..2.0 lower -> more sensitive
      const e = audio.bass;
      beat.history[beat.idx] = e; beat.idx = (beat.idx + 1) % beat.history.length;
      const mean = beat.history.reduce((a,b)=>a+b,0)/beat.history.length;
      const variance = beat.history.reduce((a,b)=>a+(b-mean)*(b-mean),0)/beat.history.length;
      const std = Math.sqrt(variance);
      const threshold = mean + std * (1.35 * (2.0/sens));
      audio.beat = e > threshold && (performance.now() - beat.last > 120); // cap at ~8.3Hz
      if (audio.beat) { beat.last = performance.now(); beat.cool = 1; }
      else beat.cool = Math.max(0, beat.cool - dt*3);
      hud.beat.textContent = audio.beat ? 'BOOM' : '—';
    }

    // ===== Patterns
    const patterns = [
      { id:'rainbow', name:'Rainbow Flow', fn: (p,t,a)=>{
        const hue = (p.gx/cols)*360 + t*120*a.speed + options.hue;
        const bri = 55 + 45*Math.sin((p.gy/rows)*Math.PI*2 + t*2*a.speed);
        return hsl(hue, 85, bri);
      }},
      { id:'pulse', name:'Pulse', fn: (p,t,a)=>{
        const base = hexToRgb(options.colorA);
        const mod = 0.4 + 0.6*Math.sin(t*3*a.speed + (p.gx+p.gy)*0.05);
        const energy = (a.energy*1.6 + a.bass*1.2);
        const k = clamp((mod + energy) * options.intensity, 0, 2);
        return mix([0,0,0], base, clamp(k,0,1));
      }},
      { id:'strobe', name:'Strobe', fn: (p,t,a)=>{
        const on = (Math.sin(t*20*a.speed) > 0.8 || a.beat) ? 1 : 0;
        const c = on ? [255,255,255] : [20,20,25];
        return c;
      }},
      { id:'waves', name:'Waves', fn: (p,t,a)=>{
        const u = p.gx/cols, v = p.gy/rows;
        const w = Math.sin((u*8 + t*1.5*a.speed)*Math.PI) + Math.cos((v*6 - t*1.2*a.speed)*Math.PI);
        const hue = 200 + 80*w + options.hue;
        const sat = 70 + 20*Math.sin(t + u*5);
        const bri = 40 + 40*(w*0.5+0.5) + a.mid*40;
        return hsl(hue, sat, bri);
      }},
      { id:'ripple', name:'Ripples', fn: (p,t,a)=>{
        let acc=0; for (const r of ripplePool) {
          const dx = (p.x - r.x)/W, dy = (p.y - r.y)/H; const d = Math.hypot(dx,dy);
          const w = Math.sin((d*40 - (t - r.t)*8*a.speed)*Math.PI);
          acc += Math.max(0, 1 - d*2) * Math.max(0, w);
        }
        const hue = (options.hue + (p.gx/cols)*180) % 360;
        const bri = clamp(20 + 90*acc + a.bass*50, 0, 100);
        return hsl(hue, 85, bri);
      }},
      { id:'spiral', name:'Spiral', fn: (p,t,a)=>{
        const cx = (p.x/W - 0.5), cy = (p.y/H - 0.5)*H/W; // aspect-correct
        const r = Math.hypot(cx, cy), ang = Math.atan2(cy, cx);
        const k = Math.sin(10*r - t*3*a.speed + ang*4);
        const hue = (options.hue + ang*180/Math.PI + 360) % 360;
        const bri = 30 + 70*(k*0.5+0.5) + a.high*25;
        return hsl(hue, 90, bri);
      }},
      { id:'bars', name:'Audio Bars', fn: (p,t,a)=>{
        // Columns mapped to frequency bands
        const bin = Math.floor((p.gx/cols) * (audio.dataF ? audio.dataF.length : 1));
        const mag = audio.dataF ? (audio.dataF[bin]/255) : 0;
        const threshold = 1 - (p.gy/rows);
        const on = mag > threshold*0.9;
        const hue = (options.hue + (bin/(audio.dataF?audio.dataF.length:1))*300) % 360;
        const bri = on ? 70 + mag*30 : 10;
        return hsl(hue, 90, bri);
      }},
      { id:'sparkle', name:'Sparkle', fn: (p,t,a)=>{
        const n = vnoise.noise2D(p.gx*0.9 + t*2*a.speed, p.gy*0.9 - t*1.5*a.speed);
        const twinkle = Math.max(0, Math.sin((t*6 + p.i*0.13)));
        const hue = (options.hue + n*360) % 360;
        const bri = 15 + 85*Math.pow(Math.max(0, n*0.6 + twinkle*0.5 + a.high*0.6), 1.5);
        return hsl(hue, 80, bri);
      }},
      { id:'firefly', name:'Firefly Drift', fn: (p,t,a)=>{
        const c1 = hexToRgb(options.colorA), c2 = hexToRgb(options.colorB);
        let sum=0; for (const f of fireflies) {
          const dx=(p.x - f.x)/W, dy=(p.y - f.y)/H; const d = Math.hypot(dx,dy);
          sum += Math.max(0, 1 - d*12);
        }
        const k = clamp(sum + a.energy*2, 0, 1);
        return mix(c1, c2, k);
      }},
    ];

    // Populate pattern select
    for (const p of patterns) {
      const opt = document.createElement('option'); opt.value = p.id; opt.textContent = p.name; $pattern.appendChild(opt);
    }

    // ===== Interactive extras
    const ripplePool = [];
    canvas.addEventListener('pointerdown', (e)=>{
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * DPR, y = (e.clientY - r.top) * DPR;
      ripplePool.push({ x, y, t: time });
      while (ripplePool.length > 6) ripplePool.shift();
    });

    const fireflies = Array.from({length: 12}, (_,i)=>({ x: Math.random()*W, y: Math.random()*H, a: Math.random()*Math.PI*2, s: 30 + Math.random()*80 }));

    // Palettes presets
    const presetPalettes = [
      ['#ff00a8','#00e5ff','Neon Pop'], ['#ff8a00','#ffd200','Sunset'], ['#00ffa3','#00d1ff','Tropical'], ['#8a2be2','#ff1493','Cyber'], ['#00ff9d','#b6ff00','Lime Glow']
    ];
    const $pal = document.getElementById('palettes');
    presetPalettes.forEach(([a,b,name])=>{
      const d = document.createElement('div'); d.className='chip'; d.title=name; d.innerHTML = `<span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${a};vertical-align:-1px"></span> <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${b};vertical-align:-1px"></span> ${name}`;
      d.addEventListener('click', ()=>{ $colorA.value = a; $colorB.value = b; options.colorA=a; options.colorB=b; });
      $pal.appendChild(d);
    });

    // Presets for whole show
    document.querySelectorAll('[data-preset]').forEach(chip => chip.addEventListener('click', () => {
      const p = chip.getAttribute('data-preset');
      if (p === 'rave') { options.pattern='strobe'; $pattern.value='strobe'; options.speed=1.8; $speed.value=1.8; options.intensity=1.3; $intensity.value=1.3; options.hue=0; $hue.value=0; $colorA.value='#ffffff'; $colorB.value='#ff00a8'; }
      if (p === 'chill') { options.pattern='waves'; $pattern.value='waves'; options.speed=0.8; $speed.value=0.8; options.intensity=0.9; $intensity.value=0.9; options.hue=-20; $hue.value=-20; $colorA.value='#3ddad7'; $colorB.value='#b2f7ef'; }
      if (p === 'sunset') { options.pattern='ripple'; $pattern.value='ripple'; options.speed=1.0; $speed.value=1.0; options.intensity=1.0; $intensity.value=1.0; options.hue=30; $hue.value=30; $colorA.value='#ff8a00'; $colorB.value='#ffd200'; }
      if (p === 'cyber') { options.pattern='spiral'; $pattern.value='spiral'; options.speed=1.2; $speed.value=1.2; options.intensity=1.2; $intensity.value=1.2; options.hue=120; $hue.value=120; $colorA.value='#ff00a8'; $colorB.value='#00e5ff'; }
      options.colorA = $colorA.value; options.colorB = $colorB.value; labelsUpdate(); hud.pattern.textContent = patterns.find(x=>x.id===options.pattern)?.name || '-';
    }));

    // ===== UI wiring
    function labelsUpdate(){ labels.speed.textContent = options.speed.toFixed(2); labels.intensity.textContent = options.intensity.toFixed(2); labels.size.textContent = options.size|0; labels.hue.textContent = (options.hue|0)+'°'; labels.sens.textContent = (+$sensitivity.value).toFixed(2); }
    $pattern.addEventListener('change', ()=>{ options.pattern=$pattern.value; hud.pattern.textContent = patterns.find(x=>x.id===options.pattern)?.name || '-'; options.blend = 0.999; });
    $speed.addEventListener('input', ()=>{ options.speed=+$speed.value; labelsUpdate(); });
    $intensity.addEventListener('input', ()=>{ options.intensity=+$intensity.value; labelsUpdate(); });
    $size.addEventListener('input', ()=>{ options.size=+$size.value; labelsUpdate(); resize(); });
    $hue.addEventListener('input', ()=>{ options.hue=+$hue.value; labelsUpdate(); });
    $colorA.addEventListener('input', ()=>{ options.colorA=$colorA.value; });
    $colorB.addEventListener('input', ()=>{ options.colorB=$colorB.value; });

    const $sensitivity = document.getElementById('sensitivity');
    $sensitivity.addEventListener('input', ()=> labelsUpdate());

    $btnFullscreen.addEventListener('click', ()=>{
      const r = document.documentElement; if (!document.fullscreenElement) r.requestFullscreen?.(); else document.exitFullscreen?.();
    });
    $btnRandomize.addEventListener('click', ()=>{
      const ids = patterns.map(p=>p.id); const id = ids[(Math.random()*ids.length)|0]; $pattern.value = id; options.pattern = id;
      $speed.value = (Math.random()*2.2 + 0.2).toFixed(2); options.speed = +$speed.value;
      $intensity.value = (Math.random()*1.4 + 0.2).toFixed(2); options.intensity = +$intensity.value;
      $hue.value = ((Math.random()*360 - 180)|0); options.hue = +$hue.value;
      const randHex = ()=>'#'+Array.from({length:6},()=>('0123456789abcdef'[(Math.random()*16)|0])).join('');
      options.colorA = $colorA.value = randHex(); options.colorB = $colorB.value = randHex();
      options.blend = 0.999; labelsUpdate(); hud.pattern.textContent = patterns.find(x=>x.id===options.pattern)?.name || '-';
    });

    $btnBlend.addEventListener('click', ()=>{ options.blend = 0.999; // trigger one-shot crossfade
      // also rotate to next pattern
      const idx = patterns.findIndex(p=>p.id===options.pattern); const next = patterns[(idx+1)%patterns.length]; options.pattern = next.id; $pattern.value = next.id; hud.pattern.textContent = next.name; });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if (e.key === ' ') { e.preventDefault(); $btnAudioToggle.click(); }
      if (e.key === 'm' || e.key === 'M') { $btnMic.click(); }
      if (e.key === '[') { $speed.value = Math.max(0, +$speed.value - 0.05).toFixed(2); options.speed=+$speed.value; labelsUpdate(); }
      if (e.key === ']') { $speed.value = Math.min(3, +$speed.value + 0.05).toFixed(2); options.speed=+$speed.value; labelsUpdate(); }
      if (e.key === 'f' || e.key === 'F') { $btnFullscreen.click(); }
      if (e.key === 'b' || e.key === 'B') { $btnBlend.click(); }
      if (e.key>='1' && e.key<='9') { const i = (+e.key)-1; if (i<patterns.length){ $pattern.value=patterns[i].id; options.pattern=patterns[i].id; options.blend=0.999; hud.pattern.textContent = patterns[i].name; } }
    });

    // ===== Render loop
    let last = performance.now();
    let time = 0; // seconds
    let fpsAcc=0, fpsFrames=0, fpsTime=0;

    function render(now){
      const dt = Math.min(0.05, (now - last)/1000); last = now; time += dt;
      // Update audio metrics
      updateAudioMetrics(dt);

      // Move fireflies
      for (const f of fireflies) {
        f.a += (Math.random()-0.5)*0.3*dt; const v = f.s * (0.2 + options.speed*0.2);
        f.x += Math.cos(f.a)*v*dt; f.y += Math.sin(f.a)*v*dt;
        if (f.x < 0) f.x += W; if (f.x>W) f.x -= W; if (f.y<0) f.y += H; if (f.y>H) f.y -= H;
      }

      // Background glow
      ctx.clearRect(0,0,W,H);
      const g = ctx.createLinearGradient(0,0,W,H);
      g.addColorStop(0, `rgba(255,0,168,${0.10 + 0.06*Math.sin(time*0.7)})`);
      g.addColorStop(1, `rgba(0,229,255,${0.10 + 0.06*Math.cos(time*0.9)})`);
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

      // Select pattern function
      const pat = patterns.find(p=>p.id===options.pattern) || patterns[0];

      // Optional blending from previous frame (pseudo crossfade by lingering additive glow)
      ctx.globalCompositeOperation = 'lighter';

      const a = { speed: options.speed, intensity: options.intensity, energy: audio.energy, bass: audio.bass, mid: audio.mid, high: audio.high, beat: audio.beat };

      // Draw LEDs
      const cA = hexToRgb(options.colorA), cB = hexToRgb(options.colorB);
      for (let i=0; i<grid.length; i++) {
        const p = grid[i];
        let col = pat.fn(p, time, a);
        // blend with palette gradient along x
        const mixT = p.gx/(cols-1 || 1);
        col = mix(col, mix(cA, cB, mixT), 0.35);
        col = mix(col, [255,255,255], Math.max(0, (audio.beat?0.1:0) + a.high*0.02));
        const r = ledRadius * (1 + 0.25*(a.energy + a.bass*0.6));
        ctx.fillStyle = rgbToCss(col[0], col[1], col[2], 0.95);
        ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
      }

      // Beat flash overlay
      if (audio.beat) {
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(0,0,W,H);
      }

      // Fade for lingering glow if blending
      if (options.blend > 0) {
        ctx.globalCompositeOperation = 'destination-in';
        ctx.fillStyle = `rgba(255,255,255,${options.blend})`;
        ctx.fillRect(0,0,W,H);
        options.blend = Math.max(0, options.blend - 0.03);
      }

      // HUD
      fpsAcc += 1/dt; fpsFrames++; fpsTime += dt; if (fpsTime > 0.5) { hud.fps.textContent = (fpsAcc/fpsFrames).toFixed(0); fpsAcc=0; fpsFrames=0; fpsTime=0; }

      requestAnimationFrame(render);
    }

    // Init
    function init(){
      resize(); labelsUpdate();
      hud.pattern.textContent = patterns.find(x=>x.id===options.pattern)?.name || '-';
      requestAnimationFrame((t)=>{ last=t; render(t); });
    }

    init();

  })();
  </script>
</body>
</html>
