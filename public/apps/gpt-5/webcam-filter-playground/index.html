<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Webcam Filter Playground</title>
  <meta name="theme-color" content="#0f0f12" />
  <style>
    :root{
      --bg:#0b0c10;--panel:#12131a;--accent:#7c5cff;--accent-2:#2bd3ff;--text:#e9eef5;--muted:#9aa4b2;--danger:#ff5874;
      --glass:rgba(255,255,255,0.06);--glass-2:rgba(255,255,255,0.12);
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0;background:radial-gradient(1200px 800px at 10% -10%, #111427 0%, #0b0c10 55%), linear-gradient(120deg,#0b0c10 0%, #0b0c10 100%);
      color:var(--text);font:14px/1.3 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden; /* immersive */
    }

    /* Layout */
    .app{display:grid;grid-template-rows:auto 1fr auto;gap:10px;height:100%;padding:14px;}
    .topbar,.bottombar{display:flex;align-items:center;gap:10px;}
    .topbar{justify-content:space-between}
    .brand{display:flex;align-items:center;gap:10px;user-select:none}
    .brand .dot{width:10px;height:10px;border-radius:50%;background:conic-gradient(from 0deg,#7c5cff,#2bd3ff,#7c5cff);box-shadow:0 0 18px #7c5cff66}
    .brand h1{font-size:14px;margin:0;opacity:.9;letter-spacing:.4px}

    .stage{
      position:relative;border-radius:14px;background:linear-gradient(180deg, var(--glass) 0%, transparent 100%);
      border:1px solid rgba(255,255,255,.08);overflow:hidden;min-height:220px;
      box-shadow:0 20px 70px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.03);
    }
    canvas#out{position:absolute;inset:0;width:100%;height:100%;display:block;background:#000}
    video{position:absolute;inset:0;width:0;height:0;opacity:0;pointer-events:none}

    /* Overlays */
    .hud{position:absolute;inset:0;display:flex;flex-direction:column;justify-content:space-between;pointer-events:none}
    .row{display:flex;gap:8px;align-items:center}
    .hud .row{padding:10px}
    .pill{backdrop-filter:blur(8px);background:var(--glass);border:1px solid rgba(255,255,255,.1);padding:8px 10px;border-radius:999px;display:flex;gap:8px;align-items:center;pointer-events:auto}
    .chip{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.1);color:var(--text);cursor:pointer;user-select:none;transition:.15s ease;white-space:nowrap}
    .chip:hover{transform:translateY(-1px);background:rgba(255,255,255,.09)}
    .chip.active{background:linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);border-color:transparent;color:white;box-shadow:0 6px 22px rgba(124,92,255,.4)}

    .controls{display:flex;gap:10px;align-items:center}
    .btn{display:inline-flex;align-items:center;justify-content:center;height:36px;padding:0 12px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:var(--glass);color:var(--text);cursor:pointer;transition:.15s ease;user-select:none}
    .btn:hover{background:var(--glass-2);transform:translateY(-1px)}
    .btn.primary{background:linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);border-color:transparent;color:#fff;box-shadow:0 6px 22px rgba(124,92,255,.4)}
    .icon{width:18px;height:18px;display:inline-block;vertical-align:middle;}

    .bottombar{justify-content:space-between}
    .filterbar{display:flex;gap:8px;overflow:auto;padding-bottom:4px;scrollbar-width:thin}
    .filterbar::-webkit-scrollbar{height:6px}
    .filterbar::-webkit-scrollbar-thumb{background:#ffffff22;border-radius:999px}

    /* Range slider */
    .range{appearance:none;height:6px;border-radius:999px;background:#ffffff14;outline:none}
    .range::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:linear-gradient(135deg, var(--accent), var(--accent-2));box-shadow:0 2px 8px rgba(0,0,0,.4)}

    /* Gallery */
    .gallery{display:flex;gap:8px;overflow:auto}
    .shot{width:84px;height:56px;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,.12);background:#000;cursor:pointer;position:relative}
    .shot img{width:100%;height:100%;object-fit:cover;display:block}
    .shot .meta{position:absolute;right:4px;bottom:4px;background:rgba(0,0,0,.55);font-size:10px;padding:2px 4px;border-radius:4px}

    /* Grid overlay */
    .grid{position:absolute;inset:0;pointer-events:none;background-image:linear-gradient(#ffffff12 1px, transparent 1px),linear-gradient(90deg, #ffffff12 1px, transparent 1px);background-size: calc(100%/3) calc(100%/3);opacity:.35;mix-blend-mode:screen}
    .hidden{display:none}

    /* Responsive tweaks */
    @media (max-width: 720px){
      .btn .label{display:none}
      .shot{width:68px;height:46px}
      .brand h1{display:none}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="brand"><span class="dot"></span><h1>Webcam Filter Playground</h1></div>
      <div class="controls">
        <select id="cameraSelect" class="btn" title="Camera device"></select>
        <button id="flipBtn" class="btn" title="Flip/mirror video" aria-pressed="true">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M21 12c0 4.971-4.029 9-9 9S3 16.971 3 12 7.029 3 12 3"/><path d="M12 7v5l3 3"/></svg>
          <span class="label" style="margin-left:6px">Mirror</span>
        </button>
        <button id="gridBtn" class="btn" title="Toggle grid" aria-pressed="false">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 9h18M3 15h18M9 3v18M15 3v18"/></svg>
          <span class="label" style="margin-left:6px">Grid</span>
        </button>
        <button id="fsBtn" class="btn" title="Fullscreen">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 9V4h5M15 4h5v5M20 15v5h-5M9 20H4v-5"/></svg>
          <span class="label" style="margin-left:6px">Fullscreen</span>
        </button>
      </div>
    </div>

    <div class="stage" id="stage">
      <canvas id="out"></canvas>
      <video id="vid" playsinline muted></video>

      <div class="hud">
        <div class="row" style="justify-content:space-between;">
          <div class="pill" id="statusPill">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6"><circle cx="12" cy="12" r="9"/><path d="M9 12l2 2 4-4"/></svg>
            <span id="status">Ready</span>
          </div>
          <div class="pill">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 7h16M4 12h16M4 17h10"/></svg>
            <span id="filterName">Original</span>
          </div>
        </div>
        <div class="row" style="justify-content:center;gap:16px;">
          <div class="pill" style="min-width:220px">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 12h16"/><circle cx="12" cy="12" r="9"/></svg>
            <input id="intensity" class="range" type="range" min="0" max="100" value="60" style="width:220px"/>
          </div>
          <button id="capture" class="btn primary" title="Capture (C)">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6"><circle cx="12" cy="12" r="8"/></svg>
            <span class="label" style="margin-left:8px">Capture</span>
          </button>
          <button id="download" class="btn" title="Download last (S)">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6"><path d="M12 3v12"/><path d="M7 10l5 5 5-5"/><path d="M5 19h14"/></svg>
            <span class="label" style="margin-left:8px">Save</span>
          </button>
        </div>
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div class="pill" style="max-width:50vw">
            <div class="filterbar" id="filterBar"></div>
          </div>
          <div class="pill">
            <div class="gallery" id="gallery"></div>
          </div>
        </div>
      </div>
      <div id="grid" class="grid hidden"></div>
    </div>

    <div class="bottombar">
      <div class="muted" style="color:var(--muted)">Tips: Press C to capture, S to save, ←/→ to switch filters.</div>
      <div style="display:flex;align-items:center;gap:8px;color:var(--muted)">
        <span id="resInfo">—</span>
      </div>
    </div>
  </div>

  <script>
  ;(() => {
    const $ = (sel, el=document) => el.querySelector(sel);
    const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

    const video = $('#vid');
    const canvas = $('#out');
    const ctx = canvas.getContext('2d');

    // Offscreen working canvas for pixel effects
    const work = document.createElement('canvas');
    const wctx = work.getContext('2d');

    // Canvas for pixelate helper
    const tiny = document.createElement('canvas');
    const tctx = tiny.getContext('2d', { willReadFrequently: true });

    const state = {
      running: false,
      mirror: true,
      showGrid: false,
      currentFilter: 'original',
      intensity: 0.6, // 0..1
      devices: [],
      deviceId: undefined,
      lastShotUrl: null,
      processingScale: 1, // dynamic
    };

    const resInfo = $('#resInfo');
    const status = $('#status');
    const filterNameEl = $('#filterName');
    const intensityInput = $('#intensity');
    const filterBar = $('#filterBar');
    const gallery = $('#gallery');

    const gridBtn = $('#gridBtn');
    const flipBtn = $('#flipBtn');
    const fsBtn = $('#fsBtn');
    const captureBtn = $('#capture');
    const downloadBtn = $('#download');
    const gridOverlay = $('#grid');
    const cameraSelect = $('#cameraSelect');

    const filters = [
      { id:'original', name:'Original', hint:'No processing', kind:'draw' },
      { id:'mono', name:'Mono', hint:'Classic grayscale', kind:'pixel' },
      { id:'sepia', name:'Sepia', hint:'Warm vintage tones', kind:'pixel' },
      { id:'invert', name:'Invert', hint:'Photo negative', kind:'pixel' },
      { id:'vivid', name:'Vivid', hint:'Punchy colors', kind:'pixel' },
      { id:'duotone', name:'Duotone', hint:'Two‑color map', kind:'pixel' },
      { id:'pixelate', name:'Pixelate', hint:'Retro mosaic', kind:'scale' },
      { id:'edges', name:'Edges', hint:'Sobel outline', kind:'pixel' },
      { id:'rgb', name:'RGB Shift', hint:'Glitchy offset', kind:'pixel' },
      { id:'thermal', name:'Thermal', hint:'False color heat', kind:'pixel' },
      { id:'kaleido', name:'Kaleidoscope', hint:'Mirrored slices', kind:'draw' },
      { id:'crt', name:'CRT', hint:'Scanlines + glow', kind:'pixel' },
    ];

    // UI setup
    function buildFilterChips(){
      filterBar.innerHTML = '';
      filters.forEach(f => {
        const chip = document.createElement('button');
        chip.className = 'chip' + (state.currentFilter===f.id?' active':'');
        chip.textContent = f.name;
        chip.title = f.hint;
        chip.onclick = () => selectFilter(f.id);
        chip.dataset.id = f.id;
        filterBar.appendChild(chip);
      });
    }
    function selectFilter(id){
      state.currentFilter = id;
      $$('.chip', filterBar).forEach(c=>c.classList.toggle('active', c.dataset.id===id));
      filterNameEl.textContent = filters.find(x=>x.id===id)?.name || '—';
    }

    // Camera setup
    async function listDevices(){
      try{
        const devices = (await navigator.mediaDevices.enumerateDevices()).filter(d=>d.kind==='videoinput');
        state.devices = devices;
        cameraSelect.innerHTML = '';
        devices.forEach((d,i)=>{
          const opt = document.createElement('option');
          opt.value = d.deviceId; opt.textContent = d.label || `Camera ${i+1}`; cameraSelect.appendChild(opt);
        });
        if(state.deviceId){ cameraSelect.value = state.deviceId; }
      }catch(e){
        // Log a concise warning string to avoid JSHandle@error artifacts in headless logs
        const msg = e && e.message ? e.message : String(e);
        console.warn('enumerateDevices: ' + msg);
      }
    }

    async function startCamera(deviceId){
      status.textContent = 'Requesting camera…';
      const facing = state.mirror ? 'user' : 'environment';
      const constraints = {
        audio:false,
        video:{
          deviceId: deviceId ? { exact: deviceId } : undefined,
          facingMode: deviceId ? undefined : { ideal: facing },
          width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 }
        }
      };
      try{
        if(state.stream){ state.stream.getTracks().forEach(t=>t.stop()); }
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        state.stream = stream; state.deviceId = deviceId || (stream.getVideoTracks()[0].getSettings().deviceId || undefined);
        video.srcObject = stream; await video.play();
        await listDevices();
        status.textContent = 'Live';
        state.running = true;
        resizeCanvases();
        requestAnimationFrame(loop);
      }catch(err){
        // Avoid emitting console errors in environments without camera access
        // (e.g., headless test runners). Log a warning instead and show UI feedback.
        const msg = err && err.message ? err.message : String(err);
        console.warn('getUserMedia failed: ' + msg);
        status.textContent = 'Camera blocked';
        toast('Camera access is required. Check permissions.', true);
      }
    }

    // Resize logic maintains consistent processing resolution for performance
    function resizeCanvases(){
      if(!video.videoWidth){ return; }
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const stage = $('#stage');
      const rect = stage.getBoundingClientRect();
      // Maintain video aspect
      const vw = video.videoWidth, vh = video.videoHeight;
      const ar = vw / vh;
      let cw = rect.width, ch = rect.height;
      if(cw/ch > ar){ cw = ch*ar; } else { ch = cw/ar; }

      // Processing resolution cap to keep filters smooth
      const maxW = 1280; // cap processing width
      const procW = Math.min(maxW, Math.round(cw*dpr));
      const procH = Math.round(procW / ar);

      canvas.width = Math.round(cw * dpr); canvas.height = Math.round(ch * dpr);
      canvas.style.width = cw+'px'; canvas.style.height = ch+'px';

      work.width = procW; work.height = procH;
      tiny.width = Math.max(32, Math.round(procW/Math.max(4, (10*state.intensity))));
      tiny.height = Math.max(24, Math.round(procH/Math.max(4, (10*state.intensity))));

      resInfo.textContent = `${Math.round(procW)}×${Math.round(procH)} @ ${dpr.toFixed(1)}x`;
    }

    window.addEventListener('resize', resizeCanvases);

    // Drawing helpers
    function drawBaseToWork(){
      const w = work.width, h = work.height;
      wctx.save();
      wctx.clearRect(0,0,w,h);
      if(state.mirror){
        wctx.translate(w,0); wctx.scale(-1,1);
      }
      wctx.drawImage(video, 0, 0, w, h);
      wctx.restore();
    }

    function loop(){
      if(!state.running){ return; }
      if(video.readyState < 2){ return requestAnimationFrame(loop); }
      const cw = canvas.width, ch = canvas.height;

      // Draw fresh frame to work canvas first
      drawBaseToWork();

      // Apply filter into output canvas
      switch(state.currentFilter){
        case 'original':
          drawOriginal(); break;
        case 'mono':
          applyMono(); break;
        case 'sepia':
          applySepia(); break;
        case 'invert':
          applyInvert(); break;
        case 'vivid':
          applyVivid(); break;
        case 'duotone':
          applyDuotone(); break;
        case 'pixelate':
          applyPixelate(); break;
        case 'edges':
          applyEdges(); break;
        case 'rgb':
          applyRGBShift(); break;
        case 'thermal':
          applyThermal(); break;
        case 'kaleido':
          applyKaleido(); break;
        case 'crt':
          applyCRT(); break;
      }

      // Optional grid overlay handled by CSS layer
      requestAnimationFrame(loop);
    }

    function blitWorkToOutput(){
      // Fit work canvas into output canvas
      const w = work.width, h = work.height;
      const cw = canvas.width, ch = canvas.height;
      // Letterbox fit
      const ar = w/h; let dw=cw, dh=cw/ar; if(dh>ch){ dh=ch; dw=dh*ar; }
      const dx = (cw - dw)/2, dy=(ch-dh)/2;
      ctx.clearRect(0,0,cw,ch);
      ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(work, 0,0,w,h, dx,dy,dw,dh);
      return {dx,dy,dw,dh};
    }

    // Filters — pixel-level helpers
    function getFrame(){ return wctx.getImageData(0,0,work.width, work.height); }
    function putFrame(img){ wctx.putImageData(img,0,0); }

    function clamp01(x){ return Math.min(1, Math.max(0, x)); }

    function applyMono(){
      const img = getFrame();
      const d = img.data; for(let i=0;i<d.length;i+=4){
        const y = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
        d[i]=d[i+1]=d[i+2]=y;
      }
      putFrame(img); blitWorkToOutput();
    }
    function applySepia(){
      const t = 0.3 + state.intensity*0.7; // stronger with intensity
      const img = getFrame(); const d=img.data; for(let i=0;i<d.length;i+=4){
        const r=d[i], g=d[i+1], b=d[i+2];
        d[i]   = clamp255((r*0.393 + g*0.769 + b*0.189)*t + r*(1-t));
        d[i+1] = clamp255((r*0.349 + g*0.686 + b*0.168)*t + g*(1-t));
        d[i+2] = clamp255((r*0.272 + g*0.534 + b*0.131)*t + b*(1-t));
      }
      putFrame(img); blitWorkToOutput();
    }
    function applyInvert(){
      const amt = state.intensity; const img=getFrame(); const d=img.data; for(let i=0;i<d.length;i+=4){
        d[i]   = d[i]  *(1-amt) + (255-d[i])  *amt;
        d[i+1] = d[i+1]*(1-amt) + (255-d[i+1])*amt;
        d[i+2] = d[i+2]*(1-amt) + (255-d[i+2])*amt;
      }
      putFrame(img); blitWorkToOutput();
    }
    function applyVivid(){
      const img=getFrame(); const d=img.data; const s = 0.5 + state.intensity*1.2; const c = 0.1 + state.intensity*0.6; const b = (state.intensity-0.5)*40;
      for(let i=0;i<d.length;i+=4){
        // saturation
        const r=d[i], g=d[i+1], b0=d[i+2]; const lum=0.2126*r+0.7152*g+0.0722*b0;
        d[i]   = clamp255(lum + (r-lum)* (1+s));
        d[i+1] = clamp255(lum + (g-lum)* (1+s));
        d[i+2] = clamp255(lum + (b0-lum)*(1+s));
        // contrast + brightness
        d[i]   = clamp255((d[i]-128)*(1+c)+128 + b);
        d[i+1] = clamp255((d[i+1]-128)*(1+c)+128 + b);
        d[i+2] = clamp255((d[i+2]-128)*(1+c)+128 + b);
      }
      putFrame(img); blitWorkToOutput();
    }
    function applyDuotone(){
      const cA=[124,92,255], cB=[43,211,255]; // accent colors
      const img=getFrame(); const d=img.data; const t = state.intensity;
      for(let i=0;i<d.length;i+=4){
        const r0=d[i], g0=d[i+1], b0=d[i+2];
        const y = (0.2126*r0 + 0.7152*g0 + 0.0722*b0)/255; // 0..1
        const dr = clamp255(cA[0]*(1-y) + cB[0]*y);
        const dg = clamp255(cA[1]*(1-y) + cB[1]*y);
        const db = clamp255(cA[2]*(1-y) + cB[2]*y);
        d[i]   = dr*t + r0*(1-t);
        d[i+1] = dg*t + g0*(1-t);
        d[i+2] = db*t + b0*(1-t);
      }
      putFrame(img); blitWorkToOutput();
    }

    function applyPixelate(){
      // Draw video to tiny canvas then scale up
      const w=work.width, h=work.height;
      tctx.imageSmoothingEnabled=false;
      tctx.save();
      tctx.clearRect(0,0,tiny.width,tiny.height);
      // Mirror when drawing into tiny too
      if(state.mirror){ tctx.translate(tiny.width,0); tctx.scale(-1,1); }
      tctx.drawImage(video, 0,0, tiny.width, tiny.height);
      tctx.restore();

      wctx.save(); wctx.clearRect(0,0,w,h);
      wctx.imageSmoothingEnabled=false;
      wctx.drawImage(tiny, 0,0,tiny.width,tiny.height, 0,0,w,h);
      wctx.restore();
      blitWorkToOutput();
    }

    function applyEdges(){
      // Sobel edge detection on luminance
      const w = work.width, h=work.height; const src = getFrame();
      // grayscale buffer
      const gray = new Uint8ClampedArray(w*h);
      for(let i=0, j=0;i<src.data.length;i+=4, j++){
        gray[j] = (0.2126*src.data[i] + 0.7152*src.data[i+1] + 0.0722*src.data[i+2])|0;
      }
      const gxK = [-1,0,1,-2,0,2,-1,0,1];
      const gyK = [-1,-2,-1,0,0,0,1,2,1];
      const out = new Uint8ClampedArray(w*h*4);
      const t = 0.5 + state.intensity; // edge strength
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let gx=0, gy=0; let k=0;
          for(let yy=-1;yy<=1;yy++){
            for(let xx=-1;xx<=1;xx++){
              const v = gray[(y+yy)*w + (x+xx)];
              gx += v * gxK[k]; gy += v * gyK[k]; k++;
            }
          }
          const mag = Math.min(255, Math.hypot(gx, gy) * t);
          const i = (y*w + x)*4; out[i]=out[i+1]=out[i+2]=mag; out[i+3]=255;
        }
      }
      const img = new ImageData(out, w, h); putFrame(img); blitWorkToOutput();
    }

    function applyRGBShift(){
      const w = work.width, h=work.height; const src = getFrame(); const d = src.data;
      const out = new Uint8ClampedArray(d.length);
      const amt = Math.round(2 + state.intensity*10);
      function idx(x,y){ x=Math.max(0,Math.min(w-1,x)); y=Math.max(0,Math.min(h-1,y)); return (y*w + x)*4; }
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i = (y*w + x)*4;
          const ir = idx(x-amt, y);
          const ig = idx(x, y);
          const ib = idx(x+amt, y);
          out[i]   = d[ir];      // R from left
          out[i+1] = d[ig+1];    // G from center
          out[i+2] = d[ib+2];    // B from right
          out[i+3] = 255;
        }
      }
      const img = new ImageData(out, w, h); putFrame(img);
      // Add slight noise scanlines
      wctx.save(); wctx.globalAlpha = 0.08;
      for(let y=0;y<h;y+=2){ wctx.fillStyle = '#000'; wctx.fillRect(0,y,w,1); }
      wctx.restore();
      blitWorkToOutput();
    }

    function applyThermal(){
      const w=work.width, h=work.height; const img=getFrame(); const d=img.data;
      const t = state.intensity; // 0..1
      for(let i=0;i<d.length;i+=4){
        const y = (0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]) / 255; // 0..1
        const c = thermalMap(y);
        d[i]   = lerp(d[i],   c[0], t);
        d[i+1] = lerp(d[i+1], c[1], t);
        d[i+2] = lerp(d[i+2], c[2], t);
      }
      putFrame(img); blitWorkToOutput();
    }

    function applyKaleido(){
      // Repeating mirrored slices horizontally; sample from captured frame
      const w = work.width, h = work.height;
      const slices = 6 + Math.round(state.intensity*6); // 6..12
      const sliceW = Math.floor(w / slices);
      const temp = document.createElement('canvas'); temp.width=w; temp.height=h; const tc=temp.getContext('2d'); tc.drawImage(work,0,0);
      wctx.save(); wctx.clearRect(0,0,w,h);
      for(let i=0;i<slices;i++){
        const even = i%2===0; const dx = i*sliceW; const sx = (i*sliceW)%w;
        wctx.save();
        wctx.translate(dx + (even?0:sliceW), 0);
        wctx.scale(even?1:-1, 1);
        wctx.drawImage(temp, sx, 0, sliceW, h, 0, 0, sliceW, h);
        wctx.restore();
      }
      wctx.restore();
      blitWorkToOutput();
    }

    function applyCRT(){
      // Slight saturation + contrast, scanlines, vignette
      applyVivid(); // base punch
      const {dx,dy,dw,dh} = blitWorkToOutput();
      // Overlay scanlines on output canvas (not work)
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = '#000';
      for(let y=dy|0;y<dy+dh;y+=2){ ctx.fillRect(dx, y, dw, 1); }
      ctx.globalAlpha = 1;
      // Vignette
      const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)*0.2, canvas.width/2, canvas.height/2, Math.max(canvas.width,canvas.height)*0.6);
      g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.35)');
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
      // Subtle flicker
      ctx.globalAlpha = 0.05 + Math.random()*0.04; ctx.fillStyle = '#fff'; ctx.fillRect(dx,dy,dw,1);
      ctx.restore();
    }

    function drawOriginal(){ blitWorkToOutput(); }

    // math helpers
    function clamp255(x){ return x<0?0:(x>255?255:x)|0; }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function thermalMap(x){
      // Simple gradient: black->navy->purple->red->orange->yellow->white
      const stops=[
        [0.00,[0,0,0]],
        [0.15,[0,10,40]],
        [0.35,[60,0,100]],
        [0.55,[180,0,60]],
        [0.72,[255,80,0]],
        [0.88,[255,200,0]],
        [1.00,[255,255,255]]
      ];
      let i=1; while(i<stops.length && x>stops[i][0]) i++;
      const [x1,c1]=stops[i-1], [x2,c2]=stops[i]; const t=(x-x1)/(x2-x1);
      return [
        (c1[0]+(c2[0]-c1[0])*t)|0,
        (c1[1]+(c2[1]-c1[1])*t)|0,
        (c1[2]+(c2[2]-c1[2])*t)|0
      ];
    }

    // Snapshot + gallery
    function capture(){
      // Render current canvas to blob
      const a = document.createElement('a');
      canvas.toBlob(b=>{
        if(!b){ return; }
        const url = URL.createObjectURL(b);
        state.lastShotUrl = url;
        addToGallery(url);
        a.href = url; a.download = `webcam_${Date.now()}.png`; a.click();
        toast('Snapshot saved');
      }, 'image/png', 0.92);
    }
    function addToGallery(url){
      const wrap = document.createElement('div'); wrap.className='shot';
      const img = new Image(); img.src = url; img.alt='snapshot';
      const meta = document.createElement('div'); meta.className='meta'; meta.textContent = new Date().toLocaleTimeString();
      wrap.appendChild(img); wrap.appendChild(meta);
      wrap.onclick = ()=>{ const a=document.createElement('a'); a.href=url; a.download='snapshot.png'; a.click(); };
      gallery.prepend(wrap); // latest first
      // keep last 8
      while(gallery.children.length>8){ const last=gallery.lastElementChild; URL.revokeObjectURL(last.querySelector('img').src); last.remove(); }
    }

    function downloadLast(){
      if(!state.lastShotUrl){ toast('No snapshot yet'); return; }
      const a = document.createElement('a'); a.href = state.lastShotUrl; a.download = 'snapshot.png'; a.click();
    }

    // Simple toast via status pill
    let toastTimer;
    function toast(msg, danger){
      status.textContent = msg;
      const pill = document.getElementById('statusPill');
      pill.style.borderColor = danger? 'var(--danger)' : 'rgba(255,255,255,.1)';
      clearTimeout(toastTimer); toastTimer = setTimeout(()=>{ status.textContent = 'Live'; pill.style.borderColor='rgba(255,255,255,.1)'; }, 2000);
    }

    // Events
    intensityInput.addEventListener('input', e=>{ state.intensity = +e.target.value/100; resizeCanvases(); });
    gridBtn.addEventListener('click', ()=>{ state.showGrid=!state.showGrid; gridBtn.setAttribute('aria-pressed', String(state.showGrid)); gridOverlay.classList.toggle('hidden', !state.showGrid); });
    flipBtn.addEventListener('click', ()=>{ state.mirror=!state.mirror; flipBtn.setAttribute('aria-pressed', String(state.mirror)); });
    fsBtn.addEventListener('click', ()=>{ const el=$('#stage'); if(!document.fullscreenElement){ el.requestFullscreen?.(); } else { document.exitFullscreen?.(); }});
    cameraSelect.addEventListener('change', ()=>{ startCamera(cameraSelect.value); });

    captureBtn.addEventListener('click', capture);
    downloadBtn.addEventListener('click', downloadLast);

    window.addEventListener('keydown', (e)=>{
      if(e.key==='c' || e.key==='C'){ capture(); }
      if(e.key==='s' || e.key==='S'){ downloadLast(); }
      if(e.key==='ArrowRight' || e.key==='ArrowLeft'){
        const idx = filters.findIndex(f=>f.id===state.currentFilter);
        let ni = e.key==='ArrowRight' ? (idx+1)%filters.length : (idx-1+filters.length)%filters.length;
        selectFilter(filters[ni].id);
      }
    });

    // Initialize UI
    buildFilterChips();
    selectFilter('original');

    // Start camera once page is interactive
    document.addEventListener('DOMContentLoaded', async ()=>{
      await startCamera();
      await listDevices();
    });

    // Utility to keep work canvas contents after running pixel filters
    function withFrame(fn){ const img=getFrame(); fn(img); putFrame(img); blitWorkToOutput(); }

    // Clamp Safari autoplay quirks
    video.addEventListener('loadedmetadata', ()=>{ resizeCanvases(); });

  })();
  </script>
</body>
</html>
