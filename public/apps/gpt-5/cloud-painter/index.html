<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>Cloud Painter ‚òÅÔ∏è</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;600;800&family=Quicksand:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --sky-top:#a7d9ff; /* soft blue */
      --sky-mid:#cbeeff;
      --sky-bot:#eef9ff;
      --sun:#ffe697;
      --ui-bg: rgba(255,255,255,0.55);
      --ui-bg-strong: rgba(255,255,255,0.72);
      --ui-border: rgba(255,255,255,0.92);
      --ink: #356;
      --accent:#6cc7ff;
      --accent-2:#ff99cc;
      --ok:#3fc380;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:"Baloo 2",ui-rounded,system-ui, -apple-system, Segoe UI, Roboto, "Quicksand", sans-serif;
      color:var(--ink);
      background: linear-gradient(180deg,var(--sky-top),var(--sky-mid) 55%, var(--sky-bot));
      overflow:hidden;
    }
    #app{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto;}
    header.appbar{
      position:relative;
      display:flex; align-items:center; justify-content:center;
      padding:10px 12px; gap:8px;
      z-index:5;
      pointer-events:none;
    }
    .title{
      display:inline-flex; align-items:center; gap:.5rem; padding:.35rem .8rem; border-radius:14px;
      background: var(--ui-bg);
      border: 1px solid var(--ui-border);
      box-shadow: 0 6px 16px rgba(0,0,0,.08);
      backdrop-filter: blur(10px) saturate(120%);
      font-weight:800; letter-spacing:.4px; font-size: clamp(18px, 2.2vw, 26px);
      pointer-events:auto;
    }
    .title .logo{font-size:1.2em}
    .subtitle{font-weight:600; opacity:.8; font-size:.85em; margin-left:.2em}

    .canvas-wrap{position:relative; width:100%; height:100%;}
    canvas#sky{position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; cursor:crosshair;}
    .overlay-tip{
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      background:var(--ui-bg); border:1px solid var(--ui-border); border-radius:20px; padding:12px 16px; text-align:center;
      font-weight:600; color:#245; box-shadow:0 8px 24px rgba(0,0,0,.08); backdrop-filter: blur(8px);
      pointer-events:none; user-select:none; z-index:3;
      animation: float 6s ease-in-out infinite;
    }
    @keyframes float{0%{transform:translate(-50%,-50%) translateY(0)}50%{transform:translate(-50%,-50%) translateY(-6px)}100%{transform:translate(-50%,-50%) translateY(0)}}

    .hud{
      position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:center;
      background:var(--ui-bg);
      border:1px solid var(--ui-border);
      border-radius:18px; padding:10px 12px; z-index:6;
      box-shadow: 0 12px 28px rgba(0,0,0,.10);
      backdrop-filter: blur(10px) saturate(120%);
    }
    .panel{display:flex; align-items:center; gap:8px; background:var(--ui-bg-strong); border:1px solid var(--ui-border); padding:6px 8px; border-radius:14px}
    .group{display:flex; align-items:center; gap:6px}
    .label{font-weight:700; font-size:.9rem; opacity:.9}
    button{appearance:none; border:none; background:#fff; color:#245; font-weight:800; border-radius:12px; padding:8px 10px; box-shadow:0 2px 0 rgba(0,0,0,.06) inset, 0 6px 14px rgba(0,0,0,.08); transition:.15s transform, .2s background, .2s box-shadow; cursor:pointer}
    button:hover{transform:translateY(-1px)}
    button:active{transform:translateY(0)}
    button.icon{width:44px; height:44px; display:grid; place-items:center; font-size:20px; background:linear-gradient(180deg,#fff, #f6fbff);}
    button.icon[aria-pressed="true"]{outline:2px solid var(--accent); background:linear-gradient(180deg,#fff, #eaf7ff)}
    .btn{display:inline-flex; align-items:center; gap:8px; font-size:.95rem; background:linear-gradient(180deg,#fff,#f7fbff);}
    .btn.save{background:linear-gradient(180deg,#fff,#e6fff2); color:#145a32;}
    .btn.clear{background:linear-gradient(180deg,#fff,#fff2f2); color:#6d1a1a;}
    .spacer{width:8px}

    input[type=range]{-webkit-appearance:none; width:160px; height:28px; background:transparent}
    input[type=range]::-webkit-slider-runnable-track{height:10px; border-radius:999px; background:linear-gradient(90deg, #dff3ff, #f4f9ff); border:1px solid #fff}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none; margin-top:-9px; width:26px; height:26px; border-radius:50%; background: radial-gradient(circle at 30% 30%, #fff, #e8f6ff); border:1px solid #fff; box-shadow: 0 4px 10px rgba(0,0,0,.15)}
    input[type=range]::-moz-range-track{height:10px; border-radius:999px; background:linear-gradient(90deg, #dff3ff, #f4f9ff); border:1px solid #fff}
    input[type=range]::-moz-range-thumb{width:26px; height:26px; border-radius:50%; background: radial-gradient(circle at 30% 30%, #fff, #e8f6ff); border:1px solid #fff; box-shadow: 0 4px 10px rgba(0,0,0,.15)}

    .tiny{font-size:.84rem; opacity:.8}
    .credits{position:absolute; right:12px; bottom:12px; font-size:.8rem; opacity:.75; background:var(--ui-bg); border:1px solid var(--ui-border); border-radius:999px; padding:6px 10px; backdrop-filter: blur(8px)}

    @media (max-width: 860px){
      input[type=range]{width:120px}
      button.icon{width:42px; height:42px}
      .panel{gap:6px}
    }
  </style>
</head>
<body>
  <div id="app">
    <header class="appbar">
      <div class="title" aria-label="Cloud Painter title">
        <span class="logo">‚òÅÔ∏è‚ú®</span>
        <span>Cloud Painter</span>
        <span class="subtitle">Paint the sky</span>
      </div>
    </header>

    <div class="canvas-wrap">
      <canvas id="sky" aria-label="Cloud painting canvas"></canvas>
      <div class="overlay-tip" id="tip">Tap or click and drag to paint fluffy clouds.</div>

      <div class="hud" role="toolbar" aria-label="Cloud Painter controls">
        <div class="panel" aria-label="Brushes">
          <span class="label">Brush</span>
          <div class="group" id="brushGroup">
            <button class="icon" data-brush="round" title="Round Fluff" aria-pressed="true">‚òÅÔ∏è</button>
            <button class="icon" data-brush="cloud" title="Cloud Stamp" aria-pressed="false">üå•Ô∏è</button>
            <button class="icon" data-brush="star" title="Star Puff" aria-pressed="false">‚≠ê</button>
            <button class="icon" data-brush="heart" title="Heart Puff" aria-pressed="false">‚ù§Ô∏è</button>
          </div>
          <div class="spacer"></div>
          <span class="label">Size</span>
          <input id="size" type="range" min="8" max="160" value="80" />
          <span class="label">Fluff</span>
          <input id="soft" type="range" min="0" max="100" value="70" />
        </div>

        <div class="panel" aria-label="Wind and planes">
          <span class="label">Wind</span>
          <input id="wind" type="range" min="0" max="100" value="35" title="Wind speed" />
          <div class="group">
            <button class="btn" id="togglePlanes" title="Toggle planes"><span>‚úàÔ∏è Planes</span></button>
            <button class="btn" id="addPlane" title="Add a plane">‚ûï‚úàÔ∏è</button>
          </div>
        </div>

        <div class="panel" aria-label="Actions">
          <button class="btn save" id="saveBtn" title="Save as image">üíæ Save</button>
          <button class="btn clear" id="clearBtn" title="Clear the sky">üßº Clear</button>
        </div>
      </div>

      <div class="credits">Made for kids ‚Ä¢ Cloud drift + planes ‚Ä¢ Save art</div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('sky');
    const tip = document.getElementById('tip');

    // Visible render context
    const ctx = canvas.getContext('2d', { alpha: false });
    // Offscreen buffer that stores drawn clouds in "world" space
    let cloudCanvas = document.createElement('canvas');
    let cloudCtx = cloudCanvas.getContext('2d');

    // Optional offscreen for composing saves
    const saveCanvas = document.createElement('canvas');
    const saveCtx = saveCanvas.getContext('2d');

    // Background pre-canvas for subtle animated sky
    let bgCanvas = document.createElement('canvas');
    let bgCtx = bgCanvas.getContext('2d');

    const state = {
      dpr: Math.max(1, window.devicePixelRatio || 1),
      w: 0,
      h: 0,
      driftX: 0, // pixels, increases with wind
      wind: 35,  // UI value 0..100 mapped to px/s
      brush: 'round',
      size: 80,
      soft: 0.7, // 0..1
      isPainting: false,
      pointerId: null,
      lastX: 0,
      lastY: 0,
      planesEnabled: true,
      planes: [],
      time: 0,
    };

    // Map UI wind 0..100 to pixels per second
    const windToSpeed = v => v * 0.7; // 0..70 px/s

    function resize() {
      const { innerWidth: cssW, innerHeight: cssH } = window;
      const dpr = state.dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.floor(cssW * dpr);
      const h = Math.floor(cssH * dpr);
      if (w === state.w && h === state.h) return;
      // Preserve clouds: scale old buffer into new size
      const oldCC = cloudCanvas;
      const oldCtx = cloudCtx;
      const oldW = oldCC.width || 1;
      const oldH = oldCC.height || 1;

      // Resize visible canvas
      canvas.width = w; canvas.height = h; canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
      state.w = w; state.h = h;

      // Resize background canvas
      bgCanvas.width = w; bgCanvas.height = h;
      // Resize cloud buffer
      cloudCanvas = document.createElement('canvas');
      cloudCtx = cloudCanvas.getContext('2d');
      cloudCanvas.width = w; cloudCanvas.height = h;
      // Scale old content into new buffer to avoid losing kids' art
      if (oldW && oldH) {
        cloudCtx.save();
        cloudCtx.drawImage(oldCC, 0, 0, oldW, oldH, 0, 0, w, h);
        cloudCtx.restore();
      }

      // Resize save canvas
      saveCanvas.width = w; saveCanvas.height = h;
    }

    // ---------- Drawing helpers ----------
    function modulo(n, m){ return ((n % m) + m) % m; }

    function drawBackground(t) {
      const w = state.w, h = state.h;
      const g = bgCtx.createLinearGradient(0, 0, 0, h);
      // Subtle shifting hues
      const dayPhase = 0.03 * Math.sin(t*0.00015);
      const top = shade('#a7d9ff', dayPhase);
      const mid = shade('#cbeeff', dayPhase*0.7);
      const bot = shade('#eef9ff', dayPhase*0.5);
      g.addColorStop(0, top);
      g.addColorStop(0.6, mid);
      g.addColorStop(1, bot);
      bgCtx.fillStyle = g;
      bgCtx.fillRect(0, 0, w, h);

      // Sun
      const sunX = w*0.82, sunY = h*0.16, sunR = Math.max(40, Math.min(w,h)*0.06);
      const s = bgCtx.createRadialGradient(sunX, sunY, sunR*0.2, sunX, sunY, sunR*1.4);
      s.addColorStop(0, 'rgba(255,237,170,0.95)');
      s.addColorStop(0.55, 'rgba(255,237,170,0.35)');
      s.addColorStop(1, 'rgba(255,237,170,0.0)');
      bgCtx.fillStyle = s;
      bgCtx.beginPath(); bgCtx.arc(sunX, sunY, sunR*1.4, 0, Math.PI*2); bgCtx.fill();

      // Very subtle horizon haze
      const haze = bgCtx.createLinearGradient(0, h*0.7, 0, h);
      haze.addColorStop(0, 'rgba(255,255,255,0)');
      haze.addColorStop(1, 'rgba(255,255,255,0.25)');
      bgCtx.fillStyle = haze;
      bgCtx.fillRect(0, h*0.7, w, h*0.3);
    }

    function shade(hex, amt){
      // Simple hex shade function (#rrggbb)
      const c = hex.replace('#','');
      const r = parseInt(c.substring(0,2),16);
      const g = parseInt(c.substring(2,4),16);
      const b = parseInt(c.substring(4,6),16);
      const n = (x)=> Math.max(0, Math.min(255, Math.round(x + amt*255)));
      return `rgb(${n(r)}, ${n(g)}, ${n(b)})`;
    }

    // Stamp-based brushes (draw onto cloudCtx)
    function drawStamp(x, y) {
      const size = state.size * state.dpr;
      const soft = state.soft; // 0..1
      const op = 0.22 + 0.28 * (1-soft); // higher softness => lower alpha
      cloudCtx.save();
      cloudCtx.globalCompositeOperation = 'lighter';
      switch(state.brush){
        case 'round':
          puffCircle(cloudCtx, x, y, size, soft, op);
          break;
        case 'cloud':
          cloudStamp(cloudCtx, x, y, size, soft, op);
          break;
        case 'star':
          starPuff(cloudCtx, x, y, size*0.95, soft, op);
          break;
        case 'heart':
          heartPuff(cloudCtx, x, y, size*0.95, soft, op);
          break;
      }
      cloudCtx.restore();
    }

    function puffCircle(c, x, y, size, soft, alpha){
      const r = size*0.5;
      const inner = r * (0.35 + 0.35*(1-soft));
      const g = c.createRadialGradient(x, y, inner, x, y, r);
      g.addColorStop(0, `rgba(255,255,255,${alpha})`);
      g.addColorStop(1, `rgba(255,255,255,0)`);
      c.fillStyle = g;
      c.beginPath(); c.arc(x, y, r, 0, Math.PI*2); c.fill();
      // Soft shadow bloom for extra fluff
      c.globalAlpha = 0.25 * (1-soft);
      c.fillStyle = 'rgba(255,255,255,0.5)';
      c.beginPath(); c.arc(x, y, r*0.65, 0, Math.PI*2); c.fill();
    }

    function cloudStamp(c, x, y, size, soft, alpha){
      const r = size*0.5;
      // Three main puffs + two small caps
      const jitter = r*0.15*(0.3+soft);
      const offsets = [
        {dx:0, dy:-r*0.08, s:1.0},
        {dx:-r*0.42 + rand(-jitter,jitter), dy:r*0.06 + rand(-jitter*0.3,jitter*0.3), s:0.72},
        {dx:r*0.42 + rand(-jitter,jitter), dy:r*0.06 + rand(-jitter*0.3,jitter*0.3), s:0.72},
        {dx:-r*0.15 + rand(-jitter,jitter), dy:r*0.2 + rand(-jitter,jitter), s:0.55},
        {dx:r*0.15 + rand(-jitter,jitter), dy:r*0.2 + rand(-jitter,jitter), s:0.55},
      ];
      for(const o of offsets){ puffCircle(c, x+o.dx, y+o.dy, size*o.s, soft, alpha); }
    }

    function starPuff(c, x, y, size, soft, alpha){
      const r = size*0.5;
      c.save();
      c.translate(x,y);
      c.rotate(rand(-0.3,0.3));
      const spikes = 5; const outer=r*0.9, inner=r*0.42;
      c.beginPath();
      for(let i=0;i<spikes;i++){
        const a1 = (i*2*Math.PI/spikes) - Math.PI/2;
        const a2 = a1 + Math.PI/spikes;
        c.lineTo(Math.cos(a1)*outer, Math.sin(a1)*outer);
        c.lineTo(Math.cos(a2)*inner, Math.sin(a2)*inner);
      }
      c.closePath();
      // Fill with radial gradient puff
      const g = c.createRadialGradient(0,0, inner*0.6*(0.5+0.5*(1-soft)), 0,0, outer);
      g.addColorStop(0, `rgba(255,255,255,${alpha})`);
      g.addColorStop(1, `rgba(255,255,255,0)`);
      c.fillStyle = g; c.fill();
      c.restore();
    }

    function heartPuff(c, x, y, size, soft, alpha){
      const r = size*0.5; c.save(); c.translate(x,y); c.rotate(rand(-0.25,0.25));
      const w = r*1.6, h = r*1.4;
      c.beginPath();
      c.moveTo(0, h*0.25);
      c.bezierCurveTo(w*0.5, -h*0.2,  w*0.6, h*0.6,  0, h);
      c.bezierCurveTo(-w*0.6, h*0.6, -w*0.5, -h*0.2,  0, h*0.25);
      c.closePath();
      const g = c.createRadialGradient(0, h*0.35, r*0.2 + r*0.4*(1-soft), 0, h*0.35, Math.max(w,h));
      g.addColorStop(0, `rgba(255,255,255,${alpha})`);
      g.addColorStop(1, `rgba(255,255,255,0)`);
      c.fillStyle = g; c.fill(); c.restore();
    }

    function rand(a,b){ return a + Math.random()*(b-a); }

    // Paint engine: stamp along path segments
    function paintTo(x, y) {
      // Map screen coordinate to world (cloudCanvas) coordinate: remove drift wrap
      const drawX = modulo(x - state.driftX, state.w);
      drawStamp(drawX, y);
    }

    function paintSegment(x0, y0, x1, y1){
      const spacing = Math.max(4, state.size * state.dpr * 0.28);
      const dx = x1 - x0, dy = y1 - y0;
      const dist = Math.hypot(dx, dy) || 0.0001;
      const steps = Math.ceil(dist / spacing);
      for(let i=1;i<=steps;i++){
        const t = i/steps;
        const x = x0 + dx*t;
        const y = y0 + dy*t;
        paintTo(x,y);
      }
    }

    // ---------- Planes ----------
    function spawnPlane(opts={}){
      const scale = opts.scale ?? rand(0.6, 1.15);
      const speed = opts.speed ?? rand(35, 85) * scale; // px/s
      const y = opts.y ?? rand(state.h*0.1, state.h*0.75);
      const dir = opts.dir ?? 1; // 1 to the right
      const x = dir>0 ? -80*state.dpr : state.w + 80*state.dpr;
      const color = Math.random()<0.5 ? '#ff7aa2' : '#6cc7ff';
      const trail = [];
      state.planes.push({x,y,dir,scale,speed,color,trail,phase:Math.random()*Math.PI*2});
    }

    function updatePlanes(dt){
      if (!state.planesEnabled) return;
      for(const p of state.planes){
        p.phase += dt * (0.8 + 0.6*Math.random());
        const bob = Math.sin(p.phase)*0.15*20*state.dpr;
        p.x += p.speed * p.dir * dt;
        p.y += bob*dt;
        // trail point
        p.trail.push({x:p.x, y:p.y, t:state.time});
        // keep last n seconds of trail
        const maxAge = 2.8; // seconds
        while(p.trail.length && state.time - p.trail[0].t > maxAge){ p.trail.shift(); }
      }
      // recycle offscreen planes
      state.planes = state.planes.filter(p => !(p.dir>0 ? (p.x - 120*state.dpr > state.w) : (p.x + 120*state.dpr < 0)));
      // keep a cozy sky: spawn occasionally
      if (state.planesEnabled && state.planes.length < 3 && Math.random()<0.01){ spawnPlane(); }
    }

    function drawPlane(ctx, p){
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.scale(p.scale * p.dir, p.scale);
      const base = 22*state.dpr;
      // Trail (puffy dots fading)
      if (p.trail && p.trail.length>1){
        for(let i=0;i<p.trail.length;i++){
          const node = p.trail[i];
          const age = Math.max(0, Math.min(1, (state.time - node.t)/2.8));
          const r = base*(0.4 + 0.8*(1-age));
          const a = 0.22*(1-age);
          const g = ctx.createRadialGradient((node.x - p.x)/p.dir, node.y - p.y + base*0.1, r*0.2, (node.x - p.x)/p.dir, node.y - p.y + base*0.1, r);
          g.addColorStop(0, `rgba(255,255,255,${a})`);
          g.addColorStop(1, `rgba(255,255,255,0)`);
          ctx.fillStyle = g; ctx.beginPath(); ctx.arc((node.x - p.x)/p.dir, node.y - p.y + base*0.1, r, 0, Math.PI*2); ctx.fill();
        }
      }

      // Plane body (cartoony)
      ctx.fillStyle = p.color; ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.lineWidth = 2*state.dpr;
      // fuselage
      ctx.beginPath();
      ctx.moveTo(-base*1.2, 0);
      ctx.quadraticCurveTo(-base*0.2, -base*0.6, base*1.2, -base*0.05);
      ctx.quadraticCurveTo(-base*0.2, base*0.55, -base*1.2, 0);
      ctx.closePath(); ctx.fill(); ctx.stroke();
      // wing
      ctx.beginPath();
      ctx.moveTo(-base*0.2, 0);
      ctx.lineTo(base*0.4, base*0.28);
      ctx.lineTo(-base*0.4, base*0.28);
      ctx.closePath(); ctx.fill();
      // tail
      ctx.beginPath();
      ctx.moveTo(-base*1.0, -base*0.02);
      ctx.lineTo(-base*1.25, -base*0.4);
      ctx.lineTo(-base*0.8, -base*0.08);
      ctx.closePath(); ctx.fill();
      // window dots
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      for(let i=0;i<3;i++){
        ctx.beginPath(); ctx.arc(-base*0.2 + i*base*0.35, -base*0.05, base*0.08, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    // ---------- Rendering ----------
    function drawClouds() {
      // Draw cloud buffer with wrap based on driftX
      const w = state.w, h = state.h;
      const ox = modulo(state.driftX, w);
      // First copy: at x = ox - w to ensure coverage
      ctx.drawImage(cloudCanvas, ox - w, 0);
      ctx.drawImage(cloudCanvas, ox, 0);
    }

    function composeScene(targetCtx){
      // Draw background
      targetCtx.drawImage(bgCanvas, 0, 0);
      // Clouds with wrap
      const w = state.w, h = state.h;
      const ox = modulo(state.driftX, w);
      targetCtx.drawImage(cloudCanvas, ox - w, 0);
      targetCtx.drawImage(cloudCanvas, ox, 0);
      // Planes
      if (state.planesEnabled){
        for(const p of state.planes){ drawPlane(targetCtx, p); }
      }
    }

    function loop(ts){
      if (!state._last) state._last = ts;
      const dt = Math.min(0.05, (ts - state._last)/1000);
      state._last = ts;
      state.time += dt;

      // Update
      state.driftX += windToSpeed(state.wind) * dt;
      updatePlanes(dt);

      // Background sky
      drawBackground(state.time*1000);

      // Composite to visible
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.drawImage(bgCanvas, 0, 0);
      drawClouds();
      if (state.planesEnabled){
        for(const p of state.planes){ drawPlane(ctx, p); }
      }
      ctx.restore();

      requestAnimationFrame(loop);
    }

    // ---------- Interaction ----------
    function toCanvasXY(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * state.dpr;
      const y = (e.clientY - rect.top) * state.dpr;
      return {x,y};
    }

    function pointerDown(e){
      e.preventDefault();
      tip.style.display = 'none';
      const {x,y} = toCanvasXY(e);
      state.isPainting = true; state.pointerId = e.pointerId; state.lastX = x; state.lastY = y;
      paintTo(x,y);
    }
    function pointerMove(e){
      if (!state.isPainting || e.pointerId !== state.pointerId) return;
      const {x,y} = toCanvasXY(e);
      paintSegment(state.lastX, state.lastY, x, y);
      state.lastX = x; state.lastY = y;
    }
    function pointerUp(e){
      if (e.pointerId !== state.pointerId) return;
      state.isPainting = false; state.pointerId = null;
    }

    canvas.addEventListener('pointerdown', pointerDown);
    canvas.addEventListener('pointermove', pointerMove);
    window.addEventListener('pointerup', pointerUp);
    canvas.addEventListener('pointerleave', pointerUp);

    // ---------- UI wiring ----------
    const sizeEl = document.getElementById('size');
    const softEl = document.getElementById('soft');
    const windEl = document.getElementById('wind');
    const brushGroup = document.getElementById('brushGroup');
    const clearBtn = document.getElementById('clearBtn');
    const saveBtn = document.getElementById('saveBtn');
    const addPlaneBtn = document.getElementById('addPlane');
    const togglePlanesBtn = document.getElementById('togglePlanes');

    sizeEl.addEventListener('input', ()=> state.size = +sizeEl.value);
    softEl.addEventListener('input', ()=> state.soft = (+softEl.value)/100);
    windEl.addEventListener('input', ()=> state.wind = +windEl.value);

    brushGroup.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-brush]');
      if (!btn) return;
      [...brushGroup.querySelectorAll('button[data-brush]')].forEach(b=>b.setAttribute('aria-pressed','false'));
      btn.setAttribute('aria-pressed','true');
      state.brush = btn.getAttribute('data-brush');
    });

    clearBtn.addEventListener('click', ()=>{
      const ok = confirm('Clear the sky?');
      if (!ok) return;
      cloudCtx.clearRect(0,0, state.w, state.h);
    });

    saveBtn.addEventListener('click', ()=>{
      composeScene(saveCtx);
      const url = saveCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      const now = new Date();
      const pad = (n)=> String(n).padStart(2,'0');
      const stamp = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
      a.download = `cloud-painting_${stamp}.png`;
      a.href = url; a.click();
      // playful feedback
      flashToast('Saved to image file. Nice clouds!');
    });

    addPlaneBtn.addEventListener('click', ()=>{ spawnPlane(); flashToast('A new plane takes off! ‚úàÔ∏è'); });

    togglePlanesBtn.addEventListener('click', ()=>{
      state.planesEnabled = !state.planesEnabled;
      togglePlanesBtn.innerHTML = state.planesEnabled ? '‚úàÔ∏è Planes' : '‚õîÔ∏è Planes';
      flashToast(state.planesEnabled ? 'Planes are flying.' : 'Planes are resting.');
    });

    function flashToast(text){
      const el = document.createElement('div');
      el.textContent = text;
      el.style.position='absolute'; el.style.left='50%'; el.style.bottom='90px'; el.style.transform='translateX(-50%)';
      el.style.background='var(--ui-bg)'; el.style.border='1px solid var(--ui-border)'; el.style.borderRadius='999px'; el.style.padding='8px 12px';
      el.style.fontWeight='700'; el.style.backdropFilter='blur(8px)'; el.style.boxShadow='0 8px 24px rgba(0,0,0,.1)'; el.style.zIndex=30;
      document.querySelector('.canvas-wrap').appendChild(el);
      setTimeout(()=>{ el.style.transition='opacity .4s, transform .4s'; el.style.opacity='0'; el.style.transform='translateX(-50%) translateY(6px)'; }, 850);
      setTimeout(()=> el.remove(), 1300);
    }

    // ---------- Boot ----------
    function boot(){
      resize();
      // Seed planes
      for(let i=0;i<2;i++){ spawnPlane({ x: rand(0,state.w), y: rand(state.h*0.2, state.h*0.7), dir:1 }); }
      sizeEl.value = state.size; softEl.value = Math.round(state.soft*100); windEl.value = state.wind;
      requestAnimationFrame(loop);
    }

    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', ()=> setTimeout(resize, 250));
    document.addEventListener('gesturestart', (e)=> e.preventDefault());

    // Prevent two-finger scroll on iOS while painting
    document.addEventListener('touchmove', function(e){ if (state.isPainting) e.preventDefault(); }, {passive:false});

    boot();
  })();
  </script>
</body>
</html>
