<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#6f7cff" />
  <title>Fun Game</title>
  <style>
    :root {
      --bg1: #6f7cff;
      --bg2: #a0e6ff;
      --ui: #0d0c22;
      --ui-2: #ffffff;
      --accent: #ff4fd8;
      --accent-2: #00e5a8;
      --gold: #ffd867;
      --danger: #ff6b6b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", "Comic Sans MS", Arial, sans-serif;
      color: var(--ui);
      background: linear-gradient(180deg, var(--bg1), var(--bg2));
      background-attachment: fixed;
      overflow-x: hidden;
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100dvh;
      gap: 16px;
      padding: 16px;
    }
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      background: rgba(255,255,255,0.55);
      backdrop-filter: blur(6px) saturate(1.2);
      border-radius: 14px;
      padding: 10px 14px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    }
    .brand {
      display: flex; align-items: center; gap: 10px; font-weight: 800; letter-spacing: 0.3px;
    }
    .brand .blob {
      width: 26px; height: 26px; border-radius: 50%;
      background: radial-gradient(circle at 35% 30%, #fff, #ffd2f6 40%, #ff7fe6 65%, #f03aca 100%);
      box-shadow: 0 4px 10px rgba(240,58,202,0.4), inset 0 1px 3px rgba(255,255,255,0.9);
      animation: bob 1.6s ease-in-out infinite;
    }
    @keyframes bob { 0%,100%{ transform: translateY(0);} 50%{ transform: translateY(-3px);} }
    .scorebox {
      display: flex; gap: 14px; align-items: center; flex-wrap: wrap;
      font-variant-numeric: tabular-nums;
    }
    .pill {
      background: #fff; border-radius: 999px; padding: 6px 12px; font-weight: 700; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.05), 0 4px 10px rgba(0,0,0,0.08);
    }
    .btn {
      -webkit-tap-highlight-color: transparent;
      appearance: none; border: 0; cursor: pointer; border-radius: 12px; font-weight: 800;
      padding: 10px 14px; color: #fff; background: linear-gradient(135deg, var(--accent), #8c4bff);
      box-shadow: 0 8px 18px rgba(140,75,255,0.35);
      transition: transform .12s ease, filter .12s ease;
    }
    .btn:active { transform: translateY(1px) scale(0.99); filter: brightness(0.95); }
    .btn.alt { background: linear-gradient(135deg, var(--accent-2), #2ad0ff); box-shadow: 0 8px 18px rgba(42,208,255,0.35); }
    .btn.ghost { background: rgba(0,0,0,0.08); color: var(--ui); box-shadow: none; }

    .game-card { display: grid; place-items: center; }
    .canvas-wrap {
      width: min(96vw, 1200px);
      aspect-ratio: 16/9;
      border-radius: 16px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(13,12,34,0.35), inset 0 0 0 2px rgba(255,255,255,0.35);
      background: linear-gradient(180deg, #7ec8ff, #f2fbff 85%);
    }
    canvas#game { width: 100%; height: 100%; display: block; }

    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center; padding: 20px;
      background: radial-gradient(1200px 800px at 50% 70%, rgba(255,255,255,0.7), rgba(255,255,255,0.55), rgba(255,255,255,0.2) 70%, rgba(255,255,255,0.0) 100%);
      pointer-events: none; opacity: 0; transform: scale(1.02);
      transition: opacity .25s ease, transform .25s ease;
    }
    .overlay.active { opacity: 1; transform: none; pointer-events: auto; }
    .panel {
      width: min(92%, 680px);
      background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.8));
      border-radius: 18px; padding: 22px; text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15), inset 0 0 0 1px rgba(255,255,255,0.6);
    }
    h1.title { margin: 6px 0 4px; font-size: clamp(26px, 4.4vw, 46px); letter-spacing: 0.4px; }
    .subtitle { opacity: 0.8; margin-bottom: 12px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center; margin-top: 12px; }
    .kbd { background: #fff; border-radius: 8px; padding: 6px 10px; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.05); font-weight: 700; }

    .footer { text-align: center; opacity: 0.9; color: #1b2250; font-weight: 600; }
    .link { color: #1b2250; text-decoration: none; border-bottom: 2px solid rgba(0,0,0,0.15); }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="topbar">
      <div class="brand">
        <div class="blob" aria-hidden="true"></div>
        <div>Fun Game</div>
      </div>
      <div class="scorebox">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill" title="Your best run">Best: <span id="best">0</span></div>
        <button id="soundBtn" class="btn alt" aria-pressed="false" aria-label="Toggle sound">ðŸ”Š Sound</button>
      </div>
    </header>

    <main class="game-card">
      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="game" aria-label="Fun Game canvas" role="img"></canvas>

        <div id="startOverlay" class="overlay active" aria-hidden="false">
          <div class="panel">
            <h1 class="title">Fun Game</h1>
            <div class="subtitle">Jump over obstacles and survive as long as possible.</div>
            <div class="controls">
              <span class="kbd">Space</span>
              <span class="kbd">â†‘</span>
              <span class="kbd">Tap / Click</span>
            </div>
            <div style="height:12px"></div>
            <button id="startBtn" class="btn">Start</button>
          </div>
        </div>

        <div id="gameOverOverlay" class="overlay" aria-hidden="true">
          <div class="panel">
            <h1 class="title" id="overTitle">Ouch! ðŸ˜µ</h1>
            <div class="subtitle">You bumped into something silly.</div>
            <div class="controls" style="margin-top:8px">
              <div class="pill">Final: <span id="finalScore">0</span></div>
              <div class="pill">Best: <span id="finalBest">0</span></div>
            </div>
            <div style="height:12px"></div>
            <button id="retryBtn" class="btn alt">Retry</button>
            <button id="menuBtn" class="btn ghost">Menu</button>
          </div>
        </div>
      </div>
    </main>

    <footer class="footer">Have fun and be awesome âœ¨</footer>
  </div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const wrap = document.getElementById('canvasWrap');
    const startOverlay = document.getElementById('startOverlay');
    const overOverlay = document.getElementById('gameOverOverlay');
    const startBtn = document.getElementById('startBtn');
    const retryBtn = document.getElementById('retryBtn');
    const menuBtn = document.getElementById('menuBtn');
    const soundBtn = document.getElementById('soundBtn');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const finalScoreEl = document.getElementById('finalScore');
    const finalBestEl = document.getElementById('finalBest');
    const overTitle = document.getElementById('overTitle');

    let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    let W = 0, H = 0;
    function resize(){
      const r = wrap.getBoundingClientRect();
      DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
      canvas.width = Math.floor(r.width * DPR);
      canvas.height = Math.floor(r.height * DPR);
      W = r.width; H = r.height;
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    let rngSeed = Date.now() & 0xffffffff;
    function rand(){ rngSeed ^= rngSeed << 13; rngSeed ^= rngSeed >>> 17; rngSeed ^= rngSeed << 5; return ((rngSeed>>>0) / 0xffffffff); }
    function randRange(a,b){ return a + (b-a)*rand(); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    const storage = {
      get(key, def){ try{ const v = localStorage.getItem(key); return v==null? def : JSON.parse(v);}catch{ return def;} },
      set(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch{} }
    };

    let best = storage.get('fun_game_best', 0);
    bestEl.textContent = best;

    let soundEnabled = storage.get('fun_game_sound', true) === true;
    function setSoundButton(){ soundBtn.textContent = soundEnabled? 'ðŸ”Š Sound' : 'ðŸ”‡ Sound'; soundBtn.setAttribute('aria-pressed', String(!soundEnabled)); }
    setSoundButton();

    let audioCtx = null; let masterGain = null;
    function ensureAudio(){
      if(!soundEnabled) return;
      if(!audioCtx){
        audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.3; masterGain.connect(audioCtx.destination);
      } else if(audioCtx.state === 'suspended'){ audioCtx.resume(); }
    }
    function tone({type='sine', freq=440, duration=0.2, attack=0.01, decay=0.05, sustain=0.5, release=0.1, volume=0.7, bend=null, startTime=null}){
      if(!soundEnabled) return;
      ensureAudio(); if(!audioCtx) return;
      const t0 = startTime ?? audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      if(bend){
        o.frequency.cancelScheduledValues(t0);
        o.frequency.setValueAtTime(bend.from ?? freq, t0);
        o.frequency.linearRampToValueAtTime(bend.to ?? freq, t0 + (bend.time ?? duration*0.5));
      }
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(volume, t0 + attack);
      g.gain.exponentialRampToValueAtTime(volume*sustain, t0 + attack + decay);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + attack + decay + duration + release);
      o.connect(g); g.connect(masterGain);
      o.start(t0); o.stop(t0 + attack + decay + duration + release + 0.05);
    }
    function noise(duration=0.15, lp=1200, volume=0.4){
      if(!soundEnabled) return;
      ensureAudio(); if(!audioCtx) return;
      const t0 = audioCtx.currentTime;
      const buff = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*duration), audioCtx.sampleRate);
      const data = buff.getChannelData(0);
      for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.pow(1-i/data.length, 1.6); }
      const src = audioCtx.createBufferSource(); src.buffer = buff; src.loop = false;
      const filter = audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value = lp;
      const g = audioCtx.createGain(); g.gain.value = volume;
      src.connect(filter); filter.connect(g); g.connect(masterGain); src.start();
    }
    const SFX = {
      jump(){ tone({type:'triangle', freq:260, duration:0.15, bend:{from:300, to:700, time:0.08}, volume:0.7}); tone({type:'sine', freq:800, duration:0.15, bend:{from:800,to:520,time:0.18}, volume:0.2}); },
      land(){ noise(0.08, 1200, 0.3); tone({type:'sine', freq:180, duration:0.08, volume:0.25}); },
      hit(){ tone({type:'square', freq:200, duration:0.14, bend:{from:420,to:120,time:0.12}, volume:0.7}); noise(0.12, 1400, 0.25); },
      milestone(){ tone({type:'sine', freq:660, duration:0.1, volume:0.35}); tone({type:'sine', freq:880, duration:0.12, volume:0.35, bend:{from:880,to:990,time:0.1}}); }
    };

    const state = {
      started:false, running:false, gameOver:false,
      time:0, lastT:0, dt:0,
      speed:0, baseSpeed:380, accel:26,
      groundY:0,
      score:0, distance:0,
      milestoneNext:100,
    };

    const player = {
      x: 140, y:0, vy:0, w:64, h:64, onGround:false, rot:0,
      gravity: 2000, jumpVel: 760,
      coyoteTime: 0, coyoteMax: 0.1, jumpBuffer: 0, jumpBufferMax: 0.12,
      runPhase:0, squash:0,
      colorA:'#ff7fe6', colorB:'#ff3fb2'
    };

    const groundPattern = { off:0 };
    const clouds = [];
    const farMounts = [];
    const hills = [];
    const nearTrees = [];
    const confetti = [];

    const obstacles = [];
    let spawnTimer = 0;

    function resetWorld(){
      state.time = 0; state.distance = 0; state.score = 0; state.milestoneNext = 100;
      state.speed = state.baseSpeed; state.gameOver=false; player.vy = 0; player.y = 0; player.onGround=false; player.coyoteTime = 0; player.jumpBuffer = 0; player.runPhase = 0; player.squash=0; groundPattern.off=0; player.rot=0;
      obstacles.length = 0; spawnTimer = 0.2 + rand()*0.5;
      clouds.length = 0; farMounts.length=0; hills.length=0; nearTrees.length=0; confetti.length=0;
      for(let i=0;i<6;i++){ clouds.push(makeCloud(rand()*W*1.5 + i*120)); }
      for(let i=0;i<5;i++){ farMounts.push({ x: rand()*W*1.8 + i*220, y: randRange(H*0.18, H*0.32), s: randRange(120, 220), c: `hsl(${Math.floor(randRange(210,240))} 40% 65%)` }); }
      for(let i=0;i<5;i++){ hills.push({ x: rand()*W*1.8 + i*260, y: randRange(H*0.42, H*0.5), s: randRange(200, 340), c: `hsl(${Math.floor(randRange(150,170))} 45% 56%)` }); }
      for(let i=0;i<7;i++){ nearTrees.push({ x: rand()*W*2 + i*160, y: randRange(H*0.60, H*0.66), s: randRange(36, 64), c: `hsl(${Math.floor(randRange(120,140))} 56% 38%)` }); }
    }

    function makeCloud(x){ return { x, y: randRange(H*0.06, H*0.3), s: randRange(40, 120), c: 'rgba(255,255,255,0.9)' }; }

    function drawBackground(dt){
      const skyTop = ctx.createLinearGradient(0,0,0,H);
      skyTop.addColorStop(0, '#89d6ff');
      skyTop.addColorStop(1, '#e9fbff');
      ctx.fillStyle = skyTop; ctx.fillRect(0,0,W,H);

      for(const m of farMounts){ m.x -= state.speed*0.08*dt; if(m.x < -m.s) m.x += W + m.s + rand()*200; ctx.fillStyle = m.c; ctx.beginPath(); ctx.moveTo(m.x, m.y); ctx.lineTo(m.x+m.s*0.5, m.y-m.s*0.9); ctx.lineTo(m.x+m.s, m.y); ctx.closePath(); ctx.fill(); }
      for(const h of hills){ h.x -= state.speed*0.15*dt; if(h.x < -h.s) h.x += W + h.s + rand()*240; ctx.fillStyle = h.c; ctx.beginPath(); ctx.ellipse(h.x, h.y, h.s, h.s*0.45, 0, 0, Math.PI*2); ctx.fill(); }
      for(const cl of clouds){ cl.x -= (60 + state.speed*0.06)*dt; if(cl.x < -150) { cl.x = W + rand()*300; cl.y = randRange(H*0.06, H*0.3); cl.s = randRange(40,120);} drawCloud(cl.x, cl.y, cl.s, cl.c); }

      for(const t of nearTrees){ t.x -= state.speed*0.3*dt; if(t.x < -30) t.x = W + 100 + rand()*260; drawTree(t.x, t.y, t.s, t.c); }

      groundPattern.off = (groundPattern.off + state.speed*dt) % 80;
      const groundY = state.groundY;
      ctx.fillStyle = '#8bdd72'; ctx.fillRect(0, groundY, W, H-groundY);
      for(let i=-1;i<W/80+2;i++){
        const x = i*80 - (groundPattern.off%80);
        ctx.fillStyle = '#74cf5a'; ctx.fillRect(x, groundY-8, 60, 8);
      }
    }

    function drawCloud(x,y,s,c){
      ctx.fillStyle = c;
      ctx.beginPath();
      ctx.ellipse(x, y, s*0.5, s*0.35, 0, 0, Math.PI*2);
      ctx.ellipse(x+s*0.3, y+2, s*0.45, s*0.3, 0, 0, Math.PI*2);
      ctx.ellipse(x-s*0.3, y+6, s*0.4, s*0.28, 0, 0, Math.PI*2);
      ctx.fill();
    }

    function drawTree(x,y,s,c){
      ctx.fillStyle = '#6f4d1f';
      ctx.fillRect(x-4, y- s*0.2, 8, s*0.2+H-y);
      ctx.fillStyle = c;
      ctx.beginPath(); ctx.ellipse(x, y- s*0.35, s*0.6, s*0.35, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(x-14, y- s*0.15, s*0.4, s*0.24, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(x+16, y- s*0.18, s*0.42, s*0.26, 0, 0, Math.PI*2); ctx.fill();
    }

    function spawnObstacle(){
      const t = rand();
      if(t < 0.5){ obstacles.push(makeBox()); }
      else { obstacles.push(makeDonut()); }
    }
    function makeBox(){
      const w = randRange(34, 58), h = randRange(48, 86);
      return { type:'box', x: W + 30, y: 0, w, h, spd: state.speed, face: rand()<0.7, hue: Math.floor(randRange(10, 40))* (rand()<0.5? 1:1), 
               swing: randRange(0.6, 1.2)};
    }
    function makeDonut(){
      const s = randRange(46, 76);
      return { type:'donut', x: W + 30, y: 0, w:s, h:s, spd: state.speed*1.02, rot: 0, rotSpd: randRange(-3,3), hue: Math.floor(randRange(300, 340)), face: rand()<0.5 };
    }

    function updatePlayer(dt){
      const gY = state.groundY;
      player.coyoteTime -= dt; player.jumpBuffer -= dt;
      player.vy += player.gravity * dt; player.y += player.vy * dt;
      if(player.y + player.h >= gY){
        if(!player.onGround && player.vy>500) SFX.land();
        player.onGround = true; player.y = gY - player.h; player.vy = 0; player.coyoteTime = player.coyoteMax;
      } else player.onGround = false;

      if(player.onGround && player.jumpBuffer>0){ doJump(); }

      player.runPhase += dt * clamp(state.speed/300, 1, 3);
      const targetRot = player.onGround? Math.sin(player.runPhase*10)*0.05 : (player.vy<0?-0.15:0.12);
      player.rot += (targetRot - player.rot)*Math.min(1, dt*12);
      if(player.onGround){ player.squash = Math.abs(Math.sin(player.runPhase*12))*0.08; }
      else player.squash = 0;
    }
    function doJump(){
      player.vy = -player.jumpVel; player.onGround = false; player.coyoteTime = 0; player.jumpBuffer = 0; SFX.jump();
    }

    function updateObstacles(dt){
      for(const o of obstacles){
        o.x -= state.speed * dt * (o.type==='donut'?1.05:1);
        if(o.type==='donut') o.rot += o.rotSpd * dt;
      }
      while(obstacles.length && obstacles[0].x + obstacles[0].w < -20) obstacles.shift();
    }

    function maybeSpawn(dt){
      spawnTimer -= dt;
      const minT = clamp(1.1 - state.speed/800, 0.45, 1.1);
      if(spawnTimer <= 0){ spawnObstacle(); spawnTimer = randRange(minT, minT+0.6); }
    }

    function playerRect(){ return { x: player.x-22, y: player.y+10, w: player.w-20, h: player.h-14 }; }
    function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    function checkCollisions(){
      const pr = playerRect();
      for(const o of obstacles){
        const or = { x:o.x, y: state.groundY - o.h, w:o.w, h:o.h };
        if(rectsOverlap(pr, or)){ endGame(); break; }
      }
    }

    function drawPlayer(){
      const cx = player.x + player.w*0.5, cy = player.y + player.h*0.5;
      ctx.save(); ctx.translate(cx, cy); ctx.rotate(player.rot); ctx.scale(1+player.squash*0.8, 1-player.squash);
      const grd = ctx.createRadialGradient(-10,-12,10, 6,6, 46); grd.addColorStop(0, '#ffeef8'); grd.addColorStop(1, player.colorB);
      ctx.fillStyle = grd; ctx.beginPath(); ctx.ellipse(-2,2, player.w*0.52, player.h*0.52, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#1b2250';
      const blink = (Math.sin(state.time*3 + player.runPhase*2)+1)/2 < 0.05;
      const eyeH = blink? 2 : 8; const eyeW = 8;
      ctx.beginPath(); ctx.ellipse(-12, -8, eyeW, eyeH, 0, 0, Math.PI*2); ctx.ellipse(12, -7, eyeW, eyeH, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#f039a4'; ctx.beginPath(); ctx.ellipse(0, 10, 10, 6, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function drawObstacles(){
      for(const o of obstacles){
        if(o.type==='box'){
          const x = o.x, y = state.groundY - o.h;
          const c = `hsl(${o.hue} 90% 60%)`;
          ctx.fillStyle = c; ctx.fillRect(x, y, o.w, o.h);
          ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(x+4, y+4, o.w-8, o.h-8);
          if(o.face){ ctx.fillStyle = '#1b2250'; ctx.fillRect(x+o.w*0.25, y+o.h*0.2, 8, 12); ctx.fillRect(x+o.w*0.65-8, y+o.h*0.2, 8, 12); ctx.fillRect(x+o.w*0.4, y+o.h*0.55, o.w*0.2, 10); }
        } else {
          const x = o.x + o.w*0.5, y = state.groundY - o.h*0.5;
          ctx.save(); ctx.translate(x,y); ctx.rotate(o.rot);
          const grad = ctx.createRadialGradient(0,0, 6, 0,0, o.w*0.5);
          grad.addColorStop(0, '#fff5fb'); grad.addColorStop(1, `hsl(${o.hue} 90% 63%)`);
          ctx.fillStyle = grad; ctx.beginPath(); ctx.ellipse(0,0, o.w*0.52, o.h*0.46, 0, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = '#fefefe'; ctx.beginPath(); ctx.ellipse(-6,-6, 10, 8, 0, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = '#1b2250';
          if(o.face){ ctx.beginPath(); ctx.ellipse(-10, -4, 6,6, 0,0,Math.PI*2); ctx.ellipse(10,-4, 6,6, 0,0,Math.PI*2); ctx.fill(); }
          ctx.globalCompositeOperation = 'destination-out'; ctx.beginPath(); ctx.ellipse(0,0, o.w*0.22, o.h*0.18, 0, 0, Math.PI*2); ctx.fill(); ctx.globalCompositeOperation = 'source-over';
          ctx.restore();
        }
      }
    }

    function updateScore(dt){
      state.distance += state.speed * dt; state.score = Math.floor(state.distance/6);
      scoreEl.textContent = state.score;
      if(state.score >= state.milestoneNext){ state.milestoneNext += 100; SFX.milestone(); burstConfetti(W*0.5, H*0.3, 30); }
    }

    function burstConfetti(x,y,count){
      for(let i=0;i<count;i++){
        confetti.push({ x, y, vx: randRange(-200,200), vy: randRange(-400,-160), r: randRange(2,4), rot: randRange(0,Math.PI*2), vr: randRange(-6,6), color: `hsl(${Math.floor(randRange(0,360))} 90% 55%)`, life: randRange(0.8,1.6) });
      }
    }
    function updateConfetti(dt){
      for(const p of confetti){ p.vy += 900*dt; p.x += p.vx*dt; p.y += p.vy*dt; p.rot += p.vr*dt; p.life -= dt; }
      for(let i=confetti.length-1;i>=0;i--){ if(confetti[i].life<=0 || confetti[i].y>H+20) confetti.splice(i,1); }
    }
    function drawConfetti(){
      for(const p of confetti){ ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot); ctx.fillStyle = p.color; ctx.fillRect(-p.r, -p.r*0.5, p.r*2, p.r); ctx.restore(); }
    }

    function step(ts){
      if(!state.running){ state.lastT = ts; requestAnimationFrame(step); return; }
      state.dt = Math.min(0.033, (ts - state.lastT)/1000 || 0.016);
      state.lastT = ts; state.time += state.dt;

      state.groundY = H*0.78;
      state.speed += (state.accel + state.time*2) * state.dt;

      drawBackground(state.dt);
      updatePlayer(state.dt);
      updateObstacles(state.dt);
      maybeSpawn(state.dt);
      checkCollisions();
      drawObstacles();
      drawPlayer();
      updateScore(state.dt);
      updateConfetti(state.dt); drawConfetti();

      requestAnimationFrame(step);
    }

    function startGame(){
      ensureAudio();
      startOverlay.classList.remove('active'); startOverlay.setAttribute('aria-hidden','true');
      overOverlay.classList.remove('active'); overOverlay.setAttribute('aria-hidden','true');
      resetWorld();
      state.started = true; state.running = true; state.gameOver = false; state.lastT = performance.now();
      requestAnimationFrame(step);
    }
    function endGame(){
      if(state.gameOver) return; state.gameOver = true; state.running = false; SFX.hit();
      finalScoreEl.textContent = state.score;
      let newBest = false;
      if(state.score > best){ best = state.score; storage.set('fun_game_best', best); bestEl.textContent = best; newBest = true; }
      finalBestEl.textContent = best;
      overTitle.textContent = newBest? 'New High Score! ðŸ†' : 'Ouch! ðŸ˜µ';
      if(newBest) burstConfetti(W*0.5, H*0.25, 80);
      setTimeout(()=>{ overOverlay.classList.add('active'); overOverlay.setAttribute('aria-hidden','false'); }, 250);
    }

    function toMenu(){ state.started=false; state.running=false; overOverlay.classList.remove('active'); overOverlay.setAttribute('aria-hidden','true'); startOverlay.classList.add('active'); startOverlay.setAttribute('aria-hidden','false'); }

    function pressJump(){ player.jumpBuffer = player.jumpBufferMax; if(player.coyoteTime>0 || player.onGround) doJump(); }

    window.addEventListener('keydown', (e)=>{
      if(['Space','ArrowUp','KeyW'].includes(e.code)) { e.preventDefault(); if(!state.started){ startGame(); } else if(!state.gameOver){ pressJump(); } }
      if(e.code==='Enter'){ if(!state.started || state.gameOver){ startGame(); } }
    });
    canvas.addEventListener('pointerdown', ()=>{ if(!state.started || state.gameOver){ startGame(); } else pressJump(); });
    startBtn.addEventListener('click', startGame);
    retryBtn.addEventListener('click', startGame);
    menuBtn.addEventListener('click', toMenu);
    soundBtn.addEventListener('click', ()=>{ soundEnabled = !soundEnabled; storage.set('fun_game_sound', soundEnabled); setSoundButton(); if(soundEnabled) ensureAudio(); });

    document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ state.running=false; } else if(state.started && !state.gameOver){ state.running=true; state.lastT=performance.now(); requestAnimationFrame(step); } });

    requestAnimationFrame(step);
  })();
  </script>
</body>
</html>
