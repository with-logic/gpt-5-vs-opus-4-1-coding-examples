<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light" />
    <title>Falling Fruit Catcher</title>
    <style>
      :root {
        --bg1: #7bd9ff;
        --bg2: #b8ffda;
        --ink: #1b1b1b;
        --ui: rgba(255, 255, 255, 0.82);
        --ui-strong: rgba(255, 255, 255, 0.94);
        --shadow: rgba(12, 24, 46, 0.18);
        --accent: #ff4d9a;
        --accent2: #6b5bff;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        margin: 0;
      }

      body {
        font-family:
          ui-rounded,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          "Comic Sans MS",
          "Comic Sans",
          sans-serif;
        color: var(--ink);
        background: radial-gradient(1200px 800px at 30% 10%, #ffffff 0%, rgba(255, 255, 255, 0) 45%),
          linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 75%, #fff3b0 100%);
        overflow: hidden;
      }

      .app {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: stretch;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        inset: 16px 16px auto 16px;
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
        pointer-events: none;
      }

      .pill {
        pointer-events: none;
        display: inline-flex;
        gap: 10px;
        align-items: center;
        padding: 10px 14px;
        border-radius: 999px;
        background: var(--ui);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 10px 30px var(--shadow);
        border: 1px solid rgba(255, 255, 255, 0.65);
      }

      .pill strong {
        font-size: 18px;
        letter-spacing: 0.2px;
      }

      .score {
        display: inline-flex;
        gap: 10px;
        align-items: center;
        font-weight: 800;
      }

      .score .num {
        font-variant-numeric: tabular-nums;
        font-size: 20px;
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.7);
      }

      .misses {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        font-weight: 800;
      }

      .hearts {
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }

      .heart {
        width: 26px;
        height: 26px;
        filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.1));
      }

      .heart.off {
        opacity: 0.25;
        filter: grayscale(1) drop-shadow(0 6px 10px rgba(0, 0, 0, 0.06));
      }

      .controlsHint {
        position: absolute;
        inset: auto 16px 16px 16px;
        display: flex;
        justify-content: space-between;
        gap: 12px;
        pointer-events: none;
        opacity: 0.9;
      }

      .controlsHint .tip {
        pointer-events: none;
        max-width: 56ch;
        padding: 10px 14px;
        border-radius: 18px;
        background: var(--ui);
        box-shadow: 0 10px 30px var(--shadow);
        border: 1px solid rgba(255, 255, 255, 0.65);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        font-weight: 650;
      }

      .controlsHint kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-weight: 800;
        font-size: 12px;
        padding: 2px 7px;
        border-radius: 9px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow:
          0 6px 12px rgba(0, 0, 0, 0.08),
          inset 0 0 0 1px rgba(0, 0, 0, 0.07);
        margin: 0 2px;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 18px;
        pointer-events: none;
      }

      .card {
        pointer-events: auto;
        width: min(620px, 100%);
        border-radius: 26px;
        padding: 18px;
        background: var(--ui-strong);
        box-shadow: 0 24px 70px rgba(20, 40, 80, 0.22);
        border: 1px solid rgba(255, 255, 255, 0.72);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      .titleRow {
        display: flex;
        align-items: center;
        gap: 14px;
        margin-bottom: 12px;
      }

      .logo {
        width: 54px;
        height: 54px;
        border-radius: 18px;
        background: conic-gradient(from 30deg, #ff4d9a, #ffcc00, #51f1c6, #6b5bff, #ff4d9a);
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.12);
        display: grid;
        place-items: center;
      }

      .logo span {
        font-size: 28px;
        transform: translateY(-1px);
        filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.16));
      }

      h1 {
        margin: 0;
        font-size: 26px;
        line-height: 1.1;
        letter-spacing: -0.3px;
      }

      .subtitle {
        margin: 2px 0 0 0;
        font-weight: 650;
        opacity: 0.78;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .callouts {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .callout {
        padding: 12px 12px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid rgba(0, 0, 0, 0.06);
      }

      .callout b {
        display: block;
        font-size: 13px;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        opacity: 0.72;
        margin-bottom: 6px;
      }

      .callout div {
        font-weight: 800;
        font-size: 16px;
      }

      .buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        margin-top: 6px;
      }

      .btn {
        appearance: none;
        border: 0;
        cursor: pointer;
        border-radius: 999px;
        padding: 12px 16px;
        font-weight: 900;
        font-size: 16px;
        letter-spacing: 0.2px;
        background: linear-gradient(135deg, var(--accent), #ffcc00);
        color: #111;
        box-shadow: 0 18px 35px rgba(255, 77, 154, 0.28);
        transition: transform 120ms ease, filter 120ms ease, box-shadow 120ms ease;
      }

      .btn:hover {
        transform: translateY(-1px);
        filter: saturate(1.1);
        box-shadow: 0 20px 40px rgba(255, 77, 154, 0.34);
      }

      .btn:active {
        transform: translateY(1px);
      }

      .btn.secondary {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.66));
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.12);
      }

      .btnRowRight {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .smallNote {
        font-size: 13px;
        opacity: 0.76;
        font-weight: 650;
      }

      .hidden {
        display: none !important;
      }

      @media (max-width: 520px) {
        .hud {
          inset: 12px 12px auto 12px;
        }
        .controlsHint {
          inset: auto 12px 12px 12px;
        }
        .callouts {
          grid-template-columns: 1fr;
        }
        h1 {
          font-size: 24px;
        }
        .btn {
          width: 100%;
          justify-content: center;
        }
        .buttons {
          justify-content: stretch;
        }
        .btnRowRight {
          width: 100%;
          justify-content: stretch;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .btn {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="app" aria-label="Falling Fruit Catcher">
      <canvas id="game" aria-label="Game canvas" role="img"></canvas>

      <div class="hud" aria-hidden="true">
        <div class="pill score">
          <span style="font-size: 20px">‚≠ê</span>
          <strong>Score</strong>
          <span class="num" id="score">0</span>
        </div>
        <div class="pill misses">
          <span style="font-size: 20px">üß∫</span>
          <strong>Misses</strong>
          <span class="hearts" id="hearts"></span>
        </div>
      </div>

      <div class="controlsHint" aria-hidden="true">
        <div class="tip">
          Move with <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> or your mouse/finger. Catch the fruits! Miss 3 and it‚Äôs game over.
        </div>
        <div class="tip" style="text-align: right">
          Press <kbd>P</kbd> to pause ‚Ä¢ Press <kbd>R</kbd> to restart
        </div>
      </div>

      <div class="overlay" id="overlay">
        <div class="card" id="startCard" role="dialog" aria-modal="true" aria-label="Start screen">
          <div class="titleRow">
            <div class="logo" aria-hidden="true"><span>üçì</span></div>
            <div>
              <h1>Falling Fruit Catcher</h1>
              <p class="subtitle">A bright, bouncy catch-the-fruit game for quick smiles.</p>
            </div>
          </div>
          <div class="grid">
            <div class="callouts">
              <div class="callout">
                <b>Goal</b>
                <div>Catch as many fruits as you can!</div>
              </div>
              <div class="callout">
                <b>Careful</b>
                <div>3 misses ends the game.</div>
              </div>
            </div>
            <div class="buttons">
              <button class="btn" id="playBtn" type="button">Play!</button>
              <div class="btnRowRight">
                <button class="btn secondary" id="muteBtn" type="button" aria-pressed="false">Sound: On</button>
              </div>
            </div>
            <div class="smallNote">
              Tip: On phones/tablets, drag anywhere to move the basket. The fruits are extra big for kid-friendly catching.
            </div>
          </div>
        </div>

        <div class="card hidden" id="gameOverCard" role="dialog" aria-modal="true" aria-label="Game over screen">
          <div class="titleRow">
            <div class="logo" aria-hidden="true"><span>üçç</span></div>
            <div>
              <h1>Game Over!</h1>
              <p class="subtitle" id="finalLine">You caught 0 fruits.</p>
            </div>
          </div>
          <div class="grid">
            <div class="callouts">
              <div class="callout">
                <b>Final Score</b>
                <div id="finalScore">0</div>
              </div>
              <div class="callout">
                <b>Best Today</b>
                <div id="bestScore">0</div>
              </div>
            </div>
            <div class="buttons">
              <button class="btn" id="playAgainBtn" type="button">Play Again</button>
              <div class="btnRowRight">
                <button class="btn secondary" id="shareBtn" type="button">Share</button>
                <button class="btn secondary" id="muteBtn2" type="button" aria-pressed="false">Sound: On</button>
              </div>
            </div>
            <div class="smallNote">Try moving smoothly and aim for the center of the basket.</div>
          </div>
        </div>

        <div class="card hidden" id="pausedCard" role="dialog" aria-modal="true" aria-label="Paused">
          <div class="titleRow">
            <div class="logo" aria-hidden="true"><span>‚è∏Ô∏è</span></div>
            <div>
              <h1>Paused</h1>
              <p class="subtitle">Take a breath. Press <b>P</b> to continue.</p>
            </div>
          </div>
          <div class="grid">
            <div class="buttons">
              <button class="btn" id="resumeBtn" type="button">Resume</button>
              <div class="btnRowRight">
                <button class="btn secondary" id="restartBtn" type="button">Restart</button>
              </div>
            </div>
            <div class="smallNote">Keyboard: <b>P</b> pause/resume ‚Ä¢ <b>R</b> restart</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d", { alpha: true });

        const scoreEl = document.getElementById("score");
        const heartsEl = document.getElementById("hearts");
        const overlay = document.getElementById("overlay");
        const startCard = document.getElementById("startCard");
        const gameOverCard = document.getElementById("gameOverCard");
        const pausedCard = document.getElementById("pausedCard");

        const playBtn = document.getElementById("playBtn");
        const playAgainBtn = document.getElementById("playAgainBtn");
        const shareBtn = document.getElementById("shareBtn");
        const resumeBtn = document.getElementById("resumeBtn");
        const restartBtn = document.getElementById("restartBtn");

        const muteBtn = document.getElementById("muteBtn");
        const muteBtn2 = document.getElementById("muteBtn2");

        const finalLine = document.getElementById("finalLine");
        const finalScoreEl = document.getElementById("finalScore");
        const bestScoreEl = document.getElementById("bestScore");

        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const rand = (a, b) => a + Math.random() * (b - a);
        const now = () => performance.now();

        const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;

        const state = {
          mode: "start", // start | playing | paused | gameover
          score: 0,
          misses: 0,
          best: 0,
          time: 0,
          lastT: 0,
          spawnTimer: 0,
          spawnEvery: 0.8,
          difficulty: 0,
          pointerActive: false,
          pointerX: 0.5,
          keys: { left: false, right: false },
          screenShake: 0,
          vibe: 0,
          muted: false,
        };

        function loadBest() {
          try {
            const v = Number(localStorage.getItem("ff_best") || "0");
            if (Number.isFinite(v)) state.best = Math.max(0, Math.floor(v));
          } catch {
            state.best = 0;
          }
        }

        function saveBest() {
          try {
            localStorage.setItem("ff_best", String(state.best));
          } catch {}
        }

        function setMuted(muted) {
          state.muted = muted;
          for (const btn of [muteBtn, muteBtn2]) {
            btn.setAttribute("aria-pressed", muted ? "true" : "false");
            btn.textContent = muted ? "Sound: Off" : "Sound: On";
          }
        }

        // --- Simple, self-contained sound (WebAudio) ---
        const audio = (() => {
          let ctxAudio = null;
          let master = null;
          let unlocked = false;

          const ensure = () => {
            if (ctxAudio) return;
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (!AudioCtx) return;
            ctxAudio = new AudioCtx();
            master = ctxAudio.createGain();
            master.gain.value = 0.6;
            master.connect(ctxAudio.destination);
          };

          const unlock = async () => {
            ensure();
            if (!ctxAudio || unlocked) return;
            try {
              await ctxAudio.resume();
              // quick silent blip to fully unlock on iOS-ish browsers
              const o = ctxAudio.createOscillator();
              const g = ctxAudio.createGain();
              g.gain.value = 0.0001;
              o.frequency.value = 440;
              o.connect(g);
              g.connect(master);
              o.start();
              o.stop(ctxAudio.currentTime + 0.02);
              unlocked = true;
            } catch {
              // ignore
            }
          };

          const beep = (freqStart, freqEnd, duration, type = "sine", gain = 0.15) => {
            if (state.muted) return;
            ensure();
            if (!ctxAudio || !master) return;
            const t0 = ctxAudio.currentTime;
            const o = ctxAudio.createOscillator();
            const g = ctxAudio.createGain();
            const f = o.frequency;

            o.type = type;
            f.setValueAtTime(freqStart, t0);
            f.exponentialRampToValueAtTime(Math.max(40, freqEnd), t0 + duration);

            g.gain.setValueAtTime(gain, t0);
            g.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);

            o.connect(g);
            g.connect(master);
            o.start(t0);
            o.stop(t0 + duration + 0.01);
          };

          const pop = () => {
            beep(520, 880, 0.09, "triangle", 0.16);
            beep(980, 740, 0.07, "sine", 0.09);
          };

          const thud = () => {
            beep(220, 90, 0.14, "square", 0.12);
          };

          const sparkle = () => {
            beep(900, 1400, 0.08, "sine", 0.08);
            beep(1200, 1700, 0.06, "triangle", 0.05);
          };

          return { unlock, pop, thud, sparkle };
        })();

        // --- Visual entities ---
        const FRUIT_TYPES = [
          { id: "apple", weight: 1.2 },
          { id: "orange", weight: 1.1 },
          { id: "banana", weight: 1.0 },
          { id: "strawberry", weight: 1.0 },
          { id: "grape", weight: 0.9 },
        ];

        const fruits = [];
        const particles = [];
        const floaters = [];
        const clouds = [];

        const basket = {
          x: 0,
          y: 0,
          w: 180,
          h: 64,
          rim: 18,
          targetX: 0,
          vx: 0,
        };

        function buildHearts() {
          heartsEl.innerHTML = "";
          for (let i = 0; i < 3; i++) {
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("viewBox", "0 0 24 24");
            svg.classList.add("heart");
            svg.innerHTML =
              '<path d="M12 21s-7.2-4.5-9.4-8.7C1 9 3.1 6.3 6.1 6.1c1.8-.1 3.2.8 3.9 2 0 0 1.3-2.1 4-2 3 .2 5.1 2.9 3.5 6.2C19.2 16.5 12 21 12 21z" fill="#ff4d6d" stroke="rgba(0,0,0,.08)" stroke-width="0.6"/>';
            heartsEl.appendChild(svg);
          }
        }

        function updateHearts() {
          const nodes = heartsEl.querySelectorAll(".heart");
          for (let i = 0; i < nodes.length; i++) {
            const misses = state.misses;
            const remaining = 3 - misses;
            const on = i < remaining;
            nodes[i].classList.toggle("off", !on);
          }
        }

        function resize() {
          const dpr = Math.min(2, window.devicePixelRatio || 1);
          const w = Math.max(320, Math.floor(window.innerWidth));
          const h = Math.max(520, Math.floor(window.innerHeight));
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          basket.w = clamp(w * 0.22, 160, 240);
          basket.h = clamp(w * 0.08, 56, 78);
          basket.rim = clamp(basket.h * 0.28, 14, 22);
          basket.y = h - basket.h - 26;
          basket.x = clamp(basket.x || w * 0.5, basket.w * 0.5 + 14, w - basket.w * 0.5 - 14);
          basket.targetX = basket.x;

          if (!clouds.length) {
            for (let i = 0; i < 7; i++) {
              clouds.push({
                x: rand(0, w),
                y: rand(20, h * 0.45),
                s: rand(0.8, 1.35),
                v: rand(5, 18),
                p: rand(0, Math.PI * 2),
              });
            }
          }
        }

        function resetGame() {
          state.mode = "playing";
          state.score = 0;
          state.misses = 0;
          state.time = 0;
          state.lastT = now();
          state.spawnTimer = 0;
          state.spawnEvery = 0.85;
          state.difficulty = 0;
          state.screenShake = 0;
          state.vibe = 0;

          fruits.length = 0;
          particles.length = 0;
          floaters.length = 0;

          scoreEl.textContent = "0";
          updateHearts();

          overlay.classList.add("hidden");
          startCard.classList.add("hidden");
          gameOverCard.classList.add("hidden");
          pausedCard.classList.add("hidden");
        }

        function showStart() {
          state.mode = "start";
          overlay.classList.remove("hidden");
          startCard.classList.remove("hidden");
          gameOverCard.classList.add("hidden");
          pausedCard.classList.add("hidden");
        }

        function showPaused(show) {
          if (show) {
            state.mode = "paused";
            overlay.classList.remove("hidden");
            pausedCard.classList.remove("hidden");
            startCard.classList.add("hidden");
            gameOverCard.classList.add("hidden");
          } else {
            state.mode = "playing";
            overlay.classList.add("hidden");
            pausedCard.classList.add("hidden");
            state.lastT = now();
          }
        }

        function showGameOver() {
          state.mode = "gameover";
          overlay.classList.remove("hidden");
          startCard.classList.add("hidden");
          pausedCard.classList.add("hidden");
          gameOverCard.classList.remove("hidden");
          const score = state.score;
          finalScoreEl.textContent = String(score);
          finalLine.textContent = score === 1 ? "You caught 1 fruit." : `You caught ${score} fruits.`;
          bestScoreEl.textContent = String(state.best);
        }

        function chooseFruitType() {
          const total = FRUIT_TYPES.reduce((s, f) => s + f.weight, 0);
          let r = Math.random() * total;
          for (const f of FRUIT_TYPES) {
            r -= f.weight;
            if (r <= 0) return f.id;
          }
          return "apple";
        }

        function spawnFruit() {
          const w = canvas.clientWidth || window.innerWidth;
          const h = canvas.clientHeight || window.innerHeight;

          const size = clamp(rand(w * 0.06, w * 0.085), 44, 74); // kid-friendly big
          const margin = 26 + size;
          const x = rand(margin, w - margin);

          const fallBase = lerp(240, 540, clamp(state.difficulty, 0, 1));
          const fallVar = prefersReducedMotion ? 0.12 : 0.25;
          const vy = fallBase * rand(1 - fallVar, 1 + fallVar);

          const fruit = {
            id: crypto?.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2),
            type: chooseFruitType(),
            x,
            y: -size - 8,
            r: size * 0.5,
            vy,
            wobble: rand(0.8, 1.35),
            phase: rand(0, Math.PI * 2),
            spin: rand(-1.9, 1.9),
            rot: rand(-0.2, 0.2),
            caught: false,
          };
          fruits.push(fruit);
        }

        function addFloater(x, y, text, color) {
          floaters.push({
            x,
            y,
            text,
            color,
            t: 0,
            life: 0.85,
            vy: rand(-42, -58),
            vx: rand(-14, 14),
          });
        }

        function burst(x, y, baseHue = rand(290, 360)) {
          const count = prefersReducedMotion ? 12 : 22;
          for (let i = 0; i < count; i++) {
            const a = rand(0, Math.PI * 2);
            const sp = rand(90, 320);
            particles.push({
              x,
              y,
              vx: Math.cos(a) * sp,
              vy: Math.sin(a) * sp - 120,
              g: 980,
              r: rand(2.5, 5.0),
              t: 0,
              life: rand(0.55, 0.95),
              hue: baseHue + rand(-18, 18),
              twist: rand(-6, 6),
            });
          }
        }

        function onCatch(fruit) {
          state.score += 1;
          scoreEl.textContent = String(state.score);
          state.vibe = Math.min(1, state.vibe + 0.12);
          state.screenShake = Math.min(9, state.screenShake + 2);
          audio.pop();
          burst(fruit.x, basket.y - basket.h * 0.15, rand(20, 330));
          addFloater(fruit.x, basket.y - basket.h * 0.7, "+1", "#ff4d9a");

          state.difficulty = clamp(state.score / 45, 0, 1);
          state.spawnEvery = lerp(0.9, 0.42, state.difficulty);
        }

        function onMiss(x) {
          state.misses += 1;
          updateHearts();
          state.screenShake = Math.min(12, state.screenShake + 4);
          audio.thud();
          burst(x, basket.y + basket.h * 0.65, 45);
          addFloater(x, basket.y + basket.h * 0.2, "Oops!", "#6b5bff");
          if (state.misses >= 3) {
            state.best = Math.max(state.best, state.score);
            saveBest();
            showGameOver();
            audio.sparkle();
          }
        }

        function circleRectHit(cx, cy, cr, rx, ry, rw, rh) {
          const nx = clamp(cx, rx, rx + rw);
          const ny = clamp(cy, ry, ry + rh);
          const dx = cx - nx;
          const dy = cy - ny;
          return dx * dx + dy * dy <= cr * cr;
        }

        function update(dt) {
          const w = canvas.clientWidth || window.innerWidth;
          const h = canvas.clientHeight || window.innerHeight;

          // Basket controls
          const maxSpeed = clamp(w * 1.2, 680, 1280);
          const accel = prefersReducedMotion ? 2300 : 3200;
          const friction = prefersReducedMotion ? 0.72 : 0.62;

          if (state.pointerActive) {
            basket.targetX = clamp(state.pointerX * w, basket.w * 0.5 + 14, w - basket.w * 0.5 - 14);
          } else {
            let dir = 0;
            if (state.keys.left) dir -= 1;
            if (state.keys.right) dir += 1;
            basket.vx += dir * accel * dt;
            basket.vx *= Math.pow(friction, dt * 60);
            basket.vx = clamp(basket.vx, -maxSpeed, maxSpeed);
            basket.targetX = clamp(basket.x + basket.vx * dt, basket.w * 0.5 + 14, w - basket.w * 0.5 - 14);
          }
          basket.x = lerp(basket.x, basket.targetX, 1 - Math.pow(0.001, dt * 60));

          state.time += dt;
          state.spawnTimer += dt;

          // Clouds drift
          for (const c of clouds) {
            c.x += c.v * dt;
            c.p += dt * 0.6;
            if (c.x > w + 140) c.x = -140;
          }

          // Spawn fruit
          const extra = lerp(0, 0.22, state.difficulty); // occasional double spawn later
          while (state.spawnTimer >= state.spawnEvery) {
            state.spawnTimer -= state.spawnEvery;
            spawnFruit();
            if (Math.random() < extra) spawnFruit();
          }

          // Fruits update
          const basketRect = {
            x: basket.x - basket.w * 0.5,
            y: basket.y - basket.h * 0.5,
            w: basket.w,
            h: basket.h * 0.65,
          };

          for (let i = fruits.length - 1; i >= 0; i--) {
            const f = fruits[i];
            f.phase += dt * f.wobble;
            f.rot += dt * f.spin;
            f.y += f.vy * dt;
            const wob = Math.sin(f.phase) * (prefersReducedMotion ? 4 : 9);
            const fx = f.x + wob;

            const hit = circleRectHit(fx, f.y, f.r * 0.78, basketRect.x, basketRect.y, basketRect.w, basketRect.h);
            if (hit && f.y > basketRect.y - f.r * 0.25) {
              fruits.splice(i, 1);
              onCatch({ ...f, x: fx });
              continue;
            }

            if (f.y - f.r > h + 10) {
              fruits.splice(i, 1);
              onMiss(fx);
            }
          }

          // Particles update
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.t += dt;
            p.vy += p.g * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            if (p.t >= p.life) particles.splice(i, 1);
          }

          // Floaters update
          for (let i = floaters.length - 1; i >= 0; i--) {
            const f = floaters[i];
            f.t += dt;
            f.x += f.vx * dt;
            f.y += f.vy * dt;
            if (f.t >= f.life) floaters.splice(i, 1);
          }

          state.screenShake = Math.max(0, state.screenShake - dt * 9);
          state.vibe = Math.max(0, state.vibe - dt * 0.12);
        }

        // --- Drawing ---
        function drawRoundedRect(x, y, w, h, r) {
          const rr = Math.min(r, w * 0.5, h * 0.5);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          ctx.closePath();
        }

        function drawBackground(t) {
          const w = canvas.clientWidth || window.innerWidth;
          const h = canvas.clientHeight || window.innerHeight;

          // sky glow
          const sunX = w * 0.82;
          const sunY = h * 0.18;
          const glow = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, Math.max(w, h) * 0.55);
          glow.addColorStop(0, "rgba(255, 255, 255, 0.9)");
          glow.addColorStop(0.25, "rgba(255, 241, 183, 0.55)");
          glow.addColorStop(1, "rgba(255, 255, 255, 0)");
          ctx.fillStyle = glow;
          ctx.fillRect(0, 0, w, h);

          // rainbow arc
          const arcR = Math.min(w, h) * 0.62;
          const arcX = w * 0.18;
          const arcY = h * 0.78;
          ctx.save();
          ctx.globalAlpha = 0.42;
          ctx.lineWidth = arcR * 0.08;
          const colors = ["#ff4d9a", "#ffcc00", "#45e6c8", "#6b5bff"];
          for (let i = 0; i < colors.length; i++) {
            ctx.strokeStyle = colors[i];
            ctx.beginPath();
            ctx.arc(arcX, arcY, arcR - i * ctx.lineWidth * 0.9, Math.PI * 1.08, Math.PI * 1.98);
            ctx.stroke();
          }
          ctx.restore();

          // clouds
          for (const c of clouds) {
            const yy = c.y + Math.sin(c.p) * 7;
            const xx = c.x;
            ctx.save();
            ctx.globalAlpha = 0.72;
            ctx.fillStyle = "rgba(255,255,255,0.95)";
            ctx.beginPath();
            const s = 42 * c.s;
            ctx.arc(xx, yy, s * 0.55, 0, Math.PI * 2);
            ctx.arc(xx + s * 0.6, yy + s * 0.05, s * 0.7, 0, Math.PI * 2);
            ctx.arc(xx + s * 1.35, yy, s * 0.55, 0, Math.PI * 2);
            ctx.arc(xx + s * 0.6, yy + s * 0.35, s * 0.78, 0, Math.PI * 2);
            ctx.closePath();
            ctx.shadowColor = "rgba(20,40,80,0.12)";
            ctx.shadowBlur = 16;
            ctx.shadowOffsetY = 10;
            ctx.fill();
            ctx.restore();
          }

          // playful confetti dots far background
          const n = prefersReducedMotion ? 18 : 28;
          ctx.save();
          ctx.globalAlpha = 0.18;
          for (let i = 0; i < n; i++) {
            const px = (i * 91 + t * 18) % w;
            const py = (i * 57 + t * 13) % (h * 0.7);
            ctx.fillStyle = `hsl(${(i * 37 + t * 18) % 360} 90% 65% / 0.85)`;
            ctx.beginPath();
            ctx.arc(px, py, 2.2 + ((i * 13) % 10) * 0.08, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

          // ground
          const groundH = Math.max(130, h * 0.22);
          const grad = ctx.createLinearGradient(0, h - groundH, 0, h);
          grad.addColorStop(0, "rgba(255, 243, 176, 0)");
          grad.addColorStop(0.35, "rgba(255, 243, 176, 0.8)");
          grad.addColorStop(1, "rgba(255, 230, 140, 1)");
          ctx.fillStyle = grad;
          ctx.fillRect(0, h - groundH, w, groundH);

          // bouncy grass bubbles
          ctx.save();
          ctx.globalAlpha = 0.6;
          for (let i = 0; i < 10; i++) {
            const bx = ((i * 160 + t * 55) % (w + 160)) - 80;
            const by = h - groundH * 0.32 + Math.sin(t * 0.7 + i) * 4;
            ctx.fillStyle = `hsl(${110 + i * 8} 75% 55% / 0.55)`;
            ctx.beginPath();
            ctx.ellipse(bx, by, 42, 18, Math.sin(i + t * 0.2) * 0.18, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        function drawBasket() {
          const w = canvas.clientWidth || window.innerWidth;
          const h = canvas.clientHeight || window.innerHeight;
          const x = basket.x;
          const y = basket.y;

          // shadow
          ctx.save();
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = "rgba(0,0,0,0.25)";
          ctx.beginPath();
          ctx.ellipse(x, h - 18, basket.w * 0.42, 12, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          const bx = x - basket.w * 0.5;
          const by = y - basket.h * 0.5;

          // basket body
          ctx.save();
          const bodyGrad = ctx.createLinearGradient(0, by, 0, by + basket.h);
          bodyGrad.addColorStop(0, "#ffe2b8");
          bodyGrad.addColorStop(1, "#ffb86b");
          ctx.fillStyle = bodyGrad;
          ctx.shadowColor = "rgba(20,40,80,0.18)";
          ctx.shadowBlur = 18;
          ctx.shadowOffsetY = 12;
          drawRoundedRect(bx, by, basket.w, basket.h, 22);
          ctx.fill();

          // weave stripes
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.25;
          ctx.strokeStyle = "rgba(130,70,10,0.55)";
          ctx.lineWidth = 2.5;
          for (let i = 0; i < 8; i++) {
            const yy = by + 10 + i * ((basket.h - 20) / 7);
            ctx.beginPath();
            ctx.moveTo(bx + 12, yy);
            ctx.lineTo(bx + basket.w - 12, yy);
            ctx.stroke();
          }
          ctx.globalAlpha = 0.3;
          for (let i = 0; i < 10; i++) {
            const xx = bx + 12 + i * ((basket.w - 24) / 9);
            ctx.beginPath();
            ctx.moveTo(xx, by + 10);
            ctx.lineTo(xx, by + basket.h - 10);
            ctx.stroke();
          }

          // rim
          ctx.globalAlpha = 1;
          const rimGrad = ctx.createLinearGradient(0, by, 0, by + basket.rim);
          rimGrad.addColorStop(0, "#fff2df");
          rimGrad.addColorStop(1, "#ffd1a4");
          ctx.fillStyle = rimGrad;
          drawRoundedRect(bx + 6, by + 6, basket.w - 12, basket.rim, 18);
          ctx.fill();

          // highlight
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = "#fff";
          drawRoundedRect(bx + 10, by + 10, basket.w - 20, basket.h - 20, 18);
          ctx.fill();
          ctx.restore();

          // little face on basket (kid-friendly)
          ctx.save();
          ctx.translate(x, y + basket.h * 0.05);
          ctx.globalAlpha = 0.85;
          const faceW = basket.w * 0.18;
          const eyeY = -basket.h * 0.08;
          const eyeX = faceW * 0.38;
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.beginPath();
          ctx.arc(-eyeX, eyeY, 4.2, 0, Math.PI * 2);
          ctx.arc(eyeX, eyeY, 4.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.45)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(0, eyeY + 10, 12, 0.15 * Math.PI, 0.85 * Math.PI);
          ctx.stroke();
          ctx.restore();
        }

        function drawFruit(f) {
          const wob = Math.sin(f.phase) * (prefersReducedMotion ? 4 : 9);
          const x = f.x + wob;
          const y = f.y;
          const r = f.r;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(f.rot);

          // shadow
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = "rgba(0,0,0,0.2)";
          ctx.beginPath();
          ctx.ellipse(6, r * 0.65, r * 0.62, r * 0.22, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;

          const type = f.type;
          if (type === "apple") {
            // body
            const grad = ctx.createRadialGradient(-r * 0.25, -r * 0.2, r * 0.15, 0, 0, r * 1.05);
            grad.addColorStop(0, "#ffb3c8");
            grad.addColorStop(0.4, "#ff2d55");
            grad.addColorStop(1, "#c70d2f");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.95, 0, Math.PI * 2);
            ctx.fill();
            // bite shine
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.ellipse(-r * 0.22, -r * 0.15, r * 0.32, r * 0.42, -0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            // stem + leaf
            ctx.strokeStyle = "#6b3f1d";
            ctx.lineWidth = Math.max(4, r * 0.12);
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(0, -r * 0.8);
            ctx.lineTo(r * 0.12, -r * 1.05);
            ctx.stroke();
            ctx.fillStyle = "#38d66b";
            ctx.beginPath();
            ctx.ellipse(r * 0.25, -r * 0.92, r * 0.36, r * 0.18, 0.5, 0, Math.PI * 2);
            ctx.fill();
          } else if (type === "orange") {
            const grad = ctx.createRadialGradient(-r * 0.25, -r * 0.2, r * 0.2, 0, 0, r * 1.1);
            grad.addColorStop(0, "#fff1b6");
            grad.addColorStop(0.35, "#ffb400");
            grad.addColorStop(1, "#f07400");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.95, 0, Math.PI * 2);
            ctx.fill();
            // dimples
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = "#a64d00";
            for (let i = 0; i < 14; i++) {
              const a = (i / 14) * Math.PI * 2;
              const rr = r * rand(0.1, 0.78);
              ctx.beginPath();
              ctx.arc(Math.cos(a) * rr, Math.sin(a) * rr, r * 0.06, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.globalAlpha = 1;
            // little top
            ctx.fillStyle = "#38d66b";
            ctx.beginPath();
            ctx.arc(0, -r * 0.78, r * 0.14, 0, Math.PI * 2);
            ctx.fill();
          } else if (type === "banana") {
            ctx.save();
            ctx.rotate(-0.2);
            const grad = ctx.createLinearGradient(-r, -r, r, r);
            grad.addColorStop(0, "#fff3b0");
            grad.addColorStop(0.45, "#ffd33d");
            grad.addColorStop(1, "#ffb703");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(-r * 0.9, -r * 0.2);
            ctx.quadraticCurveTo(-r * 0.1, -r * 1.0, r * 0.95, -r * 0.25);
            ctx.quadraticCurveTo(r * 0.45, r * 0.85, -r * 0.9, r * 0.3);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.moveTo(-r * 0.65, -r * 0.08);
            ctx.quadraticCurveTo(0, -r * 0.62, r * 0.72, -r * 0.12);
            ctx.quadraticCurveTo(r * 0.25, r * 0.36, -r * 0.62, r * 0.12);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
            // tips
            ctx.fillStyle = "#6b3f1d";
            ctx.beginPath();
            ctx.arc(-r * 0.86, 0, r * 0.06, 0, Math.PI * 2);
            ctx.arc(r * 0.86, -r * 0.05, r * 0.06, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (type === "strawberry") {
            const grad = ctx.createRadialGradient(-r * 0.2, -r * 0.2, r * 0.2, 0, 0, r * 1.1);
            grad.addColorStop(0, "#ffd1df");
            grad.addColorStop(0.35, "#ff3b7a");
            grad.addColorStop(1, "#b10a3b");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(0, r * 0.95);
            ctx.bezierCurveTo(r * 0.8, r * 0.55, r * 0.7, -r * 0.35, 0, -r * 0.95);
            ctx.bezierCurveTo(-r * 0.7, -r * 0.35, -r * 0.8, r * 0.55, 0, r * 0.95);
            ctx.closePath();
            ctx.fill();
            // seeds
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = "rgba(255, 225, 140, 0.95)";
            for (let i = 0; i < 18; i++) {
              const a = (i / 18) * Math.PI * 2;
              const rr = r * rand(0.08, 0.78);
              ctx.beginPath();
              ctx.ellipse(Math.cos(a) * rr * 0.8, Math.sin(a) * rr * 0.9 + r * 0.15, r * 0.07, r * 0.1, a, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.globalAlpha = 1;
            // leafy top
            ctx.fillStyle = "#38d66b";
            for (let i = 0; i < 6; i++) {
              const a = (i / 6) * Math.PI * 2;
              ctx.beginPath();
              ctx.ellipse(Math.cos(a) * r * 0.25, -r * 0.78 + Math.sin(a) * r * 0.05, r * 0.22, r * 0.12, a, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (type === "grape") {
            const base = ctx.createRadialGradient(-r * 0.2, -r * 0.25, r * 0.25, 0, 0, r * 1.1);
            base.addColorStop(0, "#f3d6ff");
            base.addColorStop(0.4, "#8b5cf6");
            base.addColorStop(1, "#4c1d95");
            ctx.fillStyle = base;
            const dots = [
              [-0.28, -0.15],
              [0.05, -0.25],
              [0.3, -0.1],
              [-0.2, 0.15],
              [0.12, 0.15],
              [0.38, 0.18],
              [0.0, 0.42],
            ];
            for (const [dx, dy] of dots) {
              ctx.beginPath();
              ctx.arc(dx * r * 1.8, dy * r * 1.6, r * 0.42, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 0.18;
              ctx.fillStyle = "#fff";
              ctx.beginPath();
              ctx.ellipse(dx * r * 1.8 - r * 0.1, dy * r * 1.6 - r * 0.14, r * 0.16, r * 0.22, -0.2, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 1;
              ctx.fillStyle = base;
            }
            // stem
            ctx.strokeStyle = "#2b1a12";
            ctx.lineWidth = Math.max(4, r * 0.1);
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(-r * 0.05, -r * 0.72);
            ctx.lineTo(r * 0.15, -r * 1.02);
            ctx.stroke();
          }

          // cute face for fruits
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          const eyeY = r * 0.08;
          ctx.beginPath();
          ctx.arc(-r * 0.22, eyeY, Math.max(3.2, r * 0.07), 0, Math.PI * 2);
          ctx.arc(r * 0.22, eyeY, Math.max(3.2, r * 0.07), 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.45)";
          ctx.lineWidth = Math.max(2.2, r * 0.06);
          ctx.beginPath();
          ctx.arc(0, eyeY + r * 0.2, r * 0.22, 0.18 * Math.PI, 0.82 * Math.PI);
          ctx.stroke();
          ctx.restore();

          ctx.restore();
        }

        function drawParticles() {
          ctx.save();
          for (const p of particles) {
            const a = 1 - p.t / p.life;
            ctx.globalAlpha = Math.max(0, a);
            ctx.fillStyle = `hsl(${p.hue} 92% 62% / 0.95)`;
            ctx.beginPath();
            const rr = p.r * (0.9 + a * 0.6);
            ctx.arc(p.x, p.y, rr, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        function drawFloaters() {
          ctx.save();
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          for (const f of floaters) {
            const a = 1 - f.t / f.life;
            ctx.globalAlpha = Math.max(0, a);
            ctx.font = "900 26px ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Arial";
            ctx.fillStyle = "rgba(0,0,0,0.12)";
            ctx.fillText(f.text, f.x + 2, f.y + 3);
            ctx.fillStyle = f.color;
            ctx.fillText(f.text, f.x, f.y);
          }
          ctx.restore();
        }

        function draw() {
          const w = canvas.clientWidth || window.innerWidth;
          const h = canvas.clientHeight || window.innerHeight;

          ctx.clearRect(0, 0, w, h);

          const t = state.time;
          const shake = state.mode === "playing" ? state.screenShake : 0;
          const sx = shake ? rand(-shake, shake) : 0;
          const sy = shake ? rand(-shake, shake) : 0;

          ctx.save();
          ctx.translate(sx, sy);

          drawBackground(t);

          // Fruits
          for (const f of fruits) drawFruit(f);

          // Basket
          drawBasket();

          // Particles + floaters
          drawParticles();
          drawFloaters();

          // subtle vignette
          ctx.save();
          const vg = ctx.createRadialGradient(w * 0.5, h * 0.45, Math.min(w, h) * 0.1, w * 0.5, h * 0.55, Math.max(w, h) * 0.72);
          vg.addColorStop(0, "rgba(0,0,0,0)");
          vg.addColorStop(1, "rgba(0,0,0,0.08)");
          ctx.fillStyle = vg;
          ctx.fillRect(-sx, -sy, w, h);
          ctx.restore();

          ctx.restore();

          // start/paused/gameover attract animation by drawing a big title glow in canvas (no motion if reduced)
          if (state.mode !== "playing") {
            ctx.save();
            ctx.globalAlpha = 0.28;
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            const wob = prefersReducedMotion ? 0 : Math.sin(t * 1.2) * 8;
            ctx.font = "900 36px ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Arial";
            ctx.fillStyle = "rgba(255,255,255,0.9)";
            ctx.fillText("Catch the Fruits!", w * 0.5, 30 + wob);
            ctx.restore();
          }
        }

        function tick() {
          const t = now();
          const dt = clamp((t - state.lastT) / 1000, 0, 0.034);
          state.lastT = t;

          if (state.mode === "playing") update(dt);
          draw();
          requestAnimationFrame(tick);
        }

        // --- Input ---
        function onPointerMove(clientX) {
          const w = canvas.clientWidth || window.innerWidth;
          state.pointerX = clamp(clientX / w, 0, 1);
          state.pointerActive = true;
        }

        function attachInput() {
          const pointerHandler = (e) => {
            if (e.touches && e.touches.length) {
              onPointerMove(e.touches[0].clientX);
            } else if (typeof e.clientX === "number") {
              onPointerMove(e.clientX);
            }
          };

          window.addEventListener("mousemove", pointerHandler, { passive: true });
          window.addEventListener(
            "touchstart",
            (e) => {
              pointerHandler(e);
              state.pointerActive = true;
            },
            { passive: true },
          );
          window.addEventListener(
            "touchmove",
            (e) => {
              pointerHandler(e);
              state.pointerActive = true;
            },
            { passive: true },
          );
          window.addEventListener(
            "touchend",
            () => {
              state.pointerActive = false;
            },
            { passive: true },
          );

          window.addEventListener("keydown", (e) => {
            if (e.key === "ArrowLeft") state.keys.left = true;
            if (e.key === "ArrowRight") state.keys.right = true;
            if (e.key === "p" || e.key === "P") {
              if (state.mode === "playing") showPaused(true);
              else if (state.mode === "paused") showPaused(false);
            }
            if (e.key === "r" || e.key === "R") {
              if (state.mode === "playing" || state.mode === "paused" || state.mode === "gameover") resetGame();
            }
          });

          window.addEventListener("keyup", (e) => {
            if (e.key === "ArrowLeft") state.keys.left = false;
            if (e.key === "ArrowRight") state.keys.right = false;
          });

          // if keyboard used, don't override with stale mouse position
          const noteKeyboard = () => (state.pointerActive = false);
          window.addEventListener("keydown", noteKeyboard, { passive: true });

          window.addEventListener("blur", () => {
            state.keys.left = false;
            state.keys.right = false;
            if (state.mode === "playing") showPaused(true);
          });

          // prevent unwanted page scroll with arrows on some browsers
          window.addEventListener(
            "keydown",
            (e) => {
              if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === " " || e.key === "ArrowUp" || e.key === "ArrowDown") {
                e.preventDefault();
              }
            },
            { passive: false },
          );
        }

        // --- Buttons ---
        playBtn.addEventListener("click", async () => {
          await audio.unlock();
          resetGame();
        });
        playAgainBtn.addEventListener("click", async () => {
          await audio.unlock();
          resetGame();
        });
        resumeBtn.addEventListener("click", () => showPaused(false));
        restartBtn.addEventListener("click", () => resetGame());

        const toggleMute = async () => {
          await audio.unlock();
          setMuted(!state.muted);
        };
        muteBtn.addEventListener("click", toggleMute);
        muteBtn2.addEventListener("click", toggleMute);

        shareBtn.addEventListener("click", async () => {
          const text = `I caught ${state.score} fruits in Falling Fruit Catcher! üçéüß∫`;
          const url = location.href;
          try {
            if (navigator.share) {
              await navigator.share({ title: "Falling Fruit Catcher", text, url });
            } else {
              await navigator.clipboard.writeText(text + " " + url);
              shareBtn.textContent = "Copied!";
              setTimeout(() => (shareBtn.textContent = "Share"), 900);
            }
          } catch {
            // ignore
          }
        });

        // --- Init ---
        buildHearts();
        loadBest();
        updateHearts();
        setMuted(false);
        resize();
        attachInput();
        showStart();

        window.addEventListener("resize", resize, { passive: true });

        // Start animation loop
        state.lastT = now();
        requestAnimationFrame(tick);

        // Gentle nudge: unlock audio on first interaction
        const unlockOnce = async () => {
          window.removeEventListener("pointerdown", unlockOnce);
          window.removeEventListener("touchstart", unlockOnce);
          await audio.unlock();
        };
        window.addEventListener("pointerdown", unlockOnce, { passive: true });
        window.addEventListener("touchstart", unlockOnce, { passive: true });
      })();
    </script>
  </body>
</html>
