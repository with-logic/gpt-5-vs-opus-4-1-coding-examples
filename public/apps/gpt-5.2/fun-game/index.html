<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <meta name="theme-color" content="#6c5ce7" />
    <title>Fun Game</title>
    <style>
      :root{
        --bg1:#0b1026;
        --bg2:#3a1c71;
        --bg3:#ff6a88;
        --ui:#ffffff;
        --ui2:rgba(255,255,255,.12);
        --ui3:rgba(0,0,0,.35);
        --shadow: 0 10px 30px rgba(0,0,0,.35);
      }
      *{box-sizing:border-box}
      html,body{height:100%}
      body{
        margin:0;
        background: radial-gradient(1200px 800px at 20% 10%, rgba(255,255,255,.10), transparent 55%),
          radial-gradient(900px 600px at 90% 15%, rgba(255,255,255,.08), transparent 55%),
          linear-gradient(135deg, var(--bg1), var(--bg2) 45%, var(--bg3));
        color: var(--ui);
        font-family: ui-rounded, "Comic Sans MS", "Trebuchet MS", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        overflow:hidden;
        -webkit-tap-highlight-color: transparent;
        user-select:none;
      }
      #app{
        position:fixed; inset:0;
        display:grid;
        place-items:stretch;
      }
      canvas{
        width:100%;
        height:100%;
        display:block;
      }
      .hud{
        position:absolute; inset:0;
        pointer-events:none;
      }
      .topbar{
        position:absolute;
        left: max(12px, env(safe-area-inset-left));
        right: max(12px, env(safe-area-inset-right));
        top: max(12px, env(safe-area-inset-top));
        display:flex;
        gap:12px;
        justify-content:space-between;
        align-items:flex-start;
      }
      .panel{
        pointer-events:auto;
        background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.08));
        border: 1px solid rgba(255,255,255,.22);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 16px;
        box-shadow: var(--shadow);
        padding: 10px 12px;
        min-width: 160px;
      }
      .title{
        font-weight: 900;
        letter-spacing: .4px;
        font-size: 14px;
        opacity:.95;
      }
      .stats{
        display:grid;
        grid-template-columns: 1fr auto;
        gap:6px 10px;
        margin-top:8px;
        font-variant-numeric: tabular-nums;
      }
      .stats .k{opacity:.85}
      .stats .v{font-weight:900}
      .stats .v.good{color:#55efc4; text-shadow: 0 2px 0 rgba(0,0,0,.18)}
      .stats .v.bad{color:#ff7675; text-shadow: 0 2px 0 rgba(0,0,0,.18)}
      .controls{
        display:flex;
        gap:8px;
        justify-content:flex-end;
        align-items:center;
      }
      button{
        pointer-events:auto;
        border: 1px solid rgba(255,255,255,.25);
        background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.10));
        color: var(--ui);
        border-radius: 14px;
        padding: 10px 12px;
        font: inherit;
        font-weight: 900;
        letter-spacing: .2px;
        cursor:pointer;
        box-shadow: 0 10px 20px rgba(0,0,0,.22);
        transition: transform .08s ease, filter .08s ease;
      }
      button:hover{filter:brightness(1.05)}
      button:active{transform: translateY(1px) scale(.99)}
      button.small{padding: 9px 10px; border-radius: 12px}
      button.primary{
        background: linear-gradient(180deg, rgba(255,255,255,.30), rgba(255,255,255,.12));
      }
      button.danger{
        background: linear-gradient(180deg, rgba(255,140,140,.35), rgba(255,255,255,.10));
      }
      .badge{
        display:inline-flex;
        align-items:center;
        gap:8px;
        padding:8px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,.22);
        background: rgba(0,0,0,.18);
      }
      .dot{
        width:10px; height:10px; border-radius:999px;
        background: #2ecc71;
        box-shadow: 0 0 0 6px rgba(46,204,113,.18);
      }
      .dot.off{background:#ff4757; box-shadow:0 0 0 6px rgba(255,71,87,.18)}
      .overlay{
        position:absolute;
        inset:0;
        display:grid;
        place-items:center;
        pointer-events:none;
      }
      .card{
        pointer-events:auto;
        width: min(560px, calc(100vw - 28px));
        background: linear-gradient(180deg, rgba(255,255,255,.20), rgba(255,255,255,.08));
        border: 1px solid rgba(255,255,255,.24);
        border-radius: 22px;
        box-shadow: var(--shadow);
        padding: 18px 18px 16px;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }
      .card h1{
        margin: 2px 0 8px;
        font-size: 30px;
        line-height: 1.05;
        letter-spacing: .3px;
      }
      .card p{
        margin: 6px 0;
        opacity:.92;
        line-height: 1.35;
      }
      .card .row{
        display:flex;
        flex-wrap:wrap;
        gap:10px;
        margin-top:12px;
        align-items:center;
        justify-content:space-between;
      }
      .tips{
        margin-top: 10px;
        padding: 10px 12px;
        border-radius: 16px;
        background: rgba(0,0,0,.16);
        border: 1px dashed rgba(255,255,255,.24);
      }
      kbd{
        display:inline-block;
        padding: 2px 8px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,.25);
        background: rgba(0,0,0,.18);
        font-weight: 900;
        font-variant-numeric: tabular-nums;
      }
      .footer{
        margin-top: 10px;
        opacity: .85;
        font-size: 12px;
        line-height: 1.35;
      }
      .sr-only{
        position:absolute; width:1px; height:1px;
        padding:0; margin:-1px; overflow:hidden;
        clip: rect(0,0,0,0); white-space:nowrap; border:0;
      }
      @media (prefers-reduced-motion: reduce){
        button{transition:none}
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas id="game" aria-label="Fun Game canvas"></canvas>
      <div class="hud" aria-hidden="true">
        <div class="topbar">
          <div class="panel" style="min-width:220px">
            <div class="title">Fun Game</div>
            <div class="stats">
              <div class="k">Score</div><div class="v" id="score">0</div>
              <div class="k">High score</div><div class="v" id="highScore">0</div>
              <div class="k">Speed</div><div class="v" id="speed">1.0×</div>
              <div class="k">Bonus hop</div><div class="v good" id="hop">Ready</div>
            </div>
          </div>
          <div class="panel" style="min-width:220px">
            <div class="controls">
              <span class="badge" title="Sound status">
                <span class="dot" id="soundDot"></span>
                <span id="soundLabel">Sound</span>
              </span>
              <button class="small" id="soundBtn" title="Toggle sound">Toggle</button>
              <button class="small" id="pauseBtn" title="Pause (P)">Pause</button>
            </div>
            <div class="footer">Jump: <kbd>Space</kbd>/<kbd>↑</kbd> · Retry: <kbd>R</kbd> · Pause: <kbd>P</kbd></div>
          </div>
        </div>
        <div class="overlay" id="overlay">
          <div class="card" id="card">
            <h1 id="headline">Jump over obstacles.</h1>
            <p id="subhead">Survive as long as you can while the world gets faster and sillier.</p>
            <div class="tips">
              <p><strong>How to play:</strong> Tap/click or press <kbd>Space</kbd> to jump. Time it right and don’t bonk the obstacles.</p>
              <p><strong>Pro tip:</strong> You get <em>one</em> mid-air bonus hop. Use it to save your cartoon butt.</p>
            </div>
            <div class="row">
              <button class="primary" id="startBtn">Start</button>
              <button class="danger" id="retryBtn" style="display:none">Retry</button>
              <button id="shareBtn" title="Copy score to clipboard" style="display:none">Copy Score</button>
            </div>
            <div class="footer" id="footerNote">Sound is silly on purpose. First tap enables audio.</div>
            <div class="sr-only" id="ariaLive" aria-live="polite"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

        const scoreEl = document.getElementById("score");
        const highScoreEl = document.getElementById("highScore");
        const speedEl = document.getElementById("speed");
        const hopEl = document.getElementById("hop");
        const overlayEl = document.getElementById("overlay");
        const headlineEl = document.getElementById("headline");
        const subheadEl = document.getElementById("subhead");
        const footerNoteEl = document.getElementById("footerNote");
        const startBtn = document.getElementById("startBtn");
        const retryBtn = document.getElementById("retryBtn");
        const shareBtn = document.getElementById("shareBtn");
        const pauseBtn = document.getElementById("pauseBtn");
        const soundBtn = document.getElementById("soundBtn");
        const soundDot = document.getElementById("soundDot");
        const soundLabel = document.getElementById("soundLabel");
        const ariaLive = document.getElementById("ariaLive");

        const prefersReducedMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const rand = (a, b) => a + Math.random() * (b - a);
        const randi = (a, b) => Math.floor(rand(a, b + 1));
        const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
        const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

        // ---------- Audio (funny sounds, no assets) ----------
        let audio = {
          ctx: null,
          master: null,
          enabled: true,
          unlocked: false,
          lastStepAt: 0,
        };

        function ensureAudio() {
          if (audio.ctx) return;
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) {
            audio.enabled = false;
            return;
          }
          audio.ctx = new AC();
          audio.master = audio.ctx.createGain();
          audio.master.gain.value = 0.65;
          audio.master.connect(audio.ctx.destination);
        }

        function unlockAudio() {
          ensureAudio();
          if (!audio.ctx) return;
          if (audio.ctx.state === "suspended") audio.ctx.resume().catch(() => {});
          audio.unlocked = true;
        }

        function tone({ type = "sine", f0 = 440, f1 = 440, dur = 0.12, gain = 0.18, curve = "exp", detune = 0 } = {}) {
          if (!audio.enabled || !audio.unlocked || !audio.ctx) return;
          const t0 = audio.ctx.currentTime;
          const osc = audio.ctx.createOscillator();
          const g = audio.ctx.createGain();
          const shaper = audio.ctx.createWaveShaper();
          osc.type = type;
          osc.detune.value = detune;

          // tiny saturation for "cartoon" bite
          const k = 40;
          const n = 256;
          const curveArr = new Float32Array(n);
          for (let i = 0; i < n; i++) {
            const x = (i * 2) / (n - 1) - 1;
            curveArr[i] = ((1 + k) * x) / (1 + k * Math.abs(x));
          }
          shaper.curve = curveArr;
          shaper.oversample = "4x";

          g.gain.setValueAtTime(0.0001, t0);
          g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

          if (curve === "exp") {
            osc.frequency.setValueAtTime(f0, t0);
            osc.frequency.exponentialRampToValueAtTime(Math.max(30, f1), t0 + dur);
          } else {
            osc.frequency.setValueAtTime(f0, t0);
            osc.frequency.linearRampToValueAtTime(f1, t0 + dur);
          }

          osc.connect(shaper);
          shaper.connect(g);
          g.connect(audio.master);

          osc.start(t0);
          osc.stop(t0 + dur + 0.02);
        }

        function noisePop({ dur = 0.12, gain = 0.12, tilt = 0.35 } = {}) {
          if (!audio.enabled || !audio.unlocked || !audio.ctx) return;
          const t0 = audio.ctx.currentTime;
          const len = Math.max(1, Math.floor(audio.ctx.sampleRate * dur));
          const buffer = audio.ctx.createBuffer(1, len, audio.ctx.sampleRate);
          const data = buffer.getChannelData(0);
          let lp = 0;
          for (let i = 0; i < len; i++) {
            const w = (Math.random() * 2 - 1);
            lp = lerp(lp, w, tilt);
            data[i] = lp * (1 - i / len);
          }
          const src = audio.ctx.createBufferSource();
          src.buffer = buffer;
          const g = audio.ctx.createGain();
          g.gain.setValueAtTime(gain, t0);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
          src.connect(g);
          g.connect(audio.master);
          src.start(t0);
          src.stop(t0 + dur + 0.02);
        }

        const sfx = {
          jump() {
            tone({ type: "triangle", f0: 220 + rand(-10, 10), f1: 660 + rand(-20, 20), dur: 0.14, gain: 0.16, curve: "lin" });
            tone({ type: "sine", f0: 440, f1: 880, dur: 0.08, gain: 0.08, curve: "exp", detune: rand(-10, 10) });
            noisePop({ dur: 0.06, gain: 0.05, tilt: 0.55 });
          },
          bonusHop() {
            tone({ type: "square", f0: 330 + rand(-10, 10), f1: 990 + rand(-10, 10), dur: 0.11, gain: 0.12, curve: "lin" });
            tone({ type: "sine", f0: 660, f1: 1320, dur: 0.06, gain: 0.06, curve: "exp" });
          },
          step(now) {
            if (!audio.enabled || !audio.unlocked || !audio.ctx) return;
            if (now - audio.lastStepAt < 0.13) return;
            audio.lastStepAt = now;
            tone({ type: "sine", f0: 90 + rand(-10, 10), f1: 70 + rand(-8, 8), dur: 0.06, gain: 0.045, curve: "lin" });
          },
          whoosh() {
            noisePop({ dur: 0.08, gain: 0.06, tilt: 0.25 });
          },
          point() {
            const base = pick([523.25, 587.33, 659.25, 783.99]);
            tone({ type: "sine", f0: base, f1: base * 1.6, dur: 0.06, gain: 0.08, curve: "lin" });
          },
          bonk() {
            tone({ type: "square", f0: 200 + rand(-20, 20), f1: 60 + rand(-5, 5), dur: 0.24, gain: 0.18, curve: "lin" });
            tone({ type: "triangle", f0: 140 + rand(-10, 10), f1: 80, dur: 0.22, gain: 0.10, curve: "lin" });
            noisePop({ dur: 0.14, gain: 0.06, tilt: 0.45 });
          },
          newHighScore() {
            const notes = [523.25, 659.25, 783.99, 1046.5];
            notes.forEach((f, i) => {
              setTimeout(() => tone({ type: "triangle", f0: f, f1: f * 1.02, dur: 0.09, gain: 0.12, curve: "lin" }), i * 60);
            });
          },
          pause() {
            tone({ type: "sine", f0: 420, f1: 300, dur: 0.10, gain: 0.06, curve: "lin" });
          },
          unpause() {
            tone({ type: "sine", f0: 300, f1: 420, dur: 0.10, gain: 0.06, curve: "lin" });
          },
        };

        function updateSoundUI() {
          const on = !!audio.enabled;
          soundDot.classList.toggle("off", !on);
          soundLabel.textContent = on ? "Sound" : "Muted";
          footerNoteEl.textContent = on
            ? "Sound is silly on purpose. First tap enables audio."
            : "Muted. Toggle sound any time (still needs first tap to unlock).";
        }

        // ---------- Game model ----------
        const STATE = { READY: "ready", RUNNING: "running", PAUSED: "paused", GAMEOVER: "gameover" };

        const storeKey = "funGameHighScoreV1";
        let highScore = Number(localStorage.getItem(storeKey) || "0") || 0;
        highScoreEl.textContent = String(highScore);

        const world = {
          state: STATE.READY,
          t: 0,
          dtSmoothed: 1 / 60,
          cameraX: 0,
          speed: 380,
          speedBase: 380,
          speedMax: 1000,
          speedRamp: 9.5, // seconds to feel faster
          score: 0,
          bestNew: false,
          lastSpawnX: 0,
          nextSpawnIn: 520,
          passedCount: 0,
          shake: 0,
          shakeT: 0,
        };

        const player = {
          x: 0,
          y: 0,
          vy: 0,
          radius: 22,
          onGround: true,
          bonusHop: true,
          wobble: 0,
          face: 0,
          hurt: 0,
          blinkAt: 0,
          blinkT: 0,
          tilt: 0,
        };

        const obstacles = [];
        const particles = [];
        const clouds = [];
        const stars = [];

        const palette = {
          skyTop: "#83d8ff",
          skyBottom: "#ffeaa7",
          sun: "#ffeaa7",
          hill1: "#6c5ce7",
          hill2: "#00b894",
          hill3: "#fd79a8",
          ground: "#2d3436",
          grass: "#55efc4",
          outline: "rgba(0,0,0,.30)",
          shadow: "rgba(0,0,0,.22)",
        };

        function resetWorld(keepHigh = true) {
          world.t = 0;
          world.cameraX = 0;
          world.speed = world.speedBase;
          world.score = 0;
          world.bestNew = false;
          world.lastSpawnX = 0;
          world.nextSpawnIn = 520;
          world.passedCount = 0;
          world.shake = 0;
          world.shakeT = 0;
          obstacles.length = 0;
          particles.length = 0;
          stars.length = 0;
          if (!keepHigh) {
            highScore = 0;
            localStorage.setItem(storeKey, "0");
            highScoreEl.textContent = "0";
          }

          player.vy = 0;
          player.onGround = true;
          player.bonusHop = true;
          player.wobble = 0;
          player.face = 0;
          player.hurt = 0;
          player.blinkAt = 0;
          player.blinkT = 0;
          player.tilt = 0;
        }

        // ---------- Geometry / sizing ----------
        const view = {
          w: 0,
          h: 0,
          dpr: 1,
          groundY: 0,
          scale: 1,
        };

        function resize() {
          const dpr = clamp(window.devicePixelRatio || 1, 1, 2);
          view.dpr = dpr;
          view.w = Math.floor(canvas.clientWidth * dpr);
          view.h = Math.floor(canvas.clientHeight * dpr);
          canvas.width = view.w;
          canvas.height = view.h;
          view.scale = Math.max(0.85, Math.min(1.2, view.h / (700 * dpr)));
          view.groundY = Math.floor(view.h * 0.78);

          // player anchor based on current view
          player.x = Math.floor(view.w * 0.22);
          player.y = view.groundY;

          // seed background elements
          if (clouds.length === 0) {
            const count = prefersReducedMotion ? 6 : 10;
            for (let i = 0; i < count; i++) {
              clouds.push({
                x: rand(0, view.w * 1.2),
                y: rand(view.h * 0.08, view.h * 0.42),
                s: rand(0.6, 1.5),
                p: rand(0, Math.PI * 2),
              });
            }
          }
          if (stars.length === 0) {
            const count = 90;
            for (let i = 0; i < count; i++) {
              stars.push({
                x: Math.random(),
                y: Math.random(),
                r: rand(0.6, 1.9),
                tw: rand(0, 1),
              });
            }
          }
        }

        // ---------- Obstacles ----------
        function spawnObstacle() {
          const s = world.speed;
          const spacing = clamp(420 - (s - world.speedBase) * 0.25, 240, 420);
          const jitter = rand(-80, 120);
          world.nextSpawnIn = spacing + jitter;

          const kind = pick(["cactus", "donut", "banana", "crate", "cone"]);
          const scale = rand(0.85, 1.25) * view.scale;
          const baseW = {
            cactus: rand(34, 54),
            donut: rand(36, 56),
            banana: rand(44, 68),
            crate: rand(40, 62),
            cone: rand(34, 50),
          }[kind];
          const baseH = {
            cactus: rand(48, 82),
            donut: rand(40, 58),
            banana: rand(28, 42),
            crate: rand(34, 54),
            cone: rand(42, 68),
          }[kind];

          const w = Math.floor(baseW * scale);
          const h = Math.floor(baseH * scale);
          const x = view.w + rand(60, 160);
          const y = view.groundY - h;

          obstacles.push({
            kind,
            x,
            y,
            w,
            h,
            passed: false,
            wob: rand(0, 10),
            hue: rand(0, 360),
          });
        }

        function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
          return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
        }

        // ---------- Particles ----------
        function puff(x, y, n = 10, color = "rgba(255,255,255,.85)") {
          for (let i = 0; i < n; i++) {
            particles.push({
              x: x + rand(-8, 8),
              y: y + rand(-4, 8),
              vx: rand(-140, 40),
              vy: rand(-140, 40),
              r: rand(3, 9) * view.scale,
              life: rand(0.35, 0.75),
              t: 0,
              color,
              kind: "puff",
            });
          }
        }

        function confetti(x, y, n = 40) {
          const colors = ["#ffeaa7", "#55efc4", "#74b9ff", "#fd79a8", "#a29bfe", "#fab1a0"];
          for (let i = 0; i < n; i++) {
            particles.push({
              x,
              y,
              vx: rand(-260, 260),
              vy: rand(-420, -120),
              r: rand(2, 6) * view.scale,
              life: rand(0.9, 1.6),
              t: 0,
              color: pick(colors),
              spin: rand(-12, 12),
              kind: "confetti",
            });
          }
        }

        function starsBurst(x, y, n = 14) {
          for (let i = 0; i < n; i++) {
            particles.push({
              x,
              y,
              vx: rand(-520, 520),
              vy: rand(-520, 140),
              r: rand(6, 12) * view.scale,
              life: rand(0.55, 1.05),
              t: 0,
              color: "rgba(255, 255, 255, .92)",
              kind: "star",
              rot: rand(0, Math.PI * 2),
            });
          }
        }

        // ---------- Drawing helpers ----------
        function setShadow(color = palette.shadow, blur = 14, ox = 0, oy = 10) {
          ctx.shadowColor = color;
          ctx.shadowBlur = blur;
          ctx.shadowOffsetX = ox;
          ctx.shadowOffsetY = oy;
        }
        function clearShadow() {
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
        function roundRect(x, y, w, h, r) {
          const rr = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          ctx.closePath();
        }
        function strokeFill(fill, stroke = palette.outline, lw = 3) {
          ctx.fillStyle = fill;
          ctx.fill();
          ctx.lineWidth = lw;
          ctx.strokeStyle = stroke;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.stroke();
        }

        function drawSky(time) {
          // Twilight candy sky with subtle stars (fun + depth)
          const g = ctx.createLinearGradient(0, 0, 0, view.h);
          g.addColorStop(0, "#7dd3fc");
          g.addColorStop(0.45, "#a78bfa");
          g.addColorStop(1, "#ffb4cc");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, view.w, view.h);

          // Stars (subtle sparkle)
          const nightMix = clamp((time % 40) / 40, 0, 1);
          ctx.save();
          ctx.globalAlpha = 0.18 + 0.12 * Math.sin(time * 0.3);
          ctx.fillStyle = "white";
          for (const st of stars) {
            const tw = 0.55 + 0.45 * Math.sin(time * 1.7 + st.tw * 10);
            const x = st.x * view.w;
            const y = st.y * view.h * 0.55;
            ctx.globalAlpha = (0.08 + 0.12 * tw) * (0.6 + 0.4 * nightMix);
            ctx.beginPath();
            ctx.arc(x, y, st.r * view.dpr, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

          // Sun / candy planet
          const sunX = view.w * 0.85;
          const sunY = view.h * 0.16;
          const sunR = 42 * view.dpr;
          const rg = ctx.createRadialGradient(sunX, sunY, 1, sunX, sunY, sunR * 4.2);
          rg.addColorStop(0, "rgba(255, 234, 167, .98)");
          rg.addColorStop(0.25, "rgba(250, 177, 160, .55)");
          rg.addColorStop(1, "rgba(255, 255, 255, 0)");
          ctx.fillStyle = rg;
          ctx.fillRect(0, 0, view.w, view.h);
          ctx.beginPath();
          ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(255, 234, 167, .95)";
          ctx.fill();
        }

        function drawCloud(x, y, s, wob) {
          ctx.save();
          ctx.translate(x, y);
          ctx.scale(s, s);
          const r = 18 * view.dpr;
          ctx.globalAlpha = 0.88;
          setShadow("rgba(0,0,0,.18)", 12, 0, 10);
          ctx.fillStyle = "rgba(255,255,255,.92)";
          ctx.beginPath();
          ctx.arc(-r * 1.3, 0, r * 1.02, 0, Math.PI * 2);
          ctx.arc(0, -r * 0.55 + wob, r * 1.25, 0, Math.PI * 2);
          ctx.arc(r * 1.35, 0, r * 0.98, 0, Math.PI * 2);
          ctx.closePath();
          ctx.fill();
          clearShadow();
          ctx.restore();
        }

        function drawHills(offsetX, yBase, amp, color, speedFactor, time) {
          const x0 = -((offsetX * speedFactor) % (view.w * 1.2));
          ctx.save();
          ctx.translate(0, yBase);
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.moveTo(x0, 0);
          const step = 40 * view.dpr;
          const totalW = view.w * 2.2;
          for (let x = 0; x <= totalW; x += step) {
            const px = x0 + x;
            const t = (x / totalW) * Math.PI * 2;
            const wave = Math.sin(t * 2 + time * 0.5) * 0.18 + Math.sin(t * 6 - time * 0.3) * 0.06;
            const y = -amp * (0.65 + 0.35 * Math.sin(t * 1.2 + 1.3)) + wave * amp * 0.35;
            ctx.lineTo(px, y);
          }
          ctx.lineTo(x0 + totalW, view.h);
          ctx.lineTo(x0, view.h);
          ctx.closePath();
          setShadow("rgba(0,0,0,.14)", 18, 0, 16);
          ctx.fill();
          clearShadow();
          ctx.restore();
        }

        function drawGround(offsetX, time) {
          const y = view.groundY;
          // dark asphalt
          ctx.fillStyle = "#1f2326";
          ctx.fillRect(0, y, view.w, view.h - y);

          // grass stripe
          const gg = ctx.createLinearGradient(0, y - 30 * view.dpr, 0, y + 30 * view.dpr);
          gg.addColorStop(0, "rgba(0,184,148,.0)");
          gg.addColorStop(0.5, "rgba(85,239,196,.92)");
          gg.addColorStop(1, "rgba(85,239,196,.0)");
          ctx.fillStyle = gg;
          ctx.fillRect(0, y - 40 * view.dpr, view.w, 80 * view.dpr);

          // stripes for motion
          const stripeW = 34 * view.dpr;
          const gap = 24 * view.dpr;
          const speedX = offsetX * 1.0;
          const xStart = -((speedX) % (stripeW + gap));
          ctx.save();
          ctx.globalAlpha = 0.35;
          for (let x = xStart; x < view.w + stripeW; x += stripeW + gap) {
            const wob = Math.sin((time * 2) + x * 0.004) * (2 * view.dpr);
            ctx.fillStyle = "rgba(255,255,255,.22)";
            roundRect(x, y + 26 * view.dpr + wob, stripeW, 9 * view.dpr, 6 * view.dpr);
            ctx.fill();
          }
          ctx.restore();
        }

        function drawPlayer(time) {
          const r = player.radius * view.dpr;
          const x = player.x;
          const y = player.y + player.wobble;
          const ground = view.groundY;
          const bob = player.onGround ? Math.sin(time * 12) * 2.2 * view.dpr : 0;
          const jumpSquash = clamp(Math.abs(player.vy) / 900, 0, 1);
          const squash = player.onGround ? 0.25 : 0.05;
          const scaleY = 1 - squash * (player.onGround ? (0.25 + jumpSquash * 0.15) : 0.05);
          const scaleX = 1 + squash * (player.onGround ? (0.25 + jumpSquash * 0.15) : 0.05);

          ctx.save();
          ctx.translate(x, y + bob);
          ctx.rotate(player.tilt);
          ctx.scale(scaleX, scaleY);

          // shadow
          ctx.save();
          ctx.globalAlpha = 0.25;
          const sh = clamp(1 - (ground - y) / (220 * view.dpr), 0.25, 1);
          ctx.fillStyle = "rgba(0,0,0,.45)";
          ctx.beginPath();
          ctx.ellipse(0, (ground - y) + 40 * view.dpr, (r * 1.2) * sh, (r * 0.42) * sh, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          // body (cartoon blob)
          setShadow("rgba(0,0,0,.22)", 18, 0, 12);
          ctx.fillStyle = "rgba(255,255,255,.25)";
          ctx.beginPath();
          ctx.arc(0, 0, r * 1.15, 0, Math.PI * 2);
          ctx.fill();
          clearShadow();

          // main suit
          const suit = ctx.createLinearGradient(-r, -r, r, r);
          suit.addColorStop(0, "#74b9ff");
          suit.addColorStop(0.55, "#a29bfe");
          suit.addColorStop(1, "#fd79a8");
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          strokeFill(suit, "rgba(0,0,0,.28)", 3 * view.dpr);

          // cheeks
          ctx.save();
          ctx.globalAlpha = 0.35 + player.face * 0.1;
          ctx.fillStyle = "#ff7675";
          ctx.beginPath();
          ctx.arc(-r * 0.45, r * 0.25, r * 0.22, 0, Math.PI * 2);
          ctx.arc(r * 0.45, r * 0.25, r * 0.22, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          // eyes
          const blink = player.blinkT > 0 ? clamp(player.blinkT, 0, 1) : 0;
          const eyeOpen = 1 - easeOutCubic(blink);
          const ey = -r * 0.15;
          const ex = r * 0.35;
          for (const side of [-1, 1]) {
            ctx.save();
            ctx.translate(ex * side, ey);
            ctx.beginPath();
            ctx.ellipse(0, 0, r * 0.18, r * 0.22 * eyeOpen + 0.0001, 0, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0,0,0,.82)";
            ctx.fill();
            if (eyeOpen > 0.2) {
              ctx.beginPath();
              ctx.arc(-r * 0.06, -r * 0.06, r * 0.06, 0, Math.PI * 2);
              ctx.fillStyle = "rgba(255,255,255,.9)";
              ctx.fill();
            }
            ctx.restore();
          }

          // mouth (changes with state)
          const mouthW = r * (0.42 + player.face * 0.12);
          const mouthY = r * (0.28 + player.face * 0.06);
          ctx.lineWidth = 4 * view.dpr;
          ctx.strokeStyle = "rgba(0,0,0,.65)";
          ctx.beginPath();
          if (player.hurt > 0.01) {
            ctx.arc(0, mouthY + r * 0.08, mouthW * 0.35, Math.PI * 1.05, Math.PI * 1.95, false);
          } else if (!player.onGround) {
            ctx.arc(0, mouthY + r * 0.04, mouthW * 0.32, 0, Math.PI * 2);
          } else {
            ctx.arc(0, mouthY, mouthW * 0.5, 0.12 * Math.PI, 0.88 * Math.PI);
          }
          ctx.stroke();

          // legs (simple run cycle)
          const run = player.onGround ? Math.sin(time * 12) : 0.0;
          const legY = r * 0.85;
          ctx.strokeStyle = "rgba(0,0,0,.32)";
          ctx.lineWidth = 5 * view.dpr;
          for (const side of [-1, 1]) {
            const phase = run * side;
            ctx.beginPath();
            ctx.moveTo(side * r * 0.35, legY - r * 0.10);
            ctx.quadraticCurveTo(side * r * (0.55 + phase * 0.20), legY + r * (0.15 + phase * 0.15), side * r * (0.40 + phase * 0.10), legY + r * 0.40);
            ctx.stroke();
            // shoe
            ctx.fillStyle = "rgba(0,0,0,.45)";
            ctx.beginPath();
            ctx.ellipse(side * r * (0.42 + phase * 0.10), legY + r * 0.46, r * 0.20, r * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }

        function drawObstacle(ob) {
          const x = ob.x;
          const y = ob.y;
          const w = ob.w;
          const h = ob.h;
          const wob = Math.sin((world.t * 2.1) + ob.wob) * (1.2 * view.dpr);
          ctx.save();
          ctx.translate(x + w / 2, y + h / 2 + wob);
          ctx.rotate(Math.sin(world.t * 1.1 + ob.wob) * 0.02);
          ctx.translate(-w / 2, -h / 2);

          if (ob.kind === "cactus") {
            setShadow("rgba(0,0,0,.22)", 16, 0, 10);
            roundRect(w * 0.28, 0, w * 0.44, h, w * 0.18);
            strokeFill("#00b894", "rgba(0,0,0,.30)", 3 * view.dpr);
            // arms
            roundRect(w * 0.04, h * 0.38, w * 0.32, h * 0.22, w * 0.14);
            strokeFill("#55efc4", "rgba(0,0,0,.30)", 3 * view.dpr);
            roundRect(w * 0.64, h * 0.22, w * 0.32, h * 0.22, w * 0.14);
            strokeFill("#55efc4", "rgba(0,0,0,.30)", 3 * view.dpr);
            clearShadow();
            // cute face
            ctx.save();
            ctx.globalAlpha = 0.75;
            ctx.fillStyle = "rgba(0,0,0,.75)";
            ctx.beginPath();
            ctx.arc(w * 0.42, h * 0.30, 3.2 * view.dpr, 0, Math.PI * 2);
            ctx.arc(w * 0.58, h * 0.30, 3.2 * view.dpr, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (ob.kind === "donut") {
            setShadow("rgba(0,0,0,.22)", 18, 0, 10);
            const cx = w / 2, cy = h / 2;
            const R = Math.min(w, h) * 0.48;
            const r = R * 0.45;
            ctx.beginPath();
            ctx.arc(cx, cy, R, 0, Math.PI * 2);
            ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
            ctx.closePath();
            const icing = ctx.createLinearGradient(0, 0, w, h);
            icing.addColorStop(0, "#fd79a8");
            icing.addColorStop(1, "#a29bfe");
            strokeFill(icing, "rgba(0,0,0,.30)", 3 * view.dpr);
            clearShadow();
            // sprinkles
            ctx.save();
            ctx.globalAlpha = 0.9;
            for (let i = 0; i < 10; i++) {
              const sx = rand(w * 0.2, w * 0.8);
              const sy = rand(h * 0.2, h * 0.8);
              const ang = rand(0, Math.PI);
              ctx.strokeStyle = pick(["#ffeaa7", "#55efc4", "#74b9ff", "#fab1a0", "#00cec9"]);
              ctx.lineWidth = 3 * view.dpr;
              ctx.beginPath();
              ctx.moveTo(sx - Math.cos(ang) * 6 * view.dpr, sy - Math.sin(ang) * 6 * view.dpr);
              ctx.lineTo(sx + Math.cos(ang) * 6 * view.dpr, sy + Math.sin(ang) * 6 * view.dpr);
              ctx.stroke();
            }
            ctx.restore();
          } else if (ob.kind === "banana") {
            setShadow("rgba(0,0,0,.22)", 16, 0, 10);
            // banana peel-ish curve
            ctx.beginPath();
            ctx.moveTo(w * 0.1, h * 0.75);
            ctx.quadraticCurveTo(w * 0.42, h * 0.05, w * 0.9, h * 0.45);
            ctx.quadraticCurveTo(w * 0.60, h * 0.56, w * 0.25, h * 0.88);
            ctx.closePath();
            strokeFill("#ffeaa7", "rgba(0,0,0,.30)", 3 * view.dpr);
            clearShadow();
            // little bruise spot
            ctx.save();
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = "#6c5ce7";
            ctx.beginPath();
            ctx.ellipse(w * 0.58, h * 0.48, w * 0.10, h * 0.12, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (ob.kind === "crate") {
            setShadow("rgba(0,0,0,.22)", 16, 0, 10);
            roundRect(0, 0, w, h, 12 * view.dpr);
            strokeFill("#fab1a0", "rgba(0,0,0,.30)", 3 * view.dpr);
            clearShadow();
            // planks
            ctx.save();
            ctx.globalAlpha = 0.35;
            ctx.strokeStyle = "rgba(0,0,0,.45)";
            ctx.lineWidth = 3 * view.dpr;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.35);
            ctx.lineTo(w, h * 0.35);
            ctx.moveTo(0, h * 0.65);
            ctx.lineTo(w, h * 0.65);
            ctx.stroke();
            ctx.restore();
            // silly label
            ctx.save();
            ctx.globalAlpha = 0.88;
            roundRect(w * 0.20, h * 0.18, w * 0.60, h * 0.24, 10 * view.dpr);
            strokeFill("rgba(255,255,255,.6)", "rgba(0,0,0,.20)", 2.5 * view.dpr);
            ctx.fillStyle = "rgba(0,0,0,.55)";
            ctx.font = `${Math.floor(14 * view.dpr)}px ui-rounded, system-ui, sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("NOPE", w * 0.50, h * 0.30);
            ctx.restore();
          } else if (ob.kind === "cone") {
            setShadow("rgba(0,0,0,.22)", 16, 0, 10);
            // traffic cone
            ctx.beginPath();
            ctx.moveTo(w * 0.50, 0);
            ctx.lineTo(w * 0.95, h);
            ctx.lineTo(w * 0.05, h);
            ctx.closePath();
            strokeFill("#ff7675", "rgba(0,0,0,.30)", 3 * view.dpr);
            clearShadow();
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = "rgba(255,255,255,.75)";
            roundRect(w * 0.18, h * 0.45, w * 0.64, h * 0.14, 8 * view.dpr);
            ctx.fill();
            ctx.restore();
          }
          ctx.restore();
        }

        function drawParticles() {
          for (const p of particles) {
            const t = clamp(p.t / p.life, 0, 1);
            const a = 1 - t;
            ctx.save();
            ctx.globalAlpha = a;
            if (p.kind === "puff") {
              ctx.fillStyle = p.color;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.r * (1 + t * 0.35), 0, Math.PI * 2);
              ctx.fill();
            } else if (p.kind === "confetti") {
              ctx.translate(p.x, p.y);
              ctx.rotate((p.spin || 0) * (0.2 + t));
              ctx.fillStyle = p.color;
              roundRect(-p.r, -p.r * 0.6, p.r * 2.0, p.r * 1.2, p.r * 0.5);
              ctx.fill();
            } else if (p.kind === "star") {
              ctx.translate(p.x, p.y);
              ctx.rotate(p.rot + t * 6);
              ctx.fillStyle = p.color;
              const R = p.r * (1 + t * 0.4);
              const r = R * 0.45;
              ctx.beginPath();
              for (let i = 0; i < 10; i++) {
                const ang = (i / 10) * Math.PI * 2;
                const rr = i % 2 === 0 ? R : r;
                ctx.lineTo(Math.cos(ang) * rr, Math.sin(ang) * rr);
              }
              ctx.closePath();
              ctx.fill();
            }
            ctx.restore();
          }
        }

        // ---------- Loop ----------
        let raf = 0;
        let last = performance.now();

        function update(dt) {
          const dtClamped = clamp(dt, 0, 0.05);
          world.dtSmoothed = lerp(world.dtSmoothed, dtClamped, 0.08);

          if (world.state === STATE.PAUSED) {
            // tiny ambient motion even when paused
            world.t += dtClamped * 0.25;
            return;
          }

          world.t += dtClamped;
          if (world.state !== STATE.RUNNING) return;

          // speed ramps up over time (increasing difficulty)
          const rampT = 1 - Math.exp(-world.t / world.speedRamp);
          world.speed = clamp(lerp(world.speedBase, world.speedMax, rampT), world.speedBase, world.speedMax);
          world.cameraX += world.speed * dtClamped;

          // score (distance-ish)
          world.score += dtClamped * (10 + (world.speed - world.speedBase) * 0.015);

          // player physics
          const g = 2600 * view.dpr;
          const jumpGravityBoost = player.vy > 0 ? 1.08 : 1.0;
          player.vy += g * jumpGravityBoost * dtClamped;
          player.y += player.vy * dtClamped;

          if (player.y >= view.groundY) {
            if (!player.onGround) {
              puff(player.x, view.groundY + 12 * view.dpr, 8, "rgba(255,255,255,.65)");
              if (!prefersReducedMotion) world.shake = Math.max(world.shake, 0.55);
              sfx.step(audio.ctx ? audio.ctx.currentTime : 0);
            }
            player.y = view.groundY;
            player.vy = 0;
            player.onGround = true;
            player.bonusHop = true;
            player.tilt = lerp(player.tilt, 0, 0.25);
          } else {
            player.onGround = false;
            player.tilt = lerp(player.tilt, clamp(-player.vy / (1600 * view.dpr), -0.35, 0.35), 0.10);
          }

          // blink sometimes
          if (player.blinkAt <= 0) player.blinkAt = rand(1.4, 4.2);
          player.blinkAt -= dtClamped;
          if (player.blinkAt <= 0) player.blinkT = 1;
          if (player.blinkT > 0) player.blinkT = Math.max(0, player.blinkT - dtClamped * 9);

          // step sounds while running
          if (player.onGround) sfx.step(audio.ctx ? audio.ctx.currentTime : 0);

          // spawn obstacles
          world.lastSpawnX += world.speed * dtClamped;
          if (world.lastSpawnX >= world.nextSpawnIn) {
            world.lastSpawnX = 0;
            spawnObstacle();
          }

          // move obstacles + collision
          const px = player.x;
          const pr = player.radius * view.dpr;
          const pBox = {
            x: px - pr * 0.75,
            y: player.y - pr * 1.1,
            w: pr * 1.5,
            h: pr * 1.7,
          };

          for (let i = obstacles.length - 1; i >= 0; i--) {
            const ob = obstacles[i];
            ob.x -= world.speed * dtClamped;
            if (!ob.passed && ob.x + ob.w < px - pr * 0.2) {
              ob.passed = true;
              world.passedCount++;
              if (world.passedCount % 3 === 0) sfx.point();
              if (world.passedCount % 7 === 0) confetti(px + 40 * view.dpr, player.y - 30 * view.dpr, 10);
            }
            if (ob.x + ob.w < -120 * view.dpr) {
              obstacles.splice(i, 1);
              continue;
            }

            // collision (slightly forgiving)
            const pad = 6 * view.dpr;
            const hit = rectsOverlap(
              pBox.x, pBox.y, pBox.w, pBox.h,
              ob.x + pad, ob.y + pad, ob.w - pad * 2, ob.h - pad * 2
            );
            if (hit) {
              gameOver();
              return;
            }
          }

          // particles update
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.t += dtClamped;
            p.x += p.vx * dtClamped;
            p.y += p.vy * dtClamped;
            p.vy += 1600 * view.dpr * dtClamped;
            if (p.kind === "confetti") p.vx *= (1 - dtClamped * 0.4);
            if (p.t >= p.life) particles.splice(i, 1);
          }

          // screen shake decay
          if (world.shake > 0) {
            world.shakeT += dtClamped;
            world.shake = Math.max(0, world.shake - dtClamped * 1.6);
          }
        }

        function render() {
          const t = world.t;

          // camera shake
          let sx = 0, sy = 0;
          if (!prefersReducedMotion && world.shake > 0.001) {
            const s = world.shake;
            sx = Math.sin(world.shakeT * 40) * 8 * view.dpr * s + rand(-2, 2) * view.dpr * s;
            sy = Math.cos(world.shakeT * 36) * 6 * view.dpr * s + rand(-2, 2) * view.dpr * s;
          }

          ctx.save();
          ctx.translate(sx, sy);
          drawSky(t);

          // parallax layers
          const offsetX = world.cameraX;
          drawHills(offsetX, view.groundY - 190 * view.dpr, 110 * view.dpr, "rgba(108,92,231,.55)", 0.18, t);
          drawHills(offsetX, view.groundY - 140 * view.dpr, 95 * view.dpr, "rgba(0,184,148,.55)", 0.28, t);
          drawHills(offsetX, view.groundY - 95 * view.dpr, 70 * view.dpr, "rgba(253,121,168,.55)", 0.40, t);

          // clouds
          ctx.save();
          const cloudDrift = (offsetX * 0.10) % (view.w * 2.2);
          for (const c of clouds) {
            const wob = Math.sin(t * 0.9 + c.p) * 4 * view.dpr;
            const x = (c.x - cloudDrift) % (view.w * 2.2);
            drawCloud(x - view.w * 0.2, c.y, c.s, wob);
            drawCloud(x - view.w * 0.2 + view.w * 2.2, c.y, c.s, wob);
          }
          ctx.restore();

          drawGround(offsetX, t);

          // obstacles
          for (const ob of obstacles) drawObstacle(ob);

          // player
          drawPlayer(t);

          // particles
          drawParticles();

          ctx.restore();
        }

        function tick(now) {
          const dt = (now - last) / 1000;
          last = now;
          update(dt);
          render();
          updateHUD();
          raf = requestAnimationFrame(tick);
        }

        function updateHUD() {
          const score = Math.floor(world.score);
          scoreEl.textContent = String(score);
          highScoreEl.textContent = String(highScore);
          const speedMult = world.speed / world.speedBase;
          speedEl.textContent = `${speedMult.toFixed(1)}×`;
          const hopReady = world.state === STATE.RUNNING ? (player.onGround || player.bonusHop) : true;
          hopEl.textContent = hopReady ? "Ready" : "Used";
          hopEl.classList.toggle("good", hopReady);
          hopEl.classList.toggle("bad", !hopReady);
          pauseBtn.textContent = world.state === STATE.PAUSED ? "Resume" : "Pause";
        }

        function setOverlay(visible) {
          overlayEl.style.display = visible ? "grid" : "none";
        }

        function announce(text) {
          ariaLive.textContent = "";
          setTimeout(() => (ariaLive.textContent = text), 10);
        }

        function startGame() {
          unlockAudio();
          resetWorld(true);
          world.state = STATE.RUNNING;
          setOverlay(false);
          startBtn.style.display = "none";
          retryBtn.style.display = "none";
          shareBtn.style.display = "none";
          headlineEl.textContent = "Jump over obstacles.";
          subheadEl.textContent = "Survive as long as you can while the world gets faster and sillier.";
          player.face = 0;
          announce("Game started.");
          sfx.whoosh();
        }

        function pauseToggle() {
          unlockAudio();
          if (world.state === STATE.RUNNING) {
            world.state = STATE.PAUSED;
            setOverlay(true);
            retryBtn.style.display = "inline-block";
            shareBtn.style.display = "inline-block";
            startBtn.style.display = "inline-block";
            startBtn.textContent = "Resume";
            headlineEl.textContent = "Paused.";
            subheadEl.textContent = "Stretch your thumbs. The obstacles will still be there. Probably.";
            sfx.pause();
            announce("Paused.");
          } else if (world.state === STATE.PAUSED) {
            world.state = STATE.RUNNING;
            setOverlay(false);
            startBtn.style.display = "none";
            sfx.unpause();
            announce("Resumed.");
          }
        }

        function gameOver() {
          if (world.state !== STATE.RUNNING) return;
          world.state = STATE.GAMEOVER;
          player.hurt = 1;
          player.face = 1;
          world.shake = Math.max(world.shake, 1.0);
          starsBurst(player.x + 18 * view.dpr, player.y - 20 * view.dpr, 16);
          confetti(player.x + 10 * view.dpr, player.y - 40 * view.dpr, 22);
          sfx.bonk();

          const score = Math.floor(world.score);
          const wasNew = score > highScore;
          if (wasNew) {
            highScore = score;
            localStorage.setItem(storeKey, String(highScore));
            world.bestNew = true;
            setTimeout(() => sfx.newHighScore(), 120);
          }

          headlineEl.textContent = wasNew ? "New high score!" : "Bonk! Game over.";
          subheadEl.textContent = wasNew
            ? "Your cartoon legend grows. Try to beat yourself again."
            : "That obstacle was clearly cheating. Try again!";
          startBtn.style.display = "none";
          retryBtn.style.display = "inline-block";
          shareBtn.style.display = "inline-block";
          setOverlay(true);
          announce(wasNew ? "New high score." : "Game over.");
        }

        function doJump() {
          unlockAudio();
          if (world.state === STATE.READY) {
            startGame();
            return;
          }
          if (world.state === STATE.GAMEOVER) return;
          if (world.state === STATE.PAUSED) return;
          if (world.state !== STATE.RUNNING) return;

          const jumpV = -980 * view.dpr;
          if (player.onGround) {
            player.vy = jumpV;
            player.onGround = false;
            player.face = 0.4;
            puff(player.x - 10 * view.dpr, view.groundY + 10 * view.dpr, 10, "rgba(255,255,255,.65)");
            sfx.jump();
          } else if (player.bonusHop) {
            player.bonusHop = false;
            player.vy = jumpV * 0.86;
            player.face = 0.7;
            puff(player.x - 10 * view.dpr, player.y + 20 * view.dpr, 8, "rgba(255,255,255,.55)");
            sfx.bonusHop();
          } else {
            // tiny sad chirp
            tone({ type: "sine", f0: 240, f1: 220, dur: 0.06, gain: 0.03, curve: "lin" });
          }
        }

        function retry() {
          unlockAudio();
          startGame();
        }

        function copyScore() {
          const score = Math.floor(world.score);
          const text = `Fun Game — I survived ${score} points! High score: ${highScore}.`;
          if (!navigator.clipboard) {
            announce("Clipboard not available.");
            return;
          }
          navigator.clipboard.writeText(text).then(
            () => {
              announce("Copied score to clipboard.");
              tone({ type: "triangle", f0: 660, f1: 880, dur: 0.09, gain: 0.08, curve: "lin" });
            },
            () => announce("Could not copy score.")
          );
        }

        function toggleSound() {
          audio.enabled = !audio.enabled;
          updateSoundUI();
          unlockAudio();
          if (audio.enabled) sfx.point();
        }

        function setStateReady() {
          world.state = STATE.READY;
          resetWorld(true);
          setOverlay(true);
          startBtn.style.display = "inline-block";
          startBtn.textContent = "Start";
          retryBtn.style.display = "none";
          shareBtn.style.display = "none";
          headlineEl.textContent = "Jump over obstacles.";
          subheadEl.textContent = "Survive as long as you can while the world gets faster and sillier.";
        }

        // ---------- Events ----------
        function onKey(e) {
          const k = e.key.toLowerCase();
          if (k === " " || k === "arrowup" || k === "w") {
            e.preventDefault();
            doJump();
          } else if (k === "r") {
            e.preventDefault();
            if (world.state === STATE.GAMEOVER || world.state === STATE.PAUSED) retry();
          } else if (k === "p") {
            e.preventDefault();
            if (world.state === STATE.RUNNING || world.state === STATE.PAUSED) pauseToggle();
          } else if (k === "m") {
            e.preventDefault();
            toggleSound();
          } else if (k === "escape") {
            e.preventDefault();
            if (world.state === STATE.RUNNING || world.state === STATE.PAUSED) pauseToggle();
          }
        }

        function onPointer(e) {
          e.preventDefault();
          doJump();
        }

        // ---------- Init ----------
        ensureAudio();
        updateSoundUI();
        resize();
        window.addEventListener("resize", resize, { passive: true });
        window.addEventListener("keydown", onKey, { passive: false });
        canvas.addEventListener("pointerdown", onPointer, { passive: false });

        startBtn.addEventListener("click", (e) => {
          e.preventDefault();
          if (world.state === STATE.PAUSED) pauseToggle();
          else startGame();
        });
        retryBtn.addEventListener("click", (e) => {
          e.preventDefault();
          retry();
        });
        shareBtn.addEventListener("click", (e) => {
          e.preventDefault();
          copyScore();
        });
        pauseBtn.addEventListener("click", (e) => {
          e.preventDefault();
          if (world.state === STATE.RUNNING || world.state === STATE.PAUSED) pauseToggle();
        });
        soundBtn.addEventListener("click", (e) => {
          e.preventDefault();
          toggleSound();
        });

        // Tap anywhere on overlay to jump/start (except buttons)
        overlayEl.addEventListener("pointerdown", (e) => {
          const target = e.target;
          if (target && (target.tagName === "BUTTON" || target.closest("button"))) return;
          onPointer(e);
        }, { passive: false });

        // Keep ambient animation in READY (a little bounce)
        setStateReady();

        // Gentle idle motion when not running
        setInterval(() => {
          if (world.state === STATE.RUNNING) return;
          player.wobble = Math.sin(performance.now() / 400) * (2.2 * view.dpr);
          player.face = lerp(player.face, 0, 0.1);
          player.hurt = lerp(player.hurt, 0, 0.08);
        }, 33);

        // Start loop
        last = performance.now();
        raf = requestAnimationFrame(tick);

        // Visibility pause
        document.addEventListener("visibilitychange", () => {
          if (document.hidden && world.state === STATE.RUNNING) pauseToggle();
        });

        // Prevent iOS double-tap zoom on canvas
        canvas.style.touchAction = "manipulation";
      })();
    </script>
  </body>
</html>
