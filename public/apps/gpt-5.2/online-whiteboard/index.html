<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark light" />
    <title>Online Whiteboard</title>
    <style>
      :root {
        --bg0: #0b1020;
        --bg1: #0b1224;
        --panel: rgba(18, 24, 40, 0.72);
        --panel2: rgba(18, 24, 40, 0.48);
        --stroke: rgba(255, 255, 255, 0.14);
        --stroke2: rgba(255, 255, 255, 0.08);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.68);
        --muted2: rgba(255, 255, 255, 0.46);
        --shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
        --shadow2: 0 12px 30px rgba(0, 0, 0, 0.35);
        --accent: #7c5cff;
        --accent2: #2dd4bf;
        --danger: #ff4d6d;
        --warn: #ffd166;
        --ok: #23c483;
        --radius: 14px;
        --radius2: 11px;
        --blur: 14px;
        --gap: 10px;
        --tool: 44px;
        --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      [data-theme="light"] {
        --bg0: #f6f8ff;
        --bg1: #f1f5ff;
        --panel: rgba(255, 255, 255, 0.74);
        --panel2: rgba(255, 255, 255, 0.5);
        --stroke: rgba(15, 23, 42, 0.12);
        --stroke2: rgba(15, 23, 42, 0.08);
        --text: rgba(15, 23, 42, 0.92);
        --muted: rgba(15, 23, 42, 0.68);
        --muted2: rgba(15, 23, 42, 0.48);
        --shadow: 0 18px 60px rgba(2, 6, 23, 0.16);
        --shadow2: 0 12px 30px rgba(2, 6, 23, 0.12);
        --accent: #5b49ff;
        --accent2: #0ea5e9;
        --danger: #e11d48;
        --warn: #f59e0b;
        --ok: #16a34a;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: var(--font);
        color: var(--text);
        background: radial-gradient(1200px 800px at 18% 14%, rgba(124, 92, 255, 0.2), transparent 55%),
          radial-gradient(900px 700px at 82% 16%, rgba(45, 212, 191, 0.18), transparent 55%),
          radial-gradient(900px 700px at 54% 85%, rgba(255, 77, 109, 0.11), transparent 52%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        overflow: hidden;
      }

      #app {
        height: 100%;
        display: grid;
        grid-template-rows: auto 1fr;
      }

      .toolbar {
        position: relative;
        z-index: 5;
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 12px;
        padding: 10px 12px;
      }
      .toolbar::before {
        content: "";
        position: absolute;
        inset: 0;
        border-bottom: 1px solid var(--stroke2);
        background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), transparent);
        pointer-events: none;
      }

      .glass {
        background: var(--panel);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        border: 1px solid var(--stroke);
        border-radius: var(--radius);
        box-shadow: var(--shadow2);
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
      }
      .logo {
        width: 34px;
        height: 34px;
        border-radius: 12px;
        background: radial-gradient(24px 24px at 30% 30%, rgba(255, 255, 255, 0.24), transparent 60%),
          linear-gradient(135deg, rgba(124, 92, 255, 1), rgba(45, 212, 191, 1));
        box-shadow: 0 14px 30px rgba(124, 92, 255, 0.22);
        position: relative;
        overflow: hidden;
      }
      .logo::after {
        content: "";
        position: absolute;
        inset: -30% -30%;
        background: conic-gradient(from 180deg, rgba(255, 255, 255, 0.15), transparent 30%, rgba(255, 255, 255, 0.1));
        animation: spin 10s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .brand h1 {
        margin: 0;
        font-size: 14px;
        letter-spacing: 0.2px;
      }
      .brand .sub {
        font-size: 12px;
        color: var(--muted2);
        margin-top: 2px;
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        background: var(--panel2);
      }
      .pill strong {
        font-weight: 650;
      }

      .centerRow {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--gap);
        padding: 8px;
      }
      .rightRow {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: var(--gap);
        padding: 8px;
      }

      .toolstrip {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .btn {
        -webkit-tap-highlight-color: transparent;
        appearance: none;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        border-radius: 12px;
        cursor: pointer;
        transition: transform 0.08s ease, background 0.16s ease, border-color 0.16s ease, box-shadow 0.16s ease;
        user-select: none;
        font: inherit;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn:hover {
        background: rgba(255, 255, 255, 0.08);
      }
      .btn[aria-pressed="true"] {
        border-color: rgba(124, 92, 255, 0.65);
        box-shadow: 0 0 0 4px rgba(124, 92, 255, 0.16);
        background: rgba(124, 92, 255, 0.16);
      }
      .tool {
        width: var(--tool);
        height: var(--tool);
        display: grid;
        place-items: center;
        padding: 0;
      }
      .tool svg {
        width: 22px;
        height: 22px;
        opacity: 0.95;
      }
      .divider {
        width: 1px;
        height: 26px;
        background: var(--stroke);
        margin: 0 4px;
      }

      .label {
        font-size: 12px;
        color: var(--muted);
        margin-right: 6px;
        white-space: nowrap;
      }
      .control {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.04);
      }
      .control input[type="range"] {
        width: 140px;
      }
      .control input[type="color"] {
        width: 34px;
        height: 34px;
        border: none;
        background: transparent;
        padding: 0;
        cursor: pointer;
      }

      .smallBtn {
        padding: 9px 10px;
        border-radius: 12px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .smallBtn svg {
        width: 18px;
        height: 18px;
      }
      .danger {
        border-color: rgba(255, 77, 109, 0.35);
        background: rgba(255, 77, 109, 0.09);
      }

      #board {
        position: relative;
        height: 100%;
        overflow: hidden;
      }

      #board[data-grid="dots"] {
        background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.14) 1px, transparent 1px);
        background-size: 22px 22px;
        background-position: 0 0;
      }
      #board[data-grid="lines"] {
        background-image: linear-gradient(rgba(255, 255, 255, 0.09) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.09) 1px, transparent 1px);
        background-size: 28px 28px;
        background-position: 0 0;
      }
      [data-theme="light"] #board[data-grid="dots"] {
        background-image: radial-gradient(circle at 1px 1px, rgba(15, 23, 42, 0.14) 1px, transparent 1px);
      }
      [data-theme="light"] #board[data-grid="lines"] {
        background-image: linear-gradient(rgba(15, 23, 42, 0.12) 1px, transparent 1px),
          linear-gradient(90deg, rgba(15, 23, 42, 0.12) 1px, transparent 1px);
      }

      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
      }
      #overlay {
        pointer-events: none;
      }

      .floatingInput {
        position: absolute;
        min-width: 140px;
        max-width: min(560px, 80vw);
        background: var(--panel);
        border: 1px solid var(--stroke);
        border-radius: 12px;
        padding: 10px 12px;
        box-shadow: var(--shadow);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        color: var(--text);
      }
      .floatingInput textarea {
        width: 100%;
        min-height: 54px;
        resize: both;
        background: transparent;
        border: none;
        outline: none;
        color: inherit;
        font: 500 16px/1.28 var(--font);
      }
      .floatingInput .hint {
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted2);
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }

      .modalBackdrop {
        position: absolute;
        inset: 0;
        z-index: 20;
        background: rgba(0, 0, 0, 0.45);
        display: grid;
        place-items: center;
        padding: 18px;
      }
      .modal {
        width: min(720px, 100%);
        border-radius: 18px;
        border: 1px solid var(--stroke);
        background: var(--panel);
        box-shadow: var(--shadow);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        overflow: hidden;
      }
      .modalHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 14px 16px;
        border-bottom: 1px solid var(--stroke2);
      }
      .modalHeader h2 {
        margin: 0;
        font-size: 14px;
        letter-spacing: 0.2px;
      }
      .modalBody {
        padding: 16px;
        display: grid;
        gap: 12px;
      }
      .modalFooter {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        padding: 14px 16px;
        border-top: 1px solid var(--stroke2);
        background: rgba(255, 255, 255, 0.03);
      }

      .field {
        display: grid;
        gap: 6px;
      }
      .field label {
        font-size: 12px;
        color: var(--muted);
      }
      .field input[type="text"],
      .field select {
        width: 100%;
        height: 40px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        padding: 0 12px;
        outline: none;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      @media (max-width: 860px) {
        .toolbar {
          grid-template-columns: 1fr;
          gap: 10px;
        }
        .control input[type="range"] {
          width: 120px;
        }
      }
      @media (max-width: 520px) {
        .row {
          grid-template-columns: 1fr;
        }
        .control input[type="range"] {
          width: 98px;
        }
        .brand .sub {
          display: none;
        }
      }

      .toastArea {
        position: absolute;
        left: 12px;
        bottom: 12px;
        z-index: 30;
        display: grid;
        gap: 8px;
        pointer-events: none;
      }
      .toast {
        pointer-events: none;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: rgba(0, 0, 0, 0.35);
        color: rgba(255, 255, 255, 0.92);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.25);
        font-size: 13px;
        line-height: 1.22;
        max-width: min(520px, 86vw);
        transform: translateY(0);
        animation: toastIn 200ms ease-out;
      }
      [data-theme="light"] .toast {
        background: rgba(255, 255, 255, 0.7);
        color: rgba(15, 23, 42, 0.92);
      }
      @keyframes toastIn {
        from {
          transform: translateY(10px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        padding: 2px 7px;
        border-radius: 8px;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
      }

      a,
      a:visited {
        color: inherit;
      }
      .hintText {
        color: var(--muted2);
        font-size: 12px;
        line-height: 1.3;
      }
      .miniList {
        display: grid;
        gap: 8px;
      }
      .miniList .item {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 12px;
        border: 1px solid var(--stroke2);
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03);
      }
      .miniList .item .lhs {
        display: grid;
        gap: 3px;
      }
      .miniList .item .lhs .t {
        font-size: 13px;
        font-weight: 600;
      }
      .miniList .item .lhs .d {
        font-size: 12px;
        color: var(--muted2);
      }

      .tooltip {
        position: relative;
      }
      .tooltip::after {
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        bottom: calc(100% + 10px);
        transform: translateX(-50%);
        font-size: 12px;
        white-space: nowrap;
        background: rgba(0, 0, 0, 0.68);
        color: rgba(255, 255, 255, 0.92);
        padding: 7px 9px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 14px 34px rgba(0, 0, 0, 0.35);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.14s ease, transform 0.14s ease;
        transform-origin: bottom center;
        transform: translateX(-50%) translateY(4px) scale(0.98);
      }
      .tooltip:hover::after {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
      }

      .srOnly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
    </style>
  </head>
  <body>
    <div id="app" data-theme="dark">
      <header class="toolbar">
        <div class="brand glass">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1>Online Whiteboard</h1>
            <div class="sub">
              <span class="pill" id="roomPill" role="button" tabindex="0" title="Change room">
                <span aria-hidden="true">Room</span>
                <strong id="roomName">lobby</strong>
              </span>
              <span class="pill" title="Local collaboration via tabs/windows">
                <span aria-hidden="true">Peers</span>
                <strong id="peerCount">1</strong>
              </span>
            </div>
          </div>
        </div>

        <div class="centerRow glass">
          <div class="toolstrip" role="toolbar" aria-label="Tools">
            <button class="btn tool tooltip" data-tool="pen" aria-pressed="true" aria-label="Pen" data-tip="Pen (P)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
                <path d="M12.2 20.4l-8.1 1.6 1.6-8.1L16.9 2.7a2.2 2.2 0 0 1 3.1 0l1.3 1.3a2.2 2.2 0 0 1 0 3.1z"></path>
                <path d="M14.3 4.7l5 5"></path>
              </svg>
            </button>
            <button class="btn tool tooltip" data-tool="highlighter" aria-pressed="false" aria-label="Highlighter" data-tip="Highlighter (H)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 3l7 7-9.5 9.5H2.5V12.5z"></path>
                <path d="M7.2 7.8l9 9"></path>
              </svg>
            </button>
            <button class="btn tool tooltip" data-tool="eraser" aria-pressed="false" aria-label="Eraser" data-tip="Eraser (E)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                <path d="M7 21h10"></path>
                <path d="M19 16l-7 7-7-7L14.5 6.5a2.1 2.1 0 0 1 3 0l1.5 1.5a2.1 2.1 0 0 1 0 3z"></path>
              </svg>
            </button>
            <div class="divider" aria-hidden="true"></div>
            <button class="btn tool tooltip" data-tool="line" aria-pressed="false" aria-label="Line" data-tip="Line (L)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
                <path d="M5 19L19 5"></path>
                <path d="M8 6h2"></path>
              </svg>
            </button>
            <button class="btn tool tooltip" data-tool="rect" aria-pressed="false" aria-label="Rectangle" data-tip="Rectangle (R)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
                <rect x="5" y="6" width="14" height="12" rx="2"></rect>
              </svg>
            </button>
            <button class="btn tool tooltip" data-tool="ellipse" aria-pressed="false" aria-label="Ellipse" data-tip="Ellipse (O)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
                <ellipse cx="12" cy="12" rx="7" ry="5.5"></ellipse>
              </svg>
            </button>
            <button class="btn tool tooltip" data-tool="arrow" aria-pressed="false" aria-label="Arrow" data-tip="Arrow (A)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                <path d="M5 19L18 6"></path>
                <path d="M12 6h6v6"></path>
              </svg>
            </button>
            <button class="btn tool tooltip" data-tool="text" aria-pressed="false" aria-label="Text" data-tip="Text (T)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                <path d="M6 6h12"></path>
                <path d="M12 6v14"></path>
                <path d="M9 20h6"></path>
              </svg>
            </button>
          </div>
        </div>

        <div class="rightRow glass" aria-label="Controls">
          <div class="control tooltip" data-tip="Color">
            <span class="label">Color</span>
            <input id="color" type="color" value="#f8fafc" aria-label="Color" />
          </div>
          <div class="control tooltip" data-tip="Brush size">
            <span class="label">Size</span>
            <input id="size" type="range" min="1" max="64" value="10" />
            <span class="label" id="sizeLabel" style="min-width: 28px; text-align: right">10</span>
          </div>
          <div class="control tooltip" data-tip="Opacity">
            <span class="label">Opacity</span>
            <input id="opacity" type="range" min="0.05" max="1" value="1" step="0.05" />
            <span class="label" id="opacityLabel" style="min-width: 36px; text-align: right">100%</span>
          </div>
          <button class="btn smallBtn tooltip" id="undoBtn" data-tip="Undo (Ctrl/⌘ Z)" aria-label="Undo">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 14l-4-4 4-4"></path>
              <path d="M5 10h9a6 6 0 1 1 0 12h-4"></path>
            </svg>
            <span style="font-size: 12px; color: var(--muted)">Undo</span>
          </button>
          <button class="btn smallBtn tooltip" id="redoBtn" data-tip="Redo (Ctrl/⌘ Shift Z)" aria-label="Redo">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M15 14l4-4-4-4"></path>
              <path d="M19 10H10a6 6 0 1 0 0 12h4"></path>
            </svg>
            <span style="font-size: 12px; color: var(--muted)">Redo</span>
          </button>
          <button class="btn smallBtn danger tooltip" id="clearBtn" data-tip="Clear (Shift+Backspace)" aria-label="Clear board">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M3 6h18"></path>
              <path d="M8 6v14"></path>
              <path d="M16 6v14"></path>
              <path d="M6 6l1-2h10l1 2"></path>
            </svg>
            <span style="font-size: 12px; color: var(--muted)">Clear</span>
          </button>
          <button class="btn smallBtn tooltip" id="saveBtn" data-tip="Save image (Ctrl/⌘ S)" aria-label="Save image">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
              <path d="M17 21v-8H7v8"></path>
              <path d="M7 3v5h8"></path>
            </svg>
            <span style="font-size: 12px; color: var(--muted)">Save</span>
          </button>
          <button class="btn smallBtn tooltip" id="moreBtn" data-tip="Settings & help (?)" aria-label="Settings and help">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <path d="M9.5 9.5a2.5 2.5 0 0 1 5 0c0 2-2.5 2-2.5 4"></path>
              <path d="M12 17h.01"></path>
            </svg>
            <span style="font-size: 12px; color: var(--muted)">Help</span>
          </button>
        </div>
      </header>

      <main id="board" data-grid="dots" aria-label="Drawing surface">
        <canvas id="canvas"></canvas>
        <canvas id="overlay"></canvas>
      </main>

      <div id="modalRoot" class="modalBackdrop" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
          <div class="modalHeader">
            <h2 id="modalTitle">Settings</h2>
            <button class="btn tool" id="closeModalBtn" aria-label="Close">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
                <path d="M6 6l12 12"></path>
                <path d="M18 6l-12 12"></path>
              </svg>
            </button>
          </div>
          <div class="modalBody">
            <div class="row">
              <div class="field">
                <label for="roomInput">Room (collaborate across tabs)</label>
                <input id="roomInput" type="text" spellcheck="false" autocomplete="off" />
                <div class="hintText">Open this page in another tab/window with the same room to draw together.</div>
              </div>
              <div class="field">
                <label for="gridSelect">Background grid</label>
                <select id="gridSelect">
                  <option value="off">Off</option>
                  <option value="dots">Dots</option>
                  <option value="lines">Lines</option>
                </select>
                <div class="hintText">Grid is visual; you can choose to include it in exports.</div>
              </div>
            </div>
            <div class="row">
              <div class="field">
                <label for="themeSelect">Theme</label>
                <select id="themeSelect">
                  <option value="dark">Dark</option>
                  <option value="light">Light</option>
                  <option value="system">System</option>
                </select>
                <div class="hintText">Uses your OS preference when set to System.</div>
              </div>
              <div class="field">
                <label for="exportBgSelect">Save image background</label>
                <select id="exportBgSelect">
                  <option value="auto">Match current background</option>
                  <option value="transparent">Transparent</option>
                  <option value="solid">Solid</option>
                </select>
                <div class="hintText">Transparent is great for pasting into slides.</div>
              </div>
            </div>

            <div class="row">
              <div class="field">
                <label for="exportScale">Save image scale</label>
                <select id="exportScale">
                  <option value="1">1×</option>
                  <option value="2" selected>2×</option>
                  <option value="3">3×</option>
                </select>
                <div class="hintText">Higher scale gives crisper exports.</div>
              </div>
              <div class="field">
                <label for="pressureToggle">Pen pressure</label>
                <select id="pressureToggle">
                  <option value="on" selected>On</option>
                  <option value="off">Off</option>
                </select>
                <div class="hintText">Uses stylus pressure when available.</div>
              </div>
            </div>

            <div class="miniList" aria-label="Keyboard shortcuts">
              <div class="item">
                <div class="lhs">
                  <div class="t">Tools</div>
                  <div class="d">Pen / Highlighter / Eraser / Shapes / Text</div>
                </div>
                <div>
                  <span class="kbd">P</span>
                  <span class="kbd">H</span>
                  <span class="kbd">E</span>
                  <span class="kbd">L</span>
                  <span class="kbd">R</span>
                  <span class="kbd">O</span>
                  <span class="kbd">A</span>
                  <span class="kbd">T</span>
                </div>
              </div>
              <div class="item">
                <div class="lhs">
                  <div class="t">Undo / Redo</div>
                  <div class="d">Local undo with room resync</div>
                </div>
                <div>
                  <span class="kbd">Ctrl/⌘</span> <span class="kbd">Z</span>
                  <span class="kbd">Shift</span> <span class="kbd">Ctrl/⌘</span> <span class="kbd">Z</span>
                </div>
              </div>
              <div class="item">
                <div class="lhs">
                  <div class="t">Save</div>
                  <div class="d">Downloads a PNG</div>
                </div>
                <div><span class="kbd">Ctrl/⌘</span> <span class="kbd">S</span></div>
              </div>
              <div class="item">
                <div class="lhs">
                  <div class="t">Clear</div>
                  <div class="d">Clears for everyone in the room</div>
                </div>
                <div><span class="kbd">Shift</span> <span class="kbd">Backspace</span></div>
              </div>
              <div class="item">
                <div class="lhs">
                  <div class="t">Shape modifiers</div>
                  <div class="d">Constrain / draw from center</div>
                </div>
                <div><span class="kbd">Shift</span> / <span class="kbd">Alt</span></div>
              </div>
            </div>
          </div>
          <div class="modalFooter">
            <button class="btn smallBtn tooltip" id="copyLinkBtn" data-tip="Copy room link" aria-label="Copy link">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1"></path>
                <path d="M14 11a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1"></path>
              </svg>
              Copy link
            </button>
            <button class="btn smallBtn danger" id="resetLocalBtn" aria-label="Reset local storage">Reset local</button>
            <button class="btn smallBtn" id="applySettingsBtn" aria-label="Apply settings">Apply</button>
          </div>
        </div>
      </div>

      <div id="toastArea" class="toastArea" aria-live="polite" aria-atomic="true"></div>
      <div class="srOnly" id="liveRegion" aria-live="assertive"></div>
    </div>

    <script>
      (() => {
        "use strict";

        const $ = (sel) => document.querySelector(sel);
        const $$ = (sel) => Array.from(document.querySelectorAll(sel));

        const STORAGE_KEY = "onlineWhiteboard.v1";
        const MAX_POINTS_PER_STROKE = 8000;

        const appEl = $("#app");
        const boardEl = $("#board");
        const canvas = $("#canvas");
        const overlay = $("#overlay");
        const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });
        const octx = overlay.getContext("2d", { alpha: true, desynchronized: true });

        const colorEl = $("#color");
        const sizeEl = $("#size");
        const opacityEl = $("#opacity");
        const sizeLabel = $("#sizeLabel");
        const opacityLabel = $("#opacityLabel");

        const undoBtn = $("#undoBtn");
        const redoBtn = $("#redoBtn");
        const clearBtn = $("#clearBtn");
        const saveBtn = $("#saveBtn");
        const moreBtn = $("#moreBtn");
        const roomPill = $("#roomPill");

        const modalRoot = $("#modalRoot");
        const closeModalBtn = $("#closeModalBtn");
        const roomInput = $("#roomInput");
        const gridSelect = $("#gridSelect");
        const themeSelect = $("#themeSelect");
        const exportBgSelect = $("#exportBgSelect");
        const exportScaleEl = $("#exportScale");
        const pressureToggle = $("#pressureToggle");
        const copyLinkBtn = $("#copyLinkBtn");
        const applySettingsBtn = $("#applySettingsBtn");
        const resetLocalBtn = $("#resetLocalBtn");

        const toastArea = $("#toastArea");
        const liveRegion = $("#liveRegion");
        const roomNameEl = $("#roomName");
        const peerCountEl = $("#peerCount");

        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const now = () => performance.now();
        const round1 = (v) => Math.round(v * 10) / 10;
        const rid = () => {
          try {
            const bytes = new Uint8Array(12);
            crypto.getRandomValues(bytes);
            return Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");
          } catch {
            return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
          }
        };
        const safeClone = (obj) => {
          try {
            return structuredClone(obj);
          } catch {
            return JSON.parse(JSON.stringify(obj));
          }
        };

        const state = {
          clientId: rid(),
          tool: "pen",
          color: "#f8fafc",
          sizePx: 10,
          opacity: 1,
          grid: "dots",
          theme: "dark", // dark | light | system
          exportBg: "auto", // auto | transparent | solid
          exportScale: 2,
          pressure: true,
          room: "lobby",
          ops: [],
          redo: [],
          lastDestructiveTs: 0,
          hasEverDrawn: false,
        };

        let boardW = 0;
        let boardH = 0;
        let dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

        let bc = null;
        let peers = new Map(); // id -> {lastSeen:number}

        let activePointerId = null;
        let pointerDown = false;
        let lastPt = null;
        let rafMove = 0;

        let localStroke = null; // {id, op, lastSentIdx, lastSendAt}
        const remoteStrokes = new Map(); // opId -> {op, lastPt}
        let shapeDraft = null; // {tool, a, b, flags, id}

        const toolButtons = $$("[data-tool]");
        const toolByKey = {
          p: "pen",
          h: "highlighter",
          e: "eraser",
          l: "line",
          r: "rect",
          o: "ellipse",
          a: "arrow",
          t: "text",
        };

        function toast(message) {
          const el = document.createElement("div");
          el.className = "toast";
          el.textContent = message;
          toastArea.appendChild(el);
          liveRegion.textContent = message;
          setTimeout(() => {
            el.style.opacity = "0";
            el.style.transition = "opacity 200ms ease";
            setTimeout(() => el.remove(), 220);
          }, 2200);
        }

        function setTheme(mode) {
          state.theme = mode;
          const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
          const effective = mode === "system" ? (prefersLight ? "light" : "dark") : mode;
          appEl.setAttribute("data-theme", effective);
        }

        function setGrid(mode) {
          state.grid = mode;
          boardEl.setAttribute("data-grid", mode);
        }

        function setTool(tool, { silent = false } = {}) {
          state.tool = tool;
          for (const b of toolButtons) b.setAttribute("aria-pressed", b.dataset.tool === tool ? "true" : "false");
          const label =
            tool === "pen"
              ? "Pen"
              : tool === "highlighter"
                ? "Highlighter"
                : tool === "eraser"
                  ? "Eraser"
                  : tool === "line"
                    ? "Line"
                    : tool === "rect"
                      ? "Rectangle"
                      : tool === "ellipse"
                        ? "Ellipse"
                        : tool === "arrow"
                          ? "Arrow"
                          : tool === "text"
                            ? "Text"
                            : tool;
          if (!silent) toast(label);
        }

        function setColor(c) {
          state.color = c;
          colorEl.value = c;
        }
        function setSize(px) {
          state.sizePx = clamp(px, 1, 128);
          sizeEl.value = String(state.sizePx);
          sizeLabel.textContent = String(state.sizePx);
        }
        function setOpacity(op) {
          state.opacity = clamp(op, 0.05, 1);
          opacityEl.value = String(state.opacity);
          opacityLabel.textContent = `${Math.round(state.opacity * 100)}%`;
        }

        function normalizePoint(pt) {
          return { x: pt.x / boardW, y: pt.y / boardH, p: pt.p ?? 0.5 };
        }
        function denormPoint(ptN) {
          return { x: ptN.x * boardW, y: ptN.y * boardH, p: ptN.p ?? 0.5 };
        }
        function sizeFracFromPx(px) {
          const m = Math.max(1, Math.min(boardW, boardH));
          return px / m;
        }
        function pxFromSizeFrac(frac) {
          const m = Math.max(1, Math.min(boardW, boardH));
          return frac * m;
        }

        function clearCanvas(targetCtx) {
          targetCtx.save();
          targetCtx.setTransform(1, 0, 0, 1, 0, 0);
          targetCtx.clearRect(0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
          targetCtx.restore();
        }

        function applyStrokeStyle(targetCtx, op) {
          targetCtx.lineCap = "round";
          targetCtx.lineJoin = "round";
          targetCtx.globalAlpha = op.opacity ?? 1;
          targetCtx.globalCompositeOperation = op.mode || "source-over";
          targetCtx.strokeStyle = op.color || "#fff";
          targetCtx.fillStyle = op.color || "#fff";
        }

        function drawStrokeSegment(targetCtx, a, b, op) {
          const size = pxFromSizeFrac(op.sizeFrac);
          const usePressure = op.pressure ?? false;
          const width = usePressure ? size * (0.35 + 0.65 * clamp(b.p ?? 0.5, 0.05, 1)) : size;
          targetCtx.lineWidth = Math.max(0.5, width);
          targetCtx.beginPath();
          targetCtx.moveTo(a.x, a.y);
          targetCtx.lineTo(b.x, b.y);
          targetCtx.stroke();
        }

        function drawDot(targetCtx, pt, op) {
          const size = pxFromSizeFrac(op.sizeFrac);
          const usePressure = op.pressure ?? false;
          const width = usePressure ? size * (0.35 + 0.65 * clamp(pt.p ?? 0.5, 0.05, 1)) : size;
          targetCtx.beginPath();
          targetCtx.arc(pt.x, pt.y, Math.max(0.5, width / 2), 0, Math.PI * 2);
          targetCtx.fill();
        }

        function drawStrokeFull(targetCtx, op) {
          const pts = op.points || [];
          if (pts.length === 1) {
            const p = denormPoint(pts[0]);
            drawDot(targetCtx, p, op);
            return;
          }
          if (pts.length < 2) return;
          const first = denormPoint(pts[0]);
          const size = pxFromSizeFrac(op.sizeFrac);
          const usePressure = op.pressure ?? false;

          targetCtx.lineWidth = Math.max(0.5, size);
          targetCtx.beginPath();
          targetCtx.moveTo(first.x, first.y);

          // Smoothing: quadratic through midpoints.
          for (let i = 1; i < pts.length - 1; i++) {
            const p0 = denormPoint(pts[i]);
            const p1 = denormPoint(pts[i + 1]);
            const mid = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
            if (usePressure) {
              const w = size * (0.35 + 0.65 * clamp(p0.p ?? 0.5, 0.05, 1));
              targetCtx.lineWidth = Math.max(0.5, w);
            }
            targetCtx.quadraticCurveTo(p0.x, p0.y, mid.x, mid.y);
          }
          const last = denormPoint(pts[pts.length - 1]);
          targetCtx.lineTo(last.x, last.y);
          targetCtx.stroke();
        }

        function drawArrow(targetCtx, a, b, widthPx) {
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.hypot(dx, dy) || 1;
          const ux = dx / len;
          const uy = dy / len;
          const head = Math.max(10, Math.min(34, widthPx * 2.4));
          const angle = Math.PI / 7.5;
          const vx = -ux;
          const vy = -uy;

          const rotate = (x, y, ang) => {
            const s = Math.sin(ang);
            const c = Math.cos(ang);
            return { x: x * c - y * s, y: x * s + y * c };
          };
          const left = rotate(vx, vy, angle);
          const right = rotate(vx, vy, -angle);

          targetCtx.beginPath();
          targetCtx.moveTo(a.x, a.y);
          targetCtx.lineTo(b.x, b.y);
          targetCtx.stroke();

          targetCtx.beginPath();
          targetCtx.moveTo(b.x, b.y);
          targetCtx.lineTo(b.x + left.x * head, b.y + left.y * head);
          targetCtx.lineTo(b.x + right.x * head, b.y + right.y * head);
          targetCtx.closePath();
          targetCtx.fill();
        }

        function drawShape(targetCtx, op, preview = false) {
          const a = denormPoint(op.a);
          const b = denormPoint(op.b);
          const size = pxFromSizeFrac(op.sizeFrac);
          targetCtx.lineWidth = Math.max(0.5, size);
          const tool = op.shape;

          const flags = op.flags || {};
          let x0 = a.x,
            y0 = a.y,
            x1 = b.x,
            y1 = b.y;

          let w = x1 - x0;
          let h = y1 - y0;
          if (flags.center) {
            w *= 2;
            h *= 2;
            x0 = a.x - w / 2;
            y0 = a.y - h / 2;
          }
          if (flags.constrain) {
            const s = Math.sign(w || 1) * Math.abs(w);
            const t = Math.sign(h || 1) * Math.abs(h);
            const side = Math.min(Math.abs(s), Math.abs(t));
            w = Math.sign(w || 1) * side;
            h = Math.sign(h || 1) * side;
          }
          const rx = x0 + w;
          const ry = y0 + h;
          const left = Math.min(x0, rx);
          const top = Math.min(y0, ry);
          const width = Math.abs(w);
          const height = Math.abs(h);

          if (preview) {
            targetCtx.save();
            targetCtx.globalAlpha = Math.min(1, (op.opacity ?? 1) * 0.9);
          }

          if (tool === "line") {
            targetCtx.beginPath();
            targetCtx.moveTo(a.x, a.y);
            targetCtx.lineTo(b.x, b.y);
            targetCtx.stroke();
          } else if (tool === "arrow") {
            drawArrow(targetCtx, a, b, targetCtx.lineWidth);
          } else if (tool === "rect") {
            targetCtx.beginPath();
            targetCtx.rect(left, top, width, height);
            if (op.fill) targetCtx.fill();
            targetCtx.stroke();
          } else if (tool === "ellipse") {
            targetCtx.beginPath();
            targetCtx.ellipse(left + width / 2, top + height / 2, width / 2, height / 2, 0, 0, Math.PI * 2);
            if (op.fill) targetCtx.fill();
            targetCtx.stroke();
          }

          if (preview) targetCtx.restore();
        }

        function drawText(targetCtx, op) {
          const p = denormPoint(op.at);
          const size = pxFromSizeFrac(op.sizeFrac);
          const maxWidth = Math.max(120, op.maxWidthFrac ? op.maxWidthFrac * Math.min(boardW, 800) : 520);
          const lines = String(op.text || "").split("\n");

          targetCtx.save();
          targetCtx.globalAlpha = op.opacity ?? 1;
          targetCtx.globalCompositeOperation = "source-over";
          targetCtx.fillStyle = op.color || "#fff";
          targetCtx.textBaseline = "top";
          targetCtx.font = `${Math.round(size)}px ${op.font || "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial"}`;

          const wrapped = [];
          for (const line of lines) {
            if (!line) {
              wrapped.push("");
              continue;
            }
            const words = line.split(/\s+/g);
            let cur = "";
            for (const w of words) {
              const next = cur ? cur + " " + w : w;
              if (targetCtx.measureText(next).width <= maxWidth) {
                cur = next;
              } else {
                if (cur) wrapped.push(cur);
                cur = w;
              }
            }
            if (cur) wrapped.push(cur);
          }

          const lineH = Math.round(size * 1.28);
          let y = p.y;
          for (const line of wrapped) {
            targetCtx.fillText(line, p.x, y);
            y += lineH;
          }
          targetCtx.restore();
        }

        function renderAll() {
          clearCanvas(ctx);
          // In-progress remote strokes are drawn incrementally; avoid replaying them here.
          for (const op of state.ops) {
            ctx.save();
            if (op.kind === "stroke") {
              applyStrokeStyle(ctx, op);
              drawStrokeFull(ctx, op);
            } else if (op.kind === "shape") {
              applyStrokeStyle(ctx, op);
              drawShape(ctx, op, false);
            } else if (op.kind === "text") {
              drawText(ctx, op);
            }
            ctx.restore();
          }
        }

        function schedulePersist() {
          if (schedulePersist.t) clearTimeout(schedulePersist.t);
          schedulePersist.t = setTimeout(() => persist(), 450);
        }
        schedulePersist.t = 0;

        function persist() {
          try {
            const payload = {
              v: 1,
              tool: state.tool,
              color: state.color,
              sizePx: state.sizePx,
              opacity: state.opacity,
              grid: state.grid,
              theme: state.theme,
              exportBg: state.exportBg,
              exportScale: state.exportScale,
              pressure: state.pressure,
              room: state.room,
              ops: state.ops,
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
          } catch {
            // ignore
          }
        }

        function loadPersisted() {
          try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const data = JSON.parse(raw);
            if (!data || data.v !== 1) return;
            state.tool = data.tool || state.tool;
            state.color = data.color || state.color;
            state.sizePx = typeof data.sizePx === "number" ? data.sizePx : state.sizePx;
            state.opacity = typeof data.opacity === "number" ? data.opacity : state.opacity;
            state.grid = data.grid || state.grid;
            state.theme = data.theme || state.theme;
            state.exportBg = data.exportBg || state.exportBg;
            state.exportScale = typeof data.exportScale === "number" ? data.exportScale : state.exportScale;
            state.pressure = typeof data.pressure === "boolean" ? data.pressure : state.pressure;
            state.room = data.room || state.room;
            state.ops = Array.isArray(data.ops) ? data.ops : [];
            state.redo = [];
            state.hasEverDrawn = state.ops.length > 0;
          } catch {
            // ignore
          }
        }

        function parseRoomFromUrl() {
          const fromHash = decodeURIComponent((location.hash || "").replace(/^#/, "") || "").trim();
          const params = new URLSearchParams(location.search || "");
          const fromQuery = (params.get("room") || "").trim();
          const name = (fromHash || fromQuery || state.room || "lobby").trim();
          return sanitizeRoom(name);
        }

        function sanitizeRoom(name) {
          const cleaned = name
            .toLowerCase()
            .replace(/[^a-z0-9_-]+/g, "-")
            .replace(/-+/g, "-")
            .replace(/^[-_]+|[-_]+$/g, "");
          return cleaned || "lobby";
        }

        function setRoom(room, { updateUrl = true, reconnect = true } = {}) {
          const cleaned = sanitizeRoom(room);
          state.room = cleaned;
          roomNameEl.textContent = cleaned;
          roomInput.value = cleaned;
          if (updateUrl) {
            try {
              location.hash = encodeURIComponent(cleaned);
            } catch {
              // ignore
            }
          }
          if (reconnect) connectRoom(cleaned);
        }

        function updatePeerCount() {
          peerCountEl.textContent = String(peers.size + 1);
        }

        function channelName(room) {
          return `online-whiteboard:${room}`;
        }

        function bcPost(type, payload) {
          if (!bc) return;
          bc.postMessage({
            v: 1,
            type,
            room: state.room,
            from: state.clientId,
            ts: Date.now(),
            payload,
          });
        }

        function connectRoom(room) {
          try {
            if (bc) bc.close();
          } catch {
            // ignore
          }
          peers.clear();
          updatePeerCount();
          remoteStrokes.clear();
          localStroke = null;
          bc = null;

          try {
            bc = new BroadcastChannel(channelName(room));
          } catch (e) {
            toast("Collaboration not available in this browser.");
            return;
          }

          bc.onmessage = (ev) => {
            const msg = ev.data;
            if (!msg || msg.v !== 1) return;
            if (msg.room !== state.room) return;
            if (msg.from === state.clientId) return;
            peers.set(msg.from, { lastSeen: Date.now() });
            updatePeerCount();

            if (msg.type === "hello") {
              bcPost("helloAck", { wantState: state.ops.length === 0 });
              // If we have content and they want it, respond.
              if (state.ops.length > 0) bcPost("stateResponse", { ops: state.ops, settings: exportSettingsSnapshot() });
            } else if (msg.type === "helloAck") {
              // If we're empty, ask for state.
              if (state.ops.length === 0 && msg.payload && msg.payload.wantState) {
                bcPost("requestState", { reason: "empty" });
              }
            } else if (msg.type === "requestState") {
              bcPost("stateResponse", { ops: state.ops, settings: exportSettingsSnapshot() });
            } else if (msg.type === "stateResponse") {
              const incoming = msg.payload && Array.isArray(msg.payload.ops) ? msg.payload.ops : null;
              if (!incoming) return;
              if (state.ops.length === 0 || incoming.length > state.ops.length + 2) {
                state.ops = safeClone(incoming);
                state.redo = [];
                applyIncomingSettings(msg.payload && msg.payload.settings);
                renderAll();
                schedulePersist();
                toast("Synced board");
              }
            } else if (msg.type === "setState") {
              if (!msg.ts || msg.ts <= state.lastDestructiveTs) return;
              state.lastDestructiveTs = msg.ts;
              const incoming = msg.payload && Array.isArray(msg.payload.ops) ? msg.payload.ops : [];
              state.ops = safeClone(incoming);
              state.redo = [];
              remoteStrokes.clear();
              clearCanvas(octx);
              applyIncomingSettings(msg.payload && msg.payload.settings);
              renderAll();
              schedulePersist();
              toast("Room updated");
            } else if (msg.type === "settings") {
              applyIncomingSettings(msg.payload && msg.payload.settings);
              schedulePersist();
            } else if (msg.type === "opCommit") {
              const op = msg.payload && msg.payload.op;
              if (!op || !op.id) return;
              if (state.ops.some((x) => x && x.id === op.id)) return;
              if (op.kind === "shape") {
                ctx.save();
                applyStrokeStyle(ctx, op);
                drawShape(ctx, op, false);
                ctx.restore();
                state.ops.push(op);
                state.hasEverDrawn = true;
                schedulePersist();
              } else if (op.kind === "text") {
                ctx.save();
                drawText(ctx, op);
                ctx.restore();
                state.ops.push(op);
                state.hasEverDrawn = true;
                schedulePersist();
              } else if (op.kind === "stroke") {
                // Strokes are streamed via opBegin/opPoints/opEnd.
              }
            } else if (msg.type === "opBegin") {
              const op = msg.payload && msg.payload.op;
              if (!op || !op.id) return;
              if (op.kind !== "stroke") return;
              const opClone = safeClone(op);
              const firstN = opClone.points && opClone.points[0];
              const first = firstN ? denormPoint(firstN) : null;
              remoteStrokes.set(op.id, { op: opClone, lastPt: first });
              if (first) {
                ctx.save();
                applyStrokeStyle(ctx, opClone);
                drawDot(ctx, first, opClone);
                ctx.restore();
              }
            } else if (msg.type === "opPoints") {
              const opId = msg.payload && msg.payload.id;
              const pts = msg.payload && msg.payload.points;
              if (!opId || !Array.isArray(pts) || pts.length === 0) return;
              const entry = remoteStrokes.get(opId);
              if (!entry) return;
              entry.op.points = entry.op.points || [];
              const maxToAdd = Math.max(0, MAX_POINTS_PER_STROKE - entry.op.points.length);
              const toAdd = pts.slice(0, maxToAdd);
              entry.op.points.push(...toAdd);

              // Draw incremental segments.
              ctx.save();
              applyStrokeStyle(ctx, entry.op);
              for (const pN of toAdd) {
                const p = denormPoint(pN);
                if (entry.lastPt) drawStrokeSegment(ctx, entry.lastPt, p, entry.op);
                else drawDot(ctx, p, entry.op);
                entry.lastPt = p;
              }
              ctx.restore();
            } else if (msg.type === "opEnd") {
              const opId = msg.payload && msg.payload.id;
              const entry = remoteStrokes.get(opId);
              if (!entry) return;
              remoteStrokes.delete(opId);
              // Commit stroke.
              state.ops.push(entry.op);
              state.hasEverDrawn = true;
              schedulePersist();
            } else if (msg.type === "ping") {
              // presence only
            }
          };

          bcPost("hello", { ua: navigator.userAgent.slice(0, 64), hasOps: state.ops.length > 0 });
          // If we are empty, attempt to fetch state quickly.
          if (state.ops.length === 0) setTimeout(() => bcPost("requestState", { reason: "startup" }), 260);
        }

        function exportSettingsSnapshot() {
          return {
            grid: state.grid,
            theme: state.theme,
          };
        }
        function applyIncomingSettings(settings) {
          if (!settings) return;
          if (typeof settings.grid === "string") {
            setGrid(settings.grid);
            gridSelect.value = settings.grid;
          }
          if (typeof settings.theme === "string") {
            setTheme(settings.theme);
            themeSelect.value = settings.theme;
          }
        }

        function broadcastSetState(reason) {
          state.lastDestructiveTs = Date.now();
          bcPost("setState", { reason, ops: state.ops, settings: exportSettingsSnapshot() });
        }

        function resize() {
          dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
          const rect = boardEl.getBoundingClientRect();
          boardW = Math.max(1, Math.round(rect.width));
          boardH = Math.max(1, Math.round(rect.height));
          canvas.width = Math.round(boardW * dpr);
          canvas.height = Math.round(boardH * dpr);
          overlay.width = Math.round(boardW * dpr);
          overlay.height = Math.round(boardH * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          octx.setTransform(dpr, 0, 0, dpr, 0, 0);
          renderAll();
        }

        function pointerPos(ev) {
          const rect = boardEl.getBoundingClientRect();
          const x = clamp(ev.clientX - rect.left, 0, rect.width);
          const y = clamp(ev.clientY - rect.top, 0, rect.height);
          const p = state.pressure ? (ev.pressure && ev.pressure > 0 ? ev.pressure : 0.5) : 0.5;
          return { x, y, p };
        }

        function startStroke(pt) {
          const tool = state.tool;
          const isEraser = tool === "eraser";
          const isHighlighter = tool === "highlighter";
          const op = {
            id: rid(),
            kind: "stroke",
            from: state.clientId,
            mode: isEraser ? "destination-out" : "source-over",
            color: isEraser ? "#000000" : state.color,
            opacity: isHighlighter ? Math.min(1, state.opacity * 0.32) : state.opacity,
            sizeFrac: sizeFracFromPx(isHighlighter ? state.sizePx * 1.5 : state.sizePx),
            points: [normalizePoint(pt)],
            pressure: !!state.pressure,
          };

          localStroke = { id: op.id, op, lastSentIdx: 1, lastSendAt: now() };
          state.hasEverDrawn = true;
          ctx.save();
          applyStrokeStyle(ctx, op);
          drawDot(ctx, pt, op);
          ctx.restore();

          bcPost("opBegin", { op });
        }

        function appendStrokePoint(pt) {
          if (!localStroke) return;
          const op = localStroke.op;
          if (!op.points) op.points = [];
          if (op.points.length >= MAX_POINTS_PER_STROKE) return;
          const prev = lastPt;
          op.points.push(normalizePoint(pt));

          if (prev) {
            ctx.save();
            applyStrokeStyle(ctx, op);
            drawStrokeSegment(ctx, prev, pt, op);
            ctx.restore();
          }

          const t = now();
          if (t - localStroke.lastSendAt > 30 || op.points.length - localStroke.lastSentIdx > 10) {
            const slice = op.points.slice(localStroke.lastSentIdx);
            localStroke.lastSentIdx = op.points.length;
            localStroke.lastSendAt = t;
            bcPost("opPoints", { id: op.id, points: slice });
          }
        }

        function endStroke() {
          if (!localStroke) return;
          const op = localStroke.op;
          // flush any remaining points
          if (localStroke.lastSentIdx < op.points.length) {
            bcPost("opPoints", { id: op.id, points: op.points.slice(localStroke.lastSentIdx) });
          }
          bcPost("opEnd", { id: op.id });
          state.ops.push(op);
          state.redo = [];
          localStroke = null;
          schedulePersist();
        }

        function beginShape(pt, ev) {
          const flags = { constrain: !!ev.shiftKey, center: !!ev.altKey };
          const tool = state.tool;
          shapeDraft = { tool, a: normalizePoint(pt), b: normalizePoint(pt), flags, id: rid() };
          clearCanvas(octx);
        }

        function updateShape(pt, ev) {
          if (!shapeDraft) return;
          shapeDraft.b = normalizePoint(pt);
          shapeDraft.flags = { constrain: !!ev.shiftKey, center: !!ev.altKey };
          clearCanvas(octx);
          const op = {
            id: shapeDraft.id,
            kind: "shape",
            from: state.clientId,
            shape: shapeDraft.tool,
            a: shapeDraft.a,
            b: shapeDraft.b,
            flags: shapeDraft.flags,
            color: state.color,
            opacity: state.opacity,
            sizeFrac: sizeFracFromPx(state.sizePx),
            fill: false,
          };
          octx.save();
          applyStrokeStyle(octx, op);
          drawShape(octx, op, true);
          octx.restore();
        }

        function endShape() {
          if (!shapeDraft) return;
          clearCanvas(octx);
          const op = {
            id: shapeDraft.id,
            kind: "shape",
            from: state.clientId,
            shape: shapeDraft.tool,
            a: shapeDraft.a,
            b: shapeDraft.b,
            flags: shapeDraft.flags,
            color: state.color,
            opacity: state.opacity,
            sizeFrac: sizeFracFromPx(state.sizePx),
            fill: false,
          };
          ctx.save();
          applyStrokeStyle(ctx, op);
          drawShape(ctx, op, false);
          ctx.restore();
          state.ops.push(op);
          state.redo = [];
          schedulePersist();
          bcPost("opCommit", { op });
          shapeDraft = null;
        }

        function openTextEditor(atPt) {
          const box = document.createElement("div");
          box.className = "floatingInput";
          box.style.left = `${Math.round(atPt.x)}px`;
          box.style.top = `${Math.round(atPt.y)}px`;

          const ta = document.createElement("textarea");
          ta.placeholder = "Type…";
          ta.spellcheck = true;

          const hint = document.createElement("div");
          hint.className = "hint";
          hint.innerHTML =
            '<span>Enter to place • Shift+Enter for newline</span><span style="color: var(--muted2)">Esc to cancel</span>';

          box.appendChild(ta);
          box.appendChild(hint);
          boardEl.appendChild(box);

          const cleanup = () => {
            box.remove();
          };

          const commit = () => {
            const text = ta.value.trimEnd();
            if (!text.trim()) {
              cleanup();
              return;
            }
            const size = clamp(state.sizePx * 2.1, 14, 72);
            const op = {
              id: rid(),
              kind: "text",
              from: state.clientId,
              at: normalizePoint({ x: atPt.x + 2, y: atPt.y + 2, p: 0.5 }),
              text,
              color: state.color,
              opacity: state.opacity,
              sizeFrac: sizeFracFromPx(size),
              font: "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
              maxWidthFrac: 0.9,
            };
            ctx.save();
            drawText(ctx, op);
            ctx.restore();
            state.ops.push(op);
            state.redo = [];
            schedulePersist();
            bcPost("opCommit", { op });
            cleanup();
          };

          ta.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              e.preventDefault();
              cleanup();
              return;
            }
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              commit();
            }
          });
          ta.addEventListener("blur", () => commit());

          setTimeout(() => ta.focus(), 0);
        }

        function undo() {
          for (let i = state.ops.length - 1; i >= 0; i--) {
            const op = state.ops[i];
            if (op.from === state.clientId) {
              state.ops.splice(i, 1);
              state.redo.push(op);
              renderAll();
              schedulePersist();
              broadcastSetState("undo");
              return;
            }
          }
          toast("Nothing to undo");
        }

        function redo() {
          const op = state.redo.pop();
          if (!op) {
            toast("Nothing to redo");
            return;
          }
          state.ops.push(op);
          renderAll();
          schedulePersist();
          broadcastSetState("redo");
        }

        let clearArmUntil = 0;
        function clearBoard() {
          const t = Date.now();
          if (state.ops.length > 0 && t > clearArmUntil) {
            clearArmUntil = t + 2000;
            toast("Press Clear again to confirm");
            return;
          }
          clearArmUntil = 0;
          state.ops = [];
          state.redo = [];
          remoteStrokes.clear();
          localStroke = null;
          shapeDraft = null;
          clearCanvas(octx);
          renderAll();
          schedulePersist();
          broadcastSetState("clear");
          toast("Cleared");
        }

        function effectiveBoardBgCss() {
          const theme = appEl.getAttribute("data-theme") || "dark";
          if (theme === "light") return "#f6f8ff";
          return "#0b1020";
        }

        function drawGridTo(ctx2d, w, h, mode, theme) {
          if (mode === "off") return;
          const isLight = theme === "light";
          const dot = isLight ? "rgba(15, 23, 42, 0.14)" : "rgba(255, 255, 255, 0.14)";
          const line = isLight ? "rgba(15, 23, 42, 0.12)" : "rgba(255, 255, 255, 0.1)";
          if (mode === "dots") {
            const step = 22;
            ctx2d.fillStyle = dot;
            for (let y = 0; y < h; y += step) {
              for (let x = 0; x < w; x += step) {
                ctx2d.fillRect(x + 1, y + 1, 1.5, 1.5);
              }
            }
          } else if (mode === "lines") {
            const step = 28;
            ctx2d.strokeStyle = line;
            ctx2d.lineWidth = 1;
            ctx2d.beginPath();
            for (let y = 0; y <= h; y += step) {
              ctx2d.moveTo(0, y + 0.5);
              ctx2d.lineTo(w, y + 0.5);
            }
            for (let x = 0; x <= w; x += step) {
              ctx2d.moveTo(x + 0.5, 0);
              ctx2d.lineTo(x + 0.5, h);
            }
            ctx2d.stroke();
          }
        }

        function saveImage() {
          const scale = clamp(Number(exportScaleEl.value || state.exportScale) || 2, 1, 4);
          const theme = appEl.getAttribute("data-theme") || "dark";
          const grid = gridSelect.value || state.grid;
          const bgMode = exportBgSelect.value || state.exportBg;

          const out = document.createElement("canvas");
          out.width = Math.max(1, Math.round(boardW * scale));
          out.height = Math.max(1, Math.round(boardH * scale));
          const outCtx = out.getContext("2d", { alpha: bgMode !== "transparent" });
          outCtx.setTransform(scale, 0, 0, scale, 0, 0);

          if (bgMode !== "transparent") {
            outCtx.fillStyle = effectiveBoardBgCss();
            outCtx.fillRect(0, 0, boardW, boardH);
            const includeGrid = bgMode === "auto";
            if (includeGrid && grid !== "off") drawGridTo(outCtx, boardW, boardH, grid, theme);
          }

          outCtx.drawImage(canvas, 0, 0, boardW, boardH);
          const url = out.toDataURL("image/png");
          const a = document.createElement("a");
          const ts = new Date();
          const pad = (n) => String(n).padStart(2, "0");
          const name = `whiteboard-${ts.getFullYear()}${pad(ts.getMonth() + 1)}${pad(ts.getDate())}-${pad(ts.getHours())}${pad(
            ts.getMinutes()
          )}${pad(ts.getSeconds())}.png`;
          a.href = url;
          a.download = name;
          document.body.appendChild(a);
          a.click();
          a.remove();
          toast("Saved PNG");
        }

        function openModal() {
          modalRoot.hidden = false;
          $("#modalTitle").textContent = "Settings & Help";
          roomInput.value = state.room;
          gridSelect.value = state.grid;
          themeSelect.value = state.theme;
          exportBgSelect.value = state.exportBg;
          exportScaleEl.value = String(state.exportScale);
          pressureToggle.value = state.pressure ? "on" : "off";
          roomInput.focus();
        }

        function closeModal() {
          modalRoot.hidden = true;
        }

        function applySettings() {
          const nextRoom = sanitizeRoom(roomInput.value || "lobby");
          const nextGrid = gridSelect.value || "dots";
          const nextTheme = themeSelect.value || "dark";
          const nextExportBg = exportBgSelect.value || "auto";
          const nextScale = clamp(Number(exportScaleEl.value) || 2, 1, 4);
          const nextPressure = pressureToggle.value === "on";

          setGrid(nextGrid);
          setTheme(nextTheme);
          state.exportBg = nextExportBg;
          state.exportScale = nextScale;
          state.pressure = nextPressure;

	          if (nextRoom !== state.room) {
	            setRoom(nextRoom, { updateUrl: true, reconnect: true });
	            // Push our current state into the new room.
	            setTimeout(() => bcPost("setState", { reason: "room-switch", ops: state.ops, settings: exportSettingsSnapshot() }), 120);
	          } else {
	            // sync settings (non-destructive)
	            bcPost("settings", { settings: exportSettingsSnapshot() });
	          }

          schedulePersist();
          closeModal();
          toast("Applied");
        }

        async function copyRoomLink() {
          const base = String(location.href || "").replace(/#.*$/, "").replace(/\?.*$/, "");
          const link = `${base}#${encodeURIComponent(state.room)}`;
          try {
            await navigator.clipboard.writeText(link);
            toast("Link copied");
          } catch {
            // Fallback: prompt
            window.prompt("Copy this link:", link);
          }
        }

        function resetLocal() {
          try {
            localStorage.removeItem(STORAGE_KEY);
          } catch {
            // ignore
          }
          toast("Local storage reset");
        }

        function attachEvents() {
          // Tools
          for (const b of toolButtons) {
            b.addEventListener("click", () => setTool(b.dataset.tool));
          }

          // Controls
          colorEl.addEventListener("input", (e) => {
            setColor(e.target.value);
            schedulePersist();
          });
          sizeEl.addEventListener("input", (e) => {
            setSize(Number(e.target.value));
            schedulePersist();
          });
          opacityEl.addEventListener("input", (e) => {
            setOpacity(Number(e.target.value));
            schedulePersist();
          });

          undoBtn.addEventListener("click", () => undo());
          redoBtn.addEventListener("click", () => redo());
          clearBtn.addEventListener("click", () => clearBoard());
          saveBtn.addEventListener("click", () => saveImage());
          moreBtn.addEventListener("click", () => openModal());
          roomPill.addEventListener("click", () => openModal());
          roomPill.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") openModal();
          });

          closeModalBtn.addEventListener("click", () => closeModal());
          modalRoot.addEventListener("click", (e) => {
            if (e.target === modalRoot) closeModal();
          });
          applySettingsBtn.addEventListener("click", () => applySettings());
          copyLinkBtn.addEventListener("click", () => copyRoomLink());
          resetLocalBtn.addEventListener("click", () => resetLocal());

          // Keyboard shortcuts
          window.addEventListener("keydown", (e) => {
            if (!modalRoot.hidden) {
              if (e.key === "Escape") closeModal();
              return;
            }
            const activeTag = (document.activeElement && document.activeElement.tagName) || "";
            const isTyping = activeTag === "INPUT" || activeTag === "TEXTAREA" || activeTag === "SELECT";
            if (!isTyping) {
              const k = (e.key || "").toLowerCase();
              if (k in toolByKey) {
                setTool(toolByKey[k]);
                e.preventDefault();
                return;
              }
              if (k === "?") {
                openModal();
                e.preventDefault();
                return;
              }
            }

            const isMac = navigator.platform && /mac/i.test(navigator.platform);
            const mod = isMac ? e.metaKey : e.ctrlKey;
            if (mod && e.key.toLowerCase() === "z") {
              e.preventDefault();
              if (e.shiftKey) redo();
              else undo();
              return;
            }
            if (mod && e.key.toLowerCase() === "s") {
              e.preventDefault();
              saveImage();
              return;
            }
            if (e.shiftKey && e.key === "Backspace") {
              e.preventDefault();
              clearBoard();
              return;
            }
          });

          // Pointer drawing
          boardEl.addEventListener("pointerdown", (ev) => {
            if (ev.button !== 0) return;
            if (activePointerId !== null) return;
            activePointerId = ev.pointerId;
            pointerDown = true;
            boardEl.setPointerCapture(ev.pointerId);
            const pt = pointerPos(ev);
            lastPt = pt;

            if (state.tool === "text") {
              pointerDown = false;
              activePointerId = null;
              openTextEditor(pt);
              return;
            }
            if (state.tool === "pen" || state.tool === "eraser" || state.tool === "highlighter") {
              startStroke(pt);
              return;
            }
            if (state.tool === "line" || state.tool === "rect" || state.tool === "ellipse" || state.tool === "arrow") {
              beginShape(pt, ev);
              updateShape(pt, ev);
              return;
            }
          });

          boardEl.addEventListener("pointermove", (ev) => {
            if (!pointerDown || ev.pointerId !== activePointerId) return;
            const pt = pointerPos(ev);
            if (rafMove) cancelAnimationFrame(rafMove);
            rafMove = requestAnimationFrame(() => {
              rafMove = 0;
              if (state.tool === "pen" || state.tool === "eraser" || state.tool === "highlighter") {
                appendStrokePoint(pt);
              } else if (state.tool === "line" || state.tool === "rect" || state.tool === "ellipse" || state.tool === "arrow") {
                updateShape(pt, ev);
              }
              lastPt = pt;
            });
          });

          function endPointer(ev) {
            if (ev.pointerId !== activePointerId) return;
            pointerDown = false;
            activePointerId = null;
            if (rafMove) cancelAnimationFrame(rafMove);
            rafMove = 0;
            if (state.tool === "pen" || state.tool === "eraser" || state.tool === "highlighter") endStroke();
            if (state.tool === "line" || state.tool === "rect" || state.tool === "ellipse" || state.tool === "arrow") endShape();
          }
          boardEl.addEventListener("pointerup", (ev) => endPointer(ev));
          boardEl.addEventListener("pointercancel", (ev) => endPointer(ev));

          // Resize
          window.addEventListener("resize", () => resize());
          if (window.visualViewport) window.visualViewport.addEventListener("resize", () => resize());
        }

        function initUiFromState() {
          setTool(state.tool, { silent: true });
          setColor(state.color);
          setSize(state.sizePx);
          setOpacity(state.opacity);
          setGrid(state.grid);
          setTheme(state.theme);
          exportBgSelect.value = state.exportBg;
          exportScaleEl.value = String(state.exportScale);
          pressureToggle.value = state.pressure ? "on" : "off";
        }

        function startPresenceLoop() {
          setInterval(() => {
            const cutoff = Date.now() - 7000;
            let changed = false;
            for (const [id, p] of peers.entries()) {
              if (p.lastSeen < cutoff) {
                peers.delete(id);
                changed = true;
              }
            }
            if (changed) updatePeerCount();
            bcPost("ping", { t: Date.now() });
          }, 2000);
        }

        // Boot
        loadPersisted();
        setRoom(parseRoomFromUrl(), { updateUrl: true, reconnect: false });
        initUiFromState();
        attachEvents();
        resize();
        renderAll();
        connectRoom(state.room);
        startPresenceLoop();

        // Keep system theme in sync.
        if (window.matchMedia) {
          const mm = window.matchMedia("(prefers-color-scheme: light)");
          const onChange = () => {
            if (state.theme === "system") setTheme("system");
          };
          if (mm.addEventListener) mm.addEventListener("change", onChange);
          else if (mm.addListener) mm.addListener(onChange);
        }

        // Friendly first-run note
        setTimeout(() => {
          if (!state.hasEverDrawn) toast("Tip: open another tab in the same room to collaborate");
        }, 650);
      })();
    </script>
  </body>
</html>
