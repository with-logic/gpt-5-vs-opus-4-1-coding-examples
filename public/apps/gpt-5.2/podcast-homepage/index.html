<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#0b1220" media="(prefers-color-scheme: dark)" />
    <meta name="theme-color" content="#f6f8ff" media="(prefers-color-scheme: light)" />
    <title>Podcast Home Page</title>
    <style>
      :root {
        --bg: #0b1220;
        --bg2: #0e1730;
        --panel: rgba(255, 255, 255, 0.06);
        --panel2: rgba(255, 255, 255, 0.1);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.72);
        --muted2: rgba(255, 255, 255, 0.56);
        --border: rgba(255, 255, 255, 0.12);
        --shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
        --shadow2: 0 10px 30px rgba(0, 0, 0, 0.28);
        --accent: #8b5cf6;
        --accent2: #22d3ee;
        --good: #34d399;
        --warn: #fbbf24;
        --bad: #fb7185;
        --ring: rgba(139, 92, 246, 0.45);
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji,
          Segoe UI Emoji;
        --radius: 18px;
        --radius2: 14px;
        --max: 1220px;
        --headerH: 76px;
        --playerH: 86px;
      }

      [data-theme="light"] {
        --bg: #f6f8ff;
        --bg2: #edf2ff;
        --panel: rgba(3, 7, 18, 0.06);
        --panel2: rgba(3, 7, 18, 0.1);
        --text: rgba(3, 7, 18, 0.9);
        --muted: rgba(3, 7, 18, 0.7);
        --muted2: rgba(3, 7, 18, 0.55);
        --border: rgba(3, 7, 18, 0.14);
        --shadow: 0 18px 50px rgba(2, 6, 23, 0.14);
        --shadow2: 0 10px 30px rgba(2, 6, 23, 0.12);
        --ring: rgba(34, 211, 238, 0.35);
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: var(--sans);
        color: var(--text);
        background:
          radial-gradient(1100px 700px at 10% 10%, rgba(139, 92, 246, 0.22), transparent 60%),
          radial-gradient(900px 520px at 80% 15%, rgba(34, 211, 238, 0.18), transparent 62%),
          radial-gradient(1100px 740px at 70% 80%, rgba(251, 191, 36, 0.12), transparent 60%),
          linear-gradient(180deg, var(--bg), var(--bg2));
        overflow-x: hidden;
      }

      a {
        color: inherit;
      }
      button,
      input,
      select {
        font: inherit;
        color: inherit;
      }
      ::selection {
        background: rgba(139, 92, 246, 0.25);
      }

      .wrap {
        max-width: var(--max);
        margin: 0 auto;
        padding: 18px 18px 0 18px;
      }

      header {
        position: sticky;
        top: 0;
        z-index: 50;
        backdrop-filter: blur(14px);
        background: linear-gradient(180deg, rgba(0, 0, 0, 0.45), rgba(0, 0, 0, 0));
      }
      [data-theme="light"] header {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.75), rgba(255, 255, 255, 0));
      }
      .headerInner {
        max-width: var(--max);
        margin: 0 auto;
        padding: 14px 18px 12px 18px;
        display: grid;
        grid-template-columns: 1fr minmax(240px, 520px) auto;
        gap: 12px;
        align-items: center;
        height: var(--headerH);
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 200px;
      }
      .logo {
        width: 42px;
        height: 42px;
        border-radius: 14px;
        background:
          radial-gradient(18px 18px at 30% 30%, rgba(255, 255, 255, 0.7), transparent 58%),
          linear-gradient(135deg, rgba(139, 92, 246, 1), rgba(34, 211, 238, 1));
        box-shadow: var(--shadow2);
        display: grid;
        place-items: center;
        position: relative;
        overflow: hidden;
      }
      .logo::after {
        content: "";
        position: absolute;
        inset: -30%;
        background: conic-gradient(
          from 210deg,
          transparent,
          rgba(255, 255, 255, 0.35),
          transparent 55%
        );
        animation: spin 9s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(1turn);
        }
      }
      .logo svg {
        position: relative;
        z-index: 1;
        filter: drop-shadow(0 8px 18px rgba(0, 0, 0, 0.25));
      }
      .brandTitle {
        display: flex;
        flex-direction: column;
        line-height: 1.1;
      }
      .brandTitle strong {
        font-weight: 820;
        letter-spacing: -0.02em;
        font-size: 15px;
      }
      .brandTitle span {
        font-size: 12px;
        color: var(--muted2);
        margin-top: 2px;
      }

      .searchBar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        border-radius: 999px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.12);
      }
      [data-theme="light"] .searchBar {
        background: rgba(255, 255, 255, 0.7);
      }
      .searchBar:focus-within {
        outline: 2px solid transparent;
        border-color: rgba(139, 92, 246, 0.55);
        box-shadow: 0 0 0 6px var(--ring), 0 14px 30px rgba(0, 0, 0, 0.1);
      }
      .searchIcon {
        width: 18px;
        height: 18px;
        opacity: 0.85;
      }
      #q {
        width: 100%;
        border: 0;
        outline: 0;
        background: transparent;
        font-size: 14px;
      }
      .kbd {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--muted2);
        border: 1px solid var(--border);
        padding: 3px 8px;
        border-radius: 999px;
        user-select: none;
      }

      .headerActions {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .btn {
        appearance: none;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 999px;
        cursor: pointer;
        transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        line-height: 1;
        white-space: nowrap;
      }
      [data-theme="light"] .btn {
        background: rgba(255, 255, 255, 0.8);
      }
      .btn:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 255, 255, 0.22);
        background: rgba(255, 255, 255, 0.1);
      }
      .btn:active {
        transform: translateY(0px);
      }
      .btn.primary {
        border-color: rgba(139, 92, 246, 0.55);
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.9), rgba(34, 211, 238, 0.85));
        box-shadow: 0 18px 40px rgba(139, 92, 246, 0.18);
      }
      .btn.primary:hover {
        border-color: rgba(139, 92, 246, 0.75);
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.98), rgba(34, 211, 238, 0.92));
      }
      .btn.icon {
        padding: 10px 11px;
      }
      .btn svg {
        width: 16px;
        height: 16px;
      }

      main {
        max-width: var(--max);
        margin: 0 auto;
        padding: 10px 18px 130px 18px;
      }

      .hero {
        display: grid;
        grid-template-columns: 1.15fr 0.85fr;
        gap: 14px;
        align-items: stretch;
        margin-top: 10px;
      }
      .card {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        border-radius: var(--radius);
        box-shadow: var(--shadow2);
        overflow: hidden;
        position: relative;
      }
      [data-theme="light"] .card {
        background: rgba(255, 255, 255, 0.75);
      }

      .nowPlaying {
        padding: 18px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .npTop {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: start;
      }
      .npTitle {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .npTitle h1 {
        margin: 0;
        font-size: 20px;
        letter-spacing: -0.02em;
        line-height: 1.25;
      }
      .npMeta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        color: var(--muted);
        font-size: 12.5px;
      }
      .pill {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        padding: 5px 10px;
        border-radius: 999px;
        font-size: 12px;
        color: var(--muted);
      }
      .pill strong {
        color: var(--text);
        font-weight: 700;
      }
      .npActions {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .wave {
        border-radius: var(--radius2);
        border: 1px solid var(--border);
        background:
          radial-gradient(520px 280px at 20% 20%, rgba(139, 92, 246, 0.2), transparent 60%),
          radial-gradient(520px 280px at 80% 30%, rgba(34, 211, 238, 0.18), transparent 60%),
          rgba(0, 0, 0, 0.12);
        overflow: hidden;
        height: 150px;
        position: relative;
      }
      [data-theme="light"] .wave {
        background:
          radial-gradient(520px 280px at 20% 20%, rgba(139, 92, 246, 0.17), transparent 60%),
          radial-gradient(520px 280px at 80% 30%, rgba(34, 211, 238, 0.15), transparent 60%),
          rgba(3, 7, 18, 0.03);
      }
      #viz {
        width: 100%;
        height: 100%;
        display: block;
      }
      .waveHint {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        pointer-events: none;
        color: var(--muted2);
        font-size: 13px;
        padding: 12px;
        text-align: center;
        opacity: 1;
        transition: opacity 0.2s ease;
      }
      .waveHint.hidden {
        opacity: 0;
      }

      .player {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 12px;
        align-items: center;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: var(--radius2);
        background: rgba(255, 255, 255, 0.04);
      }
      [data-theme="light"] .player {
        background: rgba(255, 255, 255, 0.65);
      }
      .bigPlay {
        width: 44px;
        height: 44px;
        border-radius: 14px;
        border: 1px solid rgba(139, 92, 246, 0.45);
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.8), rgba(34, 211, 238, 0.72));
        display: grid;
        place-items: center;
        cursor: pointer;
        box-shadow: 0 18px 40px rgba(139, 92, 246, 0.18);
      }
      .bigPlay:focus-visible {
        outline: 0;
        box-shadow: 0 0 0 6px var(--ring), 0 18px 40px rgba(139, 92, 246, 0.18);
      }
      .bigPlay svg {
        width: 18px;
        height: 18px;
      }
      .seek {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 0;
      }
      .timeRow {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        color: var(--muted2);
        font-size: 12px;
        font-variant-numeric: tabular-nums;
      }
      .barWrap {
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
      }
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 8px;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(139, 92, 246, 0.9) var(--fill, 0%), rgba(255, 255, 255, 0.15) 0);
        outline: none;
      }
      [data-theme="light"] input[type="range"] {
        background: linear-gradient(90deg, rgba(34, 211, 238, 0.8) var(--fill, 0%), rgba(3, 7, 18, 0.12) 0);
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 999px;
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.2);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.22);
      }
      [data-theme="light"] input[type="range"]::-webkit-slider-thumb {
        border: 1px solid rgba(3, 7, 18, 0.22);
      }
      input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 999px;
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.2);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.22);
      }

      .rightControls {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .smallSelect {
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        padding: 8px 10px;
        color: var(--muted);
      }
      [data-theme="light"] .smallSelect {
        background: rgba(255, 255, 255, 0.8);
      }
      .vol {
        display: flex;
        align-items: center;
        gap: 8px;
        width: 160px;
      }
      .vol input[type="range"] {
        height: 6px;
      }

      .stats {
        padding: 16px 18px;
        display: grid;
        gap: 12px;
      }
      .statGrid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
      }
      .stat {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        border-radius: var(--radius2);
        padding: 12px;
        display: grid;
        gap: 4px;
        min-height: 72px;
      }
      [data-theme="light"] .stat {
        background: rgba(255, 255, 255, 0.65);
      }
      .stat b {
        font-size: 14px;
        letter-spacing: -0.01em;
      }
      .stat span {
        font-size: 12px;
        color: var(--muted2);
      }
      .tagRow {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .chip {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.05);
        border-radius: 999px;
        padding: 8px 10px;
        cursor: pointer;
        color: var(--muted);
        font-size: 12px;
        transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
      }
      .chip:hover {
        transform: translateY(-1px);
        border-color: rgba(139, 92, 246, 0.45);
      }
      .chip.active {
        border-color: rgba(34, 211, 238, 0.65);
        background: rgba(34, 211, 238, 0.12);
        color: var(--text);
      }
      mark {
        background: rgba(251, 191, 36, 0.25);
        color: inherit;
        border-radius: 6px;
        padding: 0 4px;
      }

      .content {
        display: grid;
        grid-template-columns: 0.98fr 1.02fr;
        gap: 14px;
        margin-top: 14px;
        align-items: start;
      }
      .leftPane {
        display: grid;
        gap: 12px;
      }
      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        padding: 12px;
      }
      .toolbar .row {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .toolbar .spacer {
        flex: 1;
      }
      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.05);
        padding: 8px 10px;
        border-radius: 999px;
        cursor: pointer;
        user-select: none;
        color: var(--muted);
        transition: border-color 0.12s ease;
      }
      .toggle:hover {
        border-color: rgba(255, 255, 255, 0.25);
      }
      .toggle input {
        display: none;
      }
      .toggle .dot {
        width: 28px;
        height: 16px;
        border-radius: 999px;
        position: relative;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.08);
      }
      .toggle .dot::after {
        content: "";
        width: 12px;
        height: 12px;
        border-radius: 999px;
        position: absolute;
        top: 1px;
        left: 2px;
        background: rgba(255, 255, 255, 0.85);
        transition: transform 0.18s ease;
      }
      .toggle input:checked + .dot::after {
        transform: translateX(12px);
        background: rgba(34, 211, 238, 0.95);
      }

      .list {
        padding: 10px;
        display: grid;
        gap: 10px;
      }
      .episode {
        border: 1px solid var(--border);
        border-radius: var(--radius2);
        background: rgba(255, 255, 255, 0.04);
        padding: 12px;
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 12px;
        align-items: start;
        cursor: pointer;
        transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
      }
      [data-theme="light"] .episode {
        background: rgba(255, 255, 255, 0.65);
      }
      .episode:hover {
        transform: translateY(-1px);
        border-color: rgba(139, 92, 246, 0.35);
      }
      .episode.active {
        border-color: rgba(34, 211, 238, 0.65);
        background: rgba(34, 211, 238, 0.08);
      }
      .epBtn {
        width: 38px;
        height: 38px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        display: grid;
        place-items: center;
      }
      .episode.active .epBtn {
        border-color: rgba(34, 211, 238, 0.6);
        background: rgba(34, 211, 238, 0.16);
      }
      .epBtn svg {
        width: 16px;
        height: 16px;
      }
      .epMain {
        min-width: 0;
      }
      .epMain h3 {
        margin: 0;
        font-size: 14px;
        letter-spacing: -0.01em;
        line-height: 1.25;
      }
      .epMain p {
        margin: 6px 0 0 0;
        color: var(--muted2);
        font-size: 12.5px;
        line-height: 1.35;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      .epMeta {
        margin-top: 8px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        color: var(--muted2);
        font-size: 12px;
      }
      .epRight {
        display: grid;
        gap: 8px;
        justify-items: end;
      }
      .iconBtn {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.05);
        width: 34px;
        height: 34px;
        border-radius: 12px;
        cursor: pointer;
        display: grid;
        place-items: center;
        transition: border-color 0.12s ease, transform 0.12s ease;
      }
      .iconBtn:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 255, 255, 0.25);
      }
      .iconBtn svg {
        width: 16px;
        height: 16px;
        opacity: 0.95;
      }
      .favOn {
        border-color: rgba(251, 191, 36, 0.6) !important;
        background: rgba(251, 191, 36, 0.12) !important;
      }
      .badge {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--muted2);
      }

      .rightPane {
        display: grid;
        gap: 12px;
      }
      .details {
        padding: 16px 18px;
      }
      .details h2 {
        margin: 0;
        font-size: 16px;
        letter-spacing: -0.01em;
      }
      .details .desc {
        margin: 10px 0 0 0;
        color: var(--muted);
        line-height: 1.5;
        font-size: 13.5px;
      }
      .section {
        margin-top: 14px;
        border-top: 1px solid var(--border);
        padding-top: 14px;
      }
      .section h3 {
        margin: 0;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted2);
      }
      .notes {
        margin: 10px 0 0 0;
        padding-left: 18px;
        color: var(--muted);
        line-height: 1.5;
        font-size: 13px;
      }
      .chapters {
        display: grid;
        gap: 8px;
        margin-top: 10px;
      }
      .chapter {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 10px;
        align-items: center;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        border-radius: 14px;
        padding: 10px 10px;
      }
      [data-theme="light"] .chapter {
        background: rgba(255, 255, 255, 0.65);
      }
      .chapter button {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.05);
        width: 32px;
        height: 32px;
        border-radius: 12px;
        cursor: pointer;
        display: grid;
        place-items: center;
      }
      .chapter small {
        color: var(--muted2);
        font-variant-numeric: tabular-nums;
      }

      .toastWrap {
        position: fixed;
        top: calc(var(--headerH) + 10px);
        right: 14px;
        z-index: 80;
        display: grid;
        gap: 10px;
        pointer-events: none;
      }
      .toast {
        pointer-events: auto;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(12px);
        border-radius: 14px;
        padding: 10px 12px;
        min-width: 220px;
        box-shadow: var(--shadow2);
        display: grid;
        gap: 4px;
      }
      [data-theme="light"] .toast {
        background: rgba(255, 255, 255, 0.75);
      }
      .toast b {
        font-size: 13px;
      }
      .toast span {
        font-size: 12px;
        color: var(--muted2);
      }

      .modalBackdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        z-index: 90;
      }
      .modalBackdrop.open {
        display: grid;
        place-items: center;
      }
      .modal {
        width: min(720px, calc(100vw - 28px));
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background:
          radial-gradient(720px 460px at 18% 0%, rgba(139, 92, 246, 0.26), transparent 60%),
          radial-gradient(720px 460px at 88% 20%, rgba(34, 211, 238, 0.2), transparent 60%),
          rgba(16, 24, 45, 0.85);
        box-shadow: var(--shadow);
        overflow: hidden;
      }
      [data-theme="light"] .modal {
        background:
          radial-gradient(720px 460px at 18% 0%, rgba(139, 92, 246, 0.18), transparent 60%),
          radial-gradient(720px 460px at 88% 20%, rgba(34, 211, 238, 0.16), transparent 60%),
          rgba(255, 255, 255, 0.9);
      }
      .modalHeader {
        padding: 14px 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .modalHeader h2 {
        margin: 0;
        font-size: 14px;
        letter-spacing: -0.01em;
      }
      .modalBody {
        padding: 16px;
        display: grid;
        gap: 12px;
      }
      .subGrid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
      }
      .subCard {
        border: 1px solid var(--border);
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.06);
        padding: 12px;
        display: grid;
        gap: 8px;
      }
      [data-theme="light"] .subCard {
        background: rgba(255, 255, 255, 0.75);
      }
      .subCard b {
        font-size: 13px;
      }
      .subCard span {
        font-size: 12.5px;
        color: var(--muted2);
        line-height: 1.35;
      }
      .subRow {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .field {
        display: flex;
        align-items: center;
        gap: 10px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        border-radius: 14px;
        padding: 10px 12px;
      }
      [data-theme="light"] .field {
        background: rgba(255, 255, 255, 0.8);
      }
      .field input {
        border: 0;
        outline: 0;
        width: 100%;
        background: transparent;
        font-family: var(--mono);
        font-size: 12px;
        color: var(--muted);
      }

      .mini {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 70;
        padding: 10px 12px;
        display: grid;
        place-items: center;
        pointer-events: none;
      }
      .miniInner {
        pointer-events: auto;
        width: min(var(--max), calc(100vw - 18px));
        border: 1px solid var(--border);
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(14px);
        box-shadow: var(--shadow);
        padding: 10px 12px;
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 12px;
        align-items: center;
      }
      [data-theme="light"] .miniInner {
        background: rgba(255, 255, 255, 0.82);
      }
      .miniTitle {
        min-width: 0;
        display: grid;
        gap: 2px;
      }
      .miniTitle b {
        font-size: 12.5px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .miniTitle span {
        font-size: 11.5px;
        color: var(--muted2);
      }
      .miniCtrls {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .srOnly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }

      @media (max-width: 1020px) {
        .hero {
          grid-template-columns: 1fr;
        }
        .content {
          grid-template-columns: 1fr;
        }
        .headerInner {
          grid-template-columns: 1fr;
          height: auto;
          gap: 10px;
        }
        .brand {
          justify-content: space-between;
          width: 100%;
        }
        .headerActions {
          justify-content: flex-end;
        }
      }
      @media (max-width: 520px) {
        .vol {
          width: 120px;
        }
        .statGrid {
          grid-template-columns: 1fr;
        }
        .subGrid {
          grid-template-columns: 1fr;
        }
        .miniInner {
          border-radius: 22px;
          grid-template-columns: auto 1fr;
          grid-template-areas:
            "ctrl title"
            "seek seek";
        }
        .miniCtrls {
          grid-area: ctrl;
        }
        .miniTitle {
          grid-area: title;
        }
        .miniSeek {
          grid-area: seek;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          animation: none !important;
          transition: none !important;
          scroll-behavior: auto !important;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="headerInner" role="banner">
        <div class="brand">
          <div class="logo" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none">
              <path
                d="M12 18a3 3 0 0 0 3-3V7a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8a3 3 0 0 0 3 3Z"
                stroke="rgba(255,255,255,.95)"
                stroke-width="1.6"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M7 12a5 5 0 0 0 10 0"
                stroke="rgba(255,255,255,.95)"
                stroke-width="1.6"
                stroke-linecap="round"
              />
              <path
                d="M12 20v2"
                stroke="rgba(255,255,255,.95)"
                stroke-width="1.6"
                stroke-linecap="round"
              />
            </svg>
          </div>
          <div class="brandTitle">
            <strong>Podcast Home Page</strong>
            <span>Audio-first library · search, play, subscribe</span>
          </div>
        </div>

        <div class="searchBar" role="search" aria-label="Search episodes">
          <svg class="searchIcon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path
              d="M10.5 18a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15Z"
              stroke="currentColor"
              stroke-width="1.8"
              stroke-linecap="round"
            />
            <path
              d="M16.2 16.2 21 21"
              stroke="currentColor"
              stroke-width="1.8"
              stroke-linecap="round"
            />
          </svg>
          <input id="q" type="text" placeholder="Search episodes, guests, topics…" autocomplete="off" />
          <span class="kbd" title="Keyboard shortcut">/</span>
        </div>

        <div class="headerActions">
          <button class="btn" id="themeBtn" type="button" aria-label="Toggle theme">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z"
                stroke="currentColor"
                stroke-width="1.7"
              />
              <path
                d="M12 2v2M12 20v2M4 12H2M22 12h-2M5 5l1.5 1.5M17.5 17.5 19 19M19 5l-1.5 1.5M5 19l1.5-1.5"
                stroke="currentColor"
                stroke-width="1.7"
                stroke-linecap="round"
              />
            </svg>
            Theme
          </button>
          <button class="btn primary" id="subscribeBtn" type="button">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M4 11a8 8 0 0 1 16 0"
                stroke="rgba(255,255,255,.95)"
                stroke-width="1.8"
                stroke-linecap="round"
              />
              <path
                d="M6 11a6 6 0 0 1 12 0"
                stroke="rgba(255,255,255,.95)"
                stroke-width="1.8"
                stroke-linecap="round"
              />
              <path
                d="M8 11a4 4 0 0 1 8 0"
                stroke="rgba(255,255,255,.95)"
                stroke-width="1.8"
                stroke-linecap="round"
              />
              <path
                d="M12 14a3 3 0 0 0-3 3v1h6v-1a3 3 0 0 0-3-3Z"
                fill="rgba(255,255,255,.95)"
              />
            </svg>
            Subscribe
          </button>
        </div>
      </div>
    </header>

    <main>
      <section class="hero" aria-label="Now playing and channel overview">
        <div class="card nowPlaying">
          <div class="npTop">
            <div class="npTitle">
              <h1 id="npH">Select an episode to start listening</h1>
              <div class="npMeta" id="npMeta">
                <span class="pill"><strong id="npEp">—</strong></span>
                <span class="pill">Preview: <strong id="npDur">—</strong></span>
                <span class="pill">Published: <strong id="npDate">—</strong></span>
              </div>
            </div>
            <div class="npActions">
              <button class="btn icon" id="npShare" type="button" aria-label="Share episode">
                <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path
                    d="M12 16v-9"
                    stroke="currentColor"
                    stroke-width="1.8"
                    stroke-linecap="round"
                  />
                  <path
                    d="M8.5 9 12 6l3.5 3"
                    stroke="currentColor"
                    stroke-width="1.8"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M6 14v4a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-4"
                    stroke="currentColor"
                    stroke-width="1.8"
                    stroke-linecap="round"
                  />
                </svg>
              </button>
              <button class="btn icon" id="npFav" type="button" aria-label="Favorite episode">
                <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path
                    d="M12 17.3 6.4 20l1.1-6.2L3 9.6l6.2-.9L12 3l2.8 5.7 6.2.9-4.5 4.2 1.1 6.2L12 17.3Z"
                    stroke="currentColor"
                    stroke-width="1.7"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
              <button class="btn icon" id="npDl" type="button" aria-label="Download preview audio">
                <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path
                    d="M12 3v10"
                    stroke="currentColor"
                    stroke-width="1.8"
                    stroke-linecap="round"
                  />
                  <path
                    d="M8.5 10.5 12 14l3.5-3.5"
                    stroke="currentColor"
                    stroke-width="1.8"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M5 19h14"
                    stroke="currentColor"
                    stroke-width="1.8"
                    stroke-linecap="round"
                  />
                </svg>
              </button>
            </div>
          </div>

          <div class="wave" aria-label="Audio visualizer">
            <canvas id="viz"></canvas>
            <div class="waveHint" id="vizHint">
              Press <span class="kbd">Space</span> to play/pause • Use <span class="kbd">←</span>/<span class="kbd">→</span>
              to seek • <span class="kbd">J</span>/<span class="kbd">K</span> to switch episodes
            </div>
          </div>

          <div class="player" aria-label="Player controls">
            <button class="bigPlay" id="playBtn" type="button" aria-label="Play or pause">
              <svg id="playI" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M10 8.5v7l6-3.5-6-3.5Z"
                  fill="rgba(255,255,255,.95)"
                  stroke="rgba(255,255,255,.95)"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
            <div class="seek">
              <div class="timeRow">
                <span id="tCur">0:00</span>
                <span id="tEnd">0:00</span>
              </div>
              <div class="barWrap">
                <label class="srOnly" for="seek">Seek</label>
                <input id="seek" type="range" min="0" max="1000" value="0" />
              </div>
            </div>
            <div class="rightControls">
              <select class="smallSelect" id="speed" aria-label="Playback speed">
                <option value="0.85">0.85×</option>
                <option value="1" selected>1×</option>
                <option value="1.15">1.15×</option>
                <option value="1.25">1.25×</option>
                <option value="1.5">1.5×</option>
                <option value="2">2×</option>
              </select>
              <div class="vol" aria-label="Volume">
                <svg viewBox="0 0 24 24" fill="none" aria-hidden="true" style="width: 16px; height: 16px">
                  <path
                    d="M11 5 7 9H4v6h3l4 4V5Z"
                    stroke="currentColor"
                    stroke-width="1.7"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M16 9a4 4 0 0 1 0 6"
                    stroke="currentColor"
                    stroke-width="1.7"
                    stroke-linecap="round"
                  />
                  <path
                    d="M18.5 7a7 7 0 0 1 0 10"
                    stroke="currentColor"
                    stroke-width="1.7"
                    stroke-linecap="round"
                    opacity="0.85"
                  />
                </svg>
                <label class="srOnly" for="vol">Volume</label>
                <input id="vol" type="range" min="0" max="1000" value="820" />
              </div>
            </div>
          </div>
        </div>

        <div class="card stats" aria-label="Channel stats and filters">
          <div class="statGrid">
            <div class="stat">
              <b id="stCount">—</b>
              <span>episodes in the library</span>
            </div>
            <div class="stat">
              <b id="stNew">—</b>
              <span>newest drop</span>
            </div>
            <div class="stat">
              <b id="stListen">—</b>
              <span>listened this device</span>
            </div>
          </div>
          <div>
            <div class="tagRow" id="tagRow" aria-label="Filter by tag"></div>
          </div>
          <div class="pill" style="display: inline-flex; gap: 10px; align-items: center">
            <span style="color: var(--muted2)">Tip</span>
            <span style="color: var(--muted)"
              >Every episode has a self-generated audio preview—no external files. Great for demos and offline viewing.</span
            >
          </div>
        </div>
      </section>

      <section class="content" aria-label="Episode list and details">
        <div class="card leftPane">
          <div class="toolbar">
            <div class="row">
              <span class="pill" id="resultsPill"><strong>—</strong> results</span>
              <select class="smallSelect" id="sort" aria-label="Sort episodes">
                <option value="new">Newest</option>
                <option value="old">Oldest</option>
                <option value="az">A → Z</option>
                <option value="len">Longest preview</option>
              </select>
            </div>
            <div class="spacer"></div>
            <label class="toggle" title="Show favorites only">
              <input id="onlyFav" type="checkbox" />
              <span class="dot" aria-hidden="true"></span>
              Favorites
            </label>
          </div>
          <div class="list" id="list" role="list" aria-label="Episode list"></div>
        </div>

        <div class="card rightPane">
          <div class="details" aria-label="Episode details">
            <h2 id="dTitle">Details</h2>
            <p class="desc" id="dDesc">
              Pick an episode on the left. Use search to jump to topics, guests, or keywords. Playback position and favorites
              persist locally on this device.
            </p>
            <div class="section">
              <h3>Quick Actions</h3>
              <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px">
                <button class="btn" id="copyLink" type="button">
                  <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M10 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1"
                      stroke="currentColor"
                      stroke-width="1.7"
                      stroke-linecap="round"
                    />
                    <path
                      d="M14 11a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1"
                      stroke="currentColor"
                      stroke-width="1.7"
                      stroke-linecap="round"
                    />
                  </svg>
                  Copy episode link
                </button>
                <button class="btn" id="copyNotes" type="button">
                  <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M8 7h8M8 11h8M8 15h6"
                      stroke="currentColor"
                      stroke-width="1.7"
                      stroke-linecap="round"
                    />
                    <path
                      d="M7 3h10a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2Z"
                      stroke="currentColor"
                      stroke-width="1.7"
                      stroke-linejoin="round"
                    />
                  </svg>
                  Copy show notes
                </button>
                <button class="btn" id="sleepBtn" type="button">
                  <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M12 22a8.5 8.5 0 1 1 8.5-8.5A8.5 8.5 0 0 1 12 22Z"
                      stroke="currentColor"
                      stroke-width="1.7"
                    />
                    <path d="M12 8v5l3 2" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" />
                  </svg>
                  Sleep timer
                </button>
              </div>
            </div>
            <div class="section">
              <h3>Show Notes</h3>
              <ul class="notes" id="dNotes"></ul>
            </div>
            <div class="section">
              <h3>Chapters</h3>
              <div class="chapters" id="dChapters"></div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <div class="mini" aria-label="Mini player">
      <div class="miniInner" id="mini" style="display: none">
        <div class="miniCtrls">
          <button class="btn icon" id="miniPrev" type="button" aria-label="Previous episode">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M6 6v12" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" />
              <path
                d="M18 7v10l-8-5 8-5Z"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linejoin="round"
              />
            </svg>
          </button>
          <button class="btn icon" id="miniPlay" type="button" aria-label="Play or pause">
            <svg id="miniPI" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M10 8.5v7l6-3.5-6-3.5Z"
                fill="currentColor"
                stroke="currentColor"
                stroke-linejoin="round"
              />
            </svg>
          </button>
          <button class="btn icon" id="miniNext" type="button" aria-label="Next episode">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M18 6v12" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" />
              <path
                d="M6 7v10l8-5-8-5Z"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
        <div class="miniTitle">
          <b id="miniT">—</b>
          <span id="miniS">0:00 · 0:00</span>
        </div>
        <div class="miniSeek">
          <label class="srOnly" for="miniSeek">Seek</label>
          <input id="miniSeek" type="range" min="0" max="1000" value="0" />
        </div>
      </div>
    </div>

    <div class="toastWrap" id="toasts" aria-live="polite" aria-relevant="additions"></div>

    <div class="modalBackdrop" id="subModal" role="dialog" aria-modal="true" aria-labelledby="subTitle">
      <div class="modal" role="document">
        <div class="modalHeader">
          <h2 id="subTitle">Subscribe</h2>
          <button class="btn icon" id="closeSub" type="button" aria-label="Close subscribe dialog">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M7 7l10 10M17 7 7 17"
                stroke="currentColor"
                stroke-width="1.8"
                stroke-linecap="round"
              />
            </svg>
          </button>
        </div>
        <div class="modalBody">
          <div class="subGrid">
            <div class="subCard">
              <b>RSS</b>
              <span>Copy the RSS URL or XML (demo feed generated in-browser). Great for podcast apps.</span>
              <div class="field">
                <input id="rssUrl" readonly value="podcast://example/rss.xml" aria-label="RSS URL" />
                <button class="btn" id="copyRssUrl" type="button">Copy</button>
              </div>
              <div class="subRow">
                <button class="btn" id="copyRssXml" type="button">Copy RSS XML</button>
                <button class="btn" id="dlRssXml" type="button">Download RSS XML</button>
              </div>
            </div>
            <div class="subCard">
              <b>Apps</b>
              <span>Buttons open a placeholder subscribe intent. Replace URLs with your real show pages.</span>
              <div class="subRow">
                <button class="btn" data-sub="apple" type="button">Apple Podcasts</button>
                <button class="btn" data-sub="spotify" type="button">Spotify</button>
                <button class="btn" data-sub="yt" type="button">YouTube</button>
                <button class="btn" data-sub="overcast" type="button">Overcast</button>
              </div>
            </div>
          </div>
          <div class="pill">
            Keyboard: <strong style="margin-left: 6px">S</strong> open subscribe · <strong>F</strong> favorite · <strong>/</strong>
            search · <strong>Space</strong> play/pause
          </div>
        </div>
      </div>
    </div>

    <audio id="audio" preload="none" crossorigin="anonymous"></audio>

    <script>
      (() => {
        "use strict";

        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

        const store = {
          get(key, fallback) {
            try {
              const v = localStorage.getItem(key);
              return v == null ? fallback : JSON.parse(v);
            } catch {
              return fallback;
            }
          },
          set(key, value) {
            try {
              localStorage.setItem(key, JSON.stringify(value));
            } catch {}
          },
        };

        const fmt = {
          time(sec) {
            if (!Number.isFinite(sec) || sec < 0) return "0:00";
            const s = Math.floor(sec);
            const m = Math.floor(s / 60);
            const r = s % 60;
            return `${m}:${String(r).padStart(2, "0")}`;
          },
          date(iso) {
            try {
              const d = new Date(iso);
              return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "2-digit" });
            } catch {
              return iso;
            }
          },
        };

        function seeded(seed) {
          // Mulberry32
          let t = seed >>> 0;
          return () => {
            t += 0x6d2b79f5;
            let r = Math.imul(t ^ (t >>> 15), 1 | t);
            r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
            return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
          };
        }

        const EPISODES = [
          {
            id: 101,
            title: "The 10-Minute Mix: Building an Audio-First Product Mindset",
            date: "2026-01-22",
            guests: ["Asha Bennett"],
            tags: ["Product", "Audio UX", "Leadership"],
            blurb:
              "A practical playbook for audio-centric interfaces—what to measure, what to ship, and how to keep listening delightful.",
            notes: [
              "Why audio UIs fail: friction, ambiguity, and hidden state.",
              "Designing for ears: tactile controls, forgiving interactions, and fast resume.",
              "How to think in chapters: tiny wins that feel like progress.",
            ],
            chapters: [
              { t: 0, name: "Cold open: The “one-thumb rule”" },
              { t: 22, name: "Making controls obvious without clutter" },
              { t: 50, name: "Metrics that matter (and the ones that lie)" },
              { t: 88, name: "Chaptering like a pro" },
            ],
          },
          {
            id: 102,
            title: "Mic Technique Myths (and the Tiny Fixes That Change Everything)",
            date: "2026-01-15",
            guests: ["Nico Alvarez"],
            tags: ["Audio", "Production", "Gear"],
            blurb:
              "We bust common recording myths, then walk through setup tweaks you can do in under five minutes—no new gear required.",
            notes: [
              "Distance beats EQ: get the source right first.",
              "Room reflections: DIY treatment that actually helps.",
              "Simple editing: noise floor, breath control, and consistency.",
            ],
            chapters: [
              { t: 0, name: "Warm-up: Why your voice sounds “thin”" },
              { t: 26, name: "Mic position and proximity effect" },
              { t: 60, name: "Room reflections and quick fixes" },
              { t: 104, name: "Compression without pumping" },
            ],
          },
          {
            id: 103,
            title: "Search That Feels Instant: Indexing Episodes for Humans",
            date: "2026-01-08",
            guests: ["Kira Singh"],
            tags: ["Search", "UX", "Information Architecture"],
            blurb:
              "A deep dive into search UX: relevance, highlighting, and affordances that make large back catalogs feel approachable.",
            notes: [
              "Search is navigation, not a database query.",
              "Designing great empty states and “no results” paths.",
              "Tagging systems that don’t explode over time.",
            ],
            chapters: [
              { t: 0, name: "Defining “good enough” relevance" },
              { t: 28, name: "Highlighting that doesn’t distract" },
              { t: 66, name: "Tags vs categories vs series" },
              { t: 114, name: "The power of recent searches" },
            ],
          },
          {
            id: 104,
            title: "Chapters, Transcripts, and Trust: Accessibility as a Feature",
            date: "2025-12-18",
            guests: ["Maya Thompson"],
            tags: ["Accessibility", "Audio UX", "Community"],
            blurb:
              "Why accessible podcasts win listeners: clear controls, captions/transcripts, and chapter markers that respect attention.",
            notes: [
              "Accessible doesn’t mean boring—just clear.",
              "Chapters enable skimming without losing context.",
              "Transcripts improve discovery and trust.",
            ],
            chapters: [
              { t: 0, name: "Attention is a scarce resource" },
              { t: 30, name: "Chapters as UI: the subtle superpower" },
              { t: 70, name: "Transcript workflows that scale" },
              { t: 120, name: "Community feedback loops" },
            ],
          },
          {
            id: 105,
            title: "The Art of the Cold Open: Hook Without Hype",
            date: "2025-12-04",
            guests: ["Jordan Lee"],
            tags: ["Storytelling", "Editing", "Growth"],
            blurb:
              "Cold opens don’t need clickbait. Learn structures that earn curiosity—then deliver, quickly, with chaptered clarity.",
            notes: [
              "Three cold-open patterns that work across genres.",
              "Avoiding the “promise gap”.",
              "Editing for momentum: cut earlier, earlier, earlier.",
            ],
            chapters: [
              { t: 0, name: "The promise gap" },
              { t: 24, name: "Pattern 1: Question → proof" },
              { t: 55, name: "Pattern 2: Moment → rewind" },
              { t: 96, name: "Pattern 3: Contrarian claim" },
            ],
          },
          {
            id: 106,
            title: "Audio Branding: Sonic Logos That Don’t Get Old",
            date: "2025-11-20",
            guests: ["Elena Park"],
            tags: ["Brand", "Audio", "Design"],
            blurb:
              "Sonic identity for podcasts: what makes a signature sound timeless, and how to avoid the ‘too trendy’ trap.",
            notes: [
              "Why “memorable” ≠ “loud”.",
              "Frequency choices that survive headphones and car speakers.",
              "Keeping intros short without feeling rushed.",
            ],
            chapters: [
              { t: 0, name: "What sonic branding is (and isn’t)" },
              { t: 33, name: "Designing for contexts" },
              { t: 68, name: "Avoiding trend fatigue" },
              { t: 116, name: "Production tips and templates" },
            ],
          },
          {
            id: 107,
            title: "Listener Retention: The First 60 Seconds",
            date: "2025-11-06",
            guests: ["Samir Patel"],
            tags: ["Analytics", "Storytelling", "Growth"],
            blurb:
              "How to earn attention fast: pacing, clarity, and micro-structure. We also cover practical ‘what to cut’ heuristics.",
            notes: [
              "Pacing: breathe, but don’t wander.",
              "Clarity: name the outcome in one sentence.",
              "Structure: tease → deliver → recap.",
            ],
            chapters: [
              { t: 0, name: "The 60-second contract" },
              { t: 25, name: "Pacing without rushing" },
              { t: 58, name: "Clarity beats cleverness" },
              { t: 110, name: "Micro-structure checklist" },
            ],
          },
          {
            id: 108,
            title: "From Script to Studio: A Repeatable Episode Workflow",
            date: "2025-10-23",
            guests: ["Zoë Morgan"],
            tags: ["Workflow", "Production", "Tools"],
            blurb: "A calm, repeatable pipeline: outlines, recordings, edits, QA, and publishing—without turning your life into a checklist.",
            notes: [
              "Outlines that leave room for spontaneity.",
              "Batching: recording days vs editing days.",
              "QA: catch the small stuff before your audience does.",
            ],
            chapters: [
              { t: 0, name: "Designing a workflow you’ll keep" },
              { t: 34, name: "Outlines that breathe" },
              { t: 70, name: "Editing cadence" },
              { t: 122, name: "QA and publishing" },
            ],
          },
          {
            id: 109,
            title: "The Mini Player: Persistent Playback That Doesn’t Annoy",
            date: "2025-10-09",
            guests: ["Harper Nguyen"],
            tags: ["Audio UX", "Web", "Interaction"],
            blurb:
              "A delightful mini player keeps you in flow. We discuss progressive disclosure, keyboard shortcuts, and respectful animations.",
            notes: [
              "Always visible, never noisy.",
              "Respect focus: accessibility and keyboard-first controls.",
              "Progress indicators that feel precise.",
            ],
            chapters: [
              { t: 0, name: "The persistent playback promise" },
              { t: 29, name: "Keyboard and focus states" },
              { t: 62, name: "UX patterns that scale" },
              { t: 118, name: "Avoiding disruption" },
            ],
          },
          {
            id: 110,
            title: "Mixing for Phones: Loudness, Dynamics, and Clarity",
            date: "2025-09-18",
            guests: ["Rina Cho"],
            tags: ["Production", "Audio", "Mixing"],
            blurb:
              "Most listeners are on phones. Here’s how to mix for tiny speakers without destroying dynamics—or your sanity.",
            notes: [
              "Loudness targets and why they exist.",
              "EQ moves that translate across devices.",
              "The ‘smile curve’ temptation and when to resist.",
            ],
            chapters: [
              { t: 0, name: "What “translation” really means" },
              { t: 32, name: "Dynamic range vs intelligibility" },
              { t: 74, name: "EQ you can feel" },
              { t: 122, name: "Final checks" },
            ],
          },
          {
            id: 111,
            title: "Building Series: Making a Back Catalog Feel Curated",
            date: "2025-08-28",
            guests: ["Noah Kim"],
            tags: ["Content", "Information Architecture", "Growth"],
            blurb:
              "Turn hundreds of episodes into ‘seasons’ listeners can actually browse. We cover naming, grouping, and mental models.",
            notes: [
              "Series names should describe outcomes, not vibes.",
              "Don’t make listeners do taxonomy work for you.",
              "Use chapters and tags to help scanning.",
            ],
            chapters: [
              { t: 0, name: "Why catalogs feel overwhelming" },
              { t: 27, name: "Series frameworks" },
              { t: 63, name: "Naming conventions" },
              { t: 115, name: "Curating without losing history" },
            ],
          },
          {
            id: 112,
            title: "The Ethics of Audio AI: Consent, Attribution, and Trust",
            date: "2025-08-07",
            guests: ["Dr. Imani Wells"],
            tags: ["Ethics", "AI", "Community"],
            blurb:
              "A grounded conversation about synthetic media: how to stay transparent, protect guests, and build long-term audience trust.",
            notes: [
              "Consent flows for guests and co-hosts.",
              "Attribution: what audiences expect.",
              "Practical guardrails for creators and teams.",
            ],
            chapters: [
              { t: 0, name: "Why trust is earned slowly" },
              { t: 35, name: "Consent and disclosure" },
              { t: 78, name: "Attribution frameworks" },
              { t: 124, name: "Practical guardrails" },
            ],
          },
          {
            id: 113,
            title: "Designing the Perfect Episode Page: Scan, Then Listen",
            date: "2025-07-17",
            guests: ["Priya Nair"],
            tags: ["Design", "Audio UX", "Web"],
            blurb:
              "An episode page should be readable at a glance: clear title, crisp summary, obvious playback, and rich show notes.",
            notes: [
              "Hierarchy: title → play → summary → chapters.",
              "Show notes that read like a mini article.",
              "Reduce friction: one-click resume.",
            ],
            chapters: [
              { t: 0, name: "Designing for scanning" },
              { t: 30, name: "Clear playback affordances" },
              { t: 64, name: "Show notes as content" },
              { t: 120, name: "The resume loop" },
            ],
          },
          {
            id: 114,
            title: "Soundscapes and Beds: When Background Audio Helps",
            date: "2025-06-26",
            guests: ["Tariq Osman"],
            tags: ["Audio", "Storytelling", "Production"],
            blurb:
              "Background sound can elevate narrative—if it’s subtle. We discuss layering, EQ carving, and when silence is stronger.",
            notes: [
              "Mixing beds under dialogue safely.",
              "EQ carving: space for voice.",
              "The power of intentional silence.",
            ],
            chapters: [
              { t: 0, name: "Why beds exist" },
              { t: 26, name: "Layering without clutter" },
              { t: 62, name: "Carving space for voice" },
              { t: 112, name: "Silence as a tool" },
            ],
          },
          {
            id: 115,
            title: "Metrics for Creators: Downloads, Minutes, and Meaning",
            date: "2025-06-05",
            guests: ["Evan Richards"],
            tags: ["Analytics", "Business", "Growth"],
            blurb:
              "A no-nonsense guide to podcast metrics: what to track, what to ignore, and how to turn numbers into better episodes.",
            notes: [
              "Downloads are lagging indicators; minutes are leading.",
              "Cohorts tell stories, not single data points.",
              "Measure learning: what did you improve this week?",
            ],
            chapters: [
              { t: 0, name: "What numbers can’t tell you" },
              { t: 33, name: "Minutes listened and drop-off" },
              { t: 72, name: "Cohorts and series experiments" },
              { t: 118, name: "Turning metrics into action" },
            ],
          },
          {
            id: 116,
            title: "Community Episodes: Let Your Listeners Co-Host",
            date: "2025-05-15",
            guests: ["Kelsey Rivera"],
            tags: ["Community", "Content", "Growth"],
            blurb:
              "Community-driven episodes can be your most engaging content. Here’s how to solicit questions, curate, and credit listeners.",
            notes: [
              "Question prompts that get thoughtful answers.",
              "Curation: keep it focused without losing personality.",
              "Credit and follow-up: the relationship flywheel.",
            ],
            chapters: [
              { t: 0, name: "Why co-hosting works" },
              { t: 28, name: "Gathering listener questions" },
              { t: 64, name: "Curation and editing" },
              { t: 116, name: "Credit and follow-up" },
            ],
          },
        ];

        const audio = $("#audio");
        const q = $("#q");
        const listEl = $("#list");
        const sortEl = $("#sort");
        const onlyFavEl = $("#onlyFav");
        const tagRowEl = $("#tagRow");
        const resultsPill = $("#resultsPill");
        const themeBtn = $("#themeBtn");
        const subscribeBtn = $("#subscribeBtn");
        const subModal = $("#subModal");
        const closeSub = $("#closeSub");
        const rssUrl = $("#rssUrl");
        const copyRssUrl = $("#copyRssUrl");
        const copyRssXml = $("#copyRssXml");
        const dlRssXml = $("#dlRssXml");
        const playBtn = $("#playBtn");
        const playI = $("#playI");
        const seek = $("#seek");
        const vol = $("#vol");
        const speed = $("#speed");
        const tCur = $("#tCur");
        const tEnd = $("#tEnd");
        const viz = $("#viz");
        const vizHint = $("#vizHint");
        const toasts = $("#toasts");
        const mini = $("#mini");
        const miniT = $("#miniT");
        const miniS = $("#miniS");
        const miniSeek = $("#miniSeek");
        const miniPlay = $("#miniPlay");
        const miniPI = $("#miniPI");
        const miniPrev = $("#miniPrev");
        const miniNext = $("#miniNext");

        const npH = $("#npH");
        const npEp = $("#npEp");
        const npDur = $("#npDur");
        const npDate = $("#npDate");
        const npShare = $("#npShare");
        const npFav = $("#npFav");
        const npDl = $("#npDl");

        const dTitle = $("#dTitle");
        const dDesc = $("#dDesc");
        const dNotes = $("#dNotes");
        const dChapters = $("#dChapters");
        const copyLink = $("#copyLink");
        const copyNotes = $("#copyNotes");
        const sleepBtn = $("#sleepBtn");

        const stCount = $("#stCount");
        const stNew = $("#stNew");
        const stListen = $("#stListen");

        const LS = {
          fav: "podcast.favorites.v1",
          theme: "podcast.theme.v1",
          positions: "podcast.positions.v1",
          listened: "podcast.listenedSeconds.v1",
        };

        const state = {
          query: "",
          sort: "new",
          onlyFav: false,
          tag: null,
          selectedId: EPISODES[0]?.id ?? null,
          favorites: new Set(store.get(LS.fav, [])),
          positions: store.get(LS.positions, {}),
          listenedSeconds: store.get(LS.listened, 0),
          sleepUntil: null,
        };

        const audioCache = new Map(); // episodeId -> { url, seconds, createdAt }
        let audioCtx = null;
        let analyser = null;
        let srcNode = null;
        let vizRAF = 0;
        let lastTick = performance.now();
        let lastListenMark = 0;
        let generating = false;

        function toast(title, message) {
          const el = document.createElement("div");
          el.className = "toast";
          el.innerHTML = `<b></b><span></span>`;
          el.querySelector("b").textContent = title;
          el.querySelector("span").textContent = message;
          toasts.appendChild(el);
          setTimeout(() => {
            el.style.opacity = "0";
            el.style.transform = "translateY(-4px)";
            el.style.transition = "opacity .25s ease, transform .25s ease";
          }, 2600);
          setTimeout(() => el.remove(), 3000);
        }

        function setTheme(theme) {
          document.documentElement.dataset.theme = theme;
          store.set(LS.theme, theme);
        }

        function toggleTheme() {
          const cur = document.documentElement.dataset.theme;
          setTheme(cur === "light" ? "dark" : "light");
          toast("Theme", `Switched to ${document.documentElement.dataset.theme} mode`);
        }

        function computePreviewSeconds(ep) {
          // 95–170 seconds, deterministic.
          const r = seeded(ep.id)();
          return Math.round(95 + r * 75);
        }

        function episodeIndexById(id) {
          return EPISODES.findIndex((e) => e.id === id);
        }

        function currentEpisode() {
          return EPISODES.find((e) => e.id === state.selectedId) || EPISODES[0];
        }

        function persistFavorites() {
          store.set(LS.fav, Array.from(state.favorites));
        }

        function persistPositions() {
          store.set(LS.positions, state.positions);
        }

        function setFav(id, on) {
          if (on) state.favorites.add(id);
          else state.favorites.delete(id);
          persistFavorites();
          renderList();
          renderNowPlaying();
          toast(on ? "Saved" : "Removed", on ? "Added to favorites" : "Removed from favorites");
        }

        function escapeHtml(s) {
          return String(s)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
        }

        function highlight(text, query) {
          const t = String(text);
          const q = query.trim();
          if (!q) return escapeHtml(t);
          const parts = q
            .split(/\s+/)
            .filter(Boolean)
            .slice(0, 6)
            .map((p) => p.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
          if (!parts.length) return escapeHtml(t);
          const re = new RegExp(`(${parts.join("|")})`, "ig");
          return escapeHtml(t).replace(re, "<mark>$1</mark>");
        }

        function matches(ep) {
          const q = state.query.trim().toLowerCase();
          if (state.onlyFav && !state.favorites.has(ep.id)) return false;
          if (state.tag && !ep.tags.includes(state.tag)) return false;
          if (!q) return true;
          const hay = [
            ep.title,
            ep.blurb,
            ep.date,
            ep.guests.join(" "),
            ep.tags.join(" "),
            ep.notes.join(" "),
            ep.chapters.map((c) => c.name).join(" "),
          ]
            .join(" · ")
            .toLowerCase();
          return q.split(/\s+/).every((t) => hay.includes(t));
        }

        function sorted(eps) {
          const arr = eps.slice();
          const byDate = (a, b) => new Date(b.date) - new Date(a.date);
          const byTitle = (a, b) => a.title.localeCompare(b.title);
          const byLen = (a, b) => computePreviewSeconds(b) - computePreviewSeconds(a);
          if (state.sort === "new") arr.sort(byDate);
          else if (state.sort === "old") arr.sort((a, b) => -byDate(a, b));
          else if (state.sort === "az") arr.sort(byTitle);
          else if (state.sort === "len") arr.sort(byLen);
          return arr;
        }

        function renderTags() {
          const counts = new Map();
          for (const ep of EPISODES) {
            for (const t of ep.tags) counts.set(t, (counts.get(t) || 0) + 1);
          }
          const tags = Array.from(counts.entries())
            .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
            .slice(0, 12);
          tagRowEl.innerHTML = "";

          const all = document.createElement("button");
          all.type = "button";
          all.className = "chip" + (state.tag ? "" : " active");
          all.textContent = "All";
          all.addEventListener("click", () => {
            state.tag = null;
            renderAll();
          });
          tagRowEl.appendChild(all);

          for (const [t, c] of tags) {
            const b = document.createElement("button");
            b.type = "button";
            b.className = "chip" + (state.tag === t ? " active" : "");
            b.textContent = `${t} · ${c}`;
            b.addEventListener("click", () => {
              state.tag = state.tag === t ? null : t;
              renderAll();
            });
            tagRowEl.appendChild(b);
          }
        }

        function renderStats() {
          stCount.textContent = String(EPISODES.length);
          const newest = EPISODES.slice().sort((a, b) => new Date(b.date) - new Date(a.date))[0];
          stNew.textContent = newest ? fmt.date(newest.date) : "—";
          const mins = Math.floor((state.listenedSeconds || 0) / 60);
          stListen.textContent = mins ? `${mins} min` : "—";
        }

        function renderList() {
          const filtered = sorted(EPISODES.filter(matches));
          resultsPill.innerHTML = `<strong>${filtered.length}</strong> results`;

          const activeId = state.selectedId;
          const activeEp = EPISODES.find((e) => e.id === activeId) || null;
          const activeInFiltered = filtered.some((e) => e.id === activeId);
          const shouldPin = !!activeEp && !activeInFiltered && !audio.paused && !!audio.src;

          // Ensure selection remains valid when not playing.
          if (filtered.length && !activeInFiltered && !shouldPin) state.selectedId = filtered[0].id;

          listEl.innerHTML = "";
          if (shouldPin) {
            const ep = activeEp;
            const el = document.createElement("div");
            el.className = "episode active";
            el.role = "listitem";
            el.tabIndex = 0;
            el.innerHTML = `
              <div class="epBtn" aria-hidden="true">${icon("pause")}</div>
              <div class="epMain">
                <h3>${highlight(ep.title, state.query)}</h3>
                <p>${highlight(ep.blurb, state.query)}</p>
                <div class="epMeta">
                  <span class="pill" style="padding:4px 8px; font-size:11px; color:var(--text); border-color: rgba(34,211,238,.55); background: rgba(34,211,238,.12)">Now playing (filtered)</span>
                  <span>${fmt.date(ep.date)}</span>
                  <span>•</span>
                  <span>${computePreviewSeconds(ep)}s preview</span>
                </div>
              </div>
              <div class="epRight">
                <button class="iconBtn ${state.favorites.has(ep.id) ? "favOn" : ""}" data-act="fav" aria-label="Favorite" title="Favorite (F)">
                  ${icon("star")}
                </button>
                <div class="badge">#${ep.id}</div>
              </div>
            `;

            el.querySelector('[data-act="fav"]').addEventListener("click", (ev) => {
              ev.stopPropagation();
              setFav(ep.id, !state.favorites.has(ep.id));
            });
            const open = () => selectEpisode(ep.id);
            el.addEventListener("click", open);
            el.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                open();
              }
            });
            listEl.appendChild(el);
          }

          const effectiveActiveId = state.selectedId;
          for (const ep of filtered) {
            const el = document.createElement("div");
            el.className = "episode" + (ep.id === effectiveActiveId ? " active" : "");
            el.role = "listitem";
            el.tabIndex = 0;

            const isFav = state.favorites.has(ep.id);
            const progress = Math.min(1, Math.max(0, (state.positions[ep.id] || 0) / Math.max(1, audioCache.get(ep.id)?.seconds || computePreviewSeconds(ep))));
            const progressText = progress > 0.01 ? `${Math.round(progress * 100)}%` : "";

            el.innerHTML = `
              <div class="epBtn" aria-hidden="true">${icon("play")}</div>
              <div class="epMain">
                <h3>${highlight(ep.title, state.query)}</h3>
                <p>${highlight(ep.blurb, state.query)}</p>
                <div class="epMeta">
                  <span>${fmt.date(ep.date)}</span>
                  <span>•</span>
                  <span>${computePreviewSeconds(ep)}s preview</span>
                  <span>•</span>
                  <span>${escapeHtml(ep.guests[0] || "—")}</span>
                  ${progressText ? `<span class="badge">• ${progressText}</span>` : ""}
                </div>
              </div>
              <div class="epRight">
                <button class="iconBtn ${isFav ? "favOn" : ""}" data-act="fav" aria-label="Favorite" title="Favorite (F)">
                  ${icon("star")}
                </button>
                <div class="badge">#${ep.id}</div>
              </div>
            `;

            const favBtn = el.querySelector('[data-act="fav"]');
            favBtn.addEventListener("click", (ev) => {
              ev.stopPropagation();
              setFav(ep.id, !state.favorites.has(ep.id));
            });

            const open = () => {
              selectEpisode(ep.id);
              if (window.innerWidth <= 1020) {
                // Scroll details into view on smaller screens
                $(".rightPane")?.scrollIntoView({ behavior: "smooth", block: "start" });
              }
            };
            el.addEventListener("click", open);
            el.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                open();
              }
            });
            listEl.appendChild(el);
          }
        }

        function renderDetails() {
          const ep = currentEpisode();
          if (!ep) return;
          dTitle.textContent = ep.title;
          dDesc.textContent = ep.blurb;
          dNotes.innerHTML = "";
          for (const n of ep.notes) {
            const li = document.createElement("li");
            li.textContent = n;
            dNotes.appendChild(li);
          }
          dChapters.innerHTML = "";
          for (const c of ep.chapters) {
            const row = document.createElement("div");
            row.className = "chapter";
            row.innerHTML = `
              <button type="button" aria-label="Play from chapter">${icon("play")}</button>
              <div style="min-width:0">
                <div style="font-size:13px; line-height:1.2">${escapeHtml(c.name)}</div>
                <small>${fmt.time(c.t)}</small>
              </div>
              <small>Jump</small>
            `;
            row.querySelector("button").addEventListener("click", async () => {
              await ensureAudio(ep);
              audio.currentTime = Math.min(audio.duration || 0, c.t);
              await audio.play().catch(() => {});
            });
            dChapters.appendChild(row);
          }
        }

        function renderNowPlaying() {
          const ep = currentEpisode();
          if (!ep) return;
          npH.textContent = ep.title;
          npEp.textContent = `#${ep.id} · ${ep.guests.join(", ") || "—"}`;
          npDur.textContent = `${computePreviewSeconds(ep)}s`;
          npDate.textContent = fmt.date(ep.date);
          npFav.classList.toggle("favOn", state.favorites.has(ep.id));
          miniT.textContent = ep.title;
          document.title = `${ep.title} · Podcast Home Page`;
          updateMini();
        }

        function renderAll() {
          renderTags();
          renderStats();
          renderList();
          renderNowPlaying();
          renderDetails();
        }

        function icon(name) {
          if (name === "play")
            return `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M10 8.5v7l6-3.5-6-3.5Z" fill="currentColor" stroke="currentColor" stroke-linejoin="round"/></svg>`;
          if (name === "pause")
            return `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M8 7v10M16 7v10" stroke="currentColor" stroke-width="2.1" stroke-linecap="round"/></svg>`;
          if (name === "star")
            return `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 17.3 6.4 20l1.1-6.2L3 9.6l6.2-.9L12 3l2.8 5.7 6.2.9-4.5 4.2 1.1 6.2L12 17.3Z" stroke="currentColor" stroke-width="1.7" stroke-linejoin="round"/></svg>`;
          return "";
        }

        function updateRangeFill(inputEl) {
          const v = Number(inputEl.value) || 0;
          const min = Number(inputEl.min) || 0;
          const max = Number(inputEl.max) || 1000;
          const pct = ((v - min) / (max - min)) * 100;
          inputEl.style.setProperty("--fill", `${pct}%`);
        }

        function setPlayIcon(playing) {
          playI.innerHTML = playing ? icon("pause") : icon("play");
          miniPI.innerHTML = playing ? icon("pause") : icon("play");
          vizHint.classList.toggle("hidden", playing);
        }

        function openSub() {
          subModal.classList.add("open");
          subModal.querySelector(".modal")?.focus?.();
        }
        function closeSubModal() {
          subModal.classList.remove("open");
        }

        function rssXml() {
          const base = location.href.split("#")[0];
          const items = EPISODES.slice()
            .sort((a, b) => new Date(b.date) - new Date(a.date))
            .map((e) => {
              const desc = escapeHtml(e.blurb);
              return `
                <item>
                  <title>${escapeHtml(e.title)}</title>
                  <guid isPermaLink="false">${e.id}</guid>
                  <pubDate>${new Date(e.date).toUTCString()}</pubDate>
                  <description><![CDATA[${desc}]]></description>
                  <link>${base}#ep=${e.id}</link>
                </item>`;
            })
            .join("");

          return `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Podcast Home Page (Demo)</title>
    <link>${escapeHtml(base)}</link>
    <description>Self-contained demo feed for the Podcast Home Page single-file app.</description>
    <language>en</language>
    ${items}
  </channel>
</rss>`;
        }

        async function copyText(text, label = "Copied") {
          try {
            await navigator.clipboard.writeText(text);
            toast(label, "Saved to clipboard");
          } catch {
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            ta.remove();
            toast(label, "Saved to clipboard");
          }
        }

        function selectEpisode(id) {
          state.selectedId = id;
          renderList();
          renderNowPlaying();
          renderDetails();
          // Update hash for shareability (without scrolling jumps)
          const url = new URL(location.href);
          url.hash = `ep=${id}`;
          history.replaceState(null, "", url.toString());
        }

        function stepEpisode(delta) {
          const filtered = sorted(EPISODES.filter(matches));
          if (!filtered.length) return;
          const idx = filtered.findIndex((e) => e.id === state.selectedId);
          const next = filtered[(idx + delta + filtered.length) % filtered.length];
          if (next) selectEpisode(next.id);
        }

        function ensureAudioContext() {
          if (audioCtx) return;
          const Ctx = window.AudioContext || window.webkitAudioContext;
          audioCtx = new Ctx();
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 2048;
          analyser.smoothingTimeConstant = 0.86;
          srcNode = audioCtx.createMediaElementSource(audio);
          const gain = audioCtx.createGain();
          gain.gain.value = (Number(vol.value) || 0) / 1000;
          srcNode.connect(analyser);
          analyser.connect(gain);
          gain.connect(audioCtx.destination);
          audio._gain = gain;
        }

        function drawViz() {
          cancelAnimationFrame(vizRAF);
          const ctx = viz.getContext("2d");
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          const rect = viz.getBoundingClientRect();
          viz.width = Math.floor(rect.width * dpr);
          viz.height = Math.floor(rect.height * dpr);
          ctx.scale(dpr, dpr);

          const w = rect.width;
          const h = rect.height;
          const data = new Uint8Array(analyser ? analyser.frequencyBinCount : 1024);

          const theme = document.documentElement.dataset.theme || "dark";
          const grad = ctx.createLinearGradient(0, 0, w, 0);
          grad.addColorStop(0, theme === "light" ? "rgba(34,211,238,.9)" : "rgba(139,92,246,.92)");
          grad.addColorStop(1, theme === "light" ? "rgba(139,92,246,.9)" : "rgba(34,211,238,.9)");

          const paint = () => {
            vizRAF = requestAnimationFrame(paint);
            ctx.clearRect(0, 0, w, h);

            // Subtle grid
            ctx.globalAlpha = theme === "light" ? 0.18 : 0.12;
            ctx.strokeStyle = theme === "light" ? "rgba(3,7,18,.28)" : "rgba(255,255,255,.22)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 1; i < 6; i++) {
              const y = (h / 6) * i;
              ctx.moveTo(0, y);
              ctx.lineTo(w, y);
            }
            ctx.stroke();

            if (!analyser) {
              idleWave(ctx, w, h, performance.now(), theme);
              return;
            }

            analyser.getByteFrequencyData(data);
            const bars = 56;
            const step = Math.floor(data.length / bars);
            const gap = 5;
            const barW = (w - gap * (bars - 1)) / bars;

            // glow
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = grad;
            for (let i = 0; i < bars; i++) {
              let sum = 0;
              for (let j = 0; j < step; j++) sum += data[i * step + j];
              const v = sum / step;
              const mag = (v / 255) * 0.9;
              const barH = Math.max(4, mag * h * 0.92);
              const x = i * (barW + gap);
              const y = h - barH;
              ctx.fillRect(x, y, barW, barH);
            }
            ctx.globalAlpha = 1;

            // crisp bars
            ctx.fillStyle = grad;
            for (let i = 0; i < bars; i++) {
              let sum = 0;
              for (let j = 0; j < step; j++) sum += data[i * step + j];
              const v = sum / step;
              const mag = (v / 255) * 0.9;
              const barH = Math.max(4, mag * h * 0.75);
              const x = i * (barW + gap);
              const y = h - barH;
              ctx.fillRect(x, y, barW, barH);
            }

            // playhead overlay
            const dur = audio.duration || 0;
            const cur = audio.currentTime || 0;
            const p = dur ? cur / dur : 0;
            ctx.globalAlpha = theme === "light" ? 0.3 : 0.22;
            ctx.fillStyle = theme === "light" ? "rgba(3,7,18,.65)" : "rgba(255,255,255,.65)";
            ctx.fillRect(p * w, 0, 2, h);
            ctx.globalAlpha = 1;
          };

          paint();
        }

        function idleWave(ctx, w, h, now, theme) {
          const t = now / 1000;
          ctx.globalAlpha = theme === "light" ? 0.9 : 0.85;
          const grad = ctx.createLinearGradient(0, 0, w, 0);
          grad.addColorStop(0, theme === "light" ? "rgba(34,211,238,.55)" : "rgba(139,92,246,.55)");
          grad.addColorStop(1, theme === "light" ? "rgba(139,92,246,.55)" : "rgba(34,211,238,.55)");
          ctx.strokeStyle = grad;
          ctx.lineWidth = 2;
          ctx.beginPath();
          const mid = h * 0.56;
          for (let x = 0; x <= w; x += 8) {
            const y =
              mid +
              Math.sin(x / 50 + t * 1.2) * 10 +
              Math.sin(x / 18 - t * 0.9) * 4 +
              Math.sin(x / 120 + t * 0.45) * 12;
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        function audioBufferToWav(abuffer) {
          // 16-bit PCM WAV
          const numChannels = abuffer.numberOfChannels;
          const sampleRate = abuffer.sampleRate;
          const numFrames = abuffer.length;
          const bitsPerSample = 16;
          const blockAlign = (numChannels * bitsPerSample) / 8;
          const byteRate = sampleRate * blockAlign;
          const dataSize = numFrames * blockAlign;
          const buffer = new ArrayBuffer(44 + dataSize);
          const view = new DataView(buffer);

          function writeString(off, str) {
            for (let i = 0; i < str.length; i++) view.setUint8(off + i, str.charCodeAt(i));
          }

          writeString(0, "RIFF");
          view.setUint32(4, 36 + dataSize, true);
          writeString(8, "WAVE");
          writeString(12, "fmt ");
          view.setUint32(16, 16, true);
          view.setUint16(20, 1, true);
          view.setUint16(22, numChannels, true);
          view.setUint32(24, sampleRate, true);
          view.setUint32(28, byteRate, true);
          view.setUint16(32, blockAlign, true);
          view.setUint16(34, bitsPerSample, true);
          writeString(36, "data");
          view.setUint32(40, dataSize, true);

          let offset = 44;
          const channels = [];
          for (let c = 0; c < numChannels; c++) channels.push(abuffer.getChannelData(c));
          for (let i = 0; i < numFrames; i++) {
            for (let c = 0; c < numChannels; c++) {
              let s = channels[c][i];
              s = Math.max(-1, Math.min(1, s));
              view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
              offset += 2;
            }
          }
          return new Blob([buffer], { type: "audio/wav" });
        }

        async function generatePreview(ep, seconds) {
          const sr = 44100;
          const len = Math.floor(seconds * sr);
          const ctx = new OfflineAudioContext(2, len, sr);
          const rand = seeded(ep.id);

          // Bed: warm pad
          const pad = ctx.createOscillator();
          pad.type = "sine";
          pad.frequency.value = 110 + rand() * 50;
          const padGain = ctx.createGain();
          padGain.gain.value = 0.0001;
          pad.connect(padGain).connect(ctx.destination);

          // "Voice-ish" carrier: saw through moving bandpass to mimic formants
          const voice = ctx.createOscillator();
          voice.type = "sawtooth";
          voice.frequency.value = 130 + rand() * 80;
          const vGain = ctx.createGain();
          vGain.gain.value = 0.0001;
          const formant1 = ctx.createBiquadFilter();
          formant1.type = "bandpass";
          formant1.frequency.value = 700;
          formant1.Q.value = 5.2;
          const formant2 = ctx.createBiquadFilter();
          formant2.type = "bandpass";
          formant2.frequency.value = 1200;
          formant2.Q.value = 6.0;
          voice.connect(formant1).connect(formant2).connect(vGain).connect(ctx.destination);

          // Percussive ticks (chapters)
          const tickGain = ctx.createGain();
          tickGain.gain.value = 0.85;
          tickGain.connect(ctx.destination);

          function env(g, t0, t1, peak) {
            g.gain.setValueAtTime(0.0001, t0);
            g.gain.exponentialRampToValueAtTime(peak, t0 + 0.02);
            g.gain.exponentialRampToValueAtTime(0.0001, t1);
          }

          // Fade in beds
          env(padGain, 0.0, 1.0, 0.045);
          env(vGain, 0.0, 0.9, 0.06);
          padGain.gain.setTargetAtTime(0.03, 1.0, 0.8);
          vGain.gain.setTargetAtTime(0.035, 0.9, 0.55);

          // Prosody & formants
          const phraseCount = 10 + Math.floor(rand() * 6);
          for (let i = 0; i < phraseCount; i++) {
            const at = (seconds / phraseCount) * i + rand() * 0.08;
            const dur = 0.32 + rand() * 0.38;
            const f1 = 550 + rand() * 420;
            const f2 = 1050 + rand() * 820;
            formant1.frequency.setValueAtTime(f1, at);
            formant1.frequency.linearRampToValueAtTime(f1 + (rand() - 0.5) * 160, at + dur);
            formant2.frequency.setValueAtTime(f2, at);
            formant2.frequency.linearRampToValueAtTime(f2 + (rand() - 0.5) * 260, at + dur);
            voice.frequency.setValueAtTime(120 + rand() * 110, at);
            const burst = ctx.createGain();
            burst.gain.value = 0.0001;
            vGain.connect(burst);
            env(burst, at, at + dur, 0.8);
            burst.connect(ctx.destination);
          }

          // Chapter ticks at ep.chapters times (scaled to preview length)
          const chapTs = ep.chapters.map((c) => c.t).filter((t) => Number.isFinite(t) && t >= 0);
          const maxChap = Math.max(1, ...chapTs);
          for (const t of chapTs) {
            const tt = Math.min(seconds - 0.06, (t / maxChap) * (seconds - 0.2));
            const o = ctx.createOscillator();
            o.type = "triangle";
            o.frequency.value = 880 + rand() * 320;
            const g = ctx.createGain();
            g.gain.value = 0.0001;
            o.connect(g).connect(tickGain);
            env(g, tt, tt + 0.08, 0.14);
            o.start(tt);
            o.stop(tt + 0.1);
          }

          // Outro fade
          padGain.gain.setTargetAtTime(0.0001, Math.max(0, seconds - 1.3), 0.5);
          vGain.gain.setTargetAtTime(0.0001, Math.max(0, seconds - 1.0), 0.4);

          pad.start(0);
          voice.start(0);
          pad.stop(seconds);
          voice.stop(seconds);

          const rendered = await ctx.startRendering();
          return audioBufferToWav(rendered);
        }

        async function ensureAudio(ep) {
          if (!ep) return null;
          const seconds = computePreviewSeconds(ep);
          const cached = audioCache.get(ep.id);
          if (cached?.url) return cached;
          if (generating) {
            toast("Working", "Generating audio preview…");
          }
          generating = true;
          toast("Generating", "Creating a self-contained audio preview…");
          try {
            const wav = await generatePreview(ep, seconds);
            const url = URL.createObjectURL(wav);
            const obj = { url, seconds, createdAt: Date.now() };
            audioCache.set(ep.id, obj);
            return obj;
          } finally {
            generating = false;
          }
        }

        async function loadEpisode(ep, { autoplay = false } = {}) {
          if (!ep) return;
          ensureAudioContext();
          if (audioCtx.state === "suspended") await audioCtx.resume().catch(() => {});

          const cache = await ensureAudio(ep);
          if (!cache) return;

          const prevUrl = audio.src;
          if (prevUrl && prevUrl.startsWith("blob:") && prevUrl !== cache.url) {
            // do not revoke: could be cached for other actions; GC is fine for demo
          }
          audio.src = cache.url;
          audio.playbackRate = Number(speed.value) || 1;
          audio._gain.gain.value = (Number(vol.value) || 0) / 1000;

          const saved = Number(state.positions[ep.id] || 0);
          audio.currentTime = Math.min(saved, Math.max(0, (audio.duration || cache.seconds) - 0.25));
          if (autoplay) await audio.play().catch(() => {});
          setPlayIcon(!audio.paused);
          mini.style.display = "grid";
        }

        function updateTimes() {
          const dur = Number.isFinite(audio.duration) ? audio.duration : computePreviewSeconds(currentEpisode());
          const cur = audio.currentTime || 0;
          tCur.textContent = fmt.time(cur);
          tEnd.textContent = fmt.time(dur);
          miniS.textContent = `${fmt.time(cur)} · ${fmt.time(dur)}`;
          const p = dur ? cur / dur : 0;
          seek.value = String(Math.round(p * 1000));
          miniSeek.value = String(Math.round(p * 1000));
          updateRangeFill(seek);
          updateRangeFill(miniSeek);

          // Persist position every ~2s while playing
          if (!audio.paused && !audio.ended && Number.isFinite(cur)) {
            const now = performance.now();
            if (now - lastListenMark > 2000) {
              const ep = currentEpisode();
              state.positions[ep.id] = cur;
              persistPositions();
              lastListenMark = now;
            }
          }
        }

        function updateMini() {
          const ep = currentEpisode();
          if (!ep) return;
          miniT.textContent = ep.title;
          updateTimes();
        }

        async function togglePlay() {
          const ep = currentEpisode();
          if (!ep) return;
          ensureAudioContext();
          if (!audio.src) await loadEpisode(ep, { autoplay: false });
          if (audio.paused) {
            await audio.play().catch(() => {});
            setPlayIcon(true);
          } else {
            audio.pause();
            setPlayIcon(false);
          }
        }

        function seekToPct(pct) {
          const dur = audio.duration || computePreviewSeconds(currentEpisode());
          audio.currentTime = Math.max(0, Math.min(dur, dur * pct));
          updateTimes();
        }

        async function shareEpisode() {
          const ep = currentEpisode();
          if (!ep) return;
          const url = new URL(location.href);
          url.hash = `ep=${ep.id}`;
          const payload = {
            title: ep.title,
            text: `${ep.title} — ${ep.blurb}`,
            url: url.toString(),
          };
          if (navigator.share) {
            try {
              await navigator.share(payload);
              toast("Shared", "Sent via share sheet");
              return;
            } catch {}
          }
          await copyText(payload.url, "Link copied");
        }

        async function downloadPreview() {
          const ep = currentEpisode();
          if (!ep) return;
          const cache = await ensureAudio(ep);
          if (!cache?.url) return;
          const a = document.createElement("a");
          a.href = cache.url;
          a.download = `podcast-episode-${ep.id}-preview.wav`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          toast("Download", "Preview WAV saved");
        }

        function sleepMenu() {
          const choices = [
            { label: "Off", mins: 0 },
            { label: "5 min", mins: 5 },
            { label: "10 min", mins: 10 },
            { label: "20 min", mins: 20 },
            { label: "End of preview", mins: -1 },
          ];
          const msg = choices.map((c, i) => `${i + 1}. ${c.label}`).join("\n");
          const pick = prompt(`Sleep timer:\n${msg}\n\nType 1-${choices.length} and press Enter`, "2");
          const idx = Number(pick) - 1;
          if (!Number.isFinite(idx) || idx < 0 || idx >= choices.length) return;
          const c = choices[idx];
          if (c.mins === 0) {
            state.sleepUntil = null;
            toast("Sleep timer", "Off");
          } else if (c.mins === -1) {
            state.sleepUntil = "end";
            toast("Sleep timer", "Will stop at end of preview");
          } else {
            state.sleepUntil = Date.now() + c.mins * 60 * 1000;
            toast("Sleep timer", `Will stop in ${c.mins} minutes`);
          }
        }

        function handleSleepTick() {
          if (!state.sleepUntil) return;
          if (state.sleepUntil === "end") return;
          if (Date.now() >= state.sleepUntil) {
            audio.pause();
            setPlayIcon(false);
            state.sleepUntil = null;
            toast("Sleep timer", "Paused");
          }
        }

        function handleListenAccounting(now) {
          const dt = (now - lastTick) / 1000;
          lastTick = now;
          if (!audio.paused && Number.isFinite(dt) && dt > 0 && dt < 1.25) {
            state.listenedSeconds += dt;
            if (Math.floor(state.listenedSeconds) % 10 === 0) store.set(LS.listened, Math.floor(state.listenedSeconds));
          }
        }

        function parseHashSelection() {
          const h = (location.hash || "").replace(/^#/, "");
          const m = h.match(/(?:^|&)ep=(\d+)/);
          if (!m) return;
          const id = Number(m[1]);
          if (EPISODES.some((e) => e.id === id)) state.selectedId = id;
        }

        function bind() {
          q.addEventListener("input", () => {
            state.query = q.value;
            renderList();
            renderDetails();
          });
          sortEl.addEventListener("change", () => {
            state.sort = sortEl.value;
            renderList();
          });
          onlyFavEl.addEventListener("change", () => {
            state.onlyFav = !!onlyFavEl.checked;
            renderAll();
          });

          themeBtn.addEventListener("click", toggleTheme);

          subscribeBtn.addEventListener("click", openSub);
          closeSub.addEventListener("click", closeSubModal);
          subModal.addEventListener("click", (e) => {
            if (e.target === subModal) closeSubModal();
          });
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && subModal.classList.contains("open")) closeSubModal();
          });

          copyRssUrl.addEventListener("click", () => copyText(rssUrl.value, "RSS URL copied"));
          copyRssXml.addEventListener("click", () => copyText(rssXml(), "RSS XML copied"));
          dlRssXml.addEventListener("click", () => {
            const blob = new Blob([rssXml()], { type: "application/rss+xml" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "podcast-rss.xml";
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(url), 1000);
            toast("Download", "RSS XML saved");
          });
          $$("[data-sub]").forEach((b) => {
            b.addEventListener("click", () => {
              const kind = b.dataset.sub;
              toast("Subscribe", `Open ${kind} intent (placeholder)`);
              // Intent placeholder
              const show = encodeURIComponent("Podcast Home Page (Demo)");
              const url = kind === "spotify" ? "https://open.spotify.com/" : kind === "apple" ? "https://podcasts.apple.com/" : kind === "yt" ? "https://www.youtube.com/" : "https://overcast.fm/";
              window.open(`${url}?q=${show}`, "_blank", "noopener,noreferrer");
            });
          });

          playBtn.addEventListener("click", togglePlay);
          miniPlay.addEventListener("click", togglePlay);
          miniPrev.addEventListener("click", () => stepEpisode(-1));
          miniNext.addEventListener("click", () => stepEpisode(1));

          speed.addEventListener("change", () => {
            audio.playbackRate = Number(speed.value) || 1;
            toast("Speed", `Playback set to ${speed.options[speed.selectedIndex].text}`);
          });
          vol.addEventListener("input", () => {
            updateRangeFill(vol);
            if (audio._gain) audio._gain.gain.value = (Number(vol.value) || 0) / 1000;
          });

          seek.addEventListener("input", () => {
            updateRangeFill(seek);
            if (!audio.duration) return;
            seekToPct((Number(seek.value) || 0) / 1000);
          });
          miniSeek.addEventListener("input", () => {
            updateRangeFill(miniSeek);
            if (!audio.duration) return;
            seekToPct((Number(miniSeek.value) || 0) / 1000);
          });

          audio.addEventListener("timeupdate", updateTimes);
          audio.addEventListener("play", () => setPlayIcon(true));
          audio.addEventListener("pause", () => setPlayIcon(false));
          audio.addEventListener("ended", () => {
            setPlayIcon(false);
            const ep = currentEpisode();
            state.positions[ep.id] = 0;
            persistPositions();
            renderList();
          });
          audio.addEventListener("loadedmetadata", updateTimes);

          npShare.addEventListener("click", shareEpisode);
          npFav.addEventListener("click", () => {
            const ep = currentEpisode();
            setFav(ep.id, !state.favorites.has(ep.id));
          });
          npDl.addEventListener("click", downloadPreview);

          copyLink.addEventListener("click", async () => {
            const ep = currentEpisode();
            const url = new URL(location.href);
            url.hash = `ep=${ep.id}`;
            await copyText(url.toString(), "Link copied");
          });
          copyNotes.addEventListener("click", async () => {
            const ep = currentEpisode();
            const text = [
              ep.title,
              `Published: ${fmt.date(ep.date)}`,
              `Guests: ${ep.guests.join(", ") || "—"}`,
              `Tags: ${ep.tags.join(", ")}`,
              "",
              ep.blurb,
              "",
              "Show notes:",
              ...ep.notes.map((n) => `- ${n}`),
              "",
              "Chapters:",
              ...ep.chapters.map((c) => `- ${fmt.time(c.t)} ${c.name}`),
            ].join("\n");
            await copyText(text, "Notes copied");
          });
          sleepBtn.addEventListener("click", sleepMenu);

          // Keyboard shortcuts
          document.addEventListener("keydown", (e) => {
            const tag = (e.target && e.target.tagName) || "";
            const typing = tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || e.isComposing;
            if (e.key === "/" && !typing) {
              e.preventDefault();
              q.focus();
              return;
            }
            if (typing) return;
            if (e.key === " " || e.code === "Space") {
              e.preventDefault();
              togglePlay();
            } else if (e.key.toLowerCase() === "j") {
              stepEpisode(1);
            } else if (e.key.toLowerCase() === "k") {
              stepEpisode(-1);
            } else if (e.key.toLowerCase() === "f") {
              const ep = currentEpisode();
              setFav(ep.id, !state.favorites.has(ep.id));
            } else if (e.key.toLowerCase() === "s") {
              openSub();
            } else if (e.key === "ArrowRight") {
              if (!audio.src) return;
              audio.currentTime = Math.min((audio.duration || 1e9) - 0.01, (audio.currentTime || 0) + 15);
            } else if (e.key === "ArrowLeft") {
              if (!audio.src) return;
              audio.currentTime = Math.max(0, (audio.currentTime || 0) - 10);
            }
          });

          // Resize redraw
          window.addEventListener("resize", () => drawViz());
          window.addEventListener("hashchange", () => {
            parseHashSelection();
            renderAll();
          });

          // First user gesture: kick audio ctx and viz.
          const unlock = async () => {
            ensureAudioContext();
            if (audioCtx.state === "suspended") await audioCtx.resume().catch(() => {});
            drawViz();
            window.removeEventListener("pointerdown", unlock);
            window.removeEventListener("keydown", unlock);
          };
          window.addEventListener("pointerdown", unlock, { once: true });
          window.addEventListener("keydown", unlock, { once: true });
        }

        function tick(now) {
          handleListenAccounting(now);
          handleSleepTick();
          requestAnimationFrame(tick);
        }

        async function boot() {
          // Theme
          const savedTheme = store.get(LS.theme, null);
          if (savedTheme === "light" || savedTheme === "dark") setTheme(savedTheme);
          else {
            const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
            setTheme(prefersLight ? "light" : "dark");
          }

          // Restore selection via hash
          parseHashSelection();

          // Wire initial UI values
          sortEl.value = state.sort;
          onlyFavEl.checked = state.onlyFav;
          updateRangeFill(seek);
          updateRangeFill(miniSeek);
          updateRangeFill(vol);

          // Subscribe modal RSS URL placeholder uses current path
          rssUrl.value = `${location.origin}${location.pathname}#rss=demo`;

          bind();
          renderAll();
          drawViz();

          // Preload current episode only on explicit play; but show nice toast
          toast("Ready", "Search, pick an episode, then press Space to listen");

          // If hash selects ep, ensure list scrolled to it
          setTimeout(() => {
            const active = listEl.querySelector(".episode.active");
            active?.scrollIntoView?.({ block: "nearest" });
          }, 120);

          requestAnimationFrame(tick);
        }

        boot().catch((err) => {
          console.error(err);
          toast("Error", "Something went wrong while starting the app");
        });
      })();
    </script>
  </body>
</html>
