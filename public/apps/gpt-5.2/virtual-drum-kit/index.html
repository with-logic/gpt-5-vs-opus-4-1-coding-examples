<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <meta name="theme-color" content="#0b0f19" />
    <title>Virtual Drum Kit</title>
    <style>
      :root{
        --bg0:#070a12;
        --bg1:#0b0f19;
        --bg2:#111a2c;
        --panel:#0c1220cc;
        --panel2:#0a1020f2;
        --stroke:#273248;
        --stroke2:#33435f;
        --text:#e9eefc;
        --muted:#a6b3cc;
        --good:#27e0a5;
        --warn:#ffd36a;
        --bad:#ff5f6d;
        --accent:#7c5cff;
        --accent2:#22d3ee;
        --shadow: 0 20px 60px rgba(0,0,0,.55);
        --glow: 0 0 0 1px rgba(255,255,255,.06), 0 18px 70px rgba(124,92,255,.18), 0 0 30px rgba(34,211,238,.10);
        --radius:18px;
        --pad-radius:22px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      }

      *{ box-sizing:border-box; }
      html,body{ height:100%; }
      body{
        margin:0;
        font-family: var(--sans);
        color:var(--text);
        background:
          radial-gradient(1200px 600px at 20% -10%, rgba(124,92,255,.25), transparent 55%),
          radial-gradient(900px 500px at 90% 10%, rgba(34,211,238,.18), transparent 55%),
          radial-gradient(1000px 650px at 40% 120%, rgba(255,95,109,.12), transparent 60%),
          linear-gradient(180deg, var(--bg0), var(--bg1) 35%, #050711);
        overflow-x:hidden;
      }

      /* subtle “studio dust” */
      body::before{
        content:"";
        position:fixed;
        inset:-40px;
        pointer-events:none;
        background-image:
          radial-gradient(circle at 10% 20%, rgba(255,255,255,.05) 0 1px, transparent 2px),
          radial-gradient(circle at 70% 30%, rgba(255,255,255,.04) 0 1px, transparent 2px),
          radial-gradient(circle at 30% 70%, rgba(255,255,255,.035) 0 1px, transparent 2px),
          radial-gradient(circle at 90% 85%, rgba(255,255,255,.03) 0 1px, transparent 2px);
        background-size: 220px 220px, 280px 280px, 240px 240px, 320px 320px;
        opacity:.7;
        filter: blur(.2px);
        mix-blend-mode: screen;
      }

      a{ color:inherit; }
      button, input{ font:inherit; }

      .app{
        min-height:100%;
        display:flex;
        flex-direction:column;
      }

      header{
        padding: clamp(16px, 2vw, 22px) clamp(16px, 3vw, 28px);
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:14px;
      }

      .brand{
        display:flex;
        gap:12px;
        align-items:center;
        min-width: 240px;
      }
      .logo{
        width:44px;height:44px;
        border-radius:14px;
        background:
          radial-gradient(18px 18px at 30% 30%, rgba(255,255,255,.20), transparent 60%),
          radial-gradient(30px 30px at 70% 70%, rgba(34,211,238,.25), transparent 65%),
          linear-gradient(135deg, rgba(124,92,255,.95), rgba(19,27,54,.9));
        box-shadow: 0 12px 45px rgba(124,92,255,.25), 0 0 0 1px rgba(255,255,255,.08) inset;
        position:relative;
        overflow:hidden;
      }
      .logo::after{
        content:"";
        position:absolute;
        inset:-40%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,.28), transparent);
        transform: rotate(25deg);
        animation: sheen 8s linear infinite;
        opacity:.35;
      }
      @keyframes sheen{
        0%{ transform: translateX(-35%) rotate(25deg); }
        100%{ transform: translateX(35%) rotate(25deg); }
      }
      .title{
        display:flex;
        flex-direction:column;
        gap:4px;
      }
      .title h1{
        margin:0;
        font-size: clamp(18px, 2.2vw, 24px);
        letter-spacing:.2px;
      }
      .title p{
        margin:0;
        color:var(--muted);
        font-size: 13px;
        line-height: 1.35;
      }
      .header-actions{
        display:flex;
        align-items:center;
        gap:10px;
        flex-wrap:wrap;
        justify-content:flex-end;
      }

      .pill{
        display:inline-flex;
        align-items:center;
        gap:8px;
        padding:10px 12px;
        border-radius: 999px;
        background: rgba(10,16,32,.55);
        border: 1px solid rgba(255,255,255,.08);
        box-shadow: 0 10px 40px rgba(0,0,0,.25);
        color: var(--muted);
        user-select:none;
      }
      .dot{
        width:9px;height:9px;
        border-radius:99px;
        background: var(--bad);
        box-shadow: 0 0 0 3px rgba(255,95,109,.15);
      }
      .dot.on{
        background: var(--good);
        box-shadow: 0 0 0 3px rgba(39,224,165,.16), 0 0 25px rgba(39,224,165,.24);
      }
      .kbd{
        font-family: var(--mono);
        font-size: 12px;
        letter-spacing:.3px;
        padding: 2px 7px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(0,0,0,.25);
        color: rgba(233,238,252,.92);
      }
      .ghost-btn{
        display:inline-flex;
        align-items:center;
        gap:8px;
        padding:10px 12px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(9,14,28,.45);
        color: rgba(233,238,252,.95);
        box-shadow: 0 10px 40px rgba(0,0,0,.18);
        cursor:pointer;
        transition: transform .12s ease, background .15s ease, border-color .15s ease;
      }
      .ghost-btn:hover{ background: rgba(12,18,36,.60); border-color: rgba(255,255,255,.14); }
      .ghost-btn:active{ transform: translateY(1px) scale(.995); }
      .ghost-btn:focus-visible{
        outline: none;
        box-shadow: 0 0 0 3px rgba(124,92,255,.35), 0 10px 40px rgba(0,0,0,.18);
      }

      main{
        flex:1;
        padding: 0 clamp(14px, 3vw, 28px) clamp(18px, 3vw, 28px);
        display:grid;
        grid-template-columns: 1.45fr .85fr;
        gap: clamp(14px, 2vw, 20px);
        align-items:stretch;
      }

      .surface{
        border-radius: var(--radius);
        background: linear-gradient(180deg, rgba(15,22,44,.82), rgba(8,12,24,.72));
        border: 1px solid rgba(255,255,255,.08);
        box-shadow: var(--shadow);
        position:relative;
        overflow:hidden;
      }

      .kit{
        padding: 18px;
        display:flex;
        flex-direction:column;
        gap:14px;
      }
      .kit-top{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:12px;
      }
      .kit-top .hint{
        color: var(--muted);
        font-size: 13px;
      }
      .kit-top .hint strong{ color: rgba(233,238,252,.95); font-weight:600; }
      .kit-stage{
        flex:1;
        display:grid;
        grid-template-rows: auto 1fr;
        gap: 14px;
        min-height: 420px;
      }

      .drum-illustration{
        position:absolute;
        inset: 0;
        pointer-events:none;
        opacity:.9;
      }
      .drum-illustration svg{
        width:100%;
        height:100%;
        display:block;
        filter: drop-shadow(0 25px 60px rgba(0,0,0,.55));
      }

      .pads{
        position:relative;
        z-index:2;
        display:grid;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        grid-template-rows: repeat(4, minmax(74px, 1fr));
        gap: 12px;
        padding: 10px;
      }

      .pad{
        position:relative;
        width:100%;
        height:100%;
        min-height:74px;
        border-radius: var(--pad-radius);
        border: 1px solid rgba(255,255,255,.10);
        background:
          radial-gradient(120px 80px at 30% 25%, rgba(255,255,255,.18), transparent 65%),
          linear-gradient(180deg, rgba(20,28,54,.92), rgba(7,10,19,.95));
        box-shadow:
          0 14px 40px rgba(0,0,0,.35),
          0 0 0 1px rgba(255,255,255,.06) inset,
          0 -18px 40px rgba(124,92,255,.10) inset;
        color: rgba(233,238,252,.92);
        cursor:pointer;
        user-select:none;
        -webkit-tap-highlight-color: transparent;
        touch-action: none;
        display:flex;
        flex-direction:column;
        justify-content:space-between;
        padding: 12px 12px 11px;
        transition: transform .06s ease, box-shadow .15s ease, border-color .15s ease, filter .15s ease;
      }
      .pad::before{
        content:"";
        position:absolute;
        inset: 8px;
        border-radius: calc(var(--pad-radius) - 10px);
        border: 1px solid rgba(255,255,255,.06);
        background: linear-gradient(180deg, rgba(255,255,255,.06), transparent 55%);
        pointer-events:none;
      }
      .pad:active{ transform: translateY(1px) scale(.995); filter: brightness(1.04); }
      .pad:focus-visible{
        outline:none;
        box-shadow: var(--glow), 0 14px 40px rgba(0,0,0,.35), 0 0 0 1px rgba(255,255,255,.06) inset;
      }
      .pad .row{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap: 10px;
      }
      .pad .name{
        font-weight: 700;
        letter-spacing:.2px;
        text-shadow: 0 12px 28px rgba(0,0,0,.35);
      }
      .pad .sub{
        font-size: 12px;
        color: rgba(166,179,204,.95);
      }
      .pad .key{
        font-family: var(--mono);
        font-size: 12px;
        padding: 3px 8px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(0,0,0,.25);
        color: rgba(233,238,252,.9);
      }

      .pad[data-color="kick"]{ --c: #ffcc66; }
      .pad[data-color="snare"]{ --c: #7c5cff; }
      .pad[data-color="hat"]{ --c: #22d3ee; }
      .pad[data-color="tom"]{ --c: #27e0a5; }
      .pad[data-color="cym"]{ --c: #ff5f6d; }
      .pad[data-color="fx"]{ --c: #a7b0ff; }
      .pad{
        box-shadow:
          0 14px 40px rgba(0,0,0,.35),
          0 0 0 1px rgba(255,255,255,.06) inset,
          0 -22px 48px color-mix(in oklab, var(--c) 20%, transparent) inset;
      }
      .pad.hit{
        border-color: color-mix(in oklab, var(--c) 55%, rgba(255,255,255,.14));
        box-shadow:
          0 18px 55px rgba(0,0,0,.40),
          0 0 0 1px rgba(255,255,255,.06) inset,
          0 0 0 4px color-mix(in oklab, var(--c) 22%, transparent),
          0 0 45px color-mix(in oklab, var(--c) 35%, transparent);
        transform: translateY(1px) scale(.995);
      }

      /* Drum layout (grid placement) */
      .pad[data-id="crash"]{ grid-column: 1 / span 2; grid-row: 1; }
      .pad[data-id="ride"]{ grid-column: 5 / span 2; grid-row: 1; }
      .pad[data-id="hihat"]{ grid-column: 1 / span 2; grid-row: 2; }
      .pad[data-id="openhihat"]{ grid-column: 3 / span 2; grid-row: 2; }
      .pad[data-id="snare"]{ grid-column: 2 / span 2; grid-row: 3; }
      .pad[data-id="tom1"]{ grid-column: 3 / span 2; grid-row: 3; }
      .pad[data-id="tom2"]{ grid-column: 5 / span 2; grid-row: 3; }
      .pad[data-id="floor"]{ grid-column: 4 / span 2; grid-row: 4; }
      .pad[data-id="kick"]{ grid-column: 1 / span 3; grid-row: 4; }

      .console{
        padding: 18px;
        display:flex;
        flex-direction:column;
        gap: 12px;
      }
      .panel-title{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }
      .panel-title h2{
        margin:0;
        font-size: 14px;
        color: rgba(233,238,252,.95);
        letter-spacing:.3px;
        text-transform: uppercase;
      }
      .panel-title .sub{
        color: var(--muted);
        font-size: 12px;
      }

      .transport{
        display:grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
      }
      .btn{
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(10,16,32,.55);
        box-shadow: 0 14px 40px rgba(0,0,0,.25);
        color: rgba(233,238,252,.95);
        padding: 12px 10px;
        cursor:pointer;
        transition: transform .12s ease, background .15s ease, border-color .15s ease;
      }
      .btn:hover{ background: rgba(12,18,36,.65); border-color: rgba(255,255,255,.14); }
      .btn:active{ transform: translateY(1px) scale(.995); }
      .btn:focus-visible{ outline:none; box-shadow: 0 0 0 3px rgba(124,92,255,.35), 0 14px 40px rgba(0,0,0,.25); }
      .btn.primary{
        background: linear-gradient(180deg, rgba(124,92,255,.90), rgba(72,44,210,.82));
        border-color: rgba(255,255,255,.14);
      }
      .btn.danger{
        background: linear-gradient(180deg, rgba(255,95,109,.92), rgba(168,36,57,.78));
        border-color: rgba(255,255,255,.14);
      }
      .btn.good{
        background: linear-gradient(180deg, rgba(39,224,165,.92), rgba(10,130,92,.80));
        border-color: rgba(255,255,255,.14);
      }
      .btn.toggled{
        box-shadow: 0 0 0 3px rgba(34,211,238,.22), 0 14px 40px rgba(0,0,0,.25);
        border-color: rgba(34,211,238,.45);
      }

      .row2{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .meters{
        border-radius: 16px;
        background: rgba(6,10,20,.55);
        border: 1px solid rgba(255,255,255,.08);
        overflow:hidden;
        position:relative;
      }
      .meters header{
        padding: 10px 12px 8px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap: 12px;
      }
      .meters header .tiny{
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(166,179,204,.92);
      }
      canvas{
        width:100%;
        height: 94px;
        display:block;
      }

      .controls{
        display:flex;
        flex-direction:column;
        gap: 10px;
      }
      .control{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap: 12px;
        padding: 10px 12px;
        border-radius: 16px;
        background: rgba(8,12,24,.55);
        border: 1px solid rgba(255,255,255,.08);
      }
      .control .label{
        display:flex;
        flex-direction:column;
        gap:3px;
      }
      .control .label .name{
        font-size: 13px;
        font-weight: 700;
        letter-spacing:.2px;
      }
      .control .label .desc{
        font-size: 12px;
        color: rgba(166,179,204,.92);
      }
      .control .value{
        display:flex;
        align-items:center;
        gap: 10px;
        min-width: 140px;
        justify-content:flex-end;
      }
      input[type="range"]{
        width: 150px;
        accent-color: var(--accent2);
      }
      input[type="number"]{
        width: 76px;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(0,0,0,.25);
        color: rgba(233,238,252,.95);
        text-align:right;
      }
      .toggle{
        display:inline-flex;
        align-items:center;
        gap: 8px;
      }
      .switch{
        width: 44px;
        height: 26px;
        border-radius: 999px;
        background: rgba(255,255,255,.10);
        border: 1px solid rgba(255,255,255,.12);
        position:relative;
        cursor:pointer;
        flex:none;
      }
      .switch::after{
        content:"";
        position:absolute;
        top:3px; left:3px;
        width: 20px; height: 20px;
        border-radius: 999px;
        background: rgba(233,238,252,.95);
        box-shadow: 0 10px 25px rgba(0,0,0,.35);
        transition: transform .18s ease, background .18s ease;
      }
      .switch.on{
        background: rgba(34,211,238,.22);
        border-color: rgba(34,211,238,.40);
      }
      .switch.on::after{
        transform: translateX(18px);
        background: rgba(34,211,238,.95);
      }

      .timeline{
        border-radius: 16px;
        background: rgba(6,10,20,.55);
        border: 1px solid rgba(255,255,255,.08);
        overflow:hidden;
        position:relative;
      }
      .timeline header{
        padding: 10px 12px 8px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap: 12px;
      }
      .timeline header .right{
        display:flex;
        align-items:center;
        gap: 10px;
      }
      .chip{
        font-family: var(--mono);
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(0,0,0,.22);
        color: rgba(233,238,252,.90);
        user-select:none;
      }
      .chip.good{ border-color: rgba(39,224,165,.35); }
      .chip.warn{ border-color: rgba(255,211,106,.35); }
      .chip.bad{ border-color: rgba(255,95,109,.35); }

      footer{
        padding: 0 clamp(16px, 3vw, 28px) 16px;
        color: rgba(166,179,204,.92);
        font-size: 12px;
        display:flex;
        gap: 10px;
        flex-wrap:wrap;
        justify-content:space-between;
        align-items:center;
      }
      footer .tips{
        display:flex;
        gap: 10px;
        flex-wrap:wrap;
        align-items:center;
      }
      .sep{ opacity:.5; }

      .unlock{
        position:fixed;
        inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        padding: 18px;
        background:
          radial-gradient(900px 600px at 50% 20%, rgba(124,92,255,.28), transparent 60%),
          radial-gradient(800px 520px at 55% 70%, rgba(34,211,238,.18), transparent 62%),
          rgba(5,7,17,.72);
        backdrop-filter: blur(14px);
        z-index: 40;
      }
      .unlock.hidden{ display:none; }
      .unlock-card{
        width: min(720px, 100%);
        border-radius: 24px;
        background: linear-gradient(180deg, rgba(16,24,48,.86), rgba(8,12,24,.82));
        border: 1px solid rgba(255,255,255,.10);
        box-shadow: 0 25px 90px rgba(0,0,0,.60);
        overflow:hidden;
      }
      .unlock-card .top{
        padding: 18px 18px 12px;
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap: 16px;
      }
      .unlock-card h3{ margin:0; font-size: 18px; }
      .unlock-card p{
        margin:6px 0 0;
        color: rgba(166,179,204,.95);
        line-height:1.45;
        font-size: 13px;
      }
      .unlock-card .content{
        padding: 0 18px 18px;
        display:grid;
        grid-template-columns: 1.1fr .9fr;
        gap: 14px;
        align-items:stretch;
      }
      .unlock-card .card{
        border-radius: 18px;
        background: rgba(0,0,0,.20);
        border: 1px solid rgba(255,255,255,.08);
        padding: 14px;
      }
      .unlock-card .list{
        margin:0;
        padding-left: 16px;
        color: rgba(233,238,252,.92);
        font-size: 13px;
        line-height:1.6;
      }
      .unlock-card .cta{
        padding: 14px 18px 18px;
        display:flex;
        justify-content:flex-end;
        gap: 10px;
        border-top: 1px solid rgba(255,255,255,.08);
        background: rgba(0,0,0,.12);
      }
      .big{
        padding: 12px 14px;
        border-radius: 16px;
      }
      .badge{
        display:inline-flex;
        align-items:center;
        gap: 8px;
        font-family: var(--mono);
        font-size: 12px;
        color: rgba(233,238,252,.92);
      }
      .badge span{
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(0,0,0,.20);
      }

      dialog{
        width:min(760px, calc(100% - 24px));
        border-radius: 18px;
        border: 1px solid rgba(255,255,255,.12);
        background: linear-gradient(180deg, rgba(16,24,48,.92), rgba(8,12,24,.92));
        color: rgba(233,238,252,.95);
        box-shadow: 0 25px 90px rgba(0,0,0,.60);
        padding: 0;
      }
      dialog::backdrop{
        background: rgba(0,0,0,.55);
        backdrop-filter: blur(10px);
      }
      .dlg{
        padding: 16px 16px 14px;
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap: 12px;
        border-bottom: 1px solid rgba(255,255,255,.08);
      }
      .dlg h3{ margin:0; font-size: 16px; }
      .dlg p{ margin:6px 0 0; color: rgba(166,179,204,.95); font-size: 13px; line-height:1.45; }
      .dlg-body{ padding: 14px 16px 16px; }
      .grid-help{
        display:grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }
      .help-card{
        border-radius: 16px;
        background: rgba(0,0,0,.20);
        border: 1px solid rgba(255,255,255,.08);
        padding: 12px 12px;
      }
      .help-card h4{ margin:0 0 8px; font-size: 13px; letter-spacing:.2px; text-transform: uppercase; color: rgba(233,238,252,.92); }
      .help-card ul{ margin:0; padding-left: 16px; color: rgba(166,179,204,.95); font-size: 13px; line-height:1.6; }
      .dlg-actions{
        padding: 12px 16px 16px;
        display:flex;
        justify-content:flex-end;
        gap:10px;
        border-top: 1px solid rgba(255,255,255,.08);
      }

      @media (max-width: 980px){
        main{ grid-template-columns: 1fr; }
        .kit-stage{ min-height: 520px; }
        .pads{
          grid-template-columns: repeat(4, minmax(0, 1fr));
          grid-template-rows: repeat(5, minmax(74px, 1fr));
        }
        .pad[data-id="crash"]{ grid-column: 1 / span 2; grid-row: 1; }
        .pad[data-id="ride"]{ grid-column: 3 / span 2; grid-row: 1; }
        .pad[data-id="hihat"]{ grid-column: 1 / span 2; grid-row: 2; }
        .pad[data-id="openhihat"]{ grid-column: 3 / span 2; grid-row: 2; }
        .pad[data-id="snare"]{ grid-column: 1 / span 2; grid-row: 3; }
        .pad[data-id="tom1"]{ grid-column: 3 / span 2; grid-row: 3; }
        .pad[data-id="tom2"]{ grid-column: 1 / span 2; grid-row: 4; }
        .pad[data-id="floor"]{ grid-column: 3 / span 2; grid-row: 4; }
        .pad[data-id="kick"]{ grid-column: 1 / span 4; grid-row: 5; min-height: 92px; }
      }

      @media (prefers-reduced-motion: reduce){
        .logo::after{ animation:none; }
        .pad, .btn, .ghost-btn{ transition:none; }
      }
    </style>
  </head>
  <body>
    <div class="app" id="app">
      <header>
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div class="title">
            <h1>Virtual Drum Kit</h1>
            <p>Play with keys or taps. Record grooves. Loop them like you’re in the control room.</p>
          </div>
        </div>
        <div class="header-actions">
          <div class="pill" title="Audio engine status">
            <span class="dot" id="audioDot" aria-hidden="true"></span>
            <span id="audioStatus">Audio: Locked</span>
          </div>
          <div class="pill" title="Quick tips">
            <span class="kbd">Space</span>
            <span>Play/Stop</span>
            <span class="sep">•</span>
            <span class="kbd">R</span>
            <span>Record</span>
            <span class="sep">•</span>
            <span class="kbd">?</span>
            <span>Help</span>
          </div>
          <button class="ghost-btn" id="helpBtn" type="button" aria-haspopup="dialog" aria-controls="helpDialog">
            <span aria-hidden="true">?</span>
            <span>Help</span>
          </button>
        </div>
      </header>

      <main>
        <section class="surface kit" aria-label="Drum kit">
          <div class="drum-illustration" aria-hidden="true">
            <svg viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice">
              <defs>
                <linearGradient id="shell" x1="0" x2="0" y1="0" y2="1">
                  <stop offset="0" stop-color="#25355e"/>
                  <stop offset="1" stop-color="#0b1024"/>
                </linearGradient>
                <linearGradient id="rim" x1="0" x2="1">
                  <stop offset="0" stop-color="rgba(255,255,255,.22)"/>
                  <stop offset="1" stop-color="rgba(255,255,255,.06)"/>
                </linearGradient>
                <radialGradient id="cym" cx="30%" cy="25%" r="80%">
                  <stop offset="0" stop-color="rgba(255,211,106,.30)"/>
                  <stop offset="0.55" stop-color="rgba(255,211,106,.14)"/>
                  <stop offset="1" stop-color="rgba(0,0,0,0)"/>
                </radialGradient>
              </defs>
              <g opacity=".85">
                <path d="M150 660 C 240 560, 420 520, 520 630" stroke="rgba(255,255,255,.10)" stroke-width="6" fill="none"/>
                <path d="M1060 660 C 980 560, 800 520, 700 630" stroke="rgba(255,255,255,.10)" stroke-width="6" fill="none"/>
                <path d="M240 260 L 300 540" stroke="rgba(255,255,255,.09)" stroke-width="6" />
                <path d="M980 260 L 900 540" stroke="rgba(255,255,255,.09)" stroke-width="6" />
                <path d="M600 240 L 600 520" stroke="rgba(255,255,255,.08)" stroke-width="6" />
              </g>
              <g opacity=".95">
                <ellipse cx="260" cy="245" rx="195" ry="66" fill="url(#cym)"/>
                <ellipse cx="940" cy="245" rx="215" ry="72" fill="url(#cym)"/>
                <ellipse cx="600" cy="220" rx="160" ry="54" fill="rgba(34,211,238,.10)"/>
              </g>
              <g opacity=".9">
                <g>
                  <ellipse cx="600" cy="610" rx="260" ry="110" fill="url(#shell)" stroke="rgba(255,255,255,.10)" stroke-width="2"/>
                  <ellipse cx="600" cy="585" rx="270" ry="60" fill="rgba(255,255,255,.04)" stroke="rgba(255,255,255,.08)" stroke-width="2"/>
                  <ellipse cx="600" cy="565" rx="250" ry="45" fill="rgba(0,0,0,.35)"/>
                </g>
                <g opacity=".95">
                  <ellipse cx="430" cy="520" rx="170" ry="70" fill="url(#shell)" stroke="rgba(255,255,255,.10)" stroke-width="2"/>
                  <ellipse cx="430" cy="500" rx="178" ry="38" fill="rgba(255,255,255,.04)" stroke="rgba(255,255,255,.08)" stroke-width="2"/>
                  <ellipse cx="430" cy="486" rx="160" ry="28" fill="rgba(0,0,0,.35)"/>
                </g>
                <g opacity=".95">
                  <ellipse cx="780" cy="520" rx="170" ry="70" fill="url(#shell)" stroke="rgba(255,255,255,.10)" stroke-width="2"/>
                  <ellipse cx="780" cy="500" rx="178" ry="38" fill="rgba(255,255,255,.04)" stroke="rgba(255,255,255,.08)" stroke-width="2"/>
                  <ellipse cx="780" cy="486" rx="160" ry="28" fill="rgba(0,0,0,.35)"/>
                </g>
                <g opacity=".95">
                  <ellipse cx="310" cy="590" rx="160" ry="68" fill="url(#shell)" stroke="rgba(255,255,255,.10)" stroke-width="2"/>
                  <ellipse cx="310" cy="572" rx="168" ry="36" fill="rgba(255,255,255,.04)" stroke="rgba(255,255,255,.08)" stroke-width="2"/>
                  <ellipse cx="310" cy="560" rx="150" ry="27" fill="rgba(0,0,0,.35)"/>
                </g>
                <g opacity=".95">
                  <ellipse cx="900" cy="590" rx="170" ry="72" fill="url(#shell)" stroke="rgba(255,255,255,.10)" stroke-width="2"/>
                  <ellipse cx="900" cy="572" rx="178" ry="38" fill="rgba(255,255,255,.04)" stroke="rgba(255,255,255,.08)" stroke-width="2"/>
                  <ellipse cx="900" cy="560" rx="160" ry="28" fill="rgba(0,0,0,.35)"/>
                </g>
              </g>
            </svg>
          </div>

          <div class="kit-top">
            <div class="hint">
              <strong>Tip:</strong> tap pads with multiple fingers, or drag with a mouse to “roll”.
            </div>
            <div class="pill" title="Current mode">
              <span class="chip" id="modeChip">IDLE</span>
              <span class="chip warn" id="timeChip">00:00.0</span>
            </div>
          </div>

          <div class="kit-stage">
            <div class="pads" id="pads" aria-label="Drum pads">
              <button class="pad" data-id="crash" data-color="cym" type="button" aria-label="Crash cymbal">
                <div class="row">
                  <div class="name">Crash</div>
                  <div class="key">K</div>
                </div>
                <div class="row">
                  <div class="sub">Bright splash</div>
                  <div class="sub">Cymbal</div>
                </div>
              </button>
              <button class="pad" data-id="ride" data-color="cym" type="button" aria-label="Ride cymbal">
                <div class="row">
                  <div class="name">Ride</div>
                  <div class="key">L</div>
                </div>
                <div class="row">
                  <div class="sub">Ping + wash</div>
                  <div class="sub">Cymbal</div>
                </div>
              </button>
              <button class="pad" data-id="hihat" data-color="hat" type="button" aria-label="Closed hi-hat">
                <div class="row">
                  <div class="name">Hi‑Hat</div>
                  <div class="key">D</div>
                </div>
                <div class="row">
                  <div class="sub">Tight</div>
                  <div class="sub">Closed</div>
                </div>
              </button>
              <button class="pad" data-id="openhihat" data-color="hat" type="button" aria-label="Open hi-hat">
                <div class="row">
                  <div class="name">Open Hat</div>
                  <div class="key">F</div>
                </div>
                <div class="row">
                  <div class="sub">Sizzle</div>
                  <div class="sub">Open</div>
                </div>
              </button>
              <button class="pad" data-id="snare" data-color="snare" type="button" aria-label="Snare drum">
                <div class="row">
                  <div class="name">Snare</div>
                  <div class="key">S</div>
                </div>
                <div class="row">
                  <div class="sub">Snap</div>
                  <div class="sub">Center</div>
                </div>
              </button>
              <button class="pad" data-id="tom1" data-color="tom" type="button" aria-label="High tom">
                <div class="row">
                  <div class="name">Tom</div>
                  <div class="key">G</div>
                </div>
                <div class="row">
                  <div class="sub">High</div>
                  <div class="sub">Rack</div>
                </div>
              </button>
              <button class="pad" data-id="tom2" data-color="tom" type="button" aria-label="Mid tom">
                <div class="row">
                  <div class="name">Tom 2</div>
                  <div class="key">H</div>
                </div>
                <div class="row">
                  <div class="sub">Mid</div>
                  <div class="sub">Rack</div>
                </div>
              </button>
              <button class="pad" data-id="floor" data-color="tom" type="button" aria-label="Floor tom">
                <div class="row">
                  <div class="name">Floor</div>
                  <div class="key">J</div>
                </div>
                <div class="row">
                  <div class="sub">Low</div>
                  <div class="sub">Boom</div>
                </div>
              </button>
              <button class="pad" data-id="kick" data-color="kick" type="button" aria-label="Kick drum">
                <div class="row">
                  <div class="name">Kick</div>
                  <div class="key">A</div>
                </div>
                <div class="row">
                  <div class="sub">Punch</div>
                  <div class="sub">Sub</div>
                </div>
              </button>
            </div>
          </div>
        </section>

        <aside class="surface console" aria-label="Studio console">
          <div class="panel-title">
            <div>
              <h2>Control Room</h2>
              <div class="sub">Transport • Levels • Metronome</div>
            </div>
            <div class="badge" title="Keyboard focus tip">
              <span>Tab</span>
              <span>Enter</span>
            </div>
          </div>

          <div class="transport" role="group" aria-label="Transport controls">
            <button class="btn danger" id="recBtn" type="button">● Record</button>
            <button class="btn" id="stopBtn" type="button">■ Stop</button>
            <button class="btn good" id="playBtn" type="button">▶ Play</button>
            <button class="btn" id="loopBtn" type="button" aria-pressed="false">↻ Loop</button>
          </div>

          <div class="row2">
            <button class="btn" id="clearBtn" type="button">Clear</button>
            <button class="btn" id="exportBtn" type="button">Export</button>
          </div>

          <div class="meters" aria-label="Scope">
            <header>
              <div class="tiny">SCOPE</div>
              <div class="tiny" id="vuLabel">— dB</div>
            </header>
            <canvas id="scope" width="820" height="180" aria-label="Audio scope"></canvas>
          </div>

          <div class="timeline" aria-label="Pattern timeline">
            <header>
              <div class="tiny">PATTERN</div>
              <div class="right">
                <div class="chip good" id="hitsChip">0 hits</div>
                <div class="chip" id="lenChip">2 bars</div>
              </div>
            </header>
            <canvas id="timeline" width="820" height="200" aria-label="Pattern view"></canvas>
          </div>

          <div class="controls" aria-label="Settings">
            <div class="control">
              <div class="label">
                <div class="name">Tempo</div>
                <div class="desc">Drives loop + metronome</div>
              </div>
              <div class="value">
                <input id="bpm" type="number" inputmode="numeric" min="60" max="200" value="120" aria-label="Tempo BPM" />
                <div class="chip" id="bpmChip">BPM</div>
              </div>
            </div>

            <div class="control">
              <div class="label">
                <div class="name">Loop Length</div>
                <div class="desc">Bars per loop</div>
              </div>
              <div class="value">
                <input id="bars" type="number" inputmode="numeric" min="1" max="8" value="2" aria-label="Bars per loop" />
                <div class="chip" id="barsChip">bars</div>
              </div>
            </div>

            <div class="control">
              <div class="label">
                <div class="name">Master</div>
                <div class="desc">Output level</div>
              </div>
              <div class="value">
                <input id="master" type="range" min="0" max="100" value="78" aria-label="Master volume" />
              </div>
            </div>

            <div class="control">
              <div class="label">
                <div class="name">Room</div>
                <div class="desc">Studio reverb</div>
              </div>
              <div class="value">
                <input id="room" type="range" min="0" max="100" value="22" aria-label="Room amount" />
              </div>
            </div>

            <div class="control">
              <div class="label">
                <div class="name">Metronome</div>
                <div class="desc">Click on quarter notes</div>
              </div>
              <div class="value">
                <div class="toggle" role="group" aria-label="Metronome toggle">
                  <div class="switch" id="metroToggle" role="switch" aria-checked="false" tabindex="0"></div>
                  <div class="chip">Click</div>
                </div>
              </div>
            </div>

            <div class="control">
              <div class="label">
                <div class="name">Count‑In</div>
                <div class="desc">1 bar before recording</div>
              </div>
              <div class="value">
                <div class="toggle" role="group" aria-label="Count-in toggle">
                  <div class="switch on" id="countInToggle" role="switch" aria-checked="true" tabindex="0"></div>
                  <div class="chip">1 bar</div>
                </div>
              </div>
            </div>

            <div class="control">
              <div class="label">
                <div class="name">Fixed Record</div>
                <div class="desc">Auto‑stop at loop end</div>
              </div>
              <div class="value">
                <div class="toggle" role="group" aria-label="Fixed record toggle">
                  <div class="switch on" id="fixedToggle" role="switch" aria-checked="true" tabindex="0"></div>
                  <div class="chip">Auto</div>
                </div>
              </div>
            </div>
          </div>
        </aside>
      </main>

      <footer>
        <div class="tips">
          <span>Keys:</span>
          <span class="kbd">A</span><span>Kick</span>
          <span class="kbd">S</span><span>Snare</span>
          <span class="kbd">D</span><span>Hat</span>
          <span class="kbd">F</span><span>Open</span>
          <span class="kbd">G</span><span>Tom</span>
          <span class="kbd">H</span><span>Tom 2</span>
          <span class="kbd">J</span><span>Floor</span>
          <span class="kbd">K</span><span>Crash</span>
          <span class="kbd">L</span><span>Ride</span>
        </div>
        <div class="tips">
          <span>Pro:</span>
          <span class="kbd">Shift</span><span>for harder hits</span>
          <span class="sep">•</span>
          <span class="kbd">Esc</span><span>Stop</span>
        </div>
      </footer>
    </div>

    <div class="unlock" id="unlock">
      <div class="unlock-card" role="dialog" aria-modal="true" aria-labelledby="unlockTitle">
        <div class="top">
          <div>
            <h3 id="unlockTitle">Enable Audio</h3>
            <p>Browsers require a tap/click before sound can play. After enabling, you can drum with your keyboard or touch.</p>
          </div>
          <div class="pill" style="align-self:flex-start">
            <span class="dot" id="unlockDot" aria-hidden="true"></span>
            <span id="unlockStatus">Waiting for input…</span>
          </div>
        </div>
        <div class="content">
          <div class="card">
            <div class="badge" style="margin-bottom:10px">
              <span>Space</span>
              <span>Play/Stop</span>
              <span>R</span>
              <span>Record</span>
            </div>
            <ul class="list">
              <li>Tap any pad to test sound instantly.</li>
              <li>Record a loop, then play it back with studio‑style controls.</li>
              <li>Works great on mobile — pads are built for thumbs.</li>
            </ul>
          </div>
          <div class="card">
            <div class="badge" style="margin-bottom:10px">
              <span>Offline</span>
              <span>WebAudio</span>
              <span>Self‑contained</span>
            </div>
            <ul class="list">
              <li>All drum sounds are synthesized (no downloads).</li>
              <li>Room reverb and compressor for a polished mix.</li>
              <li>Metronome + count‑in for tight recording.</li>
            </ul>
          </div>
        </div>
        <div class="cta">
          <button class="ghost-btn big" id="unlockHelp" type="button">Help</button>
          <button class="btn primary big" id="unlockBtn" type="button">Tap to Start</button>
        </div>
      </div>
    </div>

    <dialog id="helpDialog" aria-labelledby="helpTitle">
      <div class="dlg">
        <div>
          <h3 id="helpTitle">How to Play</h3>
          <p>Click/tap the pads or use the keyboard. Record your performance, then loop it back.</p>
        </div>
        <button class="ghost-btn" id="helpCloseX" type="button">Close</button>
      </div>
      <div class="dlg-body">
        <div class="grid-help">
          <div class="help-card">
            <h4>Playing</h4>
            <ul>
              <li>Tap pads (multi‑touch supported).</li>
              <li>Keyboard triggers: <span class="kbd">A S D F G H J K L</span></li>
              <li>Hold <span class="kbd">Shift</span> for harder hits.</li>
            </ul>
          </div>
          <div class="help-card">
            <h4>Recording</h4>
            <ul>
              <li><span class="kbd">R</span> or Record starts/ends recording.</li>
              <li>Count‑in gives you 1 bar before capture.</li>
              <li>Fixed Record stops at loop end automatically.</li>
            </ul>
          </div>
          <div class="help-card">
            <h4>Playback</h4>
            <ul>
              <li><span class="kbd">Space</span> toggles Play/Stop.</li>
              <li>Loop repeats the current bar length.</li>
              <li>Export copies the pattern as JSON.</li>
            </ul>
          </div>
          <div class="help-card">
            <h4>Studio Touches</h4>
            <ul>
              <li>Room adds reverb for depth.</li>
              <li>Scope shows your groove energy.</li>
              <li>Timeline visualizes hits by lane.</li>
            </ul>
          </div>
        </div>
      </div>
      <div class="dlg-actions">
        <button class="btn" id="helpClose" type="button">Got it</button>
      </div>
    </dialog>

    <noscript>
      <div style="padding:16px; color:#fff; font-family:system-ui;">
        JavaScript is required to run Virtual Drum Kit.
      </div>
    </noscript>

    <script>
      (function () {
        "use strict";

        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        const clamp = (n, a, b) => Math.min(b, Math.max(a, n));
        const fmtTime = (sec) => {
          const s = Math.max(0, sec);
          const m = Math.floor(s / 60);
          const r = s - m * 60;
          return String(m).padStart(2, "0") + ":" + r.toFixed(1).padStart(4, "0");
        };

        const els = {
          audioDot: $("#audioDot"),
          audioStatus: $("#audioStatus"),
          modeChip: $("#modeChip"),
          timeChip: $("#timeChip"),
          vuLabel: $("#vuLabel"),
          hitsChip: $("#hitsChip"),
          lenChip: $("#lenChip"),

          pads: $("#pads"),
          padButtons: $$(".pad"),

          recBtn: $("#recBtn"),
          stopBtn: $("#stopBtn"),
          playBtn: $("#playBtn"),
          loopBtn: $("#loopBtn"),
          clearBtn: $("#clearBtn"),
          exportBtn: $("#exportBtn"),

          bpm: $("#bpm"),
          bars: $("#bars"),
          master: $("#master"),
          room: $("#room"),
          metroToggle: $("#metroToggle"),
          countInToggle: $("#countInToggle"),
          fixedToggle: $("#fixedToggle"),

          scope: $("#scope"),
          timeline: $("#timeline"),

          unlock: $("#unlock"),
          unlockBtn: $("#unlockBtn"),
          unlockHelp: $("#unlockHelp"),
          unlockDot: $("#unlockDot"),
          unlockStatus: $("#unlockStatus"),

          helpBtn: $("#helpBtn"),
          helpDialog: $("#helpDialog"),
          helpClose: $("#helpClose"),
          helpCloseX: $("#helpCloseX"),
        };

        const keyMap = new Map([
          ["a", "kick"],
          ["s", "snare"],
          ["d", "hihat"],
          ["f", "openhihat"],
          ["g", "tom1"],
          ["h", "tom2"],
          ["j", "floor"],
          ["k", "crash"],
          ["l", "ride"],
        ]);

        const lanes = [
          { id: "crash", label: "Crash" },
          { id: "ride", label: "Ride" },
          { id: "hihat", label: "Hat" },
          { id: "openhihat", label: "Open" },
          { id: "snare", label: "Snare" },
          { id: "tom1", label: "Tom" },
          { id: "tom2", label: "Tom2" },
          { id: "floor", label: "Floor" },
          { id: "kick", label: "Kick" },
        ];

        const state = {
          audio: null,
          unlocked: false,
          masterGain: null,
          liveBus: null,
          playBus: null,
          busSum: null,
          comp: null,
          analyser: null,
          convolver: null,
          dryGain: null,
          wetGain: null,
          noise: null,
          scopeRaf: 0,

          mode: "idle", // idle | recording | playing | countin
          loop: false,
          metronome: false,
          countIn: true,
          fixed: true,
          bpm: 120,
          bars: 2,

          recordStartT: 0,
          sequence: [],
          lastPadByPointer: new Map(),
          pressedKeys: new Set(),

          play: {
            originT: 0,
            loopLen: 0,
            schedulerTimer: null,
            stopTimer: null,
            scheduledThrough: 0,
            transportRaf: 0,
            startedAtPerf: 0,
          },
        };

        function setMode(next) {
          state.mode = next;
          const text = next.toUpperCase();
          els.modeChip.textContent = text;
          els.modeChip.classList.toggle("good", next === "playing");
          els.modeChip.classList.toggle("bad", next === "recording");
          els.modeChip.classList.toggle("warn", next === "countin");
          if (next === "recording") {
            els.recBtn.classList.add("toggled");
            els.playBtn.classList.remove("toggled");
            els.recBtn.textContent = "● Recording";
            els.playBtn.textContent = "▶ Play";
          } else if (next === "countin") {
            els.recBtn.classList.add("toggled");
            els.playBtn.classList.remove("toggled");
            els.recBtn.textContent = "◌ Count‑In";
            els.playBtn.textContent = "▶ Play";
          } else if (next === "playing") {
            els.playBtn.classList.add("toggled");
            els.recBtn.classList.remove("toggled");
            els.playBtn.textContent = "❚❚ Pause";
            els.recBtn.textContent = "● Record";
          } else {
            els.playBtn.classList.remove("toggled");
            els.recBtn.classList.remove("toggled");
            els.recBtn.textContent = "● Record";
            els.playBtn.textContent = "▶ Play";
          }
        }

        function setAudioStatus(on) {
          els.audioDot.classList.toggle("on", on);
          els.audioStatus.textContent = on ? "Audio: Ready" : "Audio: Locked";
          els.unlockDot.classList.toggle("on", on);
          els.unlockStatus.textContent = on ? "Ready — have fun!" : "Waiting for input…";
        }

        function loopLengthSec() {
          const beatsPerBar = 4;
          return (state.bars * beatsPerBar * 60) / state.bpm;
        }

        function makeNoiseBuffer(ctx) {
          const seconds = 1.0;
          const length = Math.floor(ctx.sampleRate * seconds);
          const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
          const data = buffer.getChannelData(0);
          let x = 0x12345678;
          const rand = () => {
            // xorshift32
            x ^= x << 13;
            x ^= x >>> 17;
            x ^= x << 5;
            return (x >>> 0) / 4294967296;
          };
          for (let i = 0; i < length; i++) data[i] = (rand() * 2 - 1) * 0.9;
          return buffer;
        }

        function makeImpulse(ctx, seconds = 1.6, decay = 3.2) {
          const length = Math.floor(ctx.sampleRate * seconds);
          const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
          for (let ch = 0; ch < 2; ch++) {
            const d = impulse.getChannelData(ch);
            let x = 0x9e3779b9 ^ (ch + 1);
            const rand = () => {
              x ^= x << 13;
              x ^= x >>> 17;
              x ^= x << 5;
              return (x >>> 0) / 4294967296;
            };
            for (let i = 0; i < length; i++) {
              const t = i / length;
              const env = Math.pow(1 - t, decay);
              d[i] = (rand() * 2 - 1) * env;
            }
          }
          return impulse;
        }

        function ensureAudio() {
          if (state.audio) return state.audio;
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) throw new Error("WebAudio not supported");
          const ctx = new AudioContext({ latencyHint: "interactive" });

          const masterGain = ctx.createGain();
          masterGain.gain.value = 0.78;

          const comp = ctx.createDynamicsCompressor();
          comp.threshold.value = -18;
          comp.knee.value = 24;
          comp.ratio.value = 5.5;
          comp.attack.value = 0.003;
          comp.release.value = 0.20;

          const analyser = ctx.createAnalyser();
          analyser.fftSize = 2048;
          analyser.smoothingTimeConstant = 0.7;

          const dryGain = ctx.createGain();
          dryGain.gain.value = 1.0;
          const wetGain = ctx.createGain();
          wetGain.gain.value = 0.22;
          const convolver = ctx.createConvolver();
          convolver.buffer = makeImpulse(ctx, 1.55, 3.25);

          const liveBus = ctx.createGain();
          liveBus.gain.value = 1.0;
          const playBus = ctx.createGain();
          playBus.gain.value = 0.0001; // silent until transport starts
          const busSum = ctx.createGain();
          busSum.gain.value = 1.0;
          liveBus.connect(busSum);
          playBus.connect(busSum);
          busSum.connect(dryGain);
          busSum.connect(convolver);
          convolver.connect(wetGain);

          const mix = ctx.createGain();
          dryGain.connect(mix);
          wetGain.connect(mix);
          mix.connect(comp);
          comp.connect(analyser);
          analyser.connect(masterGain);
          masterGain.connect(ctx.destination);

          state.audio = ctx;
          state.masterGain = masterGain;
          state.liveBus = liveBus;
          state.playBus = playBus;
          state.busSum = busSum;
          state.comp = comp;
          state.analyser = analyser;
          state.convolver = convolver;
          state.dryGain = dryGain;
          state.wetGain = wetGain;
          state.noise = makeNoiseBuffer(ctx);

          updateAudioFromUI();
          drawLoop();
          return ctx;
        }

        async function unlockAudio() {
          const ctx = ensureAudio();
          if (ctx.state !== "running") {
            try {
              await ctx.resume();
            } catch (e) {
              // ignore
            }
          }
          state.unlocked = ctx.state === "running";
          setAudioStatus(state.unlocked);
          if (state.unlocked) els.unlock.classList.add("hidden");
        }

        function updateAudioFromUI() {
          state.bpm = clamp(parseInt(els.bpm.value || "120", 10), 60, 200);
          state.bars = clamp(parseInt(els.bars.value || "2", 10), 1, 8);
          els.bpm.value = String(state.bpm);
          els.bars.value = String(state.bars);

          const master = clamp(parseInt(els.master.value || "78", 10), 0, 100) / 100;
          const room = clamp(parseInt(els.room.value || "22", 10), 0, 100) / 100;
          if (state.masterGain) state.masterGain.gain.setTargetAtTime(master, state.audio.currentTime, 0.015);
          if (state.wetGain) state.wetGain.gain.setTargetAtTime(room, state.audio.currentTime, 0.02);
          els.lenChip.textContent = `${state.bars} bar${state.bars === 1 ? "" : "s"}`;
          redrawTimeline();
        }

        function withGainEnvelope(gainNode, t0, attack, decay, peak) {
          const g = gainNode.gain;
          g.cancelScheduledValues(t0);
          g.setValueAtTime(0.0001, t0);
          g.exponentialRampToValueAtTime(Math.max(0.0002, peak), t0 + attack);
          g.exponentialRampToValueAtTime(0.0001, t0 + attack + decay);
        }

        function playNoise(ctx, dest, t0, duration, filterSetup, gainValue) {
          const src = ctx.createBufferSource();
          src.buffer = state.noise;
          src.loop = true;
          const filter = ctx.createBiquadFilter();
          filterSetup(filter);
          const gain = ctx.createGain();
          gain.gain.value = 0.0001;
          src.connect(filter);
          filter.connect(gain);
          gain.connect(dest);
          withGainEnvelope(gain, t0, 0.003, duration, gainValue);
          src.start(t0);
          src.stop(t0 + duration + 0.02);
        }

        function playOsc(ctx, dest, t0, type, freqStart, freqEnd, sweepTime, duration, gainValue, filterSetup) {
          const osc = ctx.createOscillator();
          osc.type = type;
          const gain = ctx.createGain();
          gain.gain.value = 0.0001;

          if (filterSetup) {
            const filter = ctx.createBiquadFilter();
            filterSetup(filter);
            osc.connect(filter);
            filter.connect(gain);
          } else {
            osc.connect(gain);
          }
          gain.connect(dest);

          osc.frequency.setValueAtTime(freqStart, t0);
          if (freqEnd && sweepTime > 0) {
            osc.frequency.exponentialRampToValueAtTime(Math.max(20, freqEnd), t0 + sweepTime);
          }
          withGainEnvelope(gain, t0, 0.003, duration, gainValue);
          osc.start(t0);
          osc.stop(t0 + duration + 0.05);
        }

        function drumKick(ctx, dest, t0, vel) {
          playOsc(ctx, dest, t0, "sine", 155, 46, 0.11, 0.58, 1.05 * vel, (f) => {
            f.type = "lowpass";
            f.frequency.value = 1200;
            f.Q.value = 0.8;
          });
          playNoise(
            ctx,
            dest,
            t0,
            0.03,
            (f) => {
              f.type = "highpass";
              f.frequency.value = 1800;
              f.Q.value = 0.7;
            },
            0.18 * vel
          );
        }

        function drumSnare(ctx, dest, t0, vel) {
          playNoise(
            ctx,
            dest,
            t0,
            0.18,
            (f) => {
              f.type = "bandpass";
              f.frequency.value = 1750;
              f.Q.value = 0.75;
            },
            0.62 * vel
          );
          playOsc(ctx, dest, t0, "triangle", 220, 130, 0.055, 0.14, 0.35 * vel);
        }

        function drumHatClosed(ctx, dest, t0, vel) {
          playNoise(
            ctx,
            dest,
            t0,
            0.065,
            (f) => {
              f.type = "highpass";
              f.frequency.value = 7200;
              f.Q.value = 0.6;
            },
            0.34 * vel
          );
        }

        function drumHatOpen(ctx, dest, t0, vel) {
          playNoise(
            ctx,
            dest,
            t0,
            0.32,
            (f) => {
              f.type = "highpass";
              f.frequency.value = 6800;
              f.Q.value = 0.55;
            },
            0.30 * vel
          );
        }

        function drumTom(ctx, dest, t0, vel, base) {
          playOsc(ctx, dest, t0, "sine", base * 1.55, base, 0.09, 0.32, 0.60 * vel, (f) => {
            f.type = "lowpass";
            f.frequency.value = 1800;
            f.Q.value = 0.9;
          });
          playNoise(
            ctx,
            dest,
            t0,
            0.055,
            (f) => {
              f.type = "bandpass";
              f.frequency.value = 4200;
              f.Q.value = 0.9;
            },
            0.12 * vel
          );
        }

        function cymbalCluster(ctx, dest, t0, vel, duration, brightness) {
          const sum = ctx.createGain();
          sum.gain.value = 1.0;
          sum.connect(dest);

          const hp = ctx.createBiquadFilter();
          hp.type = "highpass";
          hp.frequency.value = 3800 + brightness * 1200;
          hp.Q.value = 0.7;

          const bp = ctx.createBiquadFilter();
          bp.type = "bandpass";
          bp.frequency.value = 7400 + brightness * 900;
          bp.Q.value = 0.85;

          const gain = ctx.createGain();
          gain.gain.value = 0.0001;

          hp.connect(bp);
          bp.connect(gain);
          gain.connect(sum);

          const freqs = [405, 552, 802, 1197, 1664, 2136].map((f) => f * (1 + (Math.random() - 0.5) * 0.02));
          const oscillators = freqs.map((f, i) => {
            const o = ctx.createOscillator();
            o.type = i % 2 ? "square" : "triangle";
            o.frequency.setValueAtTime(f * (8 + brightness * 2), t0);
            o.connect(hp);
            o.start(t0);
            o.stop(t0 + duration + 0.06);
            return o;
          });

          const noise = ctx.createBufferSource();
          noise.buffer = state.noise;
          noise.loop = true;
          noise.connect(hp);
          noise.start(t0);
          noise.stop(t0 + duration + 0.06);

          withGainEnvelope(gain, t0, 0.004, duration, 0.28 * vel);
          return () => {
            try {
              oscillators.forEach((o) => o.disconnect());
              noise.disconnect();
              hp.disconnect();
              bp.disconnect();
              gain.disconnect();
              sum.disconnect();
            } catch {}
          };
        }

        function drumCrash(ctx, dest, t0, vel) {
          cymbalCluster(ctx, dest, t0, vel, 0.72, 0.9);
        }

        function drumRide(ctx, dest, t0, vel) {
          cymbalCluster(ctx, dest, t0, vel, 1.10, 0.55);
          // ping
          playOsc(ctx, dest, t0, "sine", 980, 740, 0.05, 0.24, 0.12 * vel, (f) => {
            f.type = "bandpass";
            f.frequency.value = 5200;
            f.Q.value = 1.1;
          });
        }

        function metroClick(ctx, dest, t0, isDownbeat) {
          const vel = isDownbeat ? 0.55 : 0.35;
          playOsc(ctx, dest, t0, "triangle", isDownbeat ? 1120 : 920, isDownbeat ? 760 : 690, 0.03, 0.06, vel, (f) => {
            f.type = "highpass";
            f.frequency.value = 220;
            f.Q.value = 0.6;
          });
        }

        const synth = {
          kick: (ctx, dest, t, v) => drumKick(ctx, dest, t, v),
          snare: (ctx, dest, t, v) => drumSnare(ctx, dest, t, v),
          hihat: (ctx, dest, t, v) => drumHatClosed(ctx, dest, t, v),
          openhihat: (ctx, dest, t, v) => drumHatOpen(ctx, dest, t, v),
          tom1: (ctx, dest, t, v) => drumTom(ctx, dest, t, v, 170),
          tom2: (ctx, dest, t, v) => drumTom(ctx, dest, t, v, 135),
          floor: (ctx, dest, t, v) => drumTom(ctx, dest, t, v, 98),
          crash: (ctx, dest, t, v) => drumCrash(ctx, dest, t, v),
          ride: (ctx, dest, t, v) => drumRide(ctx, dest, t, v),
        };

        function flashPad(id) {
          const el = els.padButtons.find((b) => b.dataset.id === id);
          if (!el) return;
          el.classList.add("hit");
          window.setTimeout(() => el.classList.remove("hit"), 80);
          if (navigator.vibrate) {
            try { navigator.vibrate(8); } catch {}
          }
        }

        function recordEvent(id, vel) {
          if (state.mode !== "recording") return;
          const ctx = state.audio;
          const tMs = (ctx.currentTime - state.recordStartT) * 1000;
          if (tMs < -5) return;
          state.sequence.push({ t: Math.max(0, tMs), id, v: vel });
          els.hitsChip.textContent = `${state.sequence.length} hit${state.sequence.length === 1 ? "" : "s"}`;
          redrawTimeline();
        }

        function trigger(id, vel = 1, t0 = null, shouldRecord = true, busType = "live") {
          const ctx = ensureAudio();
          const dest = busType === "play" ? state.playBus : state.liveBus;
          const t = t0 == null ? ctx.currentTime : t0;
          const fn = synth[id];
          if (!fn) return;
          fn(ctx, dest, t, vel);
          flashPad(id);
          if (shouldRecord) recordEvent(id, vel);
        }

        function stopAll() {
          // Drums are one-shots; stop means transport stop + UI.
          if (state.playBus && state.audio) {
            const now = state.audio.currentTime;
            const g = state.playBus.gain;
            g.cancelScheduledValues(now);
            g.setValueAtTime(g.value, now);
            g.setTargetAtTime(0.0001, now, 0.01);
          }
          if (state.play.schedulerTimer) window.clearInterval(state.play.schedulerTimer);
          state.play.schedulerTimer = null;
          if (state.play.stopTimer) window.clearTimeout(state.play.stopTimer);
          state.play.stopTimer = null;
          if (state.play.transportRaf) cancelAnimationFrame(state.play.transportRaf);
          state.play.transportRaf = 0;
          setMode("idle");
          els.timeChip.textContent = "00:00.0";
          redrawTimeline();
        }

        function scheduleMetronome(baseT, durationSec) {
          if (!state.metronome) return;
          const ctx = state.audio;
          const beatSec = 60 / state.bpm;
          const beats = Math.ceil(durationSec / beatSec);
          for (let i = 0; i < beats; i++) {
            const t = baseT + i * beatSec;
            const isDown = i % 4 === 0;
            metroClick(ctx, state.playBus, t, isDown);
          }
        }

        function schedulePattern(baseT) {
          const ctx = state.audio;
          const len = loopLengthSec();
          for (const e of state.sequence) {
            const t = baseT + e.t / 1000;
            if (t < baseT - 0.01 || t > baseT + len + 0.02) continue;
            trigger(e.id, e.v, t, false, "play");
          }
          scheduleMetronome(baseT, len);
        }

        function startPlayback() {
          if (!state.sequence.length) return;
          unlockAudio();
          const ctx = ensureAudio();
          if (ctx.state !== "running") return;
          stopAll();

          const now = ctx.currentTime;
          state.playBus.gain.cancelScheduledValues(now);
          state.playBus.gain.setValueAtTime(0.0001, now);
          state.playBus.gain.setTargetAtTime(1.0, now, 0.01);

          const originT = ctx.currentTime + 0.06;
          state.play.originT = originT;
          state.play.loopLen = loopLengthSec();
          state.play.scheduledThrough = 0;
          state.play.startedAtPerf = performance.now();
          setMode("playing");
          schedulePattern(originT);

          const tick = () => {
            if (state.mode !== "playing") return;
            const now = ctx.currentTime;
            const raw = now - state.play.originT;
            const posLoop = ((raw % state.play.loopLen) + state.play.loopLen) % state.play.loopLen;
            const pos = state.loop ? posLoop : (raw <= state.play.loopLen ? clamp(raw, 0, state.play.loopLen) : posLoop);
            els.timeChip.textContent = fmtTime(pos);
            redrawTimeline(pos / state.play.loopLen);
            state.play.transportRaf = requestAnimationFrame(tick);
          };
          state.play.transportRaf = requestAnimationFrame(tick);

          if (state.loop) {
            const scheduleAhead = 2;
            state.play.schedulerTimer = window.setInterval(() => {
              if (state.mode !== "playing" || !state.loop) return;
              const now = ctx.currentTime;
              const elapsed = now - state.play.originT;
              const loopIndex = Math.max(0, Math.floor(elapsed / state.play.loopLen));
              while (state.play.scheduledThrough < loopIndex + scheduleAhead) {
                state.play.scheduledThrough += 1;
                schedulePattern(state.play.originT + state.play.scheduledThrough * state.play.loopLen);
              }
            }, 120);
            // schedule the next loop immediately for seamless looping
            schedulePattern(state.play.originT + state.play.loopLen);
            state.play.scheduledThrough = 1;
          } else {
            state.play.stopTimer = window.setTimeout(() => {
              if (state.mode === "playing" && !state.loop) stopPlayback();
            }, Math.max(40, (state.play.loopLen + 0.06) * 1000));
          }
        }

        function stopPlayback() {
          if (state.mode !== "playing") return;
          stopAll();
        }

        function startRecording() {
          unlockAudio();
          const ctx = ensureAudio();
          if (ctx.state !== "running") return;

          stopAll();
          const tNow = ctx.currentTime;
          state.playBus.gain.cancelScheduledValues(tNow);
          state.playBus.gain.setValueAtTime(0.0001, tNow);
          state.playBus.gain.setTargetAtTime(1.0, tNow, 0.01);
          state.sequence = [];
          els.hitsChip.textContent = "0 hits";
          redrawTimeline();

          const len = loopLengthSec();
          const beatSec = 60 / state.bpm;
          const countInSec = state.countIn ? (4 * beatSec) : 0;
          const startAt = ctx.currentTime + 0.06 + countInSec;
          const now = ctx.currentTime;

          if (state.countIn) {
            setMode("countin");
            scheduleMetronome(now + 0.06, countInSec);
          } else {
            setMode("recording");
          }

          state.recordStartT = startAt;

          const tick = () => {
            const t = ctx.currentTime - startAt;
            if (state.mode === "countin" && ctx.currentTime >= startAt) setMode("recording");
            if (state.mode !== "countin" && state.mode !== "recording") return;
            els.timeChip.textContent = fmtTime(Math.max(0, t));
            redrawTimeline(state.mode === "recording" ? Math.min(1, Math.max(0, t / len)) : null);
            state.play.transportRaf = requestAnimationFrame(tick);
          };
          state.play.transportRaf = requestAnimationFrame(tick);

          if (state.fixed) {
            const stopAt = startAt + len;
            window.setTimeout(() => {
              if (state.mode === "recording") stopRecording();
            }, Math.max(10, (stopAt - ctx.currentTime) * 1000));
          }
        }

        function stopRecording() {
          if (state.mode !== "recording" && state.mode !== "countin") return;
          if (state.mode === "countin") {
            stopAll();
            return;
          }
          setMode("idle");
          els.timeChip.textContent = "00:00.0";
          // keep events within loop
          const lenMs = loopLengthSec() * 1000;
          state.sequence = state.sequence
            .filter((e) => e.t <= lenMs + 4)
            .sort((a, b) => a.t - b.t);
          els.hitsChip.textContent = `${state.sequence.length} hit${state.sequence.length === 1 ? "" : "s"}`;
          redrawTimeline();
        }

        function exportPattern() {
          const payload = {
            app: "Virtual Drum Kit",
            version: 1,
            bpm: state.bpm,
            bars: state.bars,
            events: state.sequence.map((e) => ({ t: Math.round(e.t), id: e.id, v: Math.round(e.v * 100) / 100 })),
          };
          const text = JSON.stringify(payload, null, 2);
          const copy = async () => {
            try {
              await navigator.clipboard.writeText(text);
              toast("Exported to clipboard");
            } catch {
              prompt("Copy your pattern JSON:", text);
            }
          };
          copy();
        }

        let toastTimer = null;
        function toast(msg) {
          let el = $("#toast");
          if (!el) {
            el = document.createElement("div");
            el.id = "toast";
            el.style.position = "fixed";
            el.style.left = "50%";
            el.style.bottom = "18px";
            el.style.transform = "translateX(-50%)";
            el.style.padding = "10px 12px";
            el.style.borderRadius = "999px";
            el.style.background = "rgba(10,16,32,.85)";
            el.style.border = "1px solid rgba(255,255,255,.12)";
            el.style.boxShadow = "0 18px 55px rgba(0,0,0,.45)";
            el.style.color = "rgba(233,238,252,.95)";
            el.style.fontSize = "13px";
            el.style.zIndex = "60";
            el.style.backdropFilter = "blur(10px)";
            document.body.appendChild(el);
          }
          el.textContent = msg;
          el.style.opacity = "1";
          if (toastTimer) clearTimeout(toastTimer);
          toastTimer = setTimeout(() => (el.style.opacity = "0"), 1100);
        }

        function redrawTimeline(playhead01 = null) {
          const canvas = els.timeline;
          const ctx2 = canvas.getContext("2d");
          const w = canvas.width;
          const h = canvas.height;
          ctx2.clearRect(0, 0, w, h);

          const pad = 14;
          const top = 32;
          const left = pad + 72;
          const right = pad;
          const bottom = pad + 10;
          const laneH = (h - top - bottom) / lanes.length;

          // background
          const bg = ctx2.createLinearGradient(0, 0, 0, h);
          bg.addColorStop(0, "rgba(255,255,255,.05)");
          bg.addColorStop(1, "rgba(0,0,0,.22)");
          ctx2.fillStyle = bg;
          ctx2.fillRect(0, 0, w, h);

          // grid: bars + beats
          const beatsPerBar = 4;
          const beats = state.bars * beatsPerBar;
          for (let i = 0; i <= beats; i++) {
            const x = left + ((w - left - right) * i) / beats;
            const isBar = i % 4 === 0;
            ctx2.strokeStyle = isBar ? "rgba(255,255,255,.16)" : "rgba(255,255,255,.08)";
            ctx2.lineWidth = isBar ? 1.4 : 1;
            ctx2.beginPath();
            ctx2.moveTo(x, top - 10);
            ctx2.lineTo(x, h - bottom + 4);
            ctx2.stroke();
          }

          // lanes
          ctx2.font = "12px " + getComputedStyle(document.body).fontFamily;
          for (let i = 0; i < lanes.length; i++) {
            const y = top + i * laneH;
            ctx2.fillStyle = "rgba(166,179,204,.88)";
            ctx2.fillText(lanes[i].label, pad + 8, y + laneH * 0.68);
            ctx2.strokeStyle = "rgba(255,255,255,.07)";
            ctx2.lineWidth = 1;
            ctx2.beginPath();
            ctx2.moveTo(left, y);
            ctx2.lineTo(w - right, y);
            ctx2.stroke();
          }

          const lenMs = loopLengthSec() * 1000;
          const laneIndex = new Map(lanes.map((l, i) => [l.id, i]));

          // hits
          for (const e of state.sequence) {
            const i = laneIndex.get(e.id);
            if (i == null) continue;
            const x = left + (w - left - right) * (e.t / lenMs);
            const cy = top + i * laneH + laneH * 0.5;
            const r = 3.3 + e.v * 4.2;
            ctx2.fillStyle = "rgba(34,211,238,.70)";
            ctx2.beginPath();
            ctx2.arc(x, cy, r, 0, Math.PI * 2);
            ctx2.fill();
            ctx2.fillStyle = "rgba(124,92,255,.28)";
            ctx2.beginPath();
            ctx2.arc(x, cy, r + 4, 0, Math.PI * 2);
            ctx2.fill();
          }

          // playhead
          if (playhead01 != null) {
            const x = left + (w - left - right) * clamp(playhead01, 0, 1);
            ctx2.strokeStyle = "rgba(255,211,106,.85)";
            ctx2.lineWidth = 2;
            ctx2.beginPath();
            ctx2.moveTo(x, top - 10);
            ctx2.lineTo(x, h - bottom + 4);
            ctx2.stroke();
          }

          // header text
          ctx2.fillStyle = "rgba(233,238,252,.80)";
          ctx2.font = "11px " + getComputedStyle(document.body).fontFamily;
          ctx2.fillText(`${state.bpm} BPM • ${state.bars} bar${state.bars === 1 ? "" : "s"}`, pad + 8, 20);
        }

        function drawScope() {
          const canvas = els.scope;
          const ctx2 = canvas.getContext("2d");
          const w = canvas.width;
          const h = canvas.height;

          ctx2.clearRect(0, 0, w, h);

          const bg = ctx2.createLinearGradient(0, 0, w, 0);
          bg.addColorStop(0, "rgba(124,92,255,.12)");
          bg.addColorStop(0.5, "rgba(34,211,238,.10)");
          bg.addColorStop(1, "rgba(255,95,109,.10)");
          ctx2.fillStyle = bg;
          ctx2.fillRect(0, 0, w, h);

          // grid
          ctx2.strokeStyle = "rgba(255,255,255,.08)";
          for (let i = 0; i < 12; i++) {
            const x = (w * (i + 0.5)) / 12;
            ctx2.beginPath();
            ctx2.moveTo(x, 0);
            ctx2.lineTo(x, h);
            ctx2.stroke();
          }
          for (let i = 0; i < 4; i++) {
            const y = (h * (i + 0.5)) / 4;
            ctx2.beginPath();
            ctx2.moveTo(0, y);
            ctx2.lineTo(w, y);
            ctx2.stroke();
          }

          if (!state.analyser) return;
          const analyser = state.analyser;
          const data = new Uint8Array(analyser.fftSize);
          analyser.getByteTimeDomainData(data);

          // pseudo VU
          let sum = 0;
          for (let i = 0; i < data.length; i++) {
            const v = (data[i] - 128) / 128;
            sum += v * v;
          }
          const rms = Math.sqrt(sum / data.length);
          const db = 20 * Math.log10(rms + 1e-5);
          els.vuLabel.textContent = `${db.toFixed(1)} dB`;

          const mid = h * 0.5;
          ctx2.lineWidth = 2;
          ctx2.strokeStyle = "rgba(255,211,106,.95)";
          ctx2.beginPath();
          for (let i = 0; i < data.length; i++) {
            const x = (w * i) / (data.length - 1);
            const y = mid + ((data[i] - 128) / 128) * (h * 0.36);
            if (i === 0) ctx2.moveTo(x, y);
            else ctx2.lineTo(x, y);
          }
          ctx2.stroke();
        }

        function drawLoop() {
          drawScope();
          state.scopeRaf = requestAnimationFrame(drawLoop);
        }

        function toggleSwitch(el, next = null) {
          const on = next == null ? !el.classList.contains("on") : !!next;
          el.classList.toggle("on", on);
          el.setAttribute("aria-checked", on ? "true" : "false");
          return on;
        }

        function setupUI() {
          // pad interactions
          els.padButtons.forEach((btn) => {
            btn.addEventListener("pointerdown", async (e) => {
              e.preventDefault();
              await unlockAudio();
              btn.setPointerCapture(e.pointerId);
              state.lastPadByPointer.set(e.pointerId, btn);
              const vel = e.shiftKey ? 1.0 : 0.78;
              trigger(btn.dataset.id, vel);
            });
            btn.addEventListener("pointerup", (e) => {
              state.lastPadByPointer.delete(e.pointerId);
            });
            btn.addEventListener("pointercancel", (e) => {
              state.lastPadByPointer.delete(e.pointerId);
            });
            btn.addEventListener("pointermove", (e) => {
              if (!state.lastPadByPointer.has(e.pointerId)) return;
              if (e.pointerType !== "mouse" && e.pointerType !== "pen") return; // avoid accidental touch drags
              const under = document.elementFromPoint(e.clientX, e.clientY);
              if (!under) return;
              const pad = under.closest && under.closest(".pad");
              if (!pad) return;
              const last = state.lastPadByPointer.get(e.pointerId);
              if (pad === last) return;
              state.lastPadByPointer.set(e.pointerId, pad);
              const vel = e.shiftKey ? 1.0 : 0.70;
              trigger(pad.dataset.id, vel);
            });
          });

          // transport
          els.recBtn.addEventListener("click", () => {
            if (state.mode === "recording" || state.mode === "countin") stopRecording();
            else startRecording();
          });
          els.stopBtn.addEventListener("click", () => {
            if (state.mode === "recording" || state.mode === "countin") stopRecording();
            stopPlayback();
            stopAll();
          });
          els.playBtn.addEventListener("click", () => {
            if (state.mode === "playing") stopPlayback();
            else startPlayback();
          });
          els.loopBtn.addEventListener("click", () => {
            state.loop = !state.loop;
            els.loopBtn.classList.toggle("toggled", state.loop);
            els.loopBtn.setAttribute("aria-pressed", state.loop ? "true" : "false");
            if (state.mode === "playing" && state.audio) {
              const ctx = state.audio;
              const raw = ctx.currentTime - state.play.originT;
              const loopLen = state.play.loopLen || loopLengthSec();
              const loopIndex = Math.max(0, Math.floor(raw / loopLen));
              const nextBoundary = state.play.originT + (loopIndex + 1) * loopLen;

              if (state.loop) {
                // enable looping seamlessly from the current bar end
                if (state.play.stopTimer) window.clearTimeout(state.play.stopTimer);
                state.play.stopTimer = null;
                if (!state.play.schedulerTimer) {
                  state.play.scheduledThrough = Math.max(loopIndex, state.play.scheduledThrough || 0);
                  state.play.schedulerTimer = window.setInterval(() => {
                    if (state.mode !== "playing" || !state.loop) return;
                    const now = ctx.currentTime;
                    const elapsed = now - state.play.originT;
                    const idx = Math.max(0, Math.floor(elapsed / state.play.loopLen));
                    const scheduleAhead = 2;
                    while (state.play.scheduledThrough < idx + scheduleAhead) {
                      state.play.scheduledThrough += 1;
                      schedulePattern(state.play.originT + state.play.scheduledThrough * state.play.loopLen);
                    }
                  }, 120);
                }
                if ((state.play.scheduledThrough || 0) < loopIndex + 1) {
                  state.play.scheduledThrough = loopIndex + 1;
                  schedulePattern(state.play.originT + state.play.scheduledThrough * state.play.loopLen);
                }
                toast("Loop on");
              } else {
                // stop at the end of the current bar
                if (state.play.schedulerTimer) window.clearInterval(state.play.schedulerTimer);
                state.play.schedulerTimer = null;
                if (state.play.stopTimer) window.clearTimeout(state.play.stopTimer);

                if (state.playBus) {
                  const g = state.playBus.gain;
                  const now = ctx.currentTime;
                  g.cancelScheduledValues(now);
                  g.setValueAtTime(g.value, now);
                  g.setValueAtTime(g.value, Math.max(now, nextBoundary - 0.004));
                  g.linearRampToValueAtTime(0.0001, nextBoundary + 0.012);
                }

                state.play.stopTimer = window.setTimeout(() => {
                  if (state.mode === "playing" && !state.loop) stopPlayback();
                }, Math.max(20, (nextBoundary - ctx.currentTime + 0.02) * 1000));
                toast("Loop off (stops at bar end)");
              }
            } else {
              toast(state.loop ? "Loop on" : "Loop off");
            }
          });
          els.clearBtn.addEventListener("click", () => {
            state.sequence = [];
            els.hitsChip.textContent = "0 hits";
            stopAll();
            redrawTimeline();
            toast("Cleared");
          });
          els.exportBtn.addEventListener("click", () => exportPattern());

          // settings
          const onSettings = () => {
            updateAudioFromUI();
            if (state.mode === "playing") {
              // restart playback with new timing to stay tight
              startPlayback();
            }
          };
          els.bpm.addEventListener("change", onSettings);
          els.bars.addEventListener("change", onSettings);
          els.master.addEventListener("input", updateAudioFromUI);
          els.room.addEventListener("input", updateAudioFromUI);

          els.metroToggle.addEventListener("click", () => {
            state.metronome = toggleSwitch(els.metroToggle);
            toast(state.metronome ? "Metronome on" : "Metronome off");
          });
          els.countInToggle.addEventListener("click", () => {
            state.countIn = toggleSwitch(els.countInToggle);
            toast(state.countIn ? "Count-in on" : "Count-in off");
          });
          els.fixedToggle.addEventListener("click", () => {
            state.fixed = toggleSwitch(els.fixedToggle);
            toast(state.fixed ? "Fixed record on" : "Fixed record off");
          });
          [els.metroToggle, els.countInToggle, els.fixedToggle].forEach((sw) => {
            sw.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                sw.click();
              }
            });
          });

          // help
          const openHelp = () => {
            if (!els.helpDialog.open) els.helpDialog.showModal();
          };
          const closeHelp = () => {
            if (els.helpDialog.open) els.helpDialog.close();
          };
          els.helpBtn.addEventListener("click", openHelp);
          els.unlockHelp.addEventListener("click", openHelp);
          els.helpClose.addEventListener("click", closeHelp);
          els.helpCloseX.addEventListener("click", closeHelp);

          // unlock overlay
          els.unlockBtn.addEventListener("click", () => unlockAudio());
          els.unlock.addEventListener("pointerdown", (e) => {
            if (e.target === els.unlock) unlockAudio();
          });

          // keyboard
          window.addEventListener("keydown", async (e) => {
            if (e.key === "?" || (e.shiftKey && e.key === "/")) {
              e.preventDefault();
              els.helpDialog.open ? els.helpDialog.close() : els.helpDialog.showModal();
              return;
            }
            if (e.key === "Escape") {
              e.preventDefault();
              if (els.helpDialog.open) els.helpDialog.close();
              stopAll();
              return;
            }
            if (e.repeat) return;

            if (e.key === " " || e.code === "Space") {
              e.preventDefault();
              await unlockAudio();
              if (state.mode === "playing") stopPlayback();
              else startPlayback();
              return;
            }
            if (e.key.toLowerCase() === "r") {
              e.preventDefault();
              await unlockAudio();
              if (state.mode === "recording" || state.mode === "countin") stopRecording();
              else startRecording();
              return;
            }
            const k = e.key.toLowerCase();
            if (!keyMap.has(k)) return;
            e.preventDefault();
            await unlockAudio();
            if (state.pressedKeys.has(k)) return;
            state.pressedKeys.add(k);
            const id = keyMap.get(k);
            const vel = e.shiftKey ? 1.0 : 0.78;
            trigger(id, vel);
          });
          window.addEventListener("keyup", (e) => {
            state.pressedKeys.delete(e.key.toLowerCase());
          });

          // responsive redraw
          window.addEventListener("resize", () => redrawTimeline());
        }

        function init() {
          setMode("idle");
          setAudioStatus(false);
          state.metronome = false;
          state.countIn = true;
          state.fixed = true;
          toggleSwitch(els.metroToggle, false);
          toggleSwitch(els.countInToggle, true);
          toggleSwitch(els.fixedToggle, true);

          setupUI();
          redrawTimeline();

          // if already allowed (rare), unlock immediately
          window.setTimeout(() => {
            try {
              const ctx = ensureAudio();
              if (ctx.state === "running") {
                state.unlocked = true;
                setAudioStatus(true);
                els.unlock.classList.add("hidden");
              }
            } catch {}
          }, 50);
        }

        init();
      })();
    </script>
  </body>
</html>
