<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#9ad9ff" />
    <title>Cloud Painter</title>
    <style>
      :root {
        --panel: rgba(255, 255, 255, 0.72);
        --panel-strong: rgba(255, 255, 255, 0.9);
        --stroke: rgba(88, 132, 168, 0.35);
        --shadow: rgba(18, 38, 56, 0.14);
        --ink: #14334a;
        --muted: rgba(20, 51, 74, 0.72);
        --accent: #6aa7ff;
        --accent2: #ff8ac3;
        --good: #2ac88a;
        --warn: #ffb43a;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: #9ad9ff;
        color: var(--ink);
        font-family:
          ui-rounded,
          "SF Pro Rounded",
          "Avenir Next Rounded",
          system-ui,
          -apple-system,
          "Segoe UI",
          Roboto,
          Arial,
          "Comic Sans MS",
          "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      #app {
        position: fixed;
        inset: 0;
      }

      canvas#sky {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      .ui {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .panel {
        pointer-events: auto;
        position: absolute;
        left: 16px;
        top: 16px;
        width: min(392px, calc(100vw - 32px));
        border-radius: 22px;
        padding: 14px 14px 12px;
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.55);
        box-shadow:
          0 16px 40px var(--shadow),
          0 1px 0 rgba(255, 255, 255, 0.8) inset;
        backdrop-filter: blur(10px) saturate(1.15);
      }

      .titleRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 2px 2px 8px;
      }

      .title {
        display: flex;
        flex-direction: column;
        line-height: 1.06;
      }
      .title h1 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.2px;
      }
      .title p {
        margin: 2px 0 0;
        font-size: 12.5px;
        color: var(--muted);
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.68);
        border: 1px solid rgba(255, 255, 255, 0.65);
        box-shadow: 0 10px 22px rgba(24, 58, 86, 0.12);
      }

      .pill small {
        font-size: 12px;
        color: var(--muted);
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .section {
        border-radius: 16px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.56);
        border: 1px solid rgba(255, 255, 255, 0.6);
      }

      .section h2 {
        margin: 0 0 8px;
        font-size: 12.5px;
        letter-spacing: 0.3px;
        color: rgba(20, 51, 74, 0.82);
        text-transform: uppercase;
      }

      .shapes {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
      }

      .shapeBtn {
        border: 1px solid rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.7);
        border-radius: 14px;
        padding: 10px 8px;
        cursor: pointer;
        box-shadow: 0 10px 18px rgba(24, 58, 86, 0.09);
        transition:
          transform 120ms ease,
          box-shadow 120ms ease,
          background 120ms ease;
        user-select: none;
      }
      .shapeBtn:hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 22px rgba(24, 58, 86, 0.12);
      }
      .shapeBtn[aria-pressed="true"] {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.62));
        border-color: rgba(106, 167, 255, 0.6);
        box-shadow:
          0 18px 28px rgba(106, 167, 255, 0.12),
          0 0 0 3px rgba(106, 167, 255, 0.18);
      }

      .shapeIcon {
        width: 100%;
        height: 24px;
        display: grid;
        place-items: center;
        margin-bottom: 6px;
      }

      .shapeBtn span {
        display: block;
        text-align: center;
        font-size: 11.5px;
        color: rgba(20, 51, 74, 0.86);
      }

      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-top: 8px;
      }

      label {
        font-size: 12px;
        color: var(--muted);
        user-select: none;
      }

      input[type="range"] {
        width: 100%;
        accent-color: var(--accent);
      }

      .sliderRow {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
        margin-top: 8px;
      }

      .valueTag {
        min-width: 46px;
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-size: 12px;
        color: rgba(20, 51, 74, 0.8);
      }

      .palette {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .swatch {
        width: 26px;
        height: 26px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.9);
        cursor: pointer;
        box-shadow: 0 10px 16px rgba(24, 58, 86, 0.1);
        position: relative;
      }

      .swatch[aria-pressed="true"]::after {
        content: "";
        position: absolute;
        inset: -4px;
        border-radius: 999px;
        border: 3px solid rgba(106, 167, 255, 0.28);
      }

      .btnRow {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }

      .btn {
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.72);
        border-radius: 16px;
        padding: 11px 12px;
        font-weight: 700;
        letter-spacing: 0.2px;
        color: rgba(20, 51, 74, 0.9);
        box-shadow: 0 12px 18px rgba(24, 58, 86, 0.09);
        transition:
          transform 120ms ease,
          box-shadow 120ms ease;
        user-select: none;
      }
      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 16px 24px rgba(24, 58, 86, 0.12);
      }
      .btn.primary {
        background: linear-gradient(180deg, rgba(106, 167, 255, 0.92), rgba(106, 167, 255, 0.72));
        border-color: rgba(106, 167, 255, 0.95);
        color: rgba(255, 255, 255, 0.98);
        text-shadow: 0 1px 0 rgba(10, 25, 35, 0.18);
      }
      .btn.warm {
        background: linear-gradient(180deg, rgba(255, 180, 58, 0.9), rgba(255, 180, 58, 0.62));
        border-color: rgba(255, 180, 58, 0.9);
        color: rgba(20, 51, 74, 0.92);
      }
      .btn.rose {
        background: linear-gradient(180deg, rgba(255, 138, 195, 0.9), rgba(255, 138, 195, 0.62));
        border-color: rgba(255, 138, 195, 0.9);
        color: rgba(20, 51, 74, 0.92);
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        user-select: none;
      }

      .switch {
        width: 44px;
        height: 26px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.75);
        background: rgba(20, 51, 74, 0.16);
        box-shadow: 0 10px 18px rgba(24, 58, 86, 0.1) inset;
        position: relative;
        flex: 0 0 auto;
      }

      .switch::after {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        width: 20px;
        height: 20px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.92);
        box-shadow: 0 10px 16px rgba(24, 58, 86, 0.14);
        transition: transform 160ms ease;
      }

      .toggle[aria-checked="true"] .switch {
        background: rgba(42, 200, 138, 0.32);
      }
      .toggle[aria-checked="true"] .switch::after {
        transform: translateX(18px);
      }

      .hud {
        pointer-events: none;
        position: absolute;
        right: 16px;
        top: 16px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-end;
      }

      .toast {
        pointer-events: none;
        opacity: 0;
        transform: translateY(-6px);
        transition:
          opacity 220ms ease,
          transform 220ms ease;
      }
      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }

      .hint {
        position: absolute;
        left: 16px;
        bottom: 16px;
        width: min(420px, calc(100vw - 32px));
        pointer-events: none;
        color: rgba(255, 255, 255, 0.92);
        text-shadow: 0 12px 26px rgba(18, 38, 56, 0.22);
        font-size: 13px;
        line-height: 1.3;
      }

      .kbd {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.22);
        border: 1px solid rgba(255, 255, 255, 0.28);
        margin: 0 3px;
        font-weight: 700;
      }

      @media (max-width: 520px) {
        .panel {
          top: 12px;
          left: 12px;
          padding: 12px;
        }
        .shapes {
          grid-template-columns: repeat(2, 1fr);
        }
        .btnRow {
          grid-template-columns: 1fr;
        }
        .hint {
          font-size: 12px;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .shapeBtn,
        .btn,
        .toast {
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas id="sky" aria-label="Sky canvas"></canvas>

      <div class="ui" aria-hidden="false">
        <div class="panel" role="region" aria-label="Cloud Painter controls">
          <div class="titleRow">
            <div class="title">
              <h1>Cloud Painter</h1>
              <p>Paint the sky with fluffy clouds (and send planes flying!)</p>
            </div>
            <div class="pill" title="Tip">
              <small><strong>Draw</strong> on the sky</small>
            </div>
          </div>

          <div class="grid">
            <div class="section">
              <h2>Brush</h2>
              <div class="shapes" role="group" aria-label="Brush shapes">
                <button class="shapeBtn" data-shape="fluffy" aria-pressed="true" type="button">
                  <div class="shapeIcon">
                    <svg width="28" height="22" viewBox="0 0 28 22" fill="none" aria-hidden="true">
                      <path
                        d="M8.4 18.2c-3.4 0-6.1-2.3-6.1-5.3 0-2.6 2-4.8 4.8-5.2C8 4.6 10.7 2.7 14 2.7c3.7 0 6.8 2.4 7.3 5.6 2.7.5 4.7 2.5 4.7 4.9 0 2.9-2.7 5-6.3 5H8.4z"
                        fill="rgba(20,51,74,0.22)"
                      />
                    </svg>
                  </div>
                  <span>Fluffy</span>
                </button>
                <button class="shapeBtn" data-shape="sprinkle" aria-pressed="false" type="button">
                  <div class="shapeIcon">
                    <svg width="28" height="22" viewBox="0 0 28 22" fill="none" aria-hidden="true">
                      <g fill="rgba(20,51,74,0.22)">
                        <circle cx="7" cy="9" r="2.2" />
                        <circle cx="13" cy="6" r="1.8" />
                        <circle cx="15.5" cy="12" r="2.6" />
                        <circle cx="21" cy="8.5" r="2.1" />
                        <circle cx="20" cy="14.5" r="1.7" />
                      </g>
                    </svg>
                  </div>
                  <span>Spray</span>
                </button>
                <button class="shapeBtn" data-shape="heart" aria-pressed="false" type="button">
                  <div class="shapeIcon">
                    <svg width="28" height="22" viewBox="0 0 28 22" fill="none" aria-hidden="true">
                      <path
                        d="M14 19.2c-4.9-3.2-8.3-6.4-8.3-9.4 0-2 1.5-3.6 3.6-3.6 1.6 0 2.8.8 3.6 2 0.8-1.2 2-2 3.6-2 2.1 0 3.6 1.6 3.6 3.6 0 3-3.4 6.2-8.3 9.4z"
                        fill="rgba(20,51,74,0.22)"
                      />
                    </svg>
                  </div>
                  <span>Heart</span>
                </button>
                <button class="shapeBtn" data-shape="star" aria-pressed="false" type="button">
                  <div class="shapeIcon">
                    <svg width="28" height="22" viewBox="0 0 28 22" fill="none" aria-hidden="true">
                      <path
                        d="M14 2.2l2.2 5.1 5.5.5-4.2 3.6 1.3 5.4-4.8-2.8-4.8 2.8 1.3-5.4-4.2-3.6 5.5-.5L14 2.2z"
                        fill="rgba(20,51,74,0.22)"
                      />
                    </svg>
                  </div>
                  <span>Star</span>
                </button>
              </div>

              <div class="sliderRow">
                <label for="size">Size</label>
                <div class="valueTag" id="sizeVal">48</div>
              </div>
              <input id="size" type="range" min="10" max="120" value="48" />

              <div class="sliderRow">
                <label for="opacity">Fluff</label>
                <div class="valueTag" id="opacityVal">85%</div>
              </div>
              <input id="opacity" type="range" min="20" max="100" value="85" />
            </div>

            <div class="section">
              <h2>Sky Magic</h2>
              <div class="row" style="margin-top: 0">
                <div class="toggle" id="driftToggle" role="switch" aria-checked="true" tabindex="0">
                  <div class="switch" aria-hidden="true"></div>
                  <label>Cloud drift</label>
                </div>
                <div class="toggle" id="planeToggle" role="switch" aria-checked="true" tabindex="0">
                  <div class="switch" aria-hidden="true"></div>
                  <label>Airplanes</label>
                </div>
              </div>

              <div class="sliderRow" style="margin-top: 10px">
                <label for="wind">Wind</label>
                <div class="valueTag" id="windVal">+24</div>
              </div>
              <input id="wind" type="range" min="-80" max="80" value="24" />

              <div class="sliderRow">
                <label for="planes">Planes</label>
                <div class="valueTag" id="planesVal">Medium</div>
              </div>
              <input id="planes" type="range" min="0" max="100" value="55" />

              <div class="row">
                <label>Cloud tint</label>
                <div class="palette" role="group" aria-label="Cloud tint palette">
                  <button class="swatch" type="button" data-tint="#ffffff" aria-pressed="true" style="background: #ffffff"></button>
                  <button class="swatch" type="button" data-tint="#ffe7f3" aria-pressed="false" style="background: #ffe7f3"></button>
                  <button class="swatch" type="button" data-tint="#e7f4ff" aria-pressed="false" style="background: #e7f4ff"></button>
                  <button class="swatch" type="button" data-tint="#fff1db" aria-pressed="false" style="background: #fff1db"></button>
                  <button class="swatch" type="button" data-tint="#efe8ff" aria-pressed="false" style="background: #efe8ff"></button>
                </div>
              </div>
            </div>
          </div>

          <div class="btnRow">
            <button class="btn rose" id="planeBtn" type="button" title="Send a plane!">Send a plane</button>
            <button class="btn primary" id="saveBtn" type="button" title="Save your sky as a PNG">Save picture</button>
            <button class="btn warm" id="undoBtn" type="button" title="Undo last cloud (Z)">Undo</button>
            <button class="btn" id="clearBtn" type="button" title="Clear the sky (C)">Clear</button>
          </div>
        </div>

        <div class="hud">
          <div class="pill toast" id="toast"><small><strong>Saved!</strong> Your sky is ready</small></div>
          <div class="pill toast" id="toast2"><small><strong>Woosh!</strong> Plane delivered</small></div>
        </div>

        <div class="hint" id="hint">
          Try: paint big clouds with <span class="kbd">drag</span>, change brush shapes, then press <span class="kbd">S</span> to save.
          Undo with <span class="kbd">Z</span>. Clear with <span class="kbd">C</span>.
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const rand = (a = 0, b = 1) => a + Math.random() * (b - a);
        const pick = (arr) => arr[(Math.random() * arr.length) | 0];
        const easeOut = (t) => 1 - Math.pow(1 - t, 3);

        const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;

        const canvas = $("#sky");
        const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });
        ctx.imageSmoothingEnabled = true;

        const ui = {
          shapeButtons: $$(".shapeBtn"),
          swatches: $$(".swatch"),
          size: $("#size"),
          opacity: $("#opacity"),
          wind: $("#wind"),
          planes: $("#planes"),
          sizeVal: $("#sizeVal"),
          opacityVal: $("#opacityVal"),
          windVal: $("#windVal"),
          planesVal: $("#planesVal"),
          driftToggle: $("#driftToggle"),
          planeToggle: $("#planeToggle"),
          saveBtn: $("#saveBtn"),
          undoBtn: $("#undoBtn"),
          clearBtn: $("#clearBtn"),
          planeBtn: $("#planeBtn"),
          toast: $("#toast"),
          toast2: $("#toast2"),
          hint: $("#hint"),
        };

        const state = {
          shape: "fluffy",
          size: 48,
          opacity: 0.85,
          tint: "#ffffff",
          drift: true,
          wind: 24, // px/s base
          planesOn: true,
          planeIntensity: 0.55,
        };

        /** @type {{w:number,h:number,dpr:number}} */
        const viewport = { w: 1, h: 1, dpr: 1 };
        const bg = {
          canvas: document.createElement("canvas"),
          ctx: null,
          noise: document.createElement("canvas"),
          noiseCtx: null,
          ambientClouds: [],
        };
        bg.ctx = bg.canvas.getContext("2d", { alpha: false });
        bg.noiseCtx = bg.noise.getContext("2d");

        /** @type {Array<Cloud>} */
        const clouds = [];
        /** @type {Array<Plane>} */
        const planes = [];

        /** @typedef {{x:number,y:number,r:number,a:number,soft:number}} Puff */
        /** @typedef {{x:number,y:number,baseX:number,baseY:number,originX:number,originY:number,puffs:Puff[],tint:[number,number,number],opacity:number,windFactor:number,bobAmp:number,bobSpeed:number,seed:number,active:boolean,createdAt:number}} Cloud */
        /** @typedef {{x:number,y:number,dir:number,speed:number,scale:number,seed:number,color:[number,number,number],born:number,life:number,trail:number}} Plane */

        const color = {
          hexToRgb(hex) {
            const h = hex.replace("#", "").trim();
            const full = h.length === 3 ? h.split("").map((c) => c + c).join("") : h;
            const n = parseInt(full, 16);
            return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
          },
          mix(a, b, t) {
            return [lerp(a[0], b[0], t), lerp(a[1], b[1], t), lerp(a[2], b[2], t)];
          },
          rgba(rgb, a) {
            return `rgba(${rgb[0] | 0},${rgb[1] | 0},${rgb[2] | 0},${a})`;
          },
        };

        function setToggle(el, on) {
          el.setAttribute("aria-checked", on ? "true" : "false");
        }

        function showToast(el) {
          el.classList.add("show");
          clearTimeout(el._t);
          el._t = setTimeout(() => el.classList.remove("show"), 1400);
        }

        function labelPlanes(v01) {
          if (v01 <= 0.08) return "Off";
          if (v01 <= 0.25) return "Few";
          if (v01 <= 0.55) return "Medium";
          if (v01 <= 0.8) return "Many";
          return "Party";
        }

        function updateUiText() {
          ui.sizeVal.textContent = `${state.size | 0}`;
          ui.opacityVal.textContent = `${Math.round(state.opacity * 100)}%`;
          const w = state.wind | 0;
          ui.windVal.textContent = `${w >= 0 ? "+" : ""}${w}`;
          ui.planesVal.textContent = labelPlanes(state.planeIntensity);
        }

        function buildNoise() {
          const s = 128;
          bg.noise.width = s;
          bg.noise.height = s;
          const nctx = bg.noiseCtx;
          const img = nctx.createImageData(s, s);
          for (let i = 0; i < img.data.length; i += 4) {
            const v = 220 + Math.random() * 35;
            img.data[i] = v;
            img.data[i + 1] = v;
            img.data[i + 2] = v;
            img.data[i + 3] = 18;
          }
          nctx.putImageData(img, 0, 0);
          nctx.globalCompositeOperation = "source-in";
          const g = nctx.createLinearGradient(0, 0, 0, s);
          g.addColorStop(0, "rgba(255,255,255,0.55)");
          g.addColorStop(1, "rgba(255,255,255,0.15)");
          nctx.fillStyle = g;
          nctx.fillRect(0, 0, s, s);
          nctx.globalCompositeOperation = "source-over";
        }

        function buildBackground() {
          bg.canvas.width = canvas.width;
          bg.canvas.height = canvas.height;
          const bctx = bg.ctx;
          const w = bg.canvas.width;
          const h = bg.canvas.height;
          const grad = bctx.createLinearGradient(0, 0, 0, h);
          grad.addColorStop(0, "#86d1ff");
          grad.addColorStop(0.35, "#bfeaff");
          grad.addColorStop(0.72, "#ffeaf5");
          grad.addColorStop(1, "#fff7ea");
          bctx.fillStyle = grad;
          bctx.fillRect(0, 0, w, h);

          const sunX = w * 0.78;
          const sunY = h * 0.18;
          const sunR = Math.min(w, h) * 0.18;
          const sun = bctx.createRadialGradient(sunX, sunY, sunR * 0.1, sunX, sunY, sunR);
          sun.addColorStop(0, "rgba(255,255,255,0.96)");
          sun.addColorStop(0.25, "rgba(255,239,176,0.72)");
          sun.addColorStop(0.55, "rgba(255,188,226,0.28)");
          sun.addColorStop(1, "rgba(255,255,255,0)");
          bctx.fillStyle = sun;
          bctx.beginPath();
          bctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
          bctx.fill();

          bg.ambientClouds = [];
          const cloudCount = Math.round(clamp((w * h) / (900 * 700), 2, 7));
          for (let i = 0; i < cloudCount; i++) {
            bg.ambientClouds.push({
              x: rand(w * 0.05, w * 0.95),
              y: rand(h * 0.1, h * 0.55),
              s: rand(0.6, 1.4),
              a: rand(0.08, 0.14),
            });
          }
          for (const c of bg.ambientClouds) drawAmbientCloud(bctx, c.x, c.y, c.s, c.a);

          const vignette = bctx.createRadialGradient(w * 0.5, h * 0.5, Math.min(w, h) * 0.1, w * 0.5, h * 0.5, Math.max(w, h) * 0.72);
          vignette.addColorStop(0, "rgba(255,255,255,0)");
          vignette.addColorStop(1, "rgba(18,38,56,0.06)");
          bctx.fillStyle = vignette;
          bctx.fillRect(0, 0, w, h);

          bctx.globalAlpha = 0.55;
          bctx.drawImage(bg.noise, 0, 0, w, h);
          bctx.globalAlpha = 1;
        }

        function resize() {
          const rect = canvas.getBoundingClientRect();
          viewport.dpr = clamp(window.devicePixelRatio || 1, 1, 2);
          viewport.w = Math.max(1, Math.round(rect.width));
          viewport.h = Math.max(1, Math.round(rect.height));
          canvas.width = Math.round(viewport.w * viewport.dpr);
          canvas.height = Math.round(viewport.h * viewport.dpr);
          ctx.setTransform(viewport.dpr, 0, 0, viewport.dpr, 0, 0);
          buildBackground();
        }

        function drawAmbientCloud(bctx, x, y, s, a) {
          bctx.save();
          bctx.globalAlpha = a;
          bctx.translate(x, y);
          bctx.scale(s, s);
          bctx.fillStyle = "rgba(255,255,255,0.95)";
          bctx.shadowColor = "rgba(255,255,255,0.75)";
          bctx.shadowBlur = 18;
          const blobs = [
            [-32, 8, 26],
            [-12, -6, 30],
            [10, -4, 28],
            [34, 10, 22],
            [0, 12, 34],
          ];
          for (const [bx, by, br] of blobs) {
            bctx.beginPath();
            bctx.arc(bx, by, br, 0, Math.PI * 2);
            bctx.fill();
          }
          bctx.restore();
        }

        function gaussian() {
          let u = 0,
            v = 0;
          while (u === 0) u = Math.random();
          while (v === 0) v = Math.random();
          return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function createCloud(x, y) {
          const tint = color.hexToRgb(state.tint);
          const base = color.hexToRgb("#ffffff");
          const mixed = color.mix(base, tint, 0.65);
          /** @type {Cloud} */
          const cloud = {
            x,
            y,
            baseX: x,
            baseY: y,
            originX: x,
            originY: y,
            puffs: [],
            tint: mixed,
            opacity: state.opacity,
            windFactor: rand(0.5, 1.15),
            bobAmp: rand(1.5, 7) * (prefersReducedMotion ? 0 : 1),
            bobSpeed: rand(0.35, 0.85) * (prefersReducedMotion ? 0 : 1),
            seed: rand(0, 1000),
            active: true,
            createdAt: performance.now(),
          };
          return cloud;
        }

        function addPuff(cloud, x, y, r, a, soft = 1) {
          const dx = x - cloud.originX;
          const dy = y - cloud.originY;
          cloud.puffs.push({ x: dx, y: dy, r, a, soft });
        }

        function stampAt(cloud, x, y, intensity = 1) {
          const size = state.size;
          const baseR = size * rand(0.24, 0.38) * intensity;
          const puffAlpha = clamp(0.18 + cloud.opacity * 0.9, 0.18, 0.95);

          if (state.shape === "fluffy") {
            const count = Math.round(rand(6, 10));
            addPuff(cloud, x, y, baseR * rand(1.05, 1.45), puffAlpha * rand(0.55, 0.85), rand(0.9, 1.1));
            for (let i = 0; i < count; i++) {
              const ang = rand(0, Math.PI * 2);
              const dist = Math.abs(gaussian()) * size * 0.32;
              const ox = Math.cos(ang) * dist;
              const oy = Math.sin(ang) * dist * 0.7;
              addPuff(cloud, x + ox, y + oy, baseR * rand(0.65, 1.25), puffAlpha * rand(0.25, 0.8), rand(0.85, 1.25));
            }
            if (Math.random() < 0.25) addPuff(cloud, x + rand(-size * 0.12, size * 0.12), y - size * 0.18, baseR * 0.55, puffAlpha * 0.22, 1.35);
            return;
          }

          if (state.shape === "sprinkle") {
            const count = Math.round(rand(12, 20));
            for (let i = 0; i < count; i++) {
              const ang = rand(0, Math.PI * 2);
              const dist = rand(0, 1) ** 0.5 * size * 0.62;
              const ox = Math.cos(ang) * dist;
              const oy = Math.sin(ang) * dist * 0.78;
              addPuff(cloud, x + ox, y + oy, baseR * rand(0.28, 0.8), puffAlpha * rand(0.18, 0.52), rand(1.0, 1.5));
            }
            addPuff(cloud, x, y, baseR * rand(1.0, 1.5), puffAlpha * rand(0.28, 0.6), rand(0.85, 1.15));
            return;
          }

          if (state.shape === "heart") {
            const steps = 14;
            const scale = size * 0.034;
            for (let i = 0; i < steps; i++) {
              const t = (i / steps) * Math.PI * 2;
              const sx = 16 * Math.sin(t) ** 3;
              const sy =
                13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
              const ox = sx * scale;
              const oy = -sy * scale * 0.9;
              addPuff(cloud, x + ox, y + oy, baseR * rand(0.42, 0.75), puffAlpha * rand(0.18, 0.45), rand(1.05, 1.65));
            }
            addPuff(cloud, x, y + size * 0.08, baseR * rand(0.95, 1.25), puffAlpha * rand(0.3, 0.65), rand(0.85, 1.15));
            return;
          }

          if (state.shape === "star") {
            const spikes = 5;
            const outer = size * 0.48;
            const inner = size * 0.22;
            const pts = [];
            let rot = -Math.PI / 2;
            for (let i = 0; i < spikes * 2; i++) {
              const rr = i % 2 === 0 ? outer : inner;
              pts.push([x + Math.cos(rot) * rr, y + Math.sin(rot) * rr]);
              rot += Math.PI / spikes;
            }
            for (let i = 0; i < pts.length; i++) {
              const [ax, ay] = pts[i];
              const [bx, by] = pts[(i + 1) % pts.length];
              const segSteps = 3;
              for (let s = 0; s <= segSteps; s++) {
                const tt = s / segSteps;
                const px = lerp(ax, bx, tt);
                const py = lerp(ay, by, tt);
                addPuff(cloud, px, py, baseR * rand(0.35, 0.7), puffAlpha * rand(0.14, 0.38), rand(1.1, 1.7));
              }
            }
            addPuff(cloud, x, y, baseR * rand(0.95, 1.3), puffAlpha * rand(0.3, 0.7), rand(0.8, 1.15));
          }
        }

        function drawPuff(ctx2, x, y, r, rgb, a, softness = 1) {
          const inner = clamp(0.08 * softness, 0.05, 0.2);
          const g = ctx2.createRadialGradient(x - r * 0.14, y - r * 0.16, r * inner, x, y, r);
          g.addColorStop(0, color.rgba(rgb, a));
          g.addColorStop(0.55, color.rgba(color.mix(rgb, [255, 255, 255], 0.55), a * 0.62));
          g.addColorStop(1, "rgba(255,255,255,0)");
          ctx2.fillStyle = g;
          ctx2.shadowColor = "rgba(255,255,255,0.62)";
          ctx2.shadowBlur = r * 0.65 * softness;
          ctx2.beginPath();
          ctx2.arc(x, y, r, 0, Math.PI * 2);
          ctx2.fill();
        }

        function drawCloud(ctx2, cloud, now) {
          ctx2.save();
          ctx2.translate(cloud.x, cloud.y);
          const time = now * 0.001;
          const sparkle = 0.03 * (Math.sin(time * 2.2 + cloud.seed) * 0.5 + 0.5);
          const alphaBase = clamp(cloud.opacity + sparkle, 0.08, 0.98);
          ctx2.globalCompositeOperation = "lighter";
          for (let i = 0; i < cloud.puffs.length; i++) {
            const p = cloud.puffs[i];
            const a = clamp(p.a * alphaBase, 0, 1);
            if (a <= 0.002) continue;
            drawPuff(ctx2, p.x, p.y, p.r, cloud.tint, a, p.soft);
          }
          ctx2.globalCompositeOperation = "source-over";
          ctx2.restore();
        }

        function spawnPlane({ x = null, y = null, dir = null } = {}) {
          const w = viewport.w;
          const h = viewport.h;
          const direction = dir ?? (Math.random() < 0.55 ? 1 : -1);
          const scale = rand(0.62, 1.15);
          const altitude = y ?? rand(h * 0.12, h * 0.62);
          const startX = x ?? (direction === 1 ? -w * 0.12 : w * 1.12);
          const speed = rand(48, 110) * (0.7 + state.planeIntensity * 0.9) * (direction === 1 ? 1 : 1);
          const palette = [
            color.hexToRgb("#ffffff"),
            color.hexToRgb("#ffe7f3"),
            color.hexToRgb("#e7f4ff"),
            color.hexToRgb("#fff1db"),
            color.hexToRgb("#efe8ff"),
          ];
          const c = color.mix(pick(palette), color.hexToRgb("#ffffff"), 0.45);
          /** @type {Plane} */
          const p = {
            x: startX,
            y: altitude,
            dir: direction,
            speed,
            scale,
            seed: rand(0, 1000),
            color: c,
            born: performance.now(),
            life: rand(14000, 24000),
            trail: rand(0.55, 1.0),
          };
          planes.push(p);
        }

        function drawPlane(ctx2, plane, now) {
          const t = now * 0.001;
          const bob = Math.sin(t * 2.2 + plane.seed) * 2.2 * plane.scale * (prefersReducedMotion ? 0 : 1);
          const x = plane.x;
          const y = plane.y + bob;
          const s = 18 * plane.scale;
          const flip = plane.dir === 1 ? 1 : -1;

          ctx2.save();
          ctx2.translate(x, y);
          ctx2.scale(flip, 1);
          ctx2.globalAlpha = 0.95;

          // Contrail
          const trailLen = s * (10 + plane.trail * 8);
          const trail = ctx2.createLinearGradient(-trailLen, 0, -s, 0);
          trail.addColorStop(0, "rgba(255,255,255,0)");
          trail.addColorStop(0.25, "rgba(255,255,255,0.18)");
          trail.addColorStop(1, "rgba(255,255,255,0.54)");
          ctx2.strokeStyle = trail;
          ctx2.lineWidth = 5 * plane.scale;
          ctx2.lineCap = "round";
          ctx2.beginPath();
          ctx2.moveTo(-trailLen, 6 * plane.scale);
          ctx2.quadraticCurveTo(-trailLen * 0.65, 3 * plane.scale, -s * 0.95, 5.5 * plane.scale);
          ctx2.stroke();

          // Body
          ctx2.shadowColor = "rgba(18,38,56,0.14)";
          ctx2.shadowBlur = 10 * plane.scale;
          const body = ctx2.createLinearGradient(-s * 1.2, 0, s * 1.2, 0);
          body.addColorStop(0, color.rgba(color.mix(plane.color, [255, 255, 255], 0.15), 0.92));
          body.addColorStop(0.55, "rgba(255,255,255,0.95)");
          body.addColorStop(1, color.rgba(color.mix(plane.color, [255, 255, 255], 0.45), 0.92));
          ctx2.fillStyle = body;
          roundedRect(ctx2, -s * 1.15, -s * 0.32, s * 2.1, s * 0.64, s * 0.32);
          ctx2.fill();

          // Nose
          ctx2.beginPath();
          ctx2.ellipse(s * 0.98, 0, s * 0.28, s * 0.26, 0, 0, Math.PI * 2);
          ctx2.fill();

          // Wing + tail
          ctx2.shadowBlur = 0;
          ctx2.fillStyle = "rgba(255,255,255,0.8)";
          ctx2.beginPath();
          ctx2.moveTo(-s * 0.12, 0);
          ctx2.lineTo(-s * 0.78, s * 0.68);
          ctx2.lineTo(s * 0.26, s * 0.18);
          ctx2.closePath();
          ctx2.fill();

          ctx2.beginPath();
          ctx2.moveTo(-s * 0.95, -s * 0.1);
          ctx2.lineTo(-s * 1.2, -s * 0.68);
          ctx2.lineTo(-s * 0.68, -s * 0.2);
          ctx2.closePath();
          ctx2.fill();

          // Windows
          ctx2.fillStyle = "rgba(106,167,255,0.5)";
          for (let i = 0; i < 3; i++) {
            const wx = -s * 0.55 + i * s * 0.36;
            ctx2.beginPath();
            ctx2.ellipse(wx, -s * 0.02, s * 0.1, s * 0.09, 0, 0, Math.PI * 2);
            ctx2.fill();
          }

          // Propeller sparkle
          const spin = (t * 18 + plane.seed) % (Math.PI * 2);
          ctx2.globalAlpha = 0.75;
          ctx2.strokeStyle = "rgba(255,255,255,0.8)";
          ctx2.lineWidth = 2.2 * plane.scale;
          ctx2.beginPath();
          ctx2.moveTo(s * 1.12, 0);
          ctx2.lineTo(s * 1.12 + Math.cos(spin) * (s * 0.32), Math.sin(spin) * (s * 0.32));
          ctx2.stroke();
          ctx2.beginPath();
          ctx2.moveTo(s * 1.12, 0);
          ctx2.lineTo(s * 1.12 + Math.cos(spin + Math.PI) * (s * 0.32), Math.sin(spin + Math.PI) * (s * 0.32));
          ctx2.stroke();

          ctx2.restore();
        }

        function roundedRect(ctx2, x, y, w, h, r) {
          const rr = Math.min(r, w / 2, h / 2);
          ctx2.beginPath();
          ctx2.moveTo(x + rr, y);
          ctx2.arcTo(x + w, y, x + w, y + h, rr);
          ctx2.arcTo(x + w, y + h, x, y + h, rr);
          ctx2.arcTo(x, y + h, x, y, rr);
          ctx2.arcTo(x, y, x + w, y, rr);
          ctx2.closePath();
        }

        let isPainting = false;
        let activeCloud = null;
        let lastPt = null;
        let planeSpawnAcc = 0;
        let lastFrame = performance.now();
        let firstInteraction = false;

        function worldPointFromEvent(e) {
          const rect = canvas.getBoundingClientRect();
          return {
            x: (e.clientX - rect.left) * (viewport.w / rect.width),
            y: (e.clientY - rect.top) * (viewport.h / rect.height),
          };
        }

        function canPaintFromEvent(e) {
          const panel = e.target.closest?.(".panel");
          return !panel;
        }

        function beginPaint(e) {
          if (!canPaintFromEvent(e)) return;
          firstInteraction = true;
          ui.hint.style.display = "none";
          const p = worldPointFromEvent(e);
          isPainting = true;
          activeCloud = createCloud(p.x, p.y);
          clouds.push(activeCloud);
          lastPt = { x: p.x, y: p.y };
          stampAt(activeCloud, p.x, p.y, 1.0);
          canvas.setPointerCapture?.(e.pointerId);
        }

        function movePaint(e) {
          if (!isPainting || !activeCloud) return;
          const p = worldPointFromEvent(e);
          const dx = p.x - lastPt.x;
          const dy = p.y - lastPt.y;
          const dist = Math.hypot(dx, dy);
          const step = clamp(state.size * 0.22, 6, 18);
          const steps = Math.max(1, Math.floor(dist / step));
          for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const x = lerp(lastPt.x, p.x, t);
            const y = lerp(lastPt.y, p.y, t);
            const pressure = typeof e.pressure === "number" && e.pressure > 0 ? e.pressure : 0.7;
            const intensity = clamp(0.7 + pressure * 0.5, 0.5, 1.1);
            stampAt(activeCloud, x, y, intensity);
          }
          lastPt = p;
          if (activeCloud.puffs.length > 3500) activeCloud.puffs.splice(0, activeCloud.puffs.length - 3500);
          if (clouds.length > 240) clouds.splice(0, clouds.length - 240);
        }

        function endPaint(e) {
          if (!isPainting) return;
          isPainting = false;
          if (activeCloud) {
            activeCloud.active = false;
            activeCloud.baseX = activeCloud.x;
            activeCloud.baseY = activeCloud.y;
            activeCloud.createdAt = performance.now();
          }
          activeCloud = null;
          lastPt = null;
          canvas.releasePointerCapture?.(e.pointerId);
        }

        function updateClouds(dt, now) {
          const w = viewport.w;
          const margin = 180;
          for (const c of clouds) {
            if (c.active) continue;
            if (state.drift && !prefersReducedMotion) c.baseX += state.wind * c.windFactor * dt;
            if (c.baseX > w + margin) c.baseX = -margin;
            if (c.baseX < -margin) c.baseX = w + margin;
            const wob = Math.sin(now * 0.001 * c.bobSpeed + c.seed) * c.bobAmp;
            c.x = c.baseX;
            c.y = c.baseY + wob;
          }
        }

        function updatePlanes(dt, now) {
          if (!state.planesOn || state.planeIntensity <= 0.08) return;
          const targetRatePerSec = lerp(0.02, 0.28, easeOut(state.planeIntensity)); // planes/sec
          planeSpawnAcc += dt * targetRatePerSec;
          const cap = clamp(10 + Math.round(state.planeIntensity * 28), 10, 40);
          while (planeSpawnAcc >= 1 && planes.length < cap) {
            planeSpawnAcc -= 1;
            spawnPlane();
          }
          const w = viewport.w;
          const off = w * 0.2;
          for (let i = planes.length - 1; i >= 0; i--) {
            const p = planes[i];
            p.x += p.speed * dt * p.dir;
            const age = now - p.born;
            if (age > p.life || (p.dir === 1 && p.x > w + off) || (p.dir === -1 && p.x < -off)) planes.splice(i, 1);
          }
        }

        function render(now) {
          const w = viewport.w;
          const h = viewport.h;
          ctx.clearRect(0, 0, w, h);

          ctx.drawImage(bg.canvas, 0, 0, w, h);

          // Gentle shimmer bands
          if (!prefersReducedMotion) {
            const t = now * 0.001;
            ctx.save();
            ctx.globalAlpha = 0.09;
            ctx.globalCompositeOperation = "screen";
            ctx.fillStyle = "rgba(255,255,255,0.85)";
            for (let i = 0; i < 3; i++) {
              const yy = (h * (0.22 + i * 0.22) + Math.sin(t * 0.6 + i) * 14) | 0;
              roundedRect(ctx, -40, yy, w + 80, 22, 22);
              ctx.fill();
            }
            ctx.restore();
          }

          // Clouds (kid-painted)
          for (const c of clouds) drawCloud(ctx, c, now);

          // Airplanes
          for (const p of planes) drawPlane(ctx, p, now);

          // Foreground soft noise
          ctx.save();
          ctx.globalAlpha = 0.35;
          ctx.globalCompositeOperation = "overlay";
          ctx.drawImage(bg.noise, 0, 0, w, h);
          ctx.restore();
        }

        function tick(now) {
          const dt = clamp((now - lastFrame) / 1000, 0, 0.04);
          lastFrame = now;
          updateClouds(dt, now);
          updatePlanes(dt, now);
          render(now);
          requestAnimationFrame(tick);
        }

        function savePng() {
          const w = viewport.w;
          const h = viewport.h;
          const exportCanvas = document.createElement("canvas");
          const dpr = clamp(window.devicePixelRatio || 1, 1, 2);
          exportCanvas.width = Math.round(w * dpr);
          exportCanvas.height = Math.round(h * dpr);
          const ex = exportCanvas.getContext("2d", { alpha: false });
          ex.setTransform(dpr, 0, 0, dpr, 0, 0);
          ex.imageSmoothingEnabled = true;

          ex.drawImage(bg.canvas, 0, 0, w, h);
          for (const c of clouds) drawCloud(ex, c, performance.now());
          for (const p of planes) drawPlane(ex, p, performance.now());
          ex.save();
          ex.globalAlpha = 0.22;
          ex.globalCompositeOperation = "overlay";
          ex.drawImage(bg.noise, 0, 0, w, h);
          ex.restore();

          exportCanvas.toBlob(
            (blob) => {
              if (!blob) return;
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = `cloud-painter-${new Date().toISOString().slice(0, 10)}.png`;
              document.body.appendChild(a);
              a.click();
              a.remove();
              setTimeout(() => URL.revokeObjectURL(url), 2000);
              showToast(ui.toast);
            },
            "image/png",
            1
          );
        }

        function clearSky() {
          clouds.length = 0;
          planes.length = 0;
          planeSpawnAcc = 0;
        }

        function undo() {
          if (clouds.length > 0) clouds.pop();
        }

        function wireUi() {
          ui.shapeButtons.forEach((b) => {
            b.addEventListener("click", () => {
              state.shape = b.dataset.shape;
              ui.shapeButtons.forEach((x) => x.setAttribute("aria-pressed", x === b ? "true" : "false"));
            });
          });

          ui.swatches.forEach((s) => {
            s.addEventListener("click", () => {
              state.tint = s.dataset.tint;
              ui.swatches.forEach((x) => x.setAttribute("aria-pressed", x === s ? "true" : "false"));
            });
          });

          ui.size.addEventListener("input", () => {
            state.size = Number(ui.size.value);
            updateUiText();
          });
          ui.opacity.addEventListener("input", () => {
            state.opacity = Number(ui.opacity.value) / 100;
            updateUiText();
          });
          ui.wind.addEventListener("input", () => {
            state.wind = Number(ui.wind.value);
            updateUiText();
          });
          ui.planes.addEventListener("input", () => {
            state.planeIntensity = Number(ui.planes.value) / 100;
            updateUiText();
          });

          function toggleSwitch(el, key) {
            const current = el.getAttribute("aria-checked") === "true";
            const next = !current;
            setToggle(el, next);
            state[key] = next;
          }

          ui.driftToggle.addEventListener("click", () => toggleSwitch(ui.driftToggle, "drift"));
          ui.planeToggle.addEventListener("click", () => toggleSwitch(ui.planeToggle, "planesOn"));
          ui.driftToggle.addEventListener("keydown", (e) => {
            if (e.key === " " || e.key === "Enter") {
              e.preventDefault();
              ui.driftToggle.click();
            }
          });
          ui.planeToggle.addEventListener("keydown", (e) => {
            if (e.key === " " || e.key === "Enter") {
              e.preventDefault();
              ui.planeToggle.click();
            }
          });

          ui.saveBtn.addEventListener("click", savePng);
          ui.clearBtn.addEventListener("click", () => {
            const ok = !firstInteraction || confirm("Clear the whole sky?");
            if (ok) clearSky();
          });
          ui.undoBtn.addEventListener("click", undo);
          ui.planeBtn.addEventListener("click", () => {
            firstInteraction = true;
            ui.hint.style.display = "none";
            if (!state.planesOn) {
              state.planesOn = true;
              setToggle(ui.planeToggle, true);
            }
            spawnPlane({ y: rand(viewport.h * 0.18, viewport.h * 0.58) });
            showToast(ui.toast2);
          });

          window.addEventListener("keydown", (e) => {
            const tag = document.activeElement?.tagName?.toLowerCase?.();
            const typing = tag === "input" || tag === "textarea" || tag === "select";
            if (typing) return;
            if ((e.key === "z" || e.key === "Z") && !(e.metaKey || e.ctrlKey)) {
              undo();
            }
            if (e.key === "s" || e.key === "S") {
              e.preventDefault();
              savePng();
            }
            if (e.key === "c" || e.key === "C") {
              const ok = !firstInteraction || confirm("Clear the whole sky?");
              if (ok) clearSky();
            }
          });
        }

        function init() {
          buildNoise();
          resize();
          wireUi();
          updateUiText();
          setToggle(ui.driftToggle, state.drift);
          setToggle(ui.planeToggle, state.planesOn);
          window.addEventListener("resize", resize, { passive: true });

          canvas.addEventListener("pointerdown", beginPaint);
          canvas.addEventListener("pointermove", movePaint);
          window.addEventListener("pointerup", endPaint, { passive: true });
          window.addEventListener("pointercancel", endPaint, { passive: true });
          canvas.addEventListener("contextmenu", (e) => e.preventDefault());

          // A few starter planes for delight
          if (!prefersReducedMotion) {
            setTimeout(() => {
              if (state.planesOn && state.planeIntensity > 0.08) spawnPlane({ dir: 1 });
            }, 900);
            setTimeout(() => {
              if (state.planesOn && state.planeIntensity > 0.08) spawnPlane({ dir: -1 });
            }, 2300);
          }

          requestAnimationFrame((t) => {
            lastFrame = t;
            requestAnimationFrame(tick);
          });
        }

        init();
      })();
    </script>
  </body>
</html>
