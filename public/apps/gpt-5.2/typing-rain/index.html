<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <meta name="color-scheme" content="dark" />
    <title>Typing Rain</title>
    <style>
      :root {
        --bg: #050711;
        --panel: rgba(10, 16, 32, 0.55);
        --panel-2: rgba(10, 16, 32, 0.38);
        --stroke: rgba(173, 216, 255, 0.18);
        --text: rgba(238, 247, 255, 0.92);
        --muted: rgba(238, 247, 255, 0.68);
        --muted-2: rgba(238, 247, 255, 0.5);
        --accent: #64d2ff;
        --accent-2: #22c55e;
        --danger: #fb7185;
        --warn: #fbbf24;
        --shadow: rgba(0, 0, 0, 0.4);
        --radius: 16px;
        --radius-lg: 22px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: radial-gradient(1200px 900px at 50% 20%, #0a1438 0%, #050711 55%, #04040b 100%);
        color: var(--text);
        font-family: var(--sans);
        overflow: hidden;
      }

      .app {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: stretch;
      }

      canvas#scene {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .hud {
        position: absolute;
        inset: 0;
        pointer-events: none;
        padding: 16px;
        padding: max(16px, env(safe-area-inset-top)) max(16px, env(safe-area-inset-right)) max(16px, env(safe-area-inset-bottom))
          max(16px, env(safe-area-inset-left));
      }

      .row {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
      }

      .panel {
        pointer-events: auto;
        background: linear-gradient(180deg, rgba(10, 16, 32, 0.62), rgba(10, 16, 32, 0.34));
        border: 1px solid var(--stroke);
        box-shadow: 0 18px 60px var(--shadow);
        border-radius: var(--radius);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }
      .panel.tight {
        padding: 10px 12px;
      }
      .panel.padded {
        padding: 14px 14px;
      }

      .stats {
        display: grid;
        gap: 8px;
        min-width: min(520px, 70vw);
      }
      .statsTop {
        display: grid;
        grid-template-columns: 1.2fr 1fr 1fr 1fr;
        gap: 10px;
      }
      .stat {
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(173, 216, 255, 0.12);
      }
      .stat .label {
        font-size: 11px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: var(--muted-2);
      }
      .stat .value {
        margin-top: 3px;
        font-size: 18px;
        font-weight: 700;
        line-height: 1.1;
      }
      .stat .sub {
        margin-top: 3px;
        font-size: 12px;
        color: var(--muted);
        font-variant-numeric: tabular-nums;
      }
      .value.mono,
      .sub.mono {
        font-family: var(--mono);
      }
      .pillRow {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 7px 10px;
        border-radius: 999px;
        border: 1px solid rgba(173, 216, 255, 0.14);
        background: rgba(255, 255, 255, 0.03);
        font-size: 12px;
        color: var(--muted);
        user-select: none;
        -webkit-user-select: none;
      }
      .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(100, 210, 255, 0.12);
      }
      .dot.green {
        background: var(--accent-2);
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.14);
      }
      .dot.red {
        background: var(--danger);
        box-shadow: 0 0 0 3px rgba(251, 113, 133, 0.14);
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: 250px;
        max-width: min(330px, 46vw);
      }
      .controls .btnRow {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      button {
        appearance: none;
        -webkit-appearance: none;
        border: 1px solid rgba(173, 216, 255, 0.18);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        border-radius: 14px;
        padding: 10px 12px;
        font-weight: 650;
        letter-spacing: 0.01em;
        cursor: pointer;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.25);
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, filter 120ms ease;
      }
      button:hover {
        filter: brightness(1.08);
      }
      button:active {
        transform: translateY(1px);
      }
      button.primary {
        border-color: rgba(100, 210, 255, 0.38);
        background: linear-gradient(180deg, rgba(100, 210, 255, 0.18), rgba(100, 210, 255, 0.06));
      }
      button.danger {
        border-color: rgba(251, 113, 133, 0.38);
        background: linear-gradient(180deg, rgba(251, 113, 133, 0.16), rgba(251, 113, 133, 0.06));
      }
      button.ghost {
        background: rgba(255, 255, 255, 0.02);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        box-shadow: none;
      }

      .kbd {
        font-family: var(--mono);
        font-size: 12px;
        padding: 2px 6px;
        border-radius: 8px;
        border: 1px solid rgba(173, 216, 255, 0.18);
        background: rgba(255, 255, 255, 0.04);
        color: rgba(238, 247, 255, 0.86);
        margin-left: 6px;
      }

      .typeDock {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        width: min(860px, calc(100vw - 26px));
        pointer-events: auto;
      }

      .typePanel {
        display: grid;
        gap: 10px;
        padding: 14px;
        border-radius: var(--radius-lg);
        background: linear-gradient(180deg, rgba(10, 16, 32, 0.68), rgba(10, 16, 32, 0.34));
      }

      .typeTop {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .prompt {
        font-size: 12px;
        color: var(--muted);
      }
      .prompt b {
        color: rgba(238, 247, 255, 0.94);
      }

      .typeRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      .typeBoxWrap {
        position: relative;
      }
      input#typeBox {
        width: 100%;
        padding: 14px 14px;
        border-radius: 16px;
        border: 1px solid rgba(173, 216, 255, 0.18);
        background: rgba(255, 255, 255, 0.04);
        outline: none;
        color: var(--text);
        font-size: 16px;
        font-family: var(--mono);
        letter-spacing: 0.02em;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
      }
      input#typeBox::placeholder {
        color: rgba(238, 247, 255, 0.45);
      }
      .shake {
        animation: shake 180ms ease;
      }
      @keyframes shake {
        0% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-6px);
        }
        55% {
          transform: translateX(5px);
        }
        80% {
          transform: translateX(-3px);
        }
        100% {
          transform: translateX(0);
        }
      }
      .tipRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        color: var(--muted);
        font-size: 12px;
      }
      .small {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.4;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 18px;
        pointer-events: auto;
      }
      .overlay.hidden {
        display: none;
      }
      .card {
        width: min(760px, 100%);
        border-radius: 26px;
        border: 1px solid rgba(173, 216, 255, 0.18);
        background: radial-gradient(1200px 600px at 20% 0%, rgba(100, 210, 255, 0.12), transparent 55%),
          linear-gradient(180deg, rgba(10, 16, 32, 0.78), rgba(10, 16, 32, 0.46));
        box-shadow: 0 30px 120px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        padding: 18px;
      }
      .hero {
        display: grid;
        gap: 12px;
        padding: 14px;
        border-radius: 20px;
        border: 1px solid rgba(173, 216, 255, 0.14);
        background: rgba(255, 255, 255, 0.03);
      }
      .titleRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
      }
      .title {
        font-size: clamp(28px, 4vw, 44px);
        font-weight: 850;
        letter-spacing: -0.02em;
        margin: 0;
      }
      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: 14px;
        line-height: 1.5;
      }
      .grid2 {
        display: grid;
        grid-template-columns: 1.1fr 0.9fr;
        gap: 12px;
        margin-top: 12px;
      }
      .list {
        display: grid;
        gap: 10px;
        padding: 12px;
        border-radius: 18px;
        border: 1px solid rgba(173, 216, 255, 0.14);
        background: rgba(255, 255, 255, 0.03);
      }
      .list h3 {
        margin: 0;
        font-size: 13px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: rgba(238, 247, 255, 0.72);
      }
      .list ul {
        margin: 0;
        padding-left: 18px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.55;
      }
      .list li {
        margin: 6px 0;
      }
      .footerRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 12px;
      }
      .footerRow .small {
        max-width: 46ch;
      }

      .tag {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 7px 10px;
        border-radius: 999px;
        border: 1px solid rgba(173, 216, 255, 0.14);
        background: rgba(255, 255, 255, 0.03);
        color: rgba(238, 247, 255, 0.78);
        font-size: 12px;
      }

      .toast {
        position: absolute;
        left: 50%;
        top: 92px;
        transform: translateX(-50%);
        pointer-events: none;
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid rgba(173, 216, 255, 0.18);
        background: rgba(10, 16, 32, 0.52);
        color: rgba(238, 247, 255, 0.86);
        font-size: 12px;
        opacity: 0;
        transition: opacity 140ms ease, transform 140ms ease;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      @media (max-width: 940px) {
        .controls {
          min-width: auto;
          max-width: 48vw;
        }
        .statsTop {
          grid-template-columns: 1.2fr 1fr;
        }
        .grid2 {
          grid-template-columns: 1fr;
        }
      }
      @media (max-width: 680px) {
        .row {
          align-items: stretch;
        }
        .controls {
          display: none;
        }
        .stats {
          min-width: 0;
        }
        .typeTop {
          flex-direction: column;
          align-items: flex-start;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          scroll-behavior: auto !important;
        }
      }
    </style>
  </head>

  <body>
    <div class="app" id="app">
      <canvas id="scene" aria-label="Typing Rain scene"></canvas>

      <div class="hud" aria-live="polite">
        <div class="row">
          <div class="panel padded stats">
            <div class="statsTop">
              <div class="stat">
                <div class="label">Score</div>
                <div class="value mono" id="score">0</div>
                <div class="sub mono" id="best">Best 0</div>
              </div>
              <div class="stat">
                <div class="label">Level</div>
                <div class="value mono" id="level">1</div>
                <div class="sub mono" id="pace">Spawn 1.20s</div>
              </div>
              <div class="stat">
                <div class="label">Accuracy</div>
                <div class="value mono" id="acc">100%</div>
                <div class="sub mono" id="keystats">0 / 0</div>
              </div>
              <div class="stat">
                <div class="label">Storm</div>
                <div class="value mono" id="lives">☂☂☂☂☂</div>
                <div class="sub mono" id="streak">Streak 0</div>
              </div>
            </div>
            <div class="pillRow">
              <span class="pill"><span class="dot green" id="dotState"></span><span id="stateText">Ready</span></span>
              <span class="pill"><span class="dot" style="background: var(--warn)"></span><span id="hintText">Type the falling words</span></span>
              <span class="pill"><span class="dot" style="background: rgba(238,247,255,0.7)"></span><span class="mono" id="wpm">0 WPM</span></span>
            </div>
          </div>

          <div class="panel padded controls">
            <div class="btnRow">
              <button class="primary" id="btnStart">Start</button>
              <button class="ghost" id="btnPause">Pause <span class="kbd">P</span></button>
              <button class="danger" id="btnReset">Reset</button>
            </div>
            <div class="btnRow">
              <button class="ghost" id="btnSound">Sound: Off</button>
              <button class="ghost" id="btnFocus">Focus Input</button>
            </div>
            <div class="small">
              Tip: match the glowing raindrop first—words closer to the ground are more urgent. You can clear instantly when your
              typed text matches a word (no need to press Enter).
            </div>
            <div class="small">
              Controls:
              <span class="kbd">Esc</span> clear,
              <span class="kbd">Backspace</span> delete,
              <span class="kbd">Enter</span>/<span class="kbd">Space</span> commit (optional),
              <span class="kbd">P</span> pause.
            </div>
          </div>
        </div>

        <div class="typeDock">
          <div class="panel typePanel">
            <div class="typeTop">
              <div class="prompt" id="targetPrompt">Target: <b id="targetWord">—</b> <span class="mono" id="targetMeta"></span></div>
              <div class="prompt">Mistakes create splashes — stay calm.</div>
            </div>
            <div class="typeRow">
              <div class="typeBoxWrap" id="typeBoxWrap">
                <input
                  id="typeBox"
                  type="text"
                  inputmode="text"
                  autocomplete="off"
                  autocapitalize="none"
                  spellcheck="false"
                  placeholder="Type here…"
                  aria-label="Typing input"
                />
              </div>
              <div class="tipRow">
                <div class="small mono" id="micro">0 hits • 0 misses</div>
                <div class="small" id="statusRight">Click the scene to refocus</div>
              </div>
            </div>
          </div>
        </div>

        <div class="toast" id="toast"></div>

        <div class="overlay" id="overlayIntro">
          <div class="card">
            <div class="hero">
              <div class="titleRow">
                <h1 class="title">Typing Rain</h1>
                <span class="tag"><span class="dot"></span><span>City Storm Mode</span></span>
              </div>
              <p class="subtitle">
                Words fall like neon raindrops. Type them before they hit the street. The storm intensifies over time—keep your
                accuracy high to survive the downpour.
              </p>
            </div>
            <div class="grid2">
              <div class="list">
                <h3>How To Play</h3>
                <ul>
                  <li>Start typing: the closest matching word becomes your target (it glows).</li>
                  <li>Finish a word to score; longer words and higher levels award more.</li>
                  <li>If a word reaches the bottom, you lose an umbrella.</li>
                  <li>Accuracy is tracked per keystroke; streaks boost your flow.</li>
                </ul>
              </div>
              <div class="list">
                <h3>Quick Start</h3>
                <ul>
                  <li>Press <span class="kbd">Start</span> or <span class="kbd">Enter</span>.</li>
                  <li>Keep your eyes on the lowest drops.</li>
                  <li>Clear input with <span class="kbd">Esc</span>.</li>
                  <li>Pause with <span class="kbd">P</span>.</li>
                </ul>
              </div>
            </div>
            <div class="footerRow">
              <div class="small">
                High score is saved locally on this device. If you have reduced motion enabled, visuals are simplified.
              </div>
              <div class="btnRow">
                <button class="ghost" id="btnIntroSound">Toggle Sound</button>
                <button class="primary" id="btnIntroStart">Start the Storm</button>
              </div>
            </div>
          </div>
        </div>

        <div class="overlay hidden" id="overlayEnd">
          <div class="card">
            <div class="hero">
              <div class="titleRow">
                <h1 class="title" id="endTitle">Storm Over</h1>
                <span class="tag"><span class="dot red"></span><span id="endTag">Game Over</span></span>
              </div>
              <p class="subtitle" id="endSubtitle">Your umbrellas are gone. The city can breathe again—until the next downpour.</p>
            </div>
            <div class="grid2">
              <div class="list">
                <h3>Results</h3>
                <ul id="endStats"></ul>
              </div>
              <div class="list">
                <h3>Try Again</h3>
                <ul>
                  <li>Type the lowest words first to avoid sudden losses.</li>
                  <li>Use <span class="kbd">Esc</span> to reset your target when you drift.</li>
                  <li>Streaks help—focus on clean, steady typing.</li>
                </ul>
              </div>
            </div>
            <div class="footerRow">
              <div class="small">Press <span class="kbd">Enter</span> to restart.</div>
              <div class="btnRow">
                <button class="ghost" id="btnEndBack">Back to Menu</button>
                <button class="primary" id="btnEndRestart">Restart</button>
              </div>
            </div>
          </div>
        </div>

        <div class="overlay hidden" id="overlayPause">
          <div class="card">
            <div class="hero">
              <div class="titleRow">
                <h1 class="title">Paused</h1>
                <span class="tag"><span class="dot" style="background: rgba(238,247,255,0.8)"></span><span>Rain Held</span></span>
              </div>
              <p class="subtitle">Take a breath. When you're ready, press <span class="kbd">P</span> to continue.</p>
            </div>
            <div class="footerRow">
              <div class="small">Tip: the target glow follows your typed prefix.</div>
              <div class="btnRow">
                <button class="ghost" id="btnPauseMenu">Menu</button>
                <button class="primary" id="btnPauseResume">Resume</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById("scene");
        const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

        const elScore = document.getElementById("score");
        const elBest = document.getElementById("best");
        const elLevel = document.getElementById("level");
        const elPace = document.getElementById("pace");
        const elAcc = document.getElementById("acc");
        const elKeyStats = document.getElementById("keystats");
        const elLives = document.getElementById("lives");
        const elStreak = document.getElementById("streak");
        const elWpm = document.getElementById("wpm");
        const elDotState = document.getElementById("dotState");
        const elStateText = document.getElementById("stateText");
        const elHintText = document.getElementById("hintText");
        const elTargetWord = document.getElementById("targetWord");
        const elTargetMeta = document.getElementById("targetMeta");
        const elMicro = document.getElementById("micro");
        const elStatusRight = document.getElementById("statusRight");
        const typeBoxWrap = document.getElementById("typeBoxWrap");
        const typeBox = document.getElementById("typeBox");
        const toast = document.getElementById("toast");

        const overlayIntro = document.getElementById("overlayIntro");
        const overlayEnd = document.getElementById("overlayEnd");
        const overlayPause = document.getElementById("overlayPause");
        const endTitle = document.getElementById("endTitle");
        const endTag = document.getElementById("endTag");
        const endSubtitle = document.getElementById("endSubtitle");
        const endStats = document.getElementById("endStats");

        const btnStart = document.getElementById("btnStart");
        const btnPause = document.getElementById("btnPause");
        const btnReset = document.getElementById("btnReset");
        const btnSound = document.getElementById("btnSound");
        const btnFocus = document.getElementById("btnFocus");
        const btnIntroStart = document.getElementById("btnIntroStart");
        const btnIntroSound = document.getElementById("btnIntroSound");
        const btnEndRestart = document.getElementById("btnEndRestart");
        const btnEndBack = document.getElementById("btnEndBack");
        const btnPauseResume = document.getElementById("btnPauseResume");
        const btnPauseMenu = document.getElementById("btnPauseMenu");

        const prefersReducedMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

        const FONT_MONO = getComputedStyle(document.documentElement).getPropertyValue("--mono").trim();
        const FONT_SANS = getComputedStyle(document.documentElement).getPropertyValue("--sans").trim();

        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const fmt = (n) => n.toLocaleString(undefined, { maximumFractionDigits: 0 });
        const now = () => performance.now();

        function mulberry32(seed) {
          let t = seed >>> 0;
          return () => {
            t += 0x6d2b79f5;
            let x = Math.imul(t ^ (t >>> 15), 1 | t);
            x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
            return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
          };
        }

        const WORDS = (() => {
          const base = [
            "rain",
            "city",
            "neon",
            "storm",
            "street",
            "alley",
            "puddle",
            "skyline",
            "midnight",
            "thunder",
            "lightning",
            "umbrella",
            "traffic",
            "signal",
            "window",
            "glimmer",
            "horizon",
            "reflection",
            "drizzle",
            "downpour",
            "mist",
            "fog",
            "subway",
            "boulevard",
            "crosswalk",
            "lantern",
            "siren",
            "echo",
            "shadow",
            "cyber",
            "analog",
            "pulse",
            "static",
            "glow",
            "sprint",
            "focus",
            "rhythm",
            "flow",
            "vector",
            "matrix",
            "signal",
            "syntax",
            "compile",
            "runtime",
            "buffer",
            "thread",
            "shader",
            "pixel",
            "canvas",
            "cascade",
            "monsoon",
            "tempest",
            "barometer",
            "atmosphere",
            "electric",
            "frequency",
            "velocity",
            "momentum",
            "accuracy",
            "precision",
            "stability",
            "resonance",
            "afterglow",
            "chromatic",
            "luminous",
            "torrential",
            "perimeter",
            "skyscraper",
            "metropolis",
            "observatory",
            "constellation",
            "diffraction",
            "phosphorescent",
          ];
          // Ensure variety, avoid duplicates.
          const uniq = Array.from(new Set(base.map((w) => w.toLowerCase())));
          // Add some short connectors for early levels.
          const short = ["aura", "mint", "blue", "coil", "nova", "grid", "dusk", "wave", "hush", "rift", "spark", "stitch"];
          for (const w of short) uniq.push(w);
          return uniq;
        })();

        const state = {
          running: false,
          paused: false,
          gameOver: false,
          time: 0,
          lastTs: 0,
          citySeed: (Math.random() * 1e9) | 0,
          gameSeed: (Math.random() * 1e9) | 0,
          fxSeed: (Math.random() * 1e9) | 0,
          gameRng: mulberry32((Math.random() * 1e9) | 0),
          fxRng: mulberry32((Math.random() * 1e9) | 0),
          w: 0,
          h: 0,
          dpr: 1,
          cityBuffer: null,
          cityCtx: null,
          cityMeta: null,
          wind: 0,
          windGoal: 0,
          windTimer: 0,
          lightning: { active: false, alpha: 0, cooldown: 0 },
          rainStreaks: [],
          drops: [],
          particles: [],
          floaters: [],
          nextId: 1,
          typed: "",
          lockedId: null,
          keystrokes: 0,
          correctKeystrokes: 0,
          score: 0,
          best: 0,
          level: 1,
          streak: 0,
          maxStreak: 0,
          hits: 0,
          misses: 0,
          lives: 5,
          startedAt: 0,
          lastHitAt: 0,
          spawnT: 0,
          stormBias: 0,
          settings: {
            sound: false,
          },
          audio: {
            ctx: null,
            master: null,
            rain: null,
            enabled: false,
          },
          ui: {
            toastT: 0,
            toastText: "",
          },
        };

        function loadBest() {
          try {
            const v = Number(localStorage.getItem("typing-rain-best") || "0");
            if (Number.isFinite(v) && v > 0) state.best = Math.floor(v);
          } catch {}
        }
        function saveBest() {
          try {
            localStorage.setItem("typing-rain-best", String(state.best | 0));
          } catch {}
        }

        function setToast(text, ms = 1300) {
          state.ui.toastText = text;
          state.ui.toastT = ms / 1000;
          toast.textContent = text;
          toast.classList.add("show");
        }
        function clearToast() {
          toast.classList.remove("show");
        }

        function ensureAudio() {
          if (state.audio.ctx) return true;
          try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return false;
            const ac = new AudioContext();
            const master = ac.createGain();
            master.gain.value = 0.9;
            master.connect(ac.destination);
            state.audio.ctx = ac;
            state.audio.master = master;
            return true;
          } catch {
            return false;
          }
        }

        function playClick(freq = 440, dur = 0.06, gain = 0.12, type = "sine") {
          if (!state.settings.sound) return;
          if (!ensureAudio()) return;
          const ac = state.audio.ctx;
          if (ac.state === "suspended") ac.resume().catch(() => {});
          const o = ac.createOscillator();
          const g = ac.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = 0;
          o.connect(g);
          g.connect(state.audio.master);
          const t0 = ac.currentTime;
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
          o.start(t0);
          o.stop(t0 + dur + 0.01);
        }

        function setSound(on) {
          state.settings.sound = !!on;
          btnSound.textContent = `Sound: ${state.settings.sound ? "On" : "Off"}`;
          btnIntroSound.textContent = state.settings.sound ? "Sound: On" : "Sound: Off";
          if (state.settings.sound) setToast("Sound enabled");
          else setToast("Sound muted");
        }

        function randGame() {
          return state.gameRng();
        }
        function randFx() {
          return state.fxRng();
        }
        function choiceGame(arr) {
          return arr[(randGame() * arr.length) | 0];
        }

        function resize() {
          const rect = canvas.getBoundingClientRect();
          const dpr = clamp(window.devicePixelRatio || 1, 1, 2.25);
          state.dpr = dpr;
          state.w = Math.max(320, Math.floor(rect.width));
          state.h = Math.max(320, Math.floor(rect.height));
          canvas.width = Math.floor(state.w * dpr);
          canvas.height = Math.floor(state.h * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          buildCityBuffer();
          resetRainStreaks();
        }

        function buildCityBuffer() {
          const bw = Math.floor(state.w);
          const bh = Math.floor(state.h);
          const buffer = document.createElement("canvas");
          buffer.width = Math.floor(bw * state.dpr);
          buffer.height = Math.floor(bh * state.dpr);
          const bctx = buffer.getContext("2d");
          bctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);

          const horizon = Math.floor(bh * 0.62);
          const skyline = (layer, colorA, colorB, density) => {
            const rng = mulberry32(((state.citySeed + layer * 99991) ^ (bw * 31 + bh * 131)) >>> 0);
            const buildings = [];
            let x = -40;
            while (x < bw + 40) {
              const w = lerp(26, 84, Math.pow(rng(), 1.6));
              const h = lerp(70, 280, Math.pow(rng(), 0.9)) * density;
              const step = w * lerp(0.72, 1.05, rng());
              buildings.push({ x, w, h, top: horizon - h, seed: (rng() * 1e9) | 0 });
              x += step;
            }
            const grd = bctx.createLinearGradient(0, horizon - 320, 0, horizon + 60);
            grd.addColorStop(0, colorA);
            grd.addColorStop(1, colorB);
            bctx.fillStyle = grd;
            for (const b of buildings) {
              const r = 8 + layer * 2;
              roundRect(bctx, b.x, b.top, b.w, b.h + 60, r);
              bctx.fill();
              // Windows
              const wx = 4 + layer;
              const wy = 7 + layer;
              const cols = Math.max(1, Math.floor((b.w - 10) / (wx + 4)));
              const rows = Math.max(1, Math.floor((b.h - 14) / (wy + 6)));
              const wrng = mulberry32(b.seed);
              bctx.globalAlpha = 0.85;
              for (let ry = 0; ry < rows; ry++) {
                for (let cx = 0; cx < cols; cx++) {
                  const lit = wrng() < lerp(0.18, 0.05, layer / 3) ? 1 : 0;
                  if (!lit) continue;
                  const px = b.x + 6 + cx * (wx + 4);
                  const py = b.top + 10 + ry * (wy + 6);
                  const glow = lerp(0.2, 0.8, wrng());
                  bctx.fillStyle = `rgba(255, ${Math.floor(210 + 35 * wrng())}, ${Math.floor(160 + 50 * wrng())}, ${0.22 + 0.22 * glow})`;
                  bctx.fillRect(px, py, wx, wy);
                }
              }
              bctx.globalAlpha = 1;
            }
          };

          // Atmosphere layers: haze + far glow
          const skyGlow = bctx.createRadialGradient(bw * 0.55, horizon - 120, 0, bw * 0.55, horizon - 120, bw * 0.9);
          skyGlow.addColorStop(0, "rgba(100, 210, 255, 0.09)");
          skyGlow.addColorStop(1, "rgba(100, 210, 255, 0)");
          bctx.fillStyle = skyGlow;
          bctx.fillRect(0, 0, bw, bh);

          skyline(0, "rgba(20, 30, 65, 0.78)", "rgba(6, 8, 16, 0.9)", 0.62);
          skyline(1, "rgba(16, 26, 60, 0.86)", "rgba(5, 7, 14, 0.95)", 0.86);
          skyline(2, "rgba(12, 22, 52, 0.96)", "rgba(4, 5, 10, 1)", 1.05);

          // Street line
          bctx.fillStyle = "rgba(100, 210, 255, 0.08)";
          bctx.fillRect(0, horizon + 30, bw, 1);

          // Fog bank near horizon
          const fog = bctx.createLinearGradient(0, horizon - 40, 0, horizon + 160);
          fog.addColorStop(0, "rgba(200, 230, 255, 0)");
          fog.addColorStop(0.5, "rgba(200, 230, 255, 0.06)");
          fog.addColorStop(1, "rgba(200, 230, 255, 0)");
          bctx.fillStyle = fog;
          bctx.fillRect(0, horizon - 80, bw, 260);

          state.cityBuffer = buffer;
          state.cityCtx = bctx;
          state.cityMeta = { horizon };
        }

        function resetRainStreaks() {
          const count = prefersReducedMotion ? 90 : 220;
          state.rainStreaks = new Array(count).fill(0).map(() => ({
            x: randFx() * state.w,
            y: randFx() * state.h,
            l: lerp(10, 36, randFx()),
            v: lerp(520, 980, randFx()),
            a: lerp(0.05, 0.16, randFx()),
            w: lerp(0.8, 1.35, randFx()),
          }));
        }

        function roundRect(c, x, y, w, h, r) {
          const rr = Math.min(r, w / 2, h / 2);
          c.beginPath();
          c.moveTo(x + rr, y);
          c.arcTo(x + w, y, x + w, y + h, rr);
          c.arcTo(x + w, y + h, x, y + h, rr);
          c.arcTo(x, y + h, x, y, rr);
          c.arcTo(x, y, x + w, y, rr);
          c.closePath();
        }

        function computeLevel() {
          if (!state.running) return 1;
          const elapsed = Math.max(0, (now() - state.startedAt) / 1000);
          // Time-based leveling keeps pressure consistent; score adds a small bump.
          const byTime = 1 + Math.floor(elapsed / 18);
          const byScore = 1 + Math.floor(state.score / 1400);
          return clamp(Math.max(byTime, byScore), 1, 20);
        }

        function difficultyParams(level) {
          const t = clamp((level - 1) / 16, 0, 1);
          const spawn = lerp(1.25, 0.38, Math.pow(t, 0.75));
          const speed = lerp(110, 340, Math.pow(t, 0.85));
          const max = Math.floor(lerp(12, 26, Math.pow(t, 0.9)));
          const lenMin = Math.floor(lerp(3, 5, t));
          const lenMax = Math.floor(lerp(6, 14, Math.pow(t, 0.85)));
          const wind = lerp(0.05, 0.22, t);
          return { spawn, speed, max, lenMin, lenMax, wind };
        }

        function pickWord(level) {
          const { lenMin, lenMax } = difficultyParams(level);
          // Weighted pick by length window + occasional long word.
          const wantLong = randGame() < clamp((level - 1) / 22, 0, 0.24);
          const min = wantLong ? Math.max(8, lenMin) : lenMin;
          const max = wantLong ? Math.max(10, lenMax + 4) : lenMax;
          const candidates = WORDS.filter((w) => w.length >= min && w.length <= max);
          if (candidates.length) return choiceGame(candidates);
          return choiceGame(WORDS);
        }

        function spawnDrop() {
          const { speed } = difficultyParams(state.level);
          const margin = 42;
          const x = lerp(margin, state.w - margin, Math.pow(randGame(), 0.85));
          const y = -30 - randGame() * 60;
          const vy = speed * lerp(0.75, 1.35, Math.pow(randGame(), 1.2));
          const word = pickWord(state.level);
          const hue = lerp(190, 208, randGame()) + (randGame() < 0.08 ? lerp(-25, 35, randGame()) : 0);
          const kind = randGame() < clamp(0.02 + state.level * 0.003, 0.02, 0.08) ? "bonus" : "normal";
          state.drops.push({
            id: state.nextId++,
            word,
            x,
            y,
            vy,
            sway: lerp(-1, 1, randGame()) * lerp(10, 32, randGame()),
            wobble: randGame() * Math.PI * 2,
            wobbleSpeed: lerp(1.05, 2.25, Math.pow(randGame(), 0.6)),
            hue,
            kind,
            t: 0,
            alive: true,
          });
        }

        function spawnSplash(x, y, hue, power = 1) {
          const n = Math.floor(lerp(10, 22, randFx()) * power);
          for (let i = 0; i < n; i++) {
            const a = randFx() * Math.PI * 2;
            const s = lerp(90, 280, Math.pow(randFx(), 0.55)) * power;
            state.particles.push({
              x,
              y,
              vx: Math.cos(a) * s,
              vy: Math.sin(a) * s * 0.8 - lerp(30, 130, randFx()) * power,
              r: lerp(1.2, 2.8, randFx()) * (0.85 + 0.3 * randFx()),
              life: lerp(0.35, 0.75, randFx()),
              t: 0,
              hue,
            });
          }
        }

        function spawnFloater(text, x, y, color = "rgba(100,210,255,0.9)") {
          state.floaters.push({
            text,
            x,
            y,
            vy: -lerp(35, 70, randFx()),
            life: 0.9,
            t: 0,
            color,
          });
        }

        function normalizeInput(s) {
          return s.trim().toLowerCase();
        }

        function findTarget(typed) {
          const t = normalizeInput(typed);
          if (!t) return null;

          const locked = state.lockedId ? state.drops.find((d) => d.id === state.lockedId) : null;
          if (locked && locked.alive && locked.word.startsWith(t)) return locked;

          // Find best match: closest to bottom with matching prefix.
          let best = null;
          let bestScore = -Infinity;
          for (const d of state.drops) {
            if (!d.alive) continue;
            if (!d.word.startsWith(t)) continue;
            const urgency = d.y / Math.max(1, state.h);
            const bonus = d.kind === "bonus" ? 0.12 : 0;
            const tie = (d.id % 13) * 0.0001;
            const score = urgency + bonus + tie;
            if (score > bestScore) {
              bestScore = score;
              best = d;
            }
          }
          if (best) state.lockedId = best.id;
          return best;
        }

        function tryCompleteWord() {
          const t = normalizeInput(state.typed);
          if (!t) return false;
          const target = findTarget(state.typed);
          if (target && target.word === t) {
            hitDrop(target);
            state.typed = "";
            state.lockedId = null;
            typeBox.value = "";
            return true;
          }
          // If exact match exists among any drop, allow it even without being current target.
          const any = state.drops.find((d) => d.alive && d.word === t);
          if (any) {
            hitDrop(any);
            state.typed = "";
            state.lockedId = null;
            typeBox.value = "";
            return true;
          }
          return false;
        }

        function hitDrop(drop) {
          drop.alive = false;
          const base = drop.word.length * 12;
          const levelMul = 1 + (state.level - 1) * 0.11;
          const urgencyMul = 1 + clamp(drop.y / state.h, 0, 1) * 0.65;
          const streakMul = 1 + clamp(state.streak / 18, 0, 1) * 0.45;
          const bonusMul = drop.kind === "bonus" ? 1.55 : 1;
          const gained = Math.round(base * levelMul * urgencyMul * streakMul * bonusMul);
          state.score += gained;
          state.hits += 1;
          state.streak += 1;
          state.maxStreak = Math.max(state.maxStreak, state.streak);
          state.lastHitAt = now();
          state.stormBias = clamp(state.stormBias + 0.12, 0, 1);

          const hue = drop.kind === "bonus" ? 48 : drop.hue;
          spawnSplash(drop.x, Math.min(state.h - 60, drop.y + 16), hue, drop.kind === "bonus" ? 1.35 : 1);
          spawnFloater(`+${gained}`, drop.x, drop.y - 6, drop.kind === "bonus" ? "rgba(251,191,36,0.95)" : "rgba(100,210,255,0.92)");
          if (drop.kind === "bonus") setToast("Bonus drop!");

          playClick(drop.kind === "bonus" ? 820 : 640, drop.kind === "bonus" ? 0.08 : 0.06, drop.kind === "bonus" ? 0.16 : 0.11, "triangle");
        }

        function missDrop(drop) {
          drop.alive = false;
          state.misses += 1;
          state.lives -= 1;
          state.streak = 0;
          state.stormBias = clamp(state.stormBias - 0.22, 0, 1);
          spawnSplash(drop.x, state.h - 44, 355, 1.25);
          spawnFloater("miss", drop.x, state.h - 66, "rgba(251,113,133,0.9)");
          playClick(170, 0.09, 0.11, "sawtooth");
        }

        function resetGame(keepMenu = false) {
          state.running = false;
          state.paused = false;
          state.gameOver = false;
          state.time = 0;
          state.lastTs = 0;
          state.drops.length = 0;
          state.particles.length = 0;
          state.floaters.length = 0;
          state.nextId = 1;
          state.typed = "";
          state.lockedId = null;
          state.keystrokes = 0;
          state.correctKeystrokes = 0;
          state.score = 0;
          state.level = 1;
          state.streak = 0;
          state.maxStreak = 0;
          state.hits = 0;
          state.misses = 0;
          state.lives = 5;
          state.startedAt = 0;
          state.lastHitAt = 0;
          state.spawnT = 0;
          state.stormBias = 0;
          state.wind = 0;
          state.windGoal = 0;
          state.windTimer = 0;
          state.lightning.active = false;
          state.lightning.alpha = 0;
          state.lightning.cooldown = 0;
          typeBox.value = "";
          btnPause.textContent = "Pause P";
          overlayPause.classList.add("hidden");
          overlayEnd.classList.add("hidden");
          if (keepMenu) overlayIntro.classList.remove("hidden");
          updateUI(true);
        }

        function startGame() {
          resetGame(false);
          overlayIntro.classList.add("hidden");
          overlayEnd.classList.add("hidden");
          overlayPause.classList.add("hidden");
          state.running = true;
          state.paused = false;
          state.gameOver = false;
          state.startedAt = now();
          state.lastTs = now();
          state.citySeed = (Math.random() * 1e9) | 0;
          state.gameSeed = (Math.random() * 1e9) | 0;
          state.fxSeed = (Math.random() * 1e9) | 0;
          state.gameRng = mulberry32(state.gameSeed);
          state.fxRng = mulberry32(state.fxSeed);
          buildCityBuffer();
          resetRainStreaks();
          state.wind = lerp(-1, 1, randGame()) * 0.3;
          state.windGoal = state.wind;
          state.windTimer = lerp(0.8, 1.6, randGame());
          // Warm start: a few drops right away
          const warm = prefersReducedMotion ? 4 : 6;
          for (let i = 0; i < warm; i++) spawnDrop();
          setToast("Storm started");
          focusInput();
          updateUI(true);
        }

        function pauseGame(on) {
          if (!state.running || state.gameOver) return;
          state.paused = !!on;
          overlayPause.classList.toggle("hidden", !state.paused);
          btnPause.textContent = state.paused ? "Resume P" : "Pause P";
          if (state.paused) {
            elDotState.classList.remove("green");
            elDotState.classList.add("red");
            elStateText.textContent = "Paused";
            elStatusRight.textContent = "Press P to resume";
          } else {
            elDotState.classList.remove("red");
            elDotState.classList.add("green");
            elStateText.textContent = "Live";
            elStatusRight.textContent = "Type to clear the rain";
            focusInput();
            state.lastTs = now();
          }
        }

        function endGame(reason = "Game Over") {
          state.running = false;
          state.paused = false;
          state.gameOver = true;
          overlayPause.classList.add("hidden");
          overlayEnd.classList.remove("hidden");
          elDotState.classList.remove("green");
          elDotState.classList.add("red");
          elStateText.textContent = "Ended";
          endTitle.textContent = "Storm Over";
          endTag.textContent = reason;
          endSubtitle.textContent = "Your umbrellas are gone. The city can breathe again—until the next downpour.";
          const elapsed = Math.max(1, (now() - state.startedAt) / 1000);
          const wpm = computeWpm(elapsed);
          const acc = computeAcc();
          const lines = [
            `Score: ${fmt(state.score)} (Best ${fmt(state.best)})`,
            `Level reached: ${state.level}`,
            `Accuracy: ${(acc * 100).toFixed(0)}% (${state.correctKeystrokes} / ${state.keystrokes})`,
            `Hits / Misses: ${state.hits} / ${state.misses}`,
            `Speed: ${wpm} WPM over ${elapsed.toFixed(0)}s`,
            `Longest streak: ${state.maxStreak}`,
          ];
          endStats.innerHTML = lines.map((s) => `<li>${escapeHtml(s)}</li>`).join("");
          setToast("Press Enter to restart");
          updateUI(true);
        }

        function escapeHtml(s) {
          return String(s).replace(/[&<>"]/g, (ch) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" }[ch]));
        }

        function computeAcc() {
          if (state.keystrokes <= 0) return 1;
          return clamp(state.correctKeystrokes / Math.max(1, state.keystrokes), 0, 1);
        }
        function computeWpm(elapsedSeconds) {
          const words = state.correctKeystrokes / 5;
          const minutes = Math.max(0.1, elapsedSeconds / 60);
          return Math.max(0, Math.round(words / minutes));
        }

        function focusInput() {
          typeBox.focus({ preventScroll: true });
          // Ensure caret at end (for some browsers if user clicks around)
          const v = typeBox.value;
          typeBox.setSelectionRange(v.length, v.length);
        }

        function onBadKey() {
          typeBoxWrap.classList.remove("shake");
          void typeBoxWrap.offsetWidth;
          typeBoxWrap.classList.add("shake");
        }

        function recordKey(char) {
          if (!char || char.length !== 1) return;
          state.keystrokes += 1;
          const t = normalizeInput(state.typed);
          const target = findTarget(state.typed);
          if (target) {
            const idx = t.length - 1;
            if (idx >= 0 && idx < target.word.length && target.word[idx] === char.toLowerCase()) state.correctKeystrokes += 1;
          }
        }

        function handleKeydown(e) {
          // Don't steal shortcuts.
          if (e.metaKey || e.ctrlKey || e.altKey) return;

          if (e.key === "Enter") {
            e.preventDefault();
            if (!state.running && !state.paused && overlayIntro && !overlayIntro.classList.contains("hidden")) startGame();
            else if (state.gameOver) startGame();
            else if (state.paused) pauseGame(false);
            else {
              // Optional commit
              const completed = tryCompleteWord();
              if (!completed && state.typed.trim()) onBadKey();
              state.typed = "";
              state.lockedId = null;
              typeBox.value = "";
              updateUI(false);
            }
            return;
          }
          if (e.key === " ") {
            // Optional commit
            if (!state.running) return;
            e.preventDefault();
            const completed = tryCompleteWord();
            if (!completed && state.typed.trim()) onBadKey();
            state.typed = "";
            state.lockedId = null;
            typeBox.value = "";
            updateUI(false);
            return;
          }
          if (e.key === "Escape") {
            e.preventDefault();
            state.typed = "";
            state.lockedId = null;
            typeBox.value = "";
            setToast("Cleared");
            updateUI(false);
            return;
          }
          if (e.key.toLowerCase() === "p") {
            // Toggle pause
            if (!state.running && !state.gameOver) return;
            e.preventDefault();
            if (state.gameOver) return;
            pauseGame(!state.paused);
            return;
          }
          if (e.key === "Backspace") {
            e.preventDefault();
            if (!state.running) {
              typeBox.value = "";
              state.typed = "";
              state.lockedId = null;
              updateUI(false);
              return;
            }
            state.typed = state.typed.slice(0, -1);
            typeBox.value = state.typed;
            if (!normalizeInput(state.typed)) state.lockedId = null;
            updateUI(false);
            return;
          }

          // Printable character input.
          if (e.key.length === 1) {
            // Avoid weird whitespace and keep words friendly.
            if (/\s/.test(e.key)) return;
            e.preventDefault();
            if (!state.running || state.paused || state.gameOver) return;

            const next = (state.typed + e.key).slice(0, 28);
            state.typed = next;
            typeBox.value = next;
            recordKey(e.key);

            // If typed stops matching any prefix, gently reject (but still allow if user wants to continue).
            const t = normalizeInput(next);
            const anyPrefix = state.drops.some((d) => d.alive && d.word.startsWith(t));
            if (!anyPrefix && t.length >= 2) {
              onBadKey();
              state.stormBias = clamp(state.stormBias - 0.035, 0, 1);
            }

            // Auto-complete on exact match.
            const completed = tryCompleteWord();
            if (completed) {
              // Small reward for clean finishes.
              state.correctKeystrokes = Math.min(state.correctKeystrokes + 0, state.keystrokes);
            }
            updateUI(false);
            return;
          }
        }

        function updateUI(force) {
          // Compute derived values
          const acc = computeAcc();
          const spawn = difficultyParams(state.level).spawn;
          elScore.textContent = fmt(state.score);
          elBest.textContent = `Best ${fmt(state.best)}`;
          elLevel.textContent = String(state.level);
          elPace.textContent = `Spawn ${spawn.toFixed(2)}s`;
          elAcc.textContent = `${Math.round(acc * 100)}%`;
          elKeyStats.textContent = `${state.correctKeystrokes} / ${state.keystrokes}`;
          elLives.textContent = "☂".repeat(Math.max(0, state.lives)) || "—";
          elStreak.textContent = `Streak ${state.streak}`;
          elMicro.textContent = `${state.hits} hits • ${state.misses} misses`;

          const elapsed = state.running ? Math.max(1, (now() - state.startedAt) / 1000) : 1;
          elWpm.textContent = `${computeWpm(elapsed)} WPM`;

          if (!state.running && !state.gameOver && !state.paused) {
            elDotState.classList.remove("red");
            elDotState.classList.add("green");
            elStateText.textContent = "Ready";
            elHintText.textContent = "Type the falling words";
          }
          if (state.running && !state.paused) {
            elDotState.classList.remove("red");
            elDotState.classList.add("green");
            elStateText.textContent = "Live";
            const t = normalizeInput(state.typed);
            if (!t) elHintText.textContent = "Catch the lowest drops first";
            else elHintText.textContent = "Finish the target to score";
          }

          const target = findTarget(state.typed);
          if (target) {
            elTargetWord.textContent = target.word;
            const dist = Math.max(0, Math.round(((state.h - 60) - target.y) / 10));
            elTargetMeta.textContent = `· ${target.kind === "bonus" ? "bonus" : "drop"} · ${dist}m`;
          } else {
            elTargetWord.textContent = "—";
            elTargetMeta.textContent = "";
          }
        }

        function tick(ts) {
          requestAnimationFrame(tick);
          if (!state.lastTs) state.lastTs = ts;
          const dt = clamp((ts - state.lastTs) / 1000, 0, 0.04);
          state.lastTs = ts;

          // Toast timer
          if (state.ui.toastT > 0) {
            state.ui.toastT -= dt;
            if (state.ui.toastT <= 0) clearToast();
          }

          // Always render ambience
          if (!state.running || state.paused || state.gameOver) {
            state.time += dt * 0.45;
            render(dt, false);
            return;
          }

          state.time += dt;
          state.level = computeLevel();
          const dif = difficultyParams(state.level);

          // Wind evolves with storm bias (higher when you do well).
          state.windTimer = Math.max(0, state.windTimer - dt);
          if (state.windTimer <= 0) {
            state.windGoal = (randGame() - 0.5) * dif.wind * (0.55 + 0.75 * state.stormBias);
            state.windTimer = lerp(0.9, 1.7, randGame());
          }
          state.wind = lerp(state.wind, state.windGoal, 0.07);

          // Lightning: triggers rarely, more often as level rises.
          state.lightning.cooldown = Math.max(0, state.lightning.cooldown - dt);
          if (state.lightning.cooldown <= 0) {
            const p = dt * (0.012 + state.level * 0.0012) * (0.45 + state.stormBias);
            if (!prefersReducedMotion && randFx() < p) {
              state.lightning.active = true;
              state.lightning.alpha = lerp(0.28, 0.62, randFx());
              state.lightning.cooldown = lerp(4.2, 9.5, randFx());
            }
          }
          if (state.lightning.active) {
            state.lightning.alpha = Math.max(0, state.lightning.alpha - dt * 0.9);
            if (state.lightning.alpha <= 0) state.lightning.active = false;
          }

          // Spawning
          state.spawnT += dt;
          const spawnInterval = dif.spawn * lerp(1, 0.86, state.stormBias);
          while (state.spawnT >= spawnInterval) {
            state.spawnT -= spawnInterval;
            if (state.drops.filter((d) => d.alive).length < dif.max) spawnDrop();
          }

          // Update drops
          const ground = state.h - 58;
          for (const d of state.drops) {
            if (!d.alive) continue;
            d.t += dt;
            d.wobble += dt * (d.wobbleSpeed || 1.4);
            const sway = Math.sin(d.wobble) * d.sway;
            d.x += (state.wind * 140 + sway * 0.4) * dt;
            d.y += d.vy * dt;

            // Keep within bounds softly
            if (d.x < 22) d.x = 22, (d.sway *= -0.85);
            if (d.x > state.w - 22) d.x = state.w - 22, (d.sway *= -0.85);

            if (d.y >= ground) {
              missDrop(d);
              if (state.lives <= 0) {
                if (state.score > state.best) {
                  state.best = state.score;
                  saveBest();
                }
                endGame("Umbrellas lost");
              }
            }
          }

          // Cleanup dead drops
          if (state.drops.length > 120) state.drops = state.drops.filter((d) => d.alive);

          // Update particles
          for (const p of state.particles) {
            p.t += dt;
            const k = p.t / p.life;
            p.vy += 520 * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= Math.pow(0.42, dt);
            p.vy *= Math.pow(0.42, dt);
            p.alpha = 1 - k;
          }
          state.particles = state.particles.filter((p) => p.t < p.life);

          // Update floaters
          for (const f of state.floaters) {
            f.t += dt;
            f.y += f.vy * dt;
            f.vy *= Math.pow(0.8, dt);
          }
          state.floaters = state.floaters.filter((f) => f.t < f.life);

          // Storm bias decays slowly if you stop hitting words
          const sinceHit = (now() - state.lastHitAt) / 1000;
          if (sinceHit > 1.8) state.stormBias = clamp(state.stormBias - dt * 0.05, 0, 1);

          render(dt, true);
          updateUI(false);
        }

        function render(dt, isLive) {
          const w = state.w;
          const h = state.h;
          const horizon = state.cityMeta?.horizon ?? Math.floor(h * 0.62);
          const t = state.time;

          // Sky gradient
          const sky = ctx.createLinearGradient(0, 0, 0, h);
          const storm = isLive ? clamp(0.15 + state.level * 0.02 + state.stormBias * 0.22, 0, 0.6) : 0.18;
          sky.addColorStop(0, `rgba(${Math.floor(8 + 6 * storm)}, ${Math.floor(10 + 10 * storm)}, ${Math.floor(22 + 40 * storm)}, 1)`);
          sky.addColorStop(0.6, `rgba(${Math.floor(6 + 8 * storm)}, ${Math.floor(7 + 9 * storm)}, ${Math.floor(16 + 26 * storm)}, 1)`);
          sky.addColorStop(1, "rgba(4,4,9,1)");
          ctx.fillStyle = sky;
          ctx.fillRect(0, 0, w, h);

          // Subtle drifting clouds (noise-ish blobs)
          if (!prefersReducedMotion) {
            const cx = (Math.sin(t * 0.12) * 0.5 + 0.5) * w;
            const cy = h * 0.22 + Math.cos(t * 0.08) * 14;
            const cloud = ctx.createRadialGradient(cx, cy, 0, cx, cy, w * 0.9);
            cloud.addColorStop(0, "rgba(120, 190, 255, 0.06)");
            cloud.addColorStop(1, "rgba(120, 190, 255, 0)");
            ctx.fillStyle = cloud;
            ctx.fillRect(0, 0, w, h);
          }

          // City silhouette buffer
          if (state.cityBuffer) {
            ctx.globalAlpha = 1;
            ctx.drawImage(state.cityBuffer, 0, 0, w, h);
          }

          // Reflection strip near ground
          const groundY = h - 62;
          const refl = ctx.createLinearGradient(0, groundY - 60, 0, groundY + 140);
          refl.addColorStop(0, "rgba(100, 210, 255, 0.0)");
          refl.addColorStop(0.3, "rgba(100, 210, 255, 0.08)");
          refl.addColorStop(1, "rgba(0, 0, 0, 0.0)");
          ctx.fillStyle = refl;
          ctx.fillRect(0, groundY - 80, w, 220);

          // Ambient rain streaks
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          ctx.lineCap = "round";
          const angle = -Math.PI / 2 + state.wind * 0.18;
          const dx = Math.cos(angle);
          const dy = Math.sin(angle);
          for (const s of state.rainStreaks) {
            s.y += s.v * dt * (isLive ? 1 : 0.65);
            s.x += (state.wind * 240 + 40 * Math.sin(t * 0.9 + s.x * 0.01)) * dt;
            if (s.y > h + 60) {
              s.y = -60;
              s.x = randFx() * w;
            }
            if (s.x < -80) s.x = w + 80;
            if (s.x > w + 80) s.x = -80;
            ctx.strokeStyle = `rgba(170, 220, 255, ${s.a * (0.7 + 0.6 * (isLive ? state.stormBias : 0.2))})`;
            ctx.lineWidth = s.w;
            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(s.x + dx * s.l, s.y + dy * s.l);
            ctx.stroke();
          }
          ctx.restore();

          // Lightning flash
          if (!prefersReducedMotion && state.lightning.alpha > 0) {
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            ctx.fillStyle = `rgba(220, 245, 255, ${state.lightning.alpha})`;
            ctx.fillRect(0, 0, w, h);
            drawBolt(ctx, w, h, horizon, t);
            ctx.restore();
          }

          // Word drops (as raindrops)
          drawDrops(ctx, w, h);

          // Splashes
          drawParticles(ctx);

          // Floating texts
          drawFloaters(ctx);

          // Ground line
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          ctx.fillRect(0, groundY + 20, w, h - (groundY + 20));
          ctx.strokeStyle = "rgba(100,210,255,0.12)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, groundY + 10);
          ctx.lineTo(w, groundY + 10);
          ctx.stroke();
          ctx.restore();
        }

        function drawBolt(c, w, h, horizon, t) {
          // Stylized lightning bolt
          const startX = lerp(w * 0.2, w * 0.8, randFx());
          const startY = lerp(20, horizon - 170, randFx());
          let x = startX;
          let y = startY;
          const segs = 18;
          c.save();
          c.globalAlpha = clamp(state.lightning.alpha * 0.95, 0, 1);
          c.lineWidth = 2;
          c.strokeStyle = "rgba(245, 255, 255, 0.85)";
          c.shadowBlur = 18;
          c.shadowColor = "rgba(180, 240, 255, 0.8)";
          c.beginPath();
          c.moveTo(x, y);
          for (let i = 0; i < segs; i++) {
            const step = lerp(12, 28, randFx());
            x += lerp(-42, 42, randFx());
            y += step + lerp(6, 16, randFx());
            if (y > horizon + 40) break;
            c.lineTo(x, y);
            // Branch
            if (randFx() < 0.12) {
              const bx = x + lerp(-50, 50, randFx());
              const by = y + lerp(18, 48, randFx());
              c.moveTo(x, y);
              c.lineTo(bx, by);
              c.moveTo(x, y);
            }
          }
          c.stroke();
          c.restore();
        }

        function drawDrops(c, w, h) {
          const typed = normalizeInput(state.typed);
          const target = findTarget(state.typed);

          // Sort: draw far first, urgent last
          const live = state.drops.filter((d) => d.alive);
          live.sort((a, b) => a.y - b.y);

          c.save();
          c.textAlign = "center";
          c.textBaseline = "middle";
          const fontSize = clamp(18 + state.level * 0.5, 18, 28);
          c.font = `700 ${fontSize}px ${FONT_MONO}`;

          for (const d of live) {
            const isTarget = target && d.id === target.id;
            const urgency = clamp(d.y / h, 0, 1);
            const alpha = clamp(0.68 + urgency * 0.35, 0, 1);
            const hue = d.kind === "bonus" ? 48 : d.hue;

            // Drop glow
            c.save();
            c.globalAlpha = alpha;
            c.globalCompositeOperation = "lighter";

            const r = clamp(18 + d.word.length * 1.35, 18, 34);
            const glow = c.createRadialGradient(d.x, d.y, 0, d.x, d.y, r * 2.3);
            const glowA = isTarget ? 0.22 : 0.12;
            const glowB = isTarget ? 0.04 : 0.02;
            glow.addColorStop(0, `hsla(${hue}, 95%, 72%, ${glowA})`);
            glow.addColorStop(0.4, `hsla(${hue}, 95%, 62%, ${glowB})`);
            glow.addColorStop(1, `hsla(${hue}, 95%, 50%, 0)`);
            c.fillStyle = glow;
            c.beginPath();
            c.arc(d.x, d.y, r * 2.2, 0, Math.PI * 2);
            c.fill();
            c.restore();

            // Drop body behind text
            c.save();
            c.globalAlpha = alpha * (isTarget ? 0.95 : 0.82);
            const body = c.createRadialGradient(d.x - 6, d.y - 8, 0, d.x, d.y, r * 1.25);
            body.addColorStop(0, `hsla(${hue}, 95%, ${d.kind === "bonus" ? 70 : 62}%, 0.55)`);
            body.addColorStop(1, `hsla(${hue}, 95%, ${d.kind === "bonus" ? 48 : 44}%, 0.16)`);
            c.fillStyle = body;
            c.beginPath();
            c.ellipse(d.x, d.y, r * 1.25, r * 0.92, 0, 0, Math.PI * 2);
            c.fill();
            c.restore();

            // Text shadow
            c.save();
            c.globalAlpha = alpha;
            c.shadowBlur = isTarget ? 18 : 10;
            c.shadowColor = `hsla(${hue}, 95%, 70%, ${isTarget ? 0.75 : 0.55})`;

            const prefix = typed && isTarget ? typed : "";
            if (prefix) {
              const remaining = d.word.slice(prefix.length);
              const fullW = c.measureText(d.word).width;
              const preW = c.measureText(prefix).width;
              const remW = fullW - preW;
              const leftX = d.x - fullW / 2;
              // typed part
              c.fillStyle = "rgba(255, 255, 255, 0.95)";
              c.textAlign = "left";
              c.fillText(prefix, leftX, d.y);
              // remaining part
              c.fillStyle = d.kind === "bonus" ? "rgba(255, 230, 170, 0.92)" : "rgba(190, 230, 255, 0.78)";
              c.fillText(remaining, leftX + preW, d.y);
              // underline
              c.globalAlpha *= 0.8;
              c.strokeStyle = d.kind === "bonus" ? "rgba(251,191,36,0.5)" : "rgba(100,210,255,0.45)";
              c.lineWidth = 2;
              c.beginPath();
              c.moveTo(leftX, d.y + fontSize * 0.55);
              c.lineTo(leftX + preW + Math.max(0, remW * 0.25), d.y + fontSize * 0.55);
              c.stroke();
              c.textAlign = "center";
            } else {
              c.fillStyle = isTarget ? "rgba(255,255,255,0.96)" : "rgba(225,245,255,0.88)";
              c.fillText(d.word, d.x, d.y);
              if (d.kind === "bonus") {
                c.globalAlpha *= 0.75;
                c.fillStyle = "rgba(251,191,36,0.9)";
                c.font = `800 ${Math.max(11, fontSize - 9)}px ${FONT_SANS}`;
                c.fillText("BONUS", d.x, d.y - fontSize * 1.05);
                c.font = `700 ${fontSize}px ${FONT_MONO}`;
              }
            }
            c.restore();

            // Tiny droplet tail
            c.save();
            c.globalAlpha = alpha * 0.65;
            c.strokeStyle = `hsla(${hue}, 95%, 70%, 0.25)`;
            c.lineWidth = 2;
            c.beginPath();
            c.moveTo(d.x, d.y - 26);
            c.lineTo(d.x + state.wind * 12, d.y - 54);
            c.stroke();
            c.restore();
          }
          c.restore();
        }

        function drawParticles(c) {
          if (!state.particles.length) return;
          c.save();
          c.globalCompositeOperation = "lighter";
          for (const p of state.particles) {
            const a = clamp(p.alpha ?? 1, 0, 1);
            if (a <= 0) continue;
            c.fillStyle = `hsla(${p.hue}, 95%, 72%, ${a * 0.55})`;
            c.beginPath();
            c.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            c.fill();
          }
          c.restore();
        }

        function drawFloaters(c) {
          if (!state.floaters.length) return;
          c.save();
          c.textAlign = "center";
          c.textBaseline = "middle";
          c.font = `800 14px ${FONT_MONO}`;
          for (const f of state.floaters) {
            const k = clamp(f.t / f.life, 0, 1);
            const a = (1 - k) * (1 - k);
            c.globalAlpha = a;
            c.fillStyle = f.color;
            c.shadowBlur = 14;
            c.shadowColor = f.color;
            c.fillText(f.text, f.x, f.y);
          }
          c.restore();
        }

        function wireUI() {
          btnStart.addEventListener("click", () => startGame());
          btnIntroStart.addEventListener("click", () => startGame());
          btnEndRestart.addEventListener("click", () => startGame());
          btnPauseResume.addEventListener("click", () => pauseGame(false));
          btnPauseMenu.addEventListener("click", () => resetGame(true));
          btnEndBack.addEventListener("click", () => resetGame(true));

          btnPause.addEventListener("click", () => {
            if (!state.running || state.gameOver) return;
            pauseGame(!state.paused);
          });

          btnReset.addEventListener("click", () => {
            if (state.running || state.gameOver) resetGame(true);
            else resetGame(true);
            setToast("Reset");
          });

          btnSound.addEventListener("click", () => setSound(!state.settings.sound));
          btnIntroSound.addEventListener("click", () => setSound(!state.settings.sound));

          btnFocus.addEventListener("click", () => focusInput());

          // Clicking anywhere refocuses input.
          canvas.addEventListener("pointerdown", () => focusInput(), { passive: true });
          document.getElementById("app").addEventListener("pointerdown", (e) => {
            if (e.target === canvas) return;
            // Keep input focus when interacting with HUD.
            setTimeout(() => focusInput(), 0);
          });

          // Prevent direct edits to the input value that bypass our logic.
          typeBox.addEventListener("input", (e) => {
            // If user pastes, allow but sanitize and immediately attempt completion.
            const v = String(typeBox.value || "");
            if (v !== state.typed) {
              state.typed = v.slice(0, 28);
              typeBox.value = state.typed;
              tryCompleteWord();
              updateUI(false);
            }
          });
        }

        function boot() {
          loadBest();
          elBest.textContent = `Best ${fmt(state.best)}`;
          setSound(false);
          resize();
          wireUI();
          updateUI(true);
          focusInput();
          requestAnimationFrame(tick);

          window.addEventListener("resize", resize, { passive: true });
          window.addEventListener("keydown", handleKeydown, { passive: false });

          // Helpful status text for focus loss.
          typeBox.addEventListener("blur", () => {
            elStatusRight.textContent = "Click the scene to refocus";
          });
          typeBox.addEventListener("focus", () => {
            elStatusRight.textContent = state.paused ? "Press P to resume" : "Type to clear the rain";
          });

          // Allow Enter to start from intro even if focus isn't in input.
          document.addEventListener("visibilitychange", () => {
            if (document.hidden && state.running && !state.gameOver) pauseGame(true);
          });

          // Initial hints
          elHintText.textContent = "Type the falling words";
          elStateText.textContent = "Ready";
          elDotState.classList.add("green");
        }

        boot();
      })();
    </script>
  </body>
</html>
