<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark" />
    <title>Webcam Filter Playground</title>
    <style>
      :root {
        --bg0: #05060a;
        --bg1: #0b1020;
        --fg: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.62);
        --hair: rgba(255, 255, 255, 0.12);
        --panel: rgba(10, 12, 18, 0.52);
        --panel2: rgba(20, 24, 34, 0.62);
        --shadow: rgba(0, 0, 0, 0.45);
        --accent: #7c3aed;
        --accent2: #22d3ee;
        --ok: #34d399;
        --warn: #fbbf24;
        --bad: #fb7185;
        --radius: 18px;
        --radius-sm: 12px;
        --ring: 0 0 0 1px rgba(255, 255, 255, 0.16) inset, 0 20px 60px rgba(0, 0, 0, 0.45);
        --blur: blur(12px);
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: radial-gradient(1200px 800px at 20% 10%, rgba(124, 58, 237, 0.25), transparent 60%),
          radial-gradient(1000px 700px at 80% 20%, rgba(34, 211, 238, 0.18), transparent 55%),
          radial-gradient(900px 600px at 50% 100%, rgba(251, 113, 133, 0.13), transparent 60%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        color: var(--fg);
        font-family: var(--sans);
        overflow: hidden;
      }

      .app {
        height: 100%;
        display: grid;
        grid-template-rows: auto 1fr auto;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 16px;
      }

      .brand {
        display: inline-flex;
        gap: 10px;
        align-items: center;
        user-select: none;
      }
      .logo {
        width: 30px;
        height: 30px;
        border-radius: 10px;
        background: conic-gradient(from 210deg, var(--accent), var(--accent2), #fb7185, var(--accent));
        box-shadow: 0 12px 34px rgba(0, 0, 0, 0.35);
        position: relative;
      }
      .logo::after {
        content: "";
        position: absolute;
        inset: 2px;
        border-radius: 9px;
        background: rgba(0, 0, 0, 0.26);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.12) inset;
      }
      .brand h1 {
        font-size: 14px;
        margin: 0;
        letter-spacing: 0.2px;
        font-weight: 650;
      }
      .brand .sub {
        font-size: 12px;
        color: var(--muted);
        margin-top: 1px;
        letter-spacing: 0.2px;
      }

      .top-right {
        display: inline-flex;
        gap: 10px;
        align-items: center;
      }
      .pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 8px 10px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.22);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.12) inset;
        color: var(--muted);
        font-family: var(--mono);
        font-size: 11px;
        user-select: none;
      }
      .dot {
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background: var(--warn);
        box-shadow: 0 0 0 4px rgba(251, 191, 36, 0.12);
      }
      .dot.ok {
        background: var(--ok);
        box-shadow: 0 0 0 4px rgba(52, 211, 153, 0.12);
      }
      .dot.bad {
        background: var(--bad);
        box-shadow: 0 0 0 4px rgba(251, 113, 133, 0.12);
      }

      main {
        padding: 0 16px 12px;
        display: grid;
        place-items: center;
        min-height: 0;
      }

      .stage {
        width: min(1100px, 100%);
        height: min(68vh, 680px);
        min-height: 360px;
        border-radius: var(--radius);
        position: relative;
        overflow: hidden;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
        box-shadow: var(--ring);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .canvas-wrap {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
      }

      canvas#view {
        width: 100%;
        height: 100%;
        display: block;
      }

      .overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .hud {
        position: absolute;
        left: 14px;
        top: 14px;
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.28);
        -webkit-backdrop-filter: var(--blur);
        backdrop-filter: var(--blur);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.12) inset;
        color: rgba(255, 255, 255, 0.9);
        font-size: 12px;
      }
      .hud b {
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .hud .mini {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--muted);
      }

      .hint {
        position: absolute;
        right: 14px;
        top: 14px;
        max-width: 360px;
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.24);
        -webkit-backdrop-filter: var(--blur);
        backdrop-filter: var(--blur);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.12) inset;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
        opacity: 0.92;
      }
      .hint kbd {
        font-family: var(--mono);
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.92);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.16) inset;
      }
      .hint .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 8px;
      }

      .controls {
        position: absolute;
        left: 12px;
        right: 12px;
        bottom: 12px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: end;
      }

      .panel {
        pointer-events: auto;
        background: var(--panel);
        -webkit-backdrop-filter: var(--blur);
        backdrop-filter: var(--blur);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: var(--radius);
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
        padding: 10px 10px 10px 12px;
        display: grid;
        grid-template-columns: 1.2fr 1fr 1fr;
        gap: 10px;
        min-width: 0;
      }

      .field {
        display: grid;
        gap: 6px;
        min-width: 0;
      }
      .label {
        font-size: 11px;
        letter-spacing: 0.2px;
        color: var(--muted);
        user-select: none;
      }
      select,
      input[type="range"] {
        width: 100%;
      }

      select {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.26);
        color: rgba(255, 255, 255, 0.92);
        border-radius: 12px;
        padding: 10px 36px 10px 12px;
        outline: none;
        font-size: 13px;
        letter-spacing: 0.2px;
        cursor: pointer;
      }
      .select-wrap {
        position: relative;
      }
      .select-wrap svg {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        opacity: 0.75;
        pointer-events: none;
      }

      input[type="range"] {
        -webkit-appearance: none;
        height: 38px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.26);
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 0 12px;
        outline: none;
        cursor: pointer;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.65));
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(0, 0, 0, 0.25);
      }
      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(0, 0, 0, 0.25);
      }

      .btns {
        pointer-events: auto;
        display: inline-flex;
        gap: 10px;
        justify-content: end;
        flex-wrap: wrap;
      }

      button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.26);
        color: rgba(255, 255, 255, 0.92);
        border-radius: 14px;
        padding: 11px 12px;
        font-size: 13px;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.25);
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, opacity 120ms ease;
        user-select: none;
      }
      button:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 255, 255, 0.18);
        background: rgba(0, 0, 0, 0.32);
      }
      button:active {
        transform: translateY(0px);
      }
      button.primary {
        background: linear-gradient(135deg, rgba(124, 58, 237, 0.85), rgba(34, 211, 238, 0.75));
        border-color: rgba(255, 255, 255, 0.18);
      }
      button.primary:hover {
        background: linear-gradient(135deg, rgba(124, 58, 237, 0.95), rgba(34, 211, 238, 0.85));
      }
      button.toggled {
        border-color: rgba(34, 211, 238, 0.35);
        box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.2) inset, 0 12px 26px rgba(0, 0, 0, 0.28);
      }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        transform: none;
      }

      .snapstrip {
        padding: 10px 16px 16px;
        display: grid;
        gap: 8px;
      }
      .snapstrip .row {
        display: flex;
        gap: 10px;
        overflow: auto;
        padding-bottom: 6px;
        scroll-snap-type: x mandatory;
      }
      .snapstrip .row::-webkit-scrollbar {
        height: 10px;
      }
      .snapstrip .row::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.14);
        border-radius: 999px;
      }
      .snapstrip .row::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.18);
        border-radius: 999px;
      }
      .thumb {
        width: 132px;
        height: 84px;
        border-radius: 14px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.35);
        flex: 0 0 auto;
        scroll-snap-align: start;
        position: relative;
        cursor: pointer;
        transition: transform 120ms ease, border-color 120ms ease;
      }
      .thumb:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 255, 255, 0.2);
      }
      .thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .badge {
        position: absolute;
        left: 8px;
        bottom: 8px;
        font-family: var(--mono);
        font-size: 10px;
        padding: 3px 6px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.36);
        color: rgba(255, 255, 255, 0.88);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.14) inset;
        max-width: calc(100% - 16px);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .toast {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: 98px;
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.35);
        -webkit-backdrop-filter: var(--blur);
        backdrop-filter: var(--blur);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.14) inset, 0 18px 40px rgba(0, 0, 0, 0.35);
        color: rgba(255, 255, 255, 0.92);
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 160ms ease, transform 160ms ease;
      }
      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-3px);
      }

      .start {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 22px;
        background: radial-gradient(700px 420px at 50% 40%, rgba(124, 58, 237, 0.22), transparent 60%),
          rgba(0, 0, 0, 0.18);
      }
      .card {
        width: min(560px, 100%);
        border-radius: var(--radius);
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.32);
        -webkit-backdrop-filter: var(--blur);
        backdrop-filter: var(--blur);
        box-shadow: 0 22px 65px rgba(0, 0, 0, 0.45);
        padding: 18px;
      }
      .card h2 {
        margin: 0 0 6px;
        font-size: 16px;
        letter-spacing: 0.2px;
      }
      .card p {
        margin: 0 0 14px;
        color: var(--muted);
        line-height: 1.5;
        font-size: 13px;
      }
      .card .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
      }
      .note {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.58);
        font-size: 12px;
        line-height: 1.4;
      }
      .error {
        margin-top: 10px;
        color: rgba(251, 113, 133, 0.9);
        font-family: var(--mono);
        font-size: 11px;
        white-space: pre-wrap;
      }

      dialog {
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: var(--radius);
        background: rgba(8, 10, 14, 0.72);
        -webkit-backdrop-filter: var(--blur);
        backdrop-filter: var(--blur);
        color: var(--fg);
        box-shadow: 0 34px 120px rgba(0, 0, 0, 0.6);
        padding: 0;
        width: min(980px, calc(100% - 22px));
      }
      dialog::backdrop {
        background: rgba(0, 0, 0, 0.55);
      }
      .modal {
        padding: 14px;
        display: grid;
        gap: 12px;
      }
      .modal .bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .modal .bar .meta {
        display: grid;
        gap: 2px;
        min-width: 0;
      }
      .modal .bar .meta .t {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.9);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .modal .bar .meta .s {
        font-size: 11px;
        color: var(--muted);
        font-family: var(--mono);
      }
      .modal img {
        width: 100%;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.04);
        max-height: min(72vh, 720px);
        object-fit: contain;
      }

      @media (max-width: 840px) {
        .panel {
          grid-template-columns: 1fr;
        }
        .controls {
          grid-template-columns: 1fr;
        }
        .hint {
          display: none;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          scroll-behavior: auto !important;
          transition: none !important;
          animation: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <div class="brand" title="Webcam Filter Playground">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1>Webcam Filter Playground</h1>
            <div class="sub">Live camera + delightful filters + snapshots</div>
          </div>
        </div>
        <div class="top-right">
          <div class="pill" title="Camera status">
            <span class="dot" id="statusDot"></span>
            <span id="statusText">waiting for camera</span>
          </div>
          <div class="pill" title="Tips">
            <span>space = snap</span>
            <span>•</span>
            <span>E = next effect</span>
          </div>
        </div>
      </header>

      <main>
        <section class="stage" id="stage" aria-label="Live preview">
          <div class="canvas-wrap">
            <canvas id="view"></canvas>
          </div>

          <div class="overlay">
            <div class="hud" id="hud">
              <b id="hudEffect">—</b>
              <span class="mini" id="hudMeta">intensity: —</span>
            </div>

            <div class="hint" id="hint">
              Try a few surprising ones:
              <div class="row" style="margin-top: 8px">
                <span><kbd>G</kbd> glitch</span>
                <span><kbd>K</kbd> kaleidoscope</span>
                <span><kbd>A</kbd> ASCII</span>
                <span><kbd>F</kbd> fullscreen</span>
                <span><kbd>M</kbd> mirror</span>
              </div>
            </div>

            <div class="controls" aria-label="Controls">
              <div class="panel">
                <div class="field">
                  <div class="label">Effect</div>
                  <div class="select-wrap">
                    <select id="effectSelect" aria-label="Effect selector"></select>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                      <path
                        d="M7 10l5 5 5-5"
                        stroke="rgba(255,255,255,0.85)"
                        stroke-width="2.2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                      />
                    </svg>
                  </div>
                </div>

                <div class="field">
                  <div class="label">Intensity</div>
                  <input id="intensity" type="range" min="0" max="100" value="55" />
                </div>

                <div class="field">
                  <div class="label">Quality</div>
                  <input id="quality" type="range" min="35" max="100" value="78" />
                </div>
              </div>

              <div class="btns">
                <button id="mirrorBtn" type="button" title="Mirror (M)">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M4 6a2 2 0 0 1 2-2h5v16H6a2 2 0 0 1-2-2V6Z"
                      stroke="rgba(255,255,255,0.9)"
                      stroke-width="2"
                      stroke-linejoin="round"
                    />
                    <path
                      d="M20 6a2 2 0 0 0-2-2h-5v16h5a2 2 0 0 0 2-2V6Z"
                      stroke="rgba(255,255,255,0.55)"
                      stroke-width="2"
                      stroke-linejoin="round"
                    />
                  </svg>
                  Mirror
                </button>
                <button id="fullscreenBtn" type="button" title="Fullscreen (F)">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M8 3H5a2 2 0 0 0-2 2v3M16 3h3a2 2 0 0 1 2 2v3M8 21H5a2 2 0 0 1-2-2v-3M16 21h3a2 2 0 0 0 2-2v-3"
                      stroke="rgba(255,255,255,0.9)"
                      stroke-width="2"
                      stroke-linecap="round"
                    />
                  </svg>
                  Fullscreen
                </button>
                <button id="snapBtn" type="button" class="primary" title="Snapshot (Space)">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M7 7h2l1-2h4l1 2h2a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H7a3 3 0 0 1-3-3v-7a3 3 0 0 1 3-3Z"
                      stroke="rgba(255,255,255,0.95)"
                      stroke-width="2"
                      stroke-linejoin="round"
                    />
                    <path
                      d="M12 17a4 4 0 1 0 0-8 4 4 0 0 0 0 8Z"
                      stroke="rgba(255,255,255,0.95)"
                      stroke-width="2"
                    />
                  </svg>
                  Snapshot
                </button>
                <button id="saveBtn" type="button" title="Download last snapshot" disabled>
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M12 3v10m0 0 4-4m-4 4-4-4"
                      stroke="rgba(255,255,255,0.9)"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    />
                    <path
                      d="M5 21h14a2 2 0 0 0 2-2v-4M3 15v4a2 2 0 0 0 2 2"
                      stroke="rgba(255,255,255,0.6)"
                      stroke-width="2"
                      stroke-linecap="round"
                    />
                  </svg>
                  Save
                </button>
              </div>
            </div>

            <div class="toast" id="toast" role="status" aria-live="polite"></div>
          </div>

          <div class="start" id="startOverlay">
            <div class="card">
              <h2>Allow camera to begin</h2>
              <p>
                This playground runs entirely in your browser. No uploads, no server. Pick an effect, tweak the sliders, then
                hit <span style="color: rgba(255, 255, 255, 0.92); font-weight: 700">Snapshot</span>.
              </p>
              <div class="row">
                <button id="startBtn" class="primary" type="button">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M4 8a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V8Z"
                      stroke="rgba(255,255,255,0.95)"
                      stroke-width="2"
                      stroke-linejoin="round"
                    />
                    <path
                      d="M18 10l4-2v8l-4-2v-4Z"
                      stroke="rgba(255,255,255,0.75)"
                      stroke-width="2"
                      stroke-linejoin="round"
                    />
                  </svg>
                  Start Camera
                </button>
                <div style="color: rgba(255, 255, 255, 0.7); font-size: 12px">
                  Works best on <span style="font-family: var(--mono)">https://</span> or <span style="font-family: var(--mono)">localhost</span>.
                </div>
              </div>
              <div class="note">
                Shortcuts: <span style="font-family: var(--mono)">Space</span> snapshot •
                <span style="font-family: var(--mono)">E</span> next effect •
                <span style="font-family: var(--mono)">Shift+E</span> prev •
                <span style="font-family: var(--mono)">M</span> mirror •
                <span style="font-family: var(--mono)">F</span> fullscreen
              </div>
              <div class="error" id="startError" hidden></div>
            </div>
          </div>
        </section>
      </main>

      <footer class="snapstrip" aria-label="Snapshots">
        <div style="display: flex; align-items: baseline; justify-content: space-between; gap: 10px">
          <div style="color: rgba(255, 255, 255, 0.86); font-size: 12px; letter-spacing: 0.2px">
            Snapshots
            <span style="color: rgba(255, 255, 255, 0.55); font-family: var(--mono)" id="snapCount">(0)</span>
          </div>
          <div style="color: rgba(255, 255, 255, 0.55); font-size: 12px">
            Click a thumbnail to preview + download
          </div>
        </div>
        <div class="row" id="snapRow"></div>
      </footer>
    </div>

    <dialog id="previewDialog">
      <div class="modal">
        <div class="bar">
          <div class="meta">
            <div class="t" id="previewTitle">Snapshot</div>
            <div class="s" id="previewSubtitle">—</div>
          </div>
          <div class="btns" style="gap: 10px">
            <button id="downloadBtn" class="primary" type="button" title="Download">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M12 3v10m0 0 4-4m-4 4-4-4"
                  stroke="rgba(255,255,255,0.95)"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M5 21h14a2 2 0 0 0 2-2v-4M3 15v4a2 2 0 0 0 2 2"
                  stroke="rgba(255,255,255,0.65)"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
              Download
            </button>
            <button id="closePreviewBtn" type="button" title="Close (Esc)">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M6 6l12 12M18 6 6 18"
                  stroke="rgba(255,255,255,0.9)"
                  stroke-width="2.2"
                  stroke-linecap="round"
                />
              </svg>
              Close
            </button>
          </div>
        </div>
        <img id="previewImg" alt="Snapshot preview" />
      </div>
    </dialog>

    <script>
      (() => {
        "use strict";

        const $ = (sel) => document.querySelector(sel);
        const view = $("#view");
        const stage = $("#stage");
        const startOverlay = $("#startOverlay");
        const startBtn = $("#startBtn");
        const startError = $("#startError");
        const statusDot = $("#statusDot");
        const statusText = $("#statusText");

        const effectSelect = $("#effectSelect");
        const intensityEl = $("#intensity");
        const qualityEl = $("#quality");
        const mirrorBtn = $("#mirrorBtn");
        const fullscreenBtn = $("#fullscreenBtn");
        const snapBtn = $("#snapBtn");
        const saveBtn = $("#saveBtn");
        const toast = $("#toast");
        const hudEffect = $("#hudEffect");
        const hudMeta = $("#hudMeta");
        const snapRow = $("#snapRow");
        const snapCount = $("#snapCount");

        const previewDialog = $("#previewDialog");
        const previewImg = $("#previewImg");
        const previewTitle = $("#previewTitle");
        const previewSubtitle = $("#previewSubtitle");
        const downloadBtn = $("#downloadBtn");
        const closePreviewBtn = $("#closePreviewBtn");

        const hiddenVideo = document.createElement("video");
        hiddenVideo.playsInline = true;
        hiddenVideo.muted = true;
        hiddenVideo.autoplay = true;

        const srcCanvas = document.createElement("canvas");
        const srcCtx = srcCanvas.getContext("2d", { willReadFrequently: true });

        const fxCanvas = document.createElement("canvas");
        const fxCtx = fxCanvas.getContext("2d", { willReadFrequently: true });

        const trailCanvas = document.createElement("canvas");
        const trailCtx = trailCanvas.getContext("2d", { willReadFrequently: true });

        const ctx = view.getContext("2d", { alpha: false, desynchronized: true });
        ctx.imageSmoothingEnabled = true;

        const state = {
          stream: null,
          running: false,
          effectId: "neon",
          intensity: 0.55,
          quality: 0.78,
          mirror: true,
          lastFrameMs: performance.now(),
          fps: 0,
          toastTimer: 0,
          snapshots: [],
          lastSnapshot: null,
          edgeBuffers: { w: 0, h: 0, gray: null, edge: null },
          seed: Math.random() * 1e9,
        };

        function clamp01(x) {
          return Math.max(0, Math.min(1, x));
        }

        function nowStamp() {
          const d = new Date();
          const pad = (n) => String(n).padStart(2, "0");
          return (
            d.getFullYear() +
            "-" +
            pad(d.getMonth() + 1) +
            "-" +
            pad(d.getDate()) +
            "_" +
            pad(d.getHours()) +
            "-" +
            pad(d.getMinutes()) +
            "-" +
            pad(d.getSeconds())
          );
        }

        function setStatus(kind, text) {
          statusDot.classList.remove("ok", "bad");
          if (kind === "ok") statusDot.classList.add("ok");
          if (kind === "bad") statusDot.classList.add("bad");
          statusText.textContent = text;
        }

        function showToast(message) {
          toast.textContent = message;
          toast.classList.add("show");
          clearTimeout(state.toastTimer);
          state.toastTimer = setTimeout(() => toast.classList.remove("show"), 900);
        }

        function rand01() {
          // Xorshift32-ish
          let x = (state.seed | 0) + 0x6d2b79f5;
          x = Math.imul(x ^ (x >>> 15), x | 1);
          x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
          state.seed = x ^ (x >>> 14);
          return ((state.seed >>> 0) / 4294967296) % 1;
        }

        function setCanvasSize(w, h) {
          const iw = Math.max(2, Math.floor(w));
          const ih = Math.max(2, Math.floor(h));
          view.width = iw;
          view.height = ih;
          srcCanvas.width = iw;
          srcCanvas.height = ih;
          fxCanvas.width = iw;
          fxCanvas.height = ih;
          trailCanvas.width = iw;
          trailCanvas.height = ih;
        }

        function drawVideoBase(targetCtx, w, h, filterStr = "none") {
          targetCtx.save();
          targetCtx.filter = filterStr;
          if (state.mirror) {
            targetCtx.translate(w, 0);
            targetCtx.scale(-1, 1);
          }
          targetCtx.drawImage(hiddenVideo, 0, 0, w, h);
          targetCtx.restore();
        }

        function getProcessingDims(w, h, scale) {
          const s = clamp01(scale);
          const pw = Math.max(2, Math.round(w * s));
          const ph = Math.max(2, Math.round(h * s));
          return [pw, ph];
        }

        function mapGradient(t) {
          // deep blue -> cyan -> lime -> yellow -> orange -> magenta
          t = clamp01(t);
          const stops = [
            [12, 18, 48],
            [18, 207, 255],
            [90, 240, 120],
            [250, 220, 60],
            [255, 120, 60],
            [255, 80, 180],
          ];
          const pos = t * (stops.length - 1);
          const i = Math.floor(pos);
          const f = pos - i;
          const a = stops[i];
          const b = stops[Math.min(stops.length - 1, i + 1)];
          const r = Math.round(a[0] + (b[0] - a[0]) * f);
          const g = Math.round(a[1] + (b[1] - a[1]) * f);
          const bl = Math.round(a[2] + (b[2] - a[2]) * f);
          return [r, g, bl];
        }

        function sobelEdge(gray, w, h, out) {
          // gray length = w*h, out length = w*h
          const gx = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
          const gy = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
          for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
              let sx = 0;
              let sy = 0;
              let k = 0;
              for (let j = -1; j <= 1; j++) {
                const row = (y + j) * w;
                for (let i = -1; i <= 1; i++) {
                  const v = gray[row + (x + i)];
                  sx += v * gx[k];
                  sy += v * gy[k];
                  k++;
                }
              }
              const mag = Math.sqrt(sx * sx + sy * sy);
              out[y * w + x] = mag;
            }
          }
        }

        const effects = [
          {
            id: "neon",
            name: "Neon Pop",
            hotkey: "1",
            render({ w, h, t }) {
              const k = state.intensity;
              const hue = 220 + 120 * k * Math.sin(t * 0.00035);
              const sat = 1.45 + 1.4 * k;
              const con = 1.05 + 1.1 * k;
              drawVideoBase(ctx, w, h, `saturate(${sat}) contrast(${con}) hue-rotate(${hue}deg)`);
              ctx.save();
              ctx.globalCompositeOperation = "screen";
              ctx.globalAlpha = 0.25 + 0.28 * k;
              const g = ctx.createLinearGradient(0, 0, w, h);
              g.addColorStop(0, "rgba(124,58,237,0.55)");
              g.addColorStop(0.5, "rgba(34,211,238,0.35)");
              g.addColorStop(1, "rgba(251,113,133,0.45)");
              ctx.fillStyle = g;
              ctx.fillRect(0, 0, w, h);
              ctx.restore();
              ctx.save();
              ctx.globalCompositeOperation = "overlay";
              ctx.globalAlpha = 0.12 + 0.18 * k;
              ctx.fillStyle = "rgba(255,255,255,1)";
              for (let i = 0; i < 6; i++) {
                const yy = Math.floor((h * (i + 0.5)) / 6);
                ctx.fillRect(0, yy, w, 1);
              }
              ctx.restore();
            },
          },
          {
            id: "pixel",
            name: "Pixel Party",
            hotkey: "2",
            render({ w, h }) {
              const k = state.intensity;
              const q = state.quality;
              const minS = 0.09;
              const maxS = 0.55;
              const s = clamp01(minS + (maxS - minS) * (1 - q) * (0.65 + 0.35 * k));
              const [pw, ph] = getProcessingDims(w, h, s);
              fxCanvas.width = pw;
              fxCanvas.height = ph;
              fxCtx.imageSmoothingEnabled = true;
              // Draw un-mirrored into the low-res buffer; mirror at final blit to avoid double mirroring.
              fxCtx.save();
              fxCtx.filter = `contrast(${1.05 + 0.6 * k}) saturate(${1.1 + 2.0 * k})`;
              fxCtx.drawImage(hiddenVideo, 0, 0, pw, ph);
              fxCtx.restore();
              ctx.imageSmoothingEnabled = false;
              ctx.save();
              if (state.mirror) {
                ctx.translate(w, 0);
                ctx.scale(-1, 1);
              }
              ctx.drawImage(fxCanvas, 0, 0, pw, ph, 0, 0, w, h);
              ctx.restore();
              ctx.imageSmoothingEnabled = true;
              ctx.save();
              ctx.globalAlpha = 0.14 + 0.15 * k;
              ctx.globalCompositeOperation = "overlay";
              ctx.fillStyle = "rgba(0,0,0,1)";
              for (let y = 0; y < h; y += Math.max(8, Math.round(20 - 16 * k))) {
                ctx.fillRect(0, y, w, 1);
              }
              ctx.restore();
            },
          },
          {
            id: "kaleido",
            name: "Kaleidoscope",
            hotkey: "3",
            render({ w, h, t }) {
              const k = state.intensity;
              const q = state.quality;
              const seg = Math.max(6, Math.min(22, Math.round(6 + 16 * k)));
              const spin = (t * 0.00035) * (0.4 + 1.3 * k);
              const cx = w / 2;
              const cy = h / 2;
              const rad = Math.max(w, h) * 0.7;
              ctx.save();
              ctx.clearRect(0, 0, w, h);
              ctx.translate(cx, cy);
              for (let i = 0; i < seg; i++) {
                ctx.save();
                const a0 = (i * (Math.PI * 2)) / seg + spin;
                const a1 = ((i + 1) * (Math.PI * 2)) / seg + spin;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, rad, a0, a1);
                ctx.closePath();
                ctx.clip();
                ctx.rotate(a0);
                const wobble = (0.02 + 0.12 * k) * Math.sin(t * 0.001 + i);
                ctx.rotate(wobble);
                ctx.scale(i % 2 === 0 ? 1 : -1, 1);
                const zoom = 1.02 + 0.22 * k;
                const sx = -cx * zoom;
                const sy = -cy * zoom;
                ctx.filter = `contrast(${1.05 + 0.5 * k}) saturate(${1.05 + 1.3 * k})`;
                if (state.mirror) ctx.scale(-1, 1);
                ctx.drawImage(hiddenVideo, sx, sy, w * zoom, h * zoom);
                ctx.restore();
              }
              ctx.restore();
              ctx.save();
              ctx.globalCompositeOperation = "overlay";
              ctx.globalAlpha = 0.1 + 0.2 * (1 - q);
              const g = ctx.createRadialGradient(cx, cy, 10, cx, cy, rad);
              g.addColorStop(0, "rgba(34,211,238,0.25)");
              g.addColorStop(1, "rgba(0,0,0,0)");
              ctx.fillStyle = g;
              ctx.fillRect(0, 0, w, h);
              ctx.restore();
            },
          },
          {
            id: "glitch",
            name: "Cyber Glitch",
            hotkey: "4",
            render({ w, h, t }) {
              const k = state.intensity;
              const q = state.quality;
              // Base frame (stable source for subsequent slice ops).
              if (srcCanvas.width !== w || srcCanvas.height !== h) {
                srcCanvas.width = w;
                srcCanvas.height = h;
              }
              drawVideoBase(srcCtx, w, h, `contrast(${1.1 + 0.8 * k}) saturate(${1.15 + 1.7 * k})`);
              ctx.drawImage(srcCanvas, 0, 0);
              const sliceCount = Math.round(8 + 26 * k);
              ctx.save();
              ctx.globalCompositeOperation = "source-over";
              for (let i = 0; i < sliceCount; i++) {
                const y = Math.floor(rand01() * h);
                const hh = Math.max(1, Math.floor((2 + rand01() * 18) * (0.7 + 0.9 * k)));
                const dx = Math.floor((rand01() - 0.5) * w * (0.12 + 0.28 * k) * (1.05 - q));
                ctx.drawImage(srcCanvas, 0, y, w, hh, dx, y, w, hh);
              }
              ctx.restore();
              // RGB split
              const shift = Math.floor((2 + 18 * k) * (1.1 - q));
              ctx.save();
              ctx.globalCompositeOperation = "screen";
              ctx.globalAlpha = 0.22 + 0.25 * k;
              ctx.fillStyle = "rgba(255,40,120,1)";
              ctx.globalCompositeOperation = "source-atop";
              ctx.drawImage(srcCanvas, shift, 0);
              ctx.globalCompositeOperation = "screen";
              ctx.globalAlpha = 0.18 + 0.22 * k;
              ctx.drawImage(srcCanvas, -shift, 0);
              ctx.restore();
              // Scanlines + time tearing
              ctx.save();
              ctx.globalAlpha = 0.16 + 0.18 * k;
              ctx.globalCompositeOperation = "multiply";
              ctx.fillStyle = "rgba(0,0,0,1)";
              for (let y = 0; y < h; y += 2) ctx.fillRect(0, y, w, 1);
              ctx.restore();
              if (rand01() < 0.06 + 0.16 * k) {
                ctx.save();
                ctx.globalAlpha = 0.35;
                ctx.globalCompositeOperation = "difference";
                const bandY = Math.floor((0.15 + 0.7 * rand01()) * h);
                ctx.drawImage(
                  srcCanvas,
                  0,
                  bandY,
                  w,
                  18,
                  Math.floor((rand01() - 0.5) * w * 0.3),
                  bandY,
                  w,
                  18
                );
                ctx.restore();
              }
              // subtle noise
              ctx.save();
              ctx.globalAlpha = 0.12 + 0.18 * (1 - q);
              ctx.globalCompositeOperation = "overlay";
              const n = Math.floor(1200 * (1 - q) + 600 * k);
              ctx.fillStyle = "rgba(255,255,255,1)";
              for (let i = 0; i < n; i++) {
                const x = Math.floor(rand01() * w);
                const y = Math.floor(rand01() * h);
                ctx.fillRect(x, y, 1, 1);
              }
              ctx.restore();
              // Slight hue drift over time
              ctx.save();
              ctx.globalCompositeOperation = "color";
              ctx.globalAlpha = 0.08 + 0.1 * k;
              ctx.fillStyle = `hsl(${(t * 0.02) % 360}, 85%, 55%)`;
              ctx.fillRect(0, 0, w, h);
              ctx.restore();
            },
          },
          {
            id: "edge",
            name: "Edge Sketch",
            hotkey: "5",
            render({ w, h }) {
              const k = state.intensity;
              const q = state.quality;
              const proc = clamp01(0.18 + 0.5 * q);
              const [pw, ph] = getProcessingDims(w, h, proc);
              fxCanvas.width = pw;
              fxCanvas.height = ph;
              fxCtx.imageSmoothingEnabled = true;
              drawVideoBase(fxCtx, pw, ph, "none");
              const img = fxCtx.getImageData(0, 0, pw, ph);
              const data = img.data;
              if (state.edgeBuffers.w !== pw || state.edgeBuffers.h !== ph || !state.edgeBuffers.gray || !state.edgeBuffers.edge) {
                state.edgeBuffers.w = pw;
                state.edgeBuffers.h = ph;
                state.edgeBuffers.gray = new Float32Array(pw * ph);
                state.edgeBuffers.edge = new Float32Array(pw * ph);
              }
              const gray = state.edgeBuffers.gray;
              const edge = state.edgeBuffers.edge;
              for (let i = 0, p = 0; i < data.length; i += 4, p++) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                gray[p] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
              }
              sobelEdge(gray, pw, ph, edge);
              const thresh = 22 + 68 * (1 - k);
              for (let p = 0, i = 0; p < edge.length; p++, i += 4) {
                let e = edge[p];
                e = Math.min(255, e * (0.75 + 1.7 * k));
                const ink = e > thresh ? 255 : Math.max(0, Math.round(e * 0.9));
                const inv = 255 - ink;
                data[i] = inv;
                data[i + 1] = inv;
                data[i + 2] = inv;
                data[i + 3] = 255;
              }
              fxCtx.putImageData(img, 0, 0);
              ctx.save();
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(fxCanvas, 0, 0, pw, ph, 0, 0, w, h);
              ctx.imageSmoothingEnabled = true;
              ctx.globalCompositeOperation = "multiply";
              ctx.globalAlpha = 0.25 + 0.25 * k;
              const g = ctx.createLinearGradient(0, 0, w, h);
              g.addColorStop(0, "rgba(124,58,237,0.65)");
              g.addColorStop(0.5, "rgba(34,211,238,0.55)");
              g.addColorStop(1, "rgba(255,190,60,0.45)");
              ctx.fillStyle = g;
              ctx.fillRect(0, 0, w, h);
              ctx.restore();
            },
          },
          {
            id: "thermal",
            name: "Thermal Vision",
            hotkey: "6",
            render({ w, h, t }) {
              const k = state.intensity;
              const q = state.quality;
              const proc = clamp01(0.16 + 0.55 * q);
              const [pw, ph] = getProcessingDims(w, h, proc);
              fxCanvas.width = pw;
              fxCanvas.height = ph;
              fxCtx.imageSmoothingEnabled = true;
              drawVideoBase(fxCtx, pw, ph, `contrast(${1.1 + 0.5 * k})`);
              const img = fxCtx.getImageData(0, 0, pw, ph);
              const d = img.data;
              const pulse = 0.04 * Math.sin(t * 0.0012);
              for (let i = 0; i < d.length; i += 4) {
                const r = d[i],
                  g = d[i + 1],
                  b = d[i + 2];
                const lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
                const v = clamp01(Math.pow(lum, 0.85 - 0.2 * k) + pulse);
                const [rr, gg, bb] = mapGradient(v);
                d[i] = rr;
                d[i + 1] = gg;
                d[i + 2] = bb;
                d[i + 3] = 255;
              }
              fxCtx.putImageData(img, 0, 0);
              ctx.save();
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(fxCanvas, 0, 0, pw, ph, 0, 0, w, h);
              ctx.imageSmoothingEnabled = true;
              ctx.globalCompositeOperation = "overlay";
              ctx.globalAlpha = 0.14 + 0.18 * k;
              ctx.fillStyle = "rgba(255,255,255,1)";
              for (let y = 0; y < h; y += 3) ctx.fillRect(0, y, w, 1);
              ctx.restore();
            },
          },
          {
            id: "ascii",
            name: "ASCII Dream",
            hotkey: "7",
            render({ w, h, t }) {
              const k = state.intensity;
              const q = state.quality;
              const chars = " .,:;i1tfLCG08@";
              const base = 0.085 + 0.22 * (1 - q);
              const proc = clamp01(base + 0.12 * (1 - k));
              const [pw, ph] = getProcessingDims(w, h, proc);
              fxCanvas.width = pw;
              fxCanvas.height = ph;
              fxCtx.imageSmoothingEnabled = true;
              drawVideoBase(fxCtx, pw, ph, "none");
              const img = fxCtx.getImageData(0, 0, pw, ph);
              const d = img.data;
              ctx.save();
              ctx.fillStyle = "rgba(0,0,0,1)";
              ctx.fillRect(0, 0, w, h);
              const cell = Math.max(6, Math.round((w / pw) * (0.85 + 0.8 * (1 - q))));
              const fontPx = Math.max(10, Math.round(cell * 1.35));
              ctx.font = `${fontPx}px ${getComputedStyle(document.documentElement).getPropertyValue("--mono") || "monospace"}`;
              ctx.textBaseline = "top";
              ctx.textAlign = "left";
              const jitter = (0.25 + 0.95 * k) * Math.sin(t * 0.001);
              let p = 0;
              for (let y = 0; y < ph; y++) {
                for (let x = 0; x < pw; x++, p++) {
                  const i = p * 4;
                  const r = d[i],
                    g = d[i + 1],
                    b = d[i + 2];
                  const lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
                  const idx = Math.min(chars.length - 1, Math.max(0, Math.floor(lum * (chars.length - 1))));
                  const ch = chars[idx];
                  if (ch === " ") continue;
                  const [rr, gg, bb] = mapGradient(clamp01(lum + 0.1 + 0.08 * jitter));
                  ctx.fillStyle = `rgba(${rr},${gg},${bb},${0.72 + 0.25 * k})`;
                  const dx = Math.round((x * w) / pw);
                  const dy = Math.round((y * h) / ph);
                  ctx.fillText(ch, dx, dy);
                }
              }
              ctx.globalCompositeOperation = "screen";
              ctx.globalAlpha = 0.12 + 0.18 * k;
              ctx.fillStyle = "rgba(34,211,238,1)";
              ctx.fillRect(0, 0, w, h);
              ctx.restore();
            },
          },
          {
            id: "ghost",
            name: "Ghost Trails",
            hotkey: "8",
            render({ w, h, t }) {
              const k = state.intensity;
              const q = state.quality;
              // fade previous trails
              trailCtx.save();
              trailCtx.globalCompositeOperation = "source-over";
              trailCtx.globalAlpha = 0.12 + 0.28 * (1 - k);
              trailCtx.fillStyle = "rgba(0,0,0,1)";
              trailCtx.fillRect(0, 0, w, h);
              trailCtx.restore();
              // add current frame into trail buffer
              trailCtx.save();
              trailCtx.globalAlpha = 0.12 + 0.55 * k;
              trailCtx.globalCompositeOperation = "screen";
              const hue = (t * 0.02) % 360;
              drawVideoBase(trailCtx, w, h, `blur(${(1 - q) * (0.5 + 4 * k)}px) saturate(${1.1 + 1.5 * k}) hue-rotate(${hue}deg)`);
              trailCtx.restore();
              // render: base + trails
              drawVideoBase(ctx, w, h, `contrast(${1.03 + 0.35 * k}) saturate(${1.02 + 0.7 * k})`);
              ctx.save();
              ctx.globalCompositeOperation = "screen";
              ctx.globalAlpha = 0.55 + 0.35 * k;
              ctx.drawImage(trailCanvas, 0, 0);
              ctx.restore();
              ctx.save();
              ctx.globalCompositeOperation = "overlay";
              ctx.globalAlpha = 0.12 + 0.16 * k;
              const g = ctx.createLinearGradient(0, 0, w, h);
              g.addColorStop(0, "rgba(255,255,255,0.0)");
              g.addColorStop(0.5, "rgba(255,255,255,0.45)");
              g.addColorStop(1, "rgba(255,255,255,0.0)");
              ctx.fillStyle = g;
              ctx.fillRect(0, 0, w, h);
              ctx.restore();
            },
          },
        ];

        const effectById = new Map(effects.map((e) => [e.id, e]));

        function populateEffects() {
          effectSelect.innerHTML = "";
          for (const e of effects) {
            const opt = document.createElement("option");
            opt.value = e.id;
            opt.textContent = `${e.name}${e.hotkey ? `  [${e.hotkey}]` : ""}`;
            effectSelect.appendChild(opt);
          }
          effectSelect.value = state.effectId;
        }

        function updateHUD() {
          const effect = effectById.get(state.effectId);
          hudEffect.textContent = effect ? effect.name : "—";
          hudMeta.textContent = `intensity: ${Math.round(state.intensity * 100)} • quality: ${Math.round(state.quality * 100)} • ${Math.round(
            state.fps
          )} fps`;
        }

        function setEffect(id) {
          if (!effectById.has(id)) return;
          state.effectId = id;
          effectSelect.value = id;
          updateHUD();
          showToast(`Effect: ${effectById.get(id).name}`);
        }

        function cycleEffect(dir) {
          const idx = effects.findIndex((e) => e.id === state.effectId);
          const next = (idx + dir + effects.length) % effects.length;
          setEffect(effects[next].id);
        }

        function updateToggles() {
          mirrorBtn.classList.toggle("toggled", state.mirror);
        }

        async function startCamera() {
          startError.hidden = true;
          setStatus("warn", "requesting permission…");
          try {
            if (!navigator.mediaDevices?.getUserMedia) {
              throw new Error("This browser does not support getUserMedia().");
            }
            const constraints = {
              audio: false,
              video: {
                facingMode: "user",
                width: { ideal: 1280 },
                height: { ideal: 720 },
              },
            };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            state.stream = stream;
            hiddenVideo.srcObject = stream;

            await new Promise((resolve) => {
              if (hiddenVideo.readyState >= 1 && hiddenVideo.videoWidth) return resolve();
              const onMeta = () => {
                hiddenVideo.removeEventListener("loadedmetadata", onMeta);
                resolve();
              };
              hiddenVideo.addEventListener("loadedmetadata", onMeta, { once: true });
            });
            await hiddenVideo.play();
            const w = hiddenVideo.videoWidth || 1280;
            const h = hiddenVideo.videoHeight || 720;
            setCanvasSize(w, h);

            startOverlay.style.display = "none";
            state.running = true;
            setStatus("ok", "live");
            showToast("Camera on");
            updateHUD();
            renderLoop();
          } catch (err) {
            setStatus("bad", "camera blocked");
            startOverlay.style.display = "grid";
            startError.hidden = false;
            startError.textContent =
              (err && err.name ? `${err.name}: ` : "") + (err && err.message ? err.message : String(err));
          }
        }

        function stopCamera() {
          if (state.stream) {
            for (const tr of state.stream.getTracks()) tr.stop();
            state.stream = null;
          }
          state.running = false;
          setStatus("warn", "stopped");
        }

        function renderLoop() {
          if (!state.running) return;
          const t = performance.now();
          const dt = Math.max(1, t - state.lastFrameMs);
          state.lastFrameMs = t;
          state.fps = 1000 / dt;

          const w = view.width;
          const h = view.height;
          const effect = effectById.get(state.effectId) || effects[0];

          // In case video dimensions change after start (rare), adapt once.
          if (hiddenVideo.videoWidth && hiddenVideo.videoHeight && (hiddenVideo.videoWidth !== w || hiddenVideo.videoHeight !== h)) {
            setCanvasSize(hiddenVideo.videoWidth, hiddenVideo.videoHeight);
          }

          try {
            effect.render({ w, h, t });
          } catch (e) {
            // Safety: fall back to clean draw if an effect errors.
            ctx.clearRect(0, 0, w, h);
            drawVideoBase(ctx, w, h, "none");
            setStatus("warn", "effect fallback");
          }

          updateHUD();
          requestAnimationFrame(renderLoop);
        }

        function safeToBlob(canvas, type = "image/png", quality) {
          return new Promise((resolve) => {
            if (canvas.toBlob) {
              canvas.toBlob((blob) => resolve(blob), type, quality);
              return;
            }
            // Fallback: dataURL -> blob
            const dataUrl = canvas.toDataURL(type, quality);
            const parts = dataUrl.split(",");
            const byteString = atob(parts[1]);
            const mimeMatch = parts[0].match(/data:(.*?);base64/);
            const mime = mimeMatch ? mimeMatch[1] : type;
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
            resolve(new Blob([ab], { type: mime }));
          });
        }

        async function takeSnapshot() {
          if (!state.running) {
            showToast("Start camera first");
            return;
          }
          const effect = effectById.get(state.effectId);
          const blob = await safeToBlob(view, "image/png");
          const url = URL.createObjectURL(blob);
          const item = {
            url,
            blob,
            ts: Date.now(),
            effect: effect ? effect.name : "Unknown",
            size: { w: view.width, h: view.height },
          };
          state.snapshots.unshift(item);
          const MAX = 24;
          while (state.snapshots.length > MAX) {
            const removed = state.snapshots.pop();
            if (removed?.url) URL.revokeObjectURL(removed.url);
          }
          state.lastSnapshot = item;
          saveBtn.disabled = false;
          renderSnapshots();
          showToast("Snapshot captured");
        }

        function renderSnapshots() {
          snapRow.innerHTML = "";
          snapCount.textContent = `(${state.snapshots.length})`;
          for (const item of state.snapshots) {
            const a = document.createElement("div");
            a.className = "thumb";
            a.title = "Click to preview";
            const img = document.createElement("img");
            img.alt = `Snapshot (${item.effect})`;
            img.src = item.url;
            const badge = document.createElement("div");
            badge.className = "badge";
            const d = new Date(item.ts);
            badge.textContent = `${item.effect} • ${d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}`;
            a.appendChild(img);
            a.appendChild(badge);
            a.addEventListener("click", () => openPreview(item));
            snapRow.appendChild(a);
          }
        }

        function downloadSnapshot(item) {
          if (!item) return;
          const name = `webcam_filter_${nowStamp()}_${item.effect.replaceAll(" ", "_").toLowerCase()}.png`;
          const a = document.createElement("a");
          a.href = item.url;
          a.download = name;
          document.body.appendChild(a);
          a.click();
          a.remove();
          showToast("Download started");
        }

        function openPreview(item) {
          if (!item) return;
          const d = new Date(item.ts);
          previewImg.src = item.url;
          previewTitle.textContent = `Snapshot • ${item.effect}`;
          previewSubtitle.textContent = `${item.size.w}×${item.size.h} • ${d.toLocaleString()}`;
          downloadBtn.onclick = () => downloadSnapshot(item);
          if (typeof previewDialog.showModal === "function") previewDialog.showModal();
          else previewDialog.setAttribute("open", "open");
        }

        function closePreview() {
          if (previewDialog.open) previewDialog.close();
          previewImg.src = "";
        }

        function toggleFullscreen() {
          const el = stage;
          if (document.fullscreenElement) {
            document.exitFullscreen?.();
            return;
          }
          el.requestFullscreen?.();
        }

        function attachEvents() {
          populateEffects();
          updateHUD();
          updateToggles();

          startBtn.addEventListener("click", startCamera);

          effectSelect.addEventListener("change", (e) => setEffect(e.target.value));
          intensityEl.addEventListener("input", (e) => {
            state.intensity = clamp01(Number(e.target.value) / 100);
          });
          qualityEl.addEventListener("input", (e) => {
            state.quality = clamp01(Number(e.target.value) / 100);
          });

          mirrorBtn.addEventListener("click", () => {
            state.mirror = !state.mirror;
            updateToggles();
            showToast(state.mirror ? "Mirror on" : "Mirror off");
          });

          fullscreenBtn.addEventListener("click", toggleFullscreen);
          snapBtn.addEventListener("click", takeSnapshot);
          saveBtn.addEventListener("click", () => downloadSnapshot(state.lastSnapshot));

          closePreviewBtn.addEventListener("click", closePreview);
          previewDialog.addEventListener("click", (e) => {
            if (e.target === previewDialog) closePreview();
          });

          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") closePreview();
            if (e.repeat) return;
            const tag = (document.activeElement && document.activeElement.tagName) || "";
            const typing = tag === "INPUT" || tag === "SELECT" || tag === "TEXTAREA";
            if (typing && e.key !== "Escape") return;

            if (e.code === "Space") {
              e.preventDefault();
              takeSnapshot();
              return;
            }
            if (e.key.toLowerCase() === "e") {
              cycleEffect(e.shiftKey ? -1 : 1);
              return;
            }
            if (e.key.toLowerCase() === "m") {
              state.mirror = !state.mirror;
              updateToggles();
              showToast(state.mirror ? "Mirror on" : "Mirror off");
              return;
            }
            if (e.key.toLowerCase() === "f") {
              toggleFullscreen();
              return;
            }
            if (e.key.toLowerCase() === "g") setEffect("glitch");
            if (e.key.toLowerCase() === "k") setEffect("kaleido");
            if (e.key.toLowerCase() === "a") setEffect("ascii");
            if (e.key >= "1" && e.key <= "8") {
              const target = effects.find((fx) => fx.hotkey === e.key);
              if (target) setEffect(target.id);
            }
          });

          document.addEventListener("visibilitychange", () => {
            if (document.hidden) return;
            // When returning to the tab, re-sync status text if stream is alive.
            if (state.stream && state.running) setStatus("ok", "live");
          });

          window.addEventListener("beforeunload", () => stopCamera());
        }

        // Gentle auto-start: some browsers allow it; if blocked, user can press Start.
        async function tryAutoStart() {
          try {
            await startCamera();
          } catch (_) {
            // startCamera handles UI + errors.
          }
        }

        function init() {
          setStatus("warn", "waiting for camera");
          attachEvents();
          // Default to a fun effect.
          setEffect(state.effectId);
          updateToggles();
          // Attempt auto-start shortly after paint.
          setTimeout(tryAutoStart, 250);
        }

        init();
      })();
    </script>
  </body>
</html>
