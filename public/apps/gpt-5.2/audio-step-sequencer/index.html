<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark" />
  <title>Audio Step Sequencer</title>
  <style>
    :root{
      --bg0:#050612;
      --bg1:#0a0b1e;
      --panel: rgba(16, 18, 38, .62);
      --panel2: rgba(10, 12, 26, .55);
      --stroke: rgba(130, 150, 255, .18);
      --stroke2: rgba(255,255,255,.08);
      --text: rgba(232, 240, 255, .92);
      --muted: rgba(232, 240, 255, .62);
      --glow: rgba(124, 255, 232, .55);
      --glow2: rgba(154, 99, 255, .55);
      --danger: rgba(255, 98, 162, .95);
      --ok: rgba(124, 255, 232, .95);
      --warn: rgba(255, 219, 102, .95);
      --shadow: 0 18px 50px rgba(0,0,0,.55);
      --radius: 16px;
      --radius2: 12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --cell: 34px;
      --gap: 8px;
      --rowH: 44px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 20%, rgba(154, 99, 255, .18), transparent 55%),
        radial-gradient(900px 700px at 80% 30%, rgba(124, 255, 232, .14), transparent 55%),
        radial-gradient(700px 500px at 55% 80%, rgba(255, 98, 162, .10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    .fx-bg::before,
    .fx-bg::after{
      content:"";
      position:fixed; inset:-40vmax;
      pointer-events:none;
      z-index:-2;
    }
    .fx-bg::before{
      background:
        conic-gradient(from 220deg at 40% 40%,
          rgba(124,255,232,.0) 0deg,
          rgba(124,255,232,.06) 90deg,
          rgba(154,99,255,.07) 160deg,
          rgba(255,98,162,.06) 240deg,
          rgba(124,255,232,.0) 360deg);
      filter: blur(30px) saturate(120%);
      animation: drift 12s linear infinite;
      opacity:.9;
    }
    .fx-bg::after{
      background:
        repeating-linear-gradient(90deg, rgba(255,255,255,.05) 0px, rgba(255,255,255,.05) 1px, transparent 1px, transparent 40px),
        repeating-linear-gradient(0deg, rgba(255,255,255,.04) 0px, rgba(255,255,255,.04) 1px, transparent 1px, transparent 40px);
      transform: perspective(900px) rotateX(68deg) translateY(18vh);
      opacity:.10;
      filter: blur(.2px);
    }
    @keyframes drift{
      from{transform:translate3d(-3%, -2%, 0) rotate(0deg)}
      to{transform:translate3d(3%, 2%, 0) rotate(360deg)}
    }

    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:18px 18px 12px;
      max-width:1200px; margin:0 auto;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      user-select:none;
    }
    .logo{
      width:38px; height:38px; border-radius:12px;
      background:
        radial-gradient(10px 10px at 30% 35%, rgba(255,255,255,.9), rgba(255,255,255,.0)),
        linear-gradient(135deg, rgba(124,255,232,.95), rgba(154,99,255,.95));
      box-shadow:
        0 0 0 1px rgba(255,255,255,.10) inset,
        0 12px 30px rgba(124,255,232,.15),
        0 18px 44px rgba(154,99,255,.18);
      position:relative;
      overflow:hidden;
    }
    .logo::after{
      content:"";
      position:absolute; inset:-40%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.7), transparent);
      transform: rotate(30deg) translateX(-30%);
      animation: shine 2.8s ease-in-out infinite;
      opacity:.35;
    }
    @keyframes shine{
      0%{transform: rotate(30deg) translateX(-60%)}
      50%{transform: rotate(30deg) translateX(60%)}
      100%{transform: rotate(30deg) translateX(120%)}
    }
    .brand h1{
      font-size:14px;
      letter-spacing:.12em;
      text-transform:uppercase;
      margin:0;
      color:rgba(232,240,255,.86);
    }
    .brand .sub{
      font-family:var(--mono);
      font-size:12px;
      color:rgba(232,240,255,.56);
      margin-top:2px;
    }
    .top-right{
      display:flex; align-items:center; gap:10px;
    }

    .chip{
      padding:8px 10px;
      background: rgba(16, 18, 38, .52);
      border:1px solid var(--stroke);
      border-radius:999px;
      box-shadow: 0 12px 28px rgba(0,0,0,.25);
      font-family: var(--mono);
      font-size:12px;
      color: rgba(232,240,255,.78);
      display:flex; align-items:center; gap:8px;
    }
    .chip b{
      font-family: var(--sans);
      letter-spacing:.08em;
      font-size:11px;
      text-transform:uppercase;
      color: rgba(232,240,255,.62);
      font-weight:600;
    }
    .dot{
      width:8px;height:8px;border-radius:999px;
      background: rgba(255,255,255,.18);
      box-shadow: 0 0 18px rgba(255,255,255,.12);
    }
    .dot.on{ background: var(--ok); box-shadow: 0 0 22px rgba(124,255,232,.45), 0 0 38px rgba(124,255,232,.22);}

    main{
      max-width:1200px; margin:0 auto;
      padding: 6px 18px 24px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 14px;
    }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
    }

    .panel{
      background: linear-gradient(180deg, rgba(16,18,38,.68), rgba(10,12,26,.52));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .panel::before{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(800px 120px at 30% 0%, rgba(124,255,232,.10), transparent 55%),
        radial-gradient(600px 160px at 90% 0%, rgba(154,99,255,.12), transparent 55%);
      pointer-events:none;
      opacity:.95;
    }
    .panel > *{ position:relative; }

    .controls{
      padding:14px;
      display:flex; flex-direction:column; gap:12px;
    }
    .section-title{
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(130,150,255,.12);
      background: rgba(255,255,255,.02);
    }
    .section-title h2{
      margin:0;
      font-size:12px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color: rgba(232,240,255,.70);
      font-weight:650;
    }
    .section-title .hint{
      font-family: var(--mono);
      font-size:11px;
      color: rgba(232,240,255,.52);
    }

    .grid-panel{
      padding: 12px 12px 14px;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      background: rgba(255,255,255,.02);
      border: 1px solid rgba(130,150,255,.10);
      border-radius: var(--radius2);
    }
    .row .col{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    label{
      display:flex; align-items:baseline; justify-content:space-between;
      gap:10px;
      color: rgba(232,240,255,.72);
      font-size:12px;
      letter-spacing:.02em;
    }
    label .value{
      font-family: var(--mono);
      color: rgba(232,240,255,.82);
      font-size:12px;
    }
    input[type="range"]{
      width:100%;
      accent-color: rgba(124,255,232,.92);
    }
    input[type="number"], select, input[type="text"], textarea{
      width:100%;
      background: rgba(5,6,18,.55);
      border:1px solid rgba(130,150,255,.18);
      color: rgba(232,240,255,.88);
      border-radius: 12px;
      padding: 10px 12px;
      outline:none;
      box-shadow: 0 0 0 1px rgba(255,255,255,.05) inset;
    }
    input[type="text"]::placeholder, textarea::placeholder{color: rgba(232,240,255,.40)}
    select{appearance:none; background-image: linear-gradient(45deg, transparent 50%, rgba(232,240,255,.55) 50%), linear-gradient(135deg, rgba(232,240,255,.55) 50%, transparent 50%); background-position: calc(100% - 18px) 18px, calc(100% - 12px) 18px; background-size: 6px 6px, 6px 6px; background-repeat:no-repeat; padding-right: 34px;}

    .btns{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      padding:12px 12px;
      border-radius: 14px;
      border:1px solid rgba(130,150,255,.20);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color: rgba(232,240,255,.86);
      cursor:pointer;
      user-select:none;
      font-weight:650;
      letter-spacing:.02em;
      box-shadow: 0 14px 26px rgba(0,0,0,.25);
      transition: transform .08s ease, border-color .15s ease, background .15s ease, box-shadow .15s ease;
    }
    .btn:hover{ border-color: rgba(124,255,232,.45); box-shadow: 0 18px 38px rgba(0,0,0,.32), 0 0 0 1px rgba(124,255,232,.10) inset;}
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn.primary{
      border-color: rgba(124,255,232,.40);
      background: linear-gradient(180deg, rgba(124,255,232,.18), rgba(154,99,255,.10));
    }
    .btn.danger{
      border-color: rgba(255,98,162,.36);
      background: linear-gradient(180deg, rgba(255,98,162,.14), rgba(255,255,255,.02));
    }
    .btn.ghost{
      background: rgba(0,0,0,.0);
      border-color: rgba(130,150,255,.16);
    }
    .btn.small{ padding:10px 12px; border-radius:12px; font-weight:600; }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    .transport{
      display:grid; grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .transport .btn{ grid-column: span 1;}
    .transport .btn.play{ grid-column: span 2; }

    .kbd{
      font-family: var(--mono);
      font-size:11px;
      color: rgba(232,240,255,.62);
      border: 1px solid rgba(130,150,255,.18);
      border-bottom-color: rgba(130,150,255,.08);
      padding: 2px 7px;
      border-radius: 8px;
      background: rgba(5,6,18,.45);
      box-shadow: 0 1px 0 rgba(255,255,255,.06) inset;
    }

    .grid-header{
      display:grid;
      grid-template-columns: 220px 1fr;
      gap:10px;
      align-items:end;
      margin-bottom: 10px;
    }
    .timeline{
      display:grid;
      grid-template-columns: repeat(16, minmax(0, 1fr));
      gap: var(--gap);
    }
    .tick{
      height: 18px;
      border-radius: 10px;
      border:1px solid rgba(130,150,255,.10);
      background: rgba(255,255,255,.02);
      font-family: var(--mono);
      font-size:11px;
      display:flex; align-items:center; justify-content:center;
      color: rgba(232,240,255,.42);
    }
    .tick.bar{ color: rgba(232,240,255,.62); border-color: rgba(124,255,232,.22); background: rgba(124,255,232,.05); }

    .tracks{
      display:flex; flex-direction:column; gap:10px;
      padding-bottom: 2px;
    }

    .track{
      display:grid;
      grid-template-columns: 220px 1fr;
      gap:10px;
      align-items:center;
    }
    .track .meta{
      height: var(--rowH);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid rgba(130,150,255,.12);
      background: rgba(255,255,255,.02);
    }
    .tname{
      display:flex; align-items:center; gap:10px;
      min-width:0;
    }
    .pill{
      width:10px; height:10px; border-radius: 999px;
      background: rgba(255,255,255,.18);
      box-shadow: 0 0 22px rgba(255,255,255,.08);
      flex:0 0 auto;
    }
    .tlabel{
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color: rgba(232,240,255,.78);
      font-weight:750;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .meta-controls{
      display:flex; align-items:center; gap:8px;
      flex:0 0 auto;
    }
    .mini{
      width:34px; height:30px;
      border-radius: 12px;
      border:1px solid rgba(130,150,255,.16);
      background: rgba(5,6,18,.35);
      color: rgba(232,240,255,.76);
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      font-family: var(--mono);
      font-size:11px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.05) inset;
      transition: border-color .15s ease, transform .08s ease, background .15s ease;
    }
    .mini:hover{ border-color: rgba(124,255,232,.35); }
    .mini:active{ transform: translateY(1px); }
    .mini.on{
      border-color: rgba(255,98,162,.45);
      background: rgba(255,98,162,.10);
      color: rgba(255,230,240,.92);
      box-shadow: 0 0 22px rgba(255,98,162,.18);
    }
    .knob{
      width: 76px;
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:flex-end;
    }
    .knob input[type="range"]{ width: 76px; }
    .knob .klabel{
      font-family: var(--mono);
      font-size:11px;
      color: rgba(232,240,255,.55);
    }

    .steps{
      display:grid;
      grid-template-columns: repeat(16, minmax(0, 1fr));
      gap: var(--gap);
      touch-action: manipulation;
    }
    .cell{
      width: 100%;
      height: var(--rowH);
      border-radius: 14px;
      border:1px solid rgba(130,150,255,.12);
      background:
        radial-gradient(18px 18px at 35% 30%, rgba(255,255,255,.10), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset, 0 14px 26px rgba(0,0,0,.18);
      cursor:pointer;
      position:relative;
      overflow:hidden;
      transition: transform .08s ease, border-color .12s ease, background .12s ease, box-shadow .12s ease, filter .12s ease;
    }
    .cell::after{
      content:"";
      position:absolute; inset: -30%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
      transform: rotate(25deg) translateX(-35%);
      opacity:0;
      transition: opacity .18s ease;
    }
    .cell:hover{
      border-color: rgba(124,255,232,.22);
      transform: translateY(-1px);
    }
    .cell:hover::after{ opacity:.25; }
    .cell:active{ transform: translateY(0px) scale(.99); }

    .cell.on{
      border-color: rgba(124,255,232,.52);
      background:
        radial-gradient(18px 18px at 35% 30%, rgba(255,255,255,.22), transparent 60%),
        linear-gradient(180deg, rgba(124,255,232,.18), rgba(154,99,255,.08));
      box-shadow:
        0 0 0 1px rgba(124,255,232,.18) inset,
        0 16px 34px rgba(124,255,232,.12),
        0 20px 44px rgba(0,0,0,.28);
    }
    .cell.accent{
      border-color: rgba(255,219,102,.56);
      background:
        radial-gradient(18px 18px at 35% 30%, rgba(255,255,255,.22), transparent 60%),
        linear-gradient(180deg, rgba(255,219,102,.20), rgba(255,98,162,.08));
      box-shadow:
        0 0 0 1px rgba(255,219,102,.16) inset,
        0 16px 34px rgba(255,219,102,.10),
        0 20px 44px rgba(0,0,0,.28);
    }
    .cell.now{
      outline: 2px solid rgba(255,255,255,.06);
      box-shadow:
        0 0 0 2px rgba(154,99,255,.16) inset,
        0 0 0 1px rgba(255,255,255,.05) inset,
        0 24px 54px rgba(154,99,255,.12),
        0 20px 44px rgba(0,0,0,.28);
      filter: saturate(115%);
    }
    .cell.now::before{
      content:"";
      position:absolute; inset:-1px;
      border-radius: 16px;
      background: radial-gradient(22px 22px at 50% 0%, rgba(154,99,255,.28), transparent 65%);
      pointer-events:none;
    }
    .cell.muted{ opacity:.35; }

    .legend{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding: 10px 12px 0;
      color: rgba(232,240,255,.62);
      font-size:12px;
    }
    .legend .swatch{
      display:flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(130,150,255,.12);
      background: rgba(255,255,255,.02);
    }
    .sq{ width:12px; height:12px; border-radius: 5px; border:1px solid rgba(255,255,255,.10); }
    .sq.off{ background: rgba(255,255,255,.03); }
    .sq.on{ background: rgba(124,255,232,.20); border-color: rgba(124,255,232,.30); }
    .sq.ac{ background: rgba(255,219,102,.18); border-color: rgba(255,219,102,.30); }

    .footer-note{
      padding: 10px 14px 14px;
      color: rgba(232,240,255,.50);
      font-size: 12px;
      line-height: 1.45;
    }
    .footer-note code{ font-family: var(--mono); font-size: 11px; color: rgba(232,240,255,.72); }

    .modal{
      position: fixed; inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 22px;
      background: rgba(0,0,0,.58);
      backdrop-filter: blur(10px);
      z-index: 50;
    }
    .modal.show{ display:flex; }
    .dialog{
      width:min(820px, 100%);
      border-radius: 18px;
      border:1px solid rgba(130,150,255,.18);
      background: linear-gradient(180deg, rgba(16,18,38,.78), rgba(10,12,26,.62));
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .dialog .hd{
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(130,150,255,.12);
      background: rgba(255,255,255,.02);
    }
    .dialog .hd .title{
      display:flex; align-items:center; gap:10px;
      font-weight:800;
      letter-spacing:.08em;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(232,240,255,.78);
    }
    .dialog .bd{ padding: 14px; display:grid; gap:12px; }
    .dialog .ft{ padding: 14px; display:flex; gap:10px; justify-content:flex-end; border-top: 1px solid rgba(130,150,255,.12); background: rgba(255,255,255,.02); }
    textarea{ min-height: 160px; resize: vertical; font-family: var(--mono); font-size: 12px; line-height: 1.35;}
    .two{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 780px){ .two{ grid-template-columns: 1fr; } }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      z-index: 80;
      display:flex; flex-direction:column; gap:8px;
      pointer-events:none;
    }
    .toast .t{
      pointer-events:none;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid rgba(130,150,255,.18);
      background: rgba(16,18,38,.78);
      color: rgba(232,240,255,.86);
      box-shadow: 0 18px 48px rgba(0,0,0,.45);
      font-family: var(--mono);
      font-size: 12px;
      opacity:0;
      transform: translateY(6px);
      animation: pop 2.8s ease forwards;
    }
    .toast .t.ok{ border-color: rgba(124,255,232,.30);}
    .toast .t.warn{ border-color: rgba(255,219,102,.30);}
    .toast .t.bad{ border-color: rgba(255,98,162,.30);}
    @keyframes pop{
      0%{opacity:0; transform: translateY(6px); }
      10%{opacity:1; transform: translateY(0px); }
      80%{opacity:1; transform: translateY(0px); }
      100%{opacity:0; transform: translateY(6px); }
    }

    .arm{
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      z-index: 60;
      background:
        radial-gradient(900px 600px at 30% 25%, rgba(124,255,232,.16), transparent 60%),
        radial-gradient(900px 650px at 80% 35%, rgba(154,99,255,.18), transparent 60%),
        rgba(0,0,0,.60);
      backdrop-filter: blur(10px);
    }
    .arm .card{
      width:min(760px, 100%);
      padding: 18px;
      border-radius: 18px;
      border:1px solid rgba(130,150,255,.20);
      background: linear-gradient(180deg, rgba(16,18,38,.80), rgba(10,12,26,.62));
      box-shadow: 0 28px 90px rgba(0,0,0,.60);
    }
    .arm .card h3{
      margin: 0 0 6px;
      font-size: 13px;
      letter-spacing: .14em;
      text-transform: uppercase;
      color: rgba(232,240,255,.82);
    }
    .arm .card p{
      margin: 0 0 12px;
      color: rgba(232,240,255,.62);
      line-height: 1.45;
      font-size: 13px;
    }
    .arm .row2{
      display:flex; gap: 10px; flex-wrap: wrap; align-items:center; justify-content:space-between;
      margin-top: 12px;
    }
    .arm .row2 .k{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; color: rgba(232,240,255,.52); font-size:12px; }
    .arm .row2 .k .kbd{ pointer-events:none; }

    .sr-only{
      position:absolute;
      width:1px;height:1px;
      padding:0;margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0);
      border:0;
    }

    @media (prefers-reduced-motion: reduce){
      *{ animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; }
      .fx-bg::before{ animation: none !important; }
      .logo::after{ animation: none !important; }
    }
  </style>
</head>
<body class="fx-bg">
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Audio Step Sequencer</h1>
        <div class="sub">16-step drum grid · WebAudio · swing · patterns · wav export</div>
      </div>
    </div>
    <div class="top-right">
      <div class="chip" title="Audio status">
        <span class="dot" id="audioDot" aria-hidden="true"></span>
        <b>Audio</b>
        <span id="audioStatus">locked</span>
      </div>
      <div class="chip" title="Transport">
        <b>Step</b>
        <span id="hudStep">—</span>
        <span style="opacity:.35">/</span>
        <span id="hudBar">—</span>
      </div>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="section-title">
        <h2>Control Deck</h2>
        <div class="hint">Space: play/stop · Shift-click: accent</div>
      </div>
      <div class="controls">
        <div class="row">
          <div class="col">
            <label for="tempo"><span>Tempo</span><span class="value"><span id="tempoVal">124</span> <span style="opacity:.65">BPM</span></span></label>
            <input id="tempo" type="range" min="60" max="190" value="124" step="1" />
          </div>
        </div>
        <div class="row">
          <div class="col">
            <label for="swing"><span>Swing</span><span class="value"><span id="swingVal">12</span><span style="opacity:.65">%</span></span></label>
            <input id="swing" type="range" min="0" max="60" value="12" step="1" />
          </div>
        </div>
        <div class="row">
          <div class="col">
            <label for="volume"><span>Master</span><span class="value"><span id="volVal">85</span><span style="opacity:.65">%</span></span></label>
            <input id="volume" type="range" min="0" max="100" value="85" step="1" />
          </div>
        </div>
        <div class="row">
          <div class="col">
            <label for="space"><span>Space</span><span class="value"><span id="spaceVal">22</span><span style="opacity:.65">%</span></span></label>
            <input id="space" type="range" min="0" max="100" value="22" step="1" />
          </div>
        </div>

        <div class="transport">
          <button class="btn primary play" id="playBtn" type="button" title="Space">
            <span id="playIcon">▶</span>
            <span id="playLabel">Play</span>
          </button>
          <button class="btn ghost" id="tapBtn" type="button" title="Tap tempo">Tap</button>
          <button class="btn ghost" id="clearBtn" type="button">Clear</button>
          <button class="btn ghost" id="randBtn" type="button">Random</button>
          <button class="btn ghost" id="fillBtn" type="button" title="Fill a classic beat">Fill</button>
        </div>

        <div class="row" style="gap:12px; align-items:stretch;">
          <div class="col" style="flex: 1.2;">
            <label for="patternSel"><span>Pattern</span><span class="value" id="patCount">—</span></label>
            <select id="patternSel" aria-label="Pattern select"></select>
          </div>
          <div class="col" style="flex:.8;">
            <label for="patternName"><span>Name</span><span class="value">save</span></label>
            <input id="patternName" type="text" placeholder="e.g. Neon Pulse" />
          </div>
        </div>
        <div class="btns">
          <button class="btn small" id="newBtn" type="button">New</button>
          <button class="btn small" id="saveBtn" type="button">Save</button>
          <button class="btn small" id="dupBtn" type="button">Duplicate</button>
          <button class="btn small danger" id="delBtn" type="button">Delete</button>
        </div>
        <div class="btns">
          <button class="btn small ghost" id="ioBtn" type="button">Import / Export</button>
          <button class="btn small primary" id="wavBtn" type="button">Export WAV</button>
        </div>

        <div class="footer-note">
          Tip: click-drag to paint steps. Each cell cycles <code>off → on → accent</code>.
          Export WAV uses an offline render (no mic, no recording permissions needed).
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="section-title">
        <h2>Neon Grid</h2>
        <div class="hint">16 steps · 4/4 · 1 bar</div>
      </div>
      <div class="grid-panel">
        <div class="grid-header">
          <div class="row" style="margin:0; height: 46px;">
            <div class="col" style="gap:6px;">
              <label><span>Paint</span><span class="value" id="paintModeVal">cycle</span></label>
              <div style="display:flex; gap:8px;">
                <button class="btn small ghost" id="paintCycleBtn" type="button" title="Cycle mode">Cycle</button>
                <button class="btn small ghost" id="paintOnBtn" type="button" title="Always paint ON">On</button>
                <button class="btn small ghost" id="paintOffBtn" type="button" title="Always paint OFF">Off</button>
              </div>
            </div>
          </div>
          <div class="timeline" id="timeline"></div>
        </div>

        <div class="tracks" id="tracks"></div>

        <div class="legend">
          <div class="swatch"><span class="sq off"></span> Off</div>
          <div class="swatch"><span class="sq on"></span> On</div>
          <div class="swatch"><span class="sq ac"></span> Accent</div>
          <div class="swatch"><span class="kbd">Space</span> Play/Stop</div>
          <div class="swatch"><span class="kbd">R</span> Random</div>
          <div class="swatch"><span class="kbd">C</span> Clear</div>
        </div>
      </div>
    </section>
  </main>

  <div class="arm" id="arm" role="dialog" aria-modal="true" aria-label="Enable audio">
    <div class="card">
      <h3>Arm the Audio Reactor</h3>
      <p>Browsers require a gesture before sound can play. Click <b>Arm Audio</b>, then hit <b>Play</b>. The sequencer uses the WebAudio API (synth drums, no samples).</p>
      <div class="row2">
        <div class="k">
          <span class="kbd">Space</span><span>play/stop</span>
          <span class="kbd">Shift</span><span>accent</span>
          <span class="kbd">Drag</span><span>paint</span>
        </div>
        <button class="btn primary" id="armBtn" type="button">Arm Audio</button>
      </div>
    </div>
  </div>

  <div class="modal" id="ioModal" role="dialog" aria-modal="true" aria-label="Import/Export">
    <div class="dialog">
      <div class="hd">
        <div class="title">Import / Export</div>
        <button class="mini" id="ioClose" type="button" aria-label="Close">✕</button>
      </div>
      <div class="bd">
        <div class="two">
          <div>
            <label><span>Export JSON</span><span class="value">share</span></label>
            <textarea id="exportBox" readonly></textarea>
          </div>
          <div>
            <label><span>Import JSON</span><span class="value">paste</span></label>
            <textarea id="importBox" placeholder='Paste JSON here, then click "Import".'></textarea>
          </div>
        </div>
        <div class="row" style="margin:0;">
          <div class="col" style="gap:10px;">
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button class="btn small" id="copyExportBtn" type="button">Copy Export</button>
              <button class="btn small" id="downloadJsonBtn" type="button">Download JSON</button>
              <button class="btn small primary" id="importBtn" type="button">Import</button>
              <button class="btn small danger" id="wipeBtn" type="button" title="Remove all saved patterns from this browser">Wipe Local Patterns</button>
            </div>
            <div style="color: rgba(232,240,255,.52); font-size:12px; line-height:1.45;">
              Export includes the grid, per-track volume/mute, and global controls (tempo/swing/space). Import merges patterns (same name overwrites).
            </div>
          </div>
        </div>
      </div>
      <div class="ft">
        <button class="btn ghost" id="ioDone" type="button">Done</button>
      </div>
    </div>
  </div>

  <div class="modal" id="wavModal" role="dialog" aria-modal="true" aria-label="Export WAV">
    <div class="dialog">
      <div class="hd">
        <div class="title">Export WAV</div>
        <button class="mini" id="wavClose" type="button" aria-label="Close">✕</button>
      </div>
      <div class="bd">
        <div class="row" style="margin:0;">
          <div class="col">
            <label for="bars"><span>Bars to render</span><span class="value"><span id="barsVal">2</span></span></label>
            <input id="bars" type="range" min="1" max="8" value="2" step="1" />
          </div>
        </div>
        <div class="row" style="margin:0;">
          <div class="col">
            <label><span>Status</span><span class="value" id="wavStatus">ready</span></label>
            <div style="height: 12px; border-radius: 999px; border:1px solid rgba(130,150,255,.16); background: rgba(5,6,18,.45); overflow:hidden;">
              <div id="wavProg" style="height:100%; width:0%; background: linear-gradient(90deg, rgba(124,255,232,.55), rgba(154,99,255,.55)); box-shadow: 0 0 24px rgba(124,255,232,.15);"></div>
            </div>
          </div>
        </div>
        <div style="color: rgba(232,240,255,.52); font-size:12px; line-height:1.45;">
          WAV export runs an offline render for consistent timing (including swing). The file downloads as 16-bit PCM stereo.
        </div>
      </div>
      <div class="ft">
        <button class="btn ghost" id="wavCancel" type="button">Cancel</button>
        <button class="btn primary" id="wavGo" type="button">Render & Download</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" aria-live="polite" aria-atomic="true"></div>

  <script>
    (() => {
      "use strict";

      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
      const clamp = (n, a, b) => Math.min(b, Math.max(a, n));
      const nowISO = () => new Date().toISOString().replace(/[:.]/g, "-");

      const STORAGE_KEY = "audio-step-sequencer.patterns.v1";
      const MAX_NAME = 42;

      const ui = {
        arm: $("#arm"),
        armBtn: $("#armBtn"),
        audioDot: $("#audioDot"),
        audioStatus: $("#audioStatus"),
        hudStep: $("#hudStep"),
        hudBar: $("#hudBar"),

        tempo: $("#tempo"),
        tempoVal: $("#tempoVal"),
        swing: $("#swing"),
        swingVal: $("#swingVal"),
        volume: $("#volume"),
        volVal: $("#volVal"),
        space: $("#space"),
        spaceVal: $("#spaceVal"),

        playBtn: $("#playBtn"),
        playLabel: $("#playLabel"),
        playIcon: $("#playIcon"),
        tapBtn: $("#tapBtn"),
        clearBtn: $("#clearBtn"),
        randBtn: $("#randBtn"),
        fillBtn: $("#fillBtn"),

        patternSel: $("#patternSel"),
        patternName: $("#patternName"),
        patCount: $("#patCount"),
        newBtn: $("#newBtn"),
        saveBtn: $("#saveBtn"),
        dupBtn: $("#dupBtn"),
        delBtn: $("#delBtn"),
        ioBtn: $("#ioBtn"),
        wavBtn: $("#wavBtn"),

        timeline: $("#timeline"),
        tracks: $("#tracks"),

        paintModeVal: $("#paintModeVal"),
        paintCycleBtn: $("#paintCycleBtn"),
        paintOnBtn: $("#paintOnBtn"),
        paintOffBtn: $("#paintOffBtn"),

        ioModal: $("#ioModal"),
        ioClose: $("#ioClose"),
        ioDone: $("#ioDone"),
        exportBox: $("#exportBox"),
        importBox: $("#importBox"),
        copyExportBtn: $("#copyExportBtn"),
        downloadJsonBtn: $("#downloadJsonBtn"),
        importBtn: $("#importBtn"),
        wipeBtn: $("#wipeBtn"),

        wavModal: $("#wavModal"),
        wavClose: $("#wavClose"),
        wavCancel: $("#wavCancel"),
        wavGo: $("#wavGo"),
        bars: $("#bars"),
        barsVal: $("#barsVal"),
        wavStatus: $("#wavStatus"),
        wavProg: $("#wavProg"),

        toast: $("#toast"),
      };

      const TRACKS = [
        { id:"kick",  name:"Kick",  color:"rgba(124,255,232,.95)" },
        { id:"snare", name:"Snare", color:"rgba(154,99,255,.95)" },
        { id:"hat",   name:"Hat",   color:"rgba(255,219,102,.95)" },
        { id:"clap",  name:"Clap",  color:"rgba(255,98,162,.95)" },
        { id:"perc",  name:"Perc",  color:"rgba(124,180,255,.95)" },
      ];

      const defaultState = () => ({
        tempo: 124,
        swingPct: 12,
        masterPct: 85,
        spacePct: 22,
        paintMode: "cycle", // cycle|on|off
        playing: false,
        currentStep: -1,
        currentBar: 1,
        selectedPattern: "Neon Pulse",
        steps: TRACKS.map(() => Array(16).fill(0)), // 0=off, 1=on, 2=accent
        trackSettings: TRACKS.reduce((acc, t) => {
          acc[t.id] = { vol: 0.85, mute: false };
          return acc;
        }, {}),
      });

      const state = defaultState();
      let patterns = {}; // name -> snapshot

      // Audio engine
      let audio = {
        ctx: null,
        master: null,
        comp: null,
        dry: null,
        wet: null,
        convolver: null,
        clock: {
          timerId: null,
          startTime: 0,
          nextTime: 0,
          step: 0,
          bar: 1,
          events: [],
        },
        unlocked: false,
      };

      const toast = (msg, kind="ok") => {
        const el = document.createElement("div");
        el.className = `t ${kind}`;
        el.textContent = msg;
        ui.toast.appendChild(el);
        setTimeout(() => el.remove(), 3200);
      };

      function setAudioStatus() {
        ui.audioDot.classList.toggle("on", !!audio.unlocked);
        ui.audioStatus.textContent = audio.unlocked ? "armed" : "locked";
      }

      function sanitizeName(name) {
        const n = (name || "").trim().replace(/\s+/g, " ");
        return n.slice(0, MAX_NAME);
      }

      function stepDurationSec(bpm) {
        // 16th note in 4/4: quarter = 60/bpm, 16th = quarter/4
        return (60 / bpm) / 4;
      }

      function swingAmount() {
        // 0..0.60
        return clamp(state.swingPct / 100, 0, 0.60);
      }

      function getCellVelocity(val) {
        if (val === 2) return 1.0;
        if (val === 1) return 0.72;
        return 0.0;
      }

      function seedTimeline() {
        ui.timeline.innerHTML = "";
        for (let i = 0; i < 16; i++) {
          const div = document.createElement("div");
          div.className = "tick" + (i % 4 === 0 ? " bar" : "");
          div.textContent = (i % 4 === 0) ? String(i/4 + 1) : "·";
          ui.timeline.appendChild(div);
        }
      }

      function renderTracks() {
        ui.tracks.innerHTML = "";
        TRACKS.forEach((t, trackIndex) => {
          const track = document.createElement("div");
          track.className = "track";
          track.dataset.track = t.id;

          const meta = document.createElement("div");
          meta.className = "meta";
          const tname = document.createElement("div");
          tname.className = "tname";
          const pill = document.createElement("span");
          pill.className = "pill";
          pill.style.background = t.color;
          pill.style.boxShadow = `0 0 24px ${t.color.replace(")", ", .20)")}, 0 0 44px ${t.color.replace(")", ", .10)")}`;
          const label = document.createElement("div");
          label.className = "tlabel";
          label.textContent = t.name;
          tname.appendChild(pill);
          tname.appendChild(label);

          const metaControls = document.createElement("div");
          metaControls.className = "meta-controls";

          const mute = document.createElement("button");
          mute.className = "mini";
          mute.type = "button";
          mute.textContent = "M";
          mute.title = "Mute";
          mute.classList.toggle("on", !!state.trackSettings[t.id].mute);
          mute.addEventListener("click", () => {
            state.trackSettings[t.id].mute = !state.trackSettings[t.id].mute;
            mute.classList.toggle("on", state.trackSettings[t.id].mute);
            updateCellsMuted();
            persistDraft();
          });

          const knob = document.createElement("div");
          knob.className = "knob";
          const klabel = document.createElement("div");
          klabel.className = "klabel";
          klabel.textContent = "VOL";
          const slider = document.createElement("input");
          slider.type = "range";
          slider.min = "0";
          slider.max = "100";
          slider.step = "1";
          slider.value = String(Math.round(state.trackSettings[t.id].vol * 100));
          slider.addEventListener("input", () => {
            state.trackSettings[t.id].vol = clamp(Number(slider.value) / 100, 0, 1);
            persistDraft();
          });
          knob.appendChild(klabel);
          knob.appendChild(slider);

          metaControls.appendChild(mute);
          metaControls.appendChild(knob);
          meta.appendChild(tname);
          meta.appendChild(metaControls);

          const steps = document.createElement("div");
          steps.className = "steps";
          for (let s = 0; s < 16; s++) {
            const btn = document.createElement("button");
            btn.className = "cell";
            btn.type = "button";
            btn.dataset.t = String(trackIndex);
            btn.dataset.s = String(s);
            btn.setAttribute("aria-label", `${t.name} step ${s+1}`);
            btn.addEventListener("pointerdown", onCellPointerDown);
            btn.addEventListener("pointerenter", onCellPointerEnter);
            steps.appendChild(btn);
          }

          track.appendChild(meta);
          track.appendChild(steps);
          ui.tracks.appendChild(track);
        });
        applyGridClasses();
      }

      function applyGridClasses() {
        $$(".cell", ui.tracks).forEach((cell) => {
          const ti = Number(cell.dataset.t);
          const si = Number(cell.dataset.s);
          const val = state.steps[ti][si];
          cell.classList.toggle("on", val === 1);
          cell.classList.toggle("accent", val === 2);
        });
        updateCellsMuted();
        updateNowHighlight();
      }

      function updateCellsMuted() {
        TRACKS.forEach((t, trackIndex) => {
          const muted = !!state.trackSettings[t.id].mute;
          $$(`.cell[data-t="${trackIndex}"]`, ui.tracks).forEach((cell) => {
            cell.classList.toggle("muted", muted);
          });
        });
      }

      function updateNowHighlight() {
        $$(".cell.now", ui.tracks).forEach(el => el.classList.remove("now"));
        if (state.currentStep < 0) return;
        $$(".cell", ui.tracks).forEach((cell) => {
          if (Number(cell.dataset.s) === state.currentStep) cell.classList.add("now");
        });
      }

      // Paint / pointer interaction
      let paint = { down: false, value: null, mode: "cycle" };

      function setPaintMode(mode){
        state.paintMode = mode;
        paint.mode = mode;
        ui.paintModeVal.textContent = mode;
        const btns = [ui.paintCycleBtn, ui.paintOnBtn, ui.paintOffBtn];
        btns.forEach(b => b.classList.remove("primary"));
        if (mode === "cycle") ui.paintCycleBtn.classList.add("primary");
        if (mode === "on") ui.paintOnBtn.classList.add("primary");
        if (mode === "off") ui.paintOffBtn.classList.add("primary");
        persistDraft();
      }

      function cycleCell(val, accent) {
        if (accent) {
          // shift-click toggles accent with a nice rule
          if (val === 2) return 0;
          return 2;
        }
        if (val === 0) return 1;
        if (val === 1) return 2;
        return 0;
      }

      function setCellValue(ti, si, nextVal){
        state.steps[ti][si] = nextVal;
        const cell = $(`.cell[data-t="${ti}"][data-s="${si}"]`, ui.tracks);
        if (cell){
          cell.classList.toggle("on", nextVal === 1);
          cell.classList.toggle("accent", nextVal === 2);
        }
      }

      function resolvePaintValue(ti, si, ev){
        const curr = state.steps[ti][si];
        const accent = !!ev.shiftKey;
        if (paint.mode === "on") return accent ? 2 : 1;
        if (paint.mode === "off") return 0;
        return cycleCell(curr, accent);
      }

      function onCellPointerDown(ev){
        const target = ev.currentTarget;
        if (!(target instanceof HTMLElement)) return;
        target.setPointerCapture?.(ev.pointerId);
        paint.down = true;
        const ti = Number(target.dataset.t);
        const si = Number(target.dataset.s);
        const v = resolvePaintValue(ti, si, ev);
        paint.value = v;
        setCellValue(ti, si, v);
        if (audio.unlocked) tryAuditionHit(ti, v);
        persistDraft();
      }
      function onCellPointerEnter(ev){
        if (!paint.down) return;
        const target = ev.currentTarget;
        if (!(target instanceof HTMLElement)) return;
        const ti = Number(target.dataset.t);
        const si = Number(target.dataset.s);
        const v = paint.value ?? 1;
        setCellValue(ti, si, v);
        persistDraft(true);
      }
      const endPaint = () => { paint.down = false; paint.value = null; };
      window.addEventListener("pointerup", endPaint);
      window.addEventListener("pointercancel", endPaint);

      function tryAuditionHit(trackIndex, stepVal){
        if (!audio.ctx || audio.ctx.state !== "running") return;
        if (getCellVelocity(stepVal) <= 0) return;
        const t = TRACKS[trackIndex];
        const vel = getCellVelocity(stepVal) * 0.9;
        triggerVoice(t.id, audio.ctx, audio.dry, audio.wet, audio.ctx.currentTime + 0.005, vel, state.trackSettings[t.id], state.spacePct);
      }

      // Patterns
      function snapshotCurrent(name){
        return {
          name,
          tempo: state.tempo,
          swingPct: state.swingPct,
          masterPct: state.masterPct,
          spacePct: state.spacePct,
          steps: state.steps.map(row => row.slice()),
          trackSettings: JSON.parse(JSON.stringify(state.trackSettings)),
          updatedAt: Date.now(),
          version: 1,
        };
      }

      function applySnapshot(snap){
        if (!snap) return;
        state.tempo = clamp(Math.round(Number(snap.tempo ?? state.tempo)), 40, 240);
        state.swingPct = clamp(Math.round(Number(snap.swingPct ?? state.swingPct)), 0, 60);
        state.masterPct = clamp(Math.round(Number(snap.masterPct ?? state.masterPct)), 0, 100);
        state.spacePct = clamp(Math.round(Number(snap.spacePct ?? state.spacePct)), 0, 100);
        if (Array.isArray(snap.steps) && snap.steps.length === TRACKS.length) {
          state.steps = snap.steps.map((row, i) => {
            const out = Array(16).fill(0);
            if (Array.isArray(row)) {
              for (let s = 0; s < 16; s++) out[s] = clamp(Number(row[s] ?? 0) | 0, 0, 2);
            }
            return out;
          });
        }
        if (snap.trackSettings && typeof snap.trackSettings === "object") {
          TRACKS.forEach((t) => {
            const src = snap.trackSettings[t.id] || {};
            state.trackSettings[t.id] = {
              vol: clamp(Number(src.vol ?? state.trackSettings[t.id].vol), 0, 1),
              mute: !!src.mute,
            };
          });
        }
        ui.tempo.value = String(state.tempo);
        ui.swing.value = String(state.swingPct);
        ui.volume.value = String(state.masterPct);
        ui.space.value = String(state.spacePct);
        updateControlLabels();
        renderTracks();
        updateMasterFromUI();
      }

      function loadPatterns(){
        try{
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return {};
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== "object") return {};
          return parsed;
        } catch { return {}; }
      }

      function savePatterns(){
        try{
          localStorage.setItem(STORAGE_KEY, JSON.stringify(patterns));
        } catch {
          toast("LocalStorage full or blocked", "warn");
        }
        updatePatternUI();
      }

      function ensureDefaultPatterns(){
        const have = Object.keys(patterns);
        if (have.length) return;

        const mk = (name, stepsByTrack, opts={}) => {
          const snap = snapshotCurrent(name);
          snap.tempo = opts.tempo ?? snap.tempo;
          snap.swingPct = opts.swingPct ?? snap.swingPct;
          snap.spacePct = opts.spacePct ?? snap.spacePct;
          snap.masterPct = opts.masterPct ?? snap.masterPct;
          snap.steps = TRACKS.map((t) => {
            const row = stepsByTrack[t.id] || [];
            const out = Array(16).fill(0);
            row.forEach((val, idx) => { if (idx >= 0 && idx < 16) out[idx] = val; });
            return out;
          });
          if (opts.trackSettings) snap.trackSettings = opts.trackSettings;
          return snap;
        };

        patterns["Neon Pulse"] = mk("Neon Pulse", {
          kick:  [2,0,0,0, 1,0,0,0, 2,0,0,0, 1,0,0,0],
          snare: [0,0,0,0, 2,0,0,0, 0,0,0,0, 2,0,0,0],
          hat:   [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
          clap:  [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,1,0],
          perc:  [0,0,0,1, 0,0,0,0, 0,2,0,0, 0,0,0,0],
        }, { tempo: 124, swingPct: 12, spacePct: 22 });

        patterns["Cyber Funk"] = mk("Cyber Funk", {
          kick:  [2,0,0,0, 0,0,2,0, 1,0,0,0, 0,0,2,0],
          snare: [0,0,0,0, 2,0,0,0, 0,0,0,0, 2,0,0,0],
          hat:   [1,1,0,1, 1,1,0,1, 1,1,0,1, 1,1,0,1],
          clap:  [0,0,0,0, 0,0,0,0, 0,0,0,0, 1,0,0,0],
          perc:  [0,0,2,0, 0,1,0,0, 0,0,1,0, 0,2,0,0],
        }, { tempo: 112, swingPct: 24, spacePct: 30 });

        patterns["Glass Break"] = mk("Glass Break", {
          kick:  [2,0,0,0, 0,0,0,0, 2,0,1,0, 0,0,0,1],
          snare: [0,0,0,0, 2,0,0,0, 0,0,0,0, 2,0,0,0],
          hat:   [1,0,1,2, 1,0,1,0, 1,0,1,2, 1,0,1,0],
          clap:  [0,0,0,0, 0,0,0,0, 0,0,0,0, 2,0,0,0],
          perc:  [0,0,0,0, 0,2,0,0, 0,0,0,0, 0,0,2,0],
        }, { tempo: 136, swingPct: 8, spacePct: 18 });

        savePatterns();
      }

      function updatePatternUI(){
        const names = Object.keys(patterns).sort((a,b) => a.localeCompare(b));
        ui.patternSel.innerHTML = "";
        names.forEach((name) => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          ui.patternSel.appendChild(opt);
        });
        ui.patCount.textContent = `${names.length} saved`;

        if (!patterns[state.selectedPattern] && names.length) state.selectedPattern = names[0];
        ui.patternSel.value = state.selectedPattern || (names[0] || "");
        ui.patternName.value = state.selectedPattern || "";

        // Update export box
        ui.exportBox.value = JSON.stringify({ patterns }, null, 2);
      }

      function persistDraft(silent=false){
        // Save current pattern snapshot as a "draft" in memory (not auto-writing to storage unless pattern exists)
        const name = sanitizeName(ui.patternName.value || state.selectedPattern || "");
        if (!name) return;
        if (!patterns[name] && !silent) return;
        patterns[name] = snapshotCurrent(name);
        state.selectedPattern = name;
        savePatterns();
        ui.patternSel.value = name;
        ui.patternName.value = name;
      }

      // WebAudio voices
      function makeImpulseResponse(ctx, seconds=1.6, decay=3.2) {
        const rate = ctx.sampleRate;
        const length = Math.floor(rate * seconds);
        const buffer = ctx.createBuffer(2, length, rate);
        for (let ch = 0; ch < 2; ch++) {
          const data = buffer.getChannelData(ch);
          for (let i = 0; i < length; i++) {
            const t = i / length;
            const env = Math.pow(1 - t, decay);
            data[i] = (Math.random() * 2 - 1) * env;
          }
        }
        return buffer;
      }

      function ensureAudio(){
        if (audio.ctx) return audio.ctx;
        const ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });
        const master = ctx.createGain();
        const comp = ctx.createDynamicsCompressor();
        const dry = ctx.createGain();
        const wet = ctx.createGain();
        const convolver = ctx.createConvolver();
        convolver.buffer = makeImpulseResponse(ctx, 1.65, 3.4);

        // FX chain: dry + wet(reverb) into compressor into master into destination
        dry.gain.value = 1.0;
        wet.gain.value = 1.0;
        comp.threshold.value = -18;
        comp.knee.value = 18;
        comp.ratio.value = 3.5;
        comp.attack.value = 0.004;
        comp.release.value = 0.12;
        master.gain.value = 0.85;

        dry.connect(comp);
        wet.connect(convolver);
        convolver.connect(comp);
        comp.connect(master);
        master.connect(ctx.destination);

        audio.ctx = ctx;
        audio.master = master;
        audio.comp = comp;
        audio.dry = dry;
        audio.wet = wet;
        audio.convolver = convolver;
        audio.unlocked = (ctx.state === "running");
        setAudioStatus();
        return ctx;
      }

      function updateMasterFromUI(){
        state.tempo = Number(ui.tempo.value) | 0;
        state.swingPct = Number(ui.swing.value) | 0;
        state.masterPct = Number(ui.volume.value) | 0;
        state.spacePct = Number(ui.space.value) | 0;
        if (audio.master) audio.master.gain.setTargetAtTime(clamp(state.masterPct/100, 0, 1), audio.ctx.currentTime, 0.02);
      }

      function noiseBuffer(ctx, seconds=0.22){
        const len = Math.floor(ctx.sampleRate * seconds);
        const buffer = ctx.createBuffer(1, len, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<len;i++) data[i] = Math.random()*2 - 1;
        return buffer;
      }

      const sharedNoise = new WeakMap(); // ctx -> AudioBuffer
      function getNoise(ctx){
        if (!sharedNoise.has(ctx)) sharedNoise.set(ctx, noiseBuffer(ctx, 0.5));
        return sharedNoise.get(ctx);
      }

      function env(gain, t0, a, d, peak){
        gain.cancelScheduledValues(t0);
        gain.setValueAtTime(0.0001, t0);
        gain.exponentialRampToValueAtTime(Math.max(0.0002, peak), t0 + a);
        gain.exponentialRampToValueAtTime(0.0001, t0 + a + d);
      }

      function triggerKick(ctx, dest, time, vel, vol){
        const out = ctx.createGain();
        out.gain.value = vol * vel;
        out.connect(dest);

        const osc = ctx.createOscillator();
        osc.type = "sine";
        const g = ctx.createGain();
        osc.connect(g);
        g.connect(out);

        const f0 = 155;
        osc.frequency.setValueAtTime(f0, time);
        osc.frequency.exponentialRampToValueAtTime(55, time + 0.09);
        osc.frequency.exponentialRampToValueAtTime(38, time + 0.22);
        env(g.gain, time, 0.002, 0.42, 1.0);

        // click
        const n = ctx.createBufferSource();
        n.buffer = getNoise(ctx);
        const nf = ctx.createBiquadFilter();
        nf.type = "highpass";
        nf.frequency.value = 2800;
        const ng = ctx.createGain();
        ng.gain.value = 0.18;
        n.connect(nf); nf.connect(ng); ng.connect(out);
        ng.gain.setValueAtTime(0.0001, time);
        ng.gain.exponentialRampToValueAtTime(0.32, time + 0.001);
        ng.gain.exponentialRampToValueAtTime(0.0001, time + 0.028);

        osc.start(time);
        osc.stop(time + 0.55);
        n.start(time);
        n.stop(time + 0.05);
      }

      function triggerSnare(ctx, dest, time, vel, vol){
        const out = ctx.createGain();
        out.gain.value = vol * vel;
        out.connect(dest);

        const n = ctx.createBufferSource();
        n.buffer = getNoise(ctx);
        const bp = ctx.createBiquadFilter();
        bp.type = "bandpass";
        bp.frequency.value = 1800;
        bp.Q.value = 0.9;
        const hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 600;
        const ng = ctx.createGain();
        n.connect(bp); bp.connect(hp); hp.connect(ng); ng.connect(out);
        env(ng.gain, time, 0.002, 0.22, 1.0);

        const osc = ctx.createOscillator();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(230, time);
        osc.frequency.exponentialRampToValueAtTime(120, time + 0.1);
        const og = ctx.createGain();
        osc.connect(og); og.connect(out);
        env(og.gain, time, 0.001, 0.14, 0.55);

        n.start(time);
        n.stop(time + 0.25);
        osc.start(time);
        osc.stop(time + 0.2);
      }

      function triggerHat(ctx, dest, time, vel, vol, open=false){
        const out = ctx.createGain();
        out.gain.value = vol * vel;
        out.connect(dest);

        const n = ctx.createBufferSource();
        n.buffer = getNoise(ctx);
        const hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 7000;
        const bp = ctx.createBiquadFilter();
        bp.type = "bandpass";
        bp.frequency.value = 9800;
        bp.Q.value = 0.8;
        const ng = ctx.createGain();
        n.connect(hp); hp.connect(bp); bp.connect(ng); ng.connect(out);
        env(ng.gain, time, 0.001, open ? 0.20 : 0.065, open ? 0.65 : 0.9);

        n.start(time);
        n.stop(time + (open ? 0.26 : 0.11));
      }

      function triggerClap(ctx, dest, time, vel, vol){
        const out = ctx.createGain();
        out.gain.value = vol * vel;
        out.connect(dest);
        const n = ctx.createBufferSource();
        n.buffer = getNoise(ctx);
        const hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 1200;
        const bp = ctx.createBiquadFilter();
        bp.type = "bandpass";
        bp.frequency.value = 2600;
        bp.Q.value = 0.7;
        const ng = ctx.createGain();
        n.connect(hp); hp.connect(bp); bp.connect(ng); ng.connect(out);
        ng.gain.setValueAtTime(0.0001, time);
        // multi-burst
        const hits = [0, 0.012, 0.024, 0.048];
        hits.forEach((dt, i) => {
          const t0 = time + dt;
          ng.gain.setValueAtTime(0.0001, t0);
          ng.gain.exponentialRampToValueAtTime(0.9 - i*0.12, t0 + 0.002);
          ng.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.06);
        });
        // tail
        ng.gain.exponentialRampToValueAtTime(0.0001, time + 0.22);

        n.start(time);
        n.stop(time + 0.25);
      }

      function triggerPerc(ctx, dest, time, vel, vol){
        const out = ctx.createGain();
        out.gain.value = vol * vel;
        out.connect(dest);

        const osc = ctx.createOscillator();
        osc.type = "square";
        const f0 = 420;
        osc.frequency.setValueAtTime(f0, time);
        osc.frequency.exponentialRampToValueAtTime(230, time + 0.08);
        const g = ctx.createGain();
        osc.connect(g); g.connect(out);
        env(g.gain, time, 0.001, 0.12, 0.65);

        // bit of noise grit
        const n = ctx.createBufferSource();
        n.buffer = getNoise(ctx);
        const bp = ctx.createBiquadFilter();
        bp.type = "bandpass";
        bp.frequency.value = 3200;
        bp.Q.value = 1.6;
        const ng = ctx.createGain();
        ng.gain.value = 0.12;
        n.connect(bp); bp.connect(ng); ng.connect(out);
        env(ng.gain, time, 0.001, 0.06, 0.35);

        osc.start(time); osc.stop(time + 0.16);
        n.start(time); n.stop(time + 0.09);
      }

      function triggerVoice(id, ctx, dry, wet, time, vel, trackSetting, spacePct){
        const vol = clamp(trackSetting?.vol ?? 0.85, 0, 1) * (trackSetting?.mute ? 0 : 1);
        if (vol <= 0 || vel <= 0) return;
        const send = clamp((spacePct/100) * 0.75, 0, 0.75);

        const bus = ctx.createGain();
        bus.gain.value = vol;
        bus.connect(dry);

        const w = ctx.createGain();
        w.gain.value = send;
        bus.connect(w);
        w.connect(wet);

        if (id === "kick") { triggerKick(ctx, bus, time, vel, 1.0); return; }
        if (id === "snare") { triggerSnare(ctx, bus, time, vel, 1.0); return; }
        if (id === "hat") { triggerHat(ctx, bus, time, vel, 1.0, vel > 0.9); return; }
        if (id === "clap") { triggerClap(ctx, bus, time, vel, 1.0); return; }
        if (id === "perc") { triggerPerc(ctx, bus, time, vel, 1.0); return; }
      }

      // Scheduler
      function scheduleStepAt(stepIndex, time){
        const ctx = audio.ctx;
        if (!ctx) return;
        const bar = audio.clock.bar;
        audio.clock.events.push({ time, step: stepIndex, bar });

        for (let ti = 0; ti < TRACKS.length; ti++) {
          const t = TRACKS[ti];
          const val = state.steps[ti][stepIndex];
          const vel = getCellVelocity(val);
          if (vel <= 0) continue;
          const st = state.trackSettings[t.id];
          triggerVoice(t.id, ctx, audio.dry, audio.wet, time, vel, st, state.spacePct);
        }
      }

      function advanceClock(){
        const d = stepDurationSec(state.tempo);
        const s = swingAmount();
        const isEven = (audio.clock.step % 2 === 0);
        const delta = isEven ? d * (1 + s) : d * (1 - s);
        audio.clock.nextTime += delta;
        audio.clock.step = (audio.clock.step + 1) % 16;
        if (audio.clock.step === 0) audio.clock.bar = audio.clock.bar + 1;
      }

      function schedulerTick(){
        const ctx = audio.ctx;
        if (!ctx) return;
        const lookAhead = 0.12;
        while (audio.clock.nextTime < ctx.currentTime + lookAhead) {
          scheduleStepAt(audio.clock.step, audio.clock.nextTime);
          advanceClock();
        }
      }

      function startTransport(){
        const ctx = ensureAudio();
        if (ctx.state !== "running") ctx.resume();
        audio.unlocked = true; setAudioStatus();

        audio.clock.events.length = 0;
        audio.clock.step = 0;
        audio.clock.bar = 1;
        audio.clock.startTime = ctx.currentTime + 0.05;
        audio.clock.nextTime = audio.clock.startTime;
        state.currentStep = -1;
        state.currentBar = 1;
        updateHUD();
        updateNowHighlight();

        if (audio.clock.timerId) clearInterval(audio.clock.timerId);
        audio.clock.timerId = setInterval(schedulerTick, 25);
        state.playing = true;
        syncPlayUI();
        requestAnimationFrame(drawLoop);
      }

      function stopTransport(){
        if (audio.clock.timerId) clearInterval(audio.clock.timerId);
        audio.clock.timerId = null;
        state.playing = false;
        state.currentStep = -1;
        state.currentBar = 1;
        updateHUD();
        updateNowHighlight();
        syncPlayUI();
      }

      function syncPlayUI(){
        ui.playIcon.textContent = state.playing ? "⏸" : "▶";
        ui.playLabel.textContent = state.playing ? "Stop" : "Play";
      }

      function updateHUD(){
        ui.hudStep.textContent = state.currentStep >= 0 ? String(state.currentStep + 1).padStart(2, "0") : "—";
        ui.hudBar.textContent = state.currentStep >= 0 ? `bar ${state.currentBar}` : "—";
      }

      function drawLoop(){
        if (!state.playing || !audio.ctx) return;
        const t = audio.ctx.currentTime;
        while (audio.clock.events.length && audio.clock.events[0].time <= t) {
          const ev = audio.clock.events.shift();
          state.currentStep = ev.step;
          state.currentBar = ev.bar;
          updateHUD();
          updateNowHighlight();
        }
        requestAnimationFrame(drawLoop);
      }

      // WAV export
      function floatTo16BitPCM(view, offset, input){
        for (let i = 0; i < input.length; i++, offset += 2) {
          let s = clamp(input[i], -1, 1);
          s = s < 0 ? s * 0x8000 : s * 0x7fff;
          view.setInt16(offset, s, true);
        }
      }
      function writeString(view, offset, string){
        for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
      }
      function encodeWAV(audioBuffer){
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const format = 1; // PCM
        const bitDepth = 16;
        const samples = audioBuffer.length;
        const blockAlign = numChannels * bitDepth / 8;
        const byteRate = sampleRate * blockAlign;
        const dataSize = samples * blockAlign;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);
        writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + dataSize, true);
        writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, format, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, byteRate, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bitDepth, true);
        writeString(view, 36, "data");
        view.setUint32(40, dataSize, true);

        // interleave
        const channels = [];
        for (let ch = 0; ch < numChannels; ch++) channels.push(audioBuffer.getChannelData(ch));
        let offset = 44;
        for (let i = 0; i < samples; i++) {
          for (let ch = 0; ch < numChannels; ch++) {
            let s = clamp(channels[ch][i], -1, 1);
            s = s < 0 ? s * 0x8000 : s * 0x7fff;
            view.setInt16(offset, s, true);
            offset += 2;
          }
        }
        return buffer;
      }

      async function renderWav(bars){
        const bpm = state.tempo;
        const swing = swingAmount();
        const dur16 = stepDurationSec(bpm);
        const barDur = 16 * dur16;
        const tail = 1.25;
        const duration = bars * barDur + tail;
        const sampleRate = 44100;

        ui.wavStatus.textContent = "building graph…";
        ui.wavProg.style.width = "8%";

        const offline = new OfflineAudioContext(2, Math.ceil(duration * sampleRate), sampleRate);
        const master = offline.createGain();
        const comp = offline.createDynamicsCompressor();
        const dry = offline.createGain();
        const wet = offline.createGain();
        const convolver = offline.createConvolver();
        convolver.buffer = makeImpulseResponse(offline, 1.65, 3.4);

        dry.gain.value = 1.0;
        wet.gain.value = 1.0;
        comp.threshold.value = -18;
        comp.knee.value = 18;
        comp.ratio.value = 3.5;
        comp.attack.value = 0.004;
        comp.release.value = 0.12;
        master.gain.value = clamp(state.masterPct/100, 0, 1);

        dry.connect(comp);
        wet.connect(convolver);
        convolver.connect(comp);
        comp.connect(master);
        master.connect(offline.destination);

        const scheduleAt = (stepIndex, time) => {
          for (let ti=0; ti<TRACKS.length; ti++){
            const t = TRACKS[ti];
            const v = getCellVelocity(state.steps[ti][stepIndex]);
            if (v <= 0) continue;
            const st = state.trackSettings[t.id];
            triggerVoice(t.id, offline, dry, wet, time, v, st, state.spacePct);
          }
        };

        ui.wavStatus.textContent = "scheduling…";
        ui.wavProg.style.width = "18%";

        let time = 0.05;
        for (let b = 0; b < bars; b++){
          for (let step = 0; step < 16; step++){
            scheduleAt(step, time);
            const isEven = (step % 2 === 0);
            const delta = isEven ? dur16 * (1 + swing) : dur16 * (1 - swing);
            time += delta;
          }
        }

        ui.wavStatus.textContent = "rendering…";
        ui.wavProg.style.width = "40%";
        const buf = await offline.startRendering();
        ui.wavProg.style.width = "72%";
        ui.wavStatus.textContent = "encoding…";
        const wav = encodeWAV(buf);
        ui.wavProg.style.width = "92%";
        ui.wavStatus.textContent = "downloading…";

        const blob = new Blob([wav], { type: "audio/wav" });
        const a = document.createElement("a");
        const safeName = sanitizeName(state.selectedPattern || "pattern").replace(/[^\w\s-]/g, "").trim().replace(/\s+/g, "_") || "pattern";
        a.download = `AudioStepSequencer_${safeName}_${bpm}bpm_${bars}bars_${nowISO()}.wav`;
        a.href = URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(a.href), 2500);

        ui.wavProg.style.width = "100%";
        ui.wavStatus.textContent = "done";
      }

      // Controls wiring
      function updateControlLabels(){
        ui.tempoVal.textContent = String(state.tempo);
        ui.swingVal.textContent = String(state.swingPct);
        ui.volVal.textContent = String(state.masterPct);
        ui.spaceVal.textContent = String(state.spacePct);
      }

      const tap = { times: [] };
      function tapTempo(){
        const t = performance.now();
        tap.times.push(t);
        if (tap.times.length > 8) tap.times.shift();
        if (tap.times.length >= 3){
          const diffs = [];
          for (let i=1; i<tap.times.length; i++) diffs.push(tap.times[i] - tap.times[i-1]);
          const avgMs = diffs.reduce((a,b)=>a+b, 0) / diffs.length;
          const bpm = clamp(Math.round(60000 / avgMs), 60, 190);
          state.tempo = bpm;
          ui.tempo.value = String(bpm);
          updateControlLabels();
          toast(`Tempo ${bpm} BPM`, "ok");
          persistDraft(true);
        } else {
          toast("Tap…", "warn");
        }
      }

      function clearGrid(){
        state.steps = TRACKS.map(() => Array(16).fill(0));
        applyGridClasses();
        persistDraft();
        toast("Cleared", "warn");
      }

      function fillClassic(){
        // A reliable, punchy starter beat
        const g = TRACKS.map(() => Array(16).fill(0));
        const set = (id, arr) => { g[TRACKS.findIndex(t => t.id === id)] = arr.slice(); };
        set("kick",  [2,0,0,0, 1,0,0,0, 2,0,0,0, 1,0,0,0]);
        set("snare", [0,0,0,0, 2,0,0,0, 0,0,0,0, 2,0,0,0]);
        set("hat",   [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0]);
        set("clap",  [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,1,0]);
        set("perc",  [0,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,0]);
        state.steps = g;
        applyGridClasses();
        persistDraft();
        toast("Filled classic beat", "ok");
      }

      function randomize(){
        const density = 0.24;
        state.steps = TRACKS.map((t, ti) => {
          const row = Array(16).fill(0);
          for (let s = 0; s < 16; s++) {
            const base = Math.random();
            let p = density;
            if (t.id === "kick") p = 0.18;
            if (t.id === "snare") p = 0.14;
            if (t.id === "hat") p = 0.42;
            if (t.id === "clap") p = 0.12;
            if (t.id === "perc") p = 0.18;
            const on = base < p;
            if (on) row[s] = (Math.random() < 0.24) ? 2 : 1;
          }
          // strengthen backbeat sometimes
          if (t.id === "snare") { row[4] = 2; row[12] = 2; }
          return row;
        });
        applyGridClasses();
        persistDraft();
        toast("Randomized", "ok");
      }

      function newPattern(){
        const name = sanitizeName(ui.patternName.value) || `Pattern ${Object.keys(patterns).length + 1}`;
        const n = sanitizeName(name);
        if (!n) return;
        if (patterns[n]) {
          toast("Name already exists", "warn");
          return;
        }
        const snap = snapshotCurrent(n);
        snap.steps = TRACKS.map(() => Array(16).fill(0));
        patterns[n] = snap;
        state.selectedPattern = n;
        savePatterns();
        applySnapshot(patterns[n]);
        toast(`New: ${n}`, "ok");
      }

      function savePattern(){
        const name = sanitizeName(ui.patternName.value || state.selectedPattern);
        if (!name) { toast("Add a pattern name", "warn"); return; }
        patterns[name] = snapshotCurrent(name);
        state.selectedPattern = name;
        savePatterns();
        toast(`Saved: ${name}`, "ok");
      }

      function duplicatePattern(){
        const src = state.selectedPattern;
        if (!src || !patterns[src]) { toast("No pattern to duplicate", "warn"); return; }
        let n = `${src} Copy`;
        n = sanitizeName(n);
        let k = 2;
        while (patterns[n]) {
          n = sanitizeName(`${src} Copy ${k++}`);
        }
        patterns[n] = snapshotCurrent(n);
        state.selectedPattern = n;
        savePatterns();
        toast(`Duplicated: ${n}`, "ok");
      }

      function deletePattern(){
        const name = state.selectedPattern;
        const keys = Object.keys(patterns);
        if (!name || !patterns[name]) return;
        if (keys.length <= 1) { toast("Keep at least one pattern", "warn"); return; }
        if (!confirm(`Delete pattern "${name}"?`)) return;
        delete patterns[name];
        const remain = Object.keys(patterns).sort((a,b)=>a.localeCompare(b));
        state.selectedPattern = remain[0];
        savePatterns();
        applySnapshot(patterns[state.selectedPattern]);
        toast("Deleted", "warn");
      }

      function openModal(modal){ modal.classList.add("show"); }
      function closeModal(modal){ modal.classList.remove("show"); }

      async function copyToClipboard(text){
        try{
          await navigator.clipboard.writeText(text);
          toast("Copied to clipboard", "ok");
        } catch {
          toast("Clipboard blocked", "warn");
        }
      }

      function downloadText(filename, text){
        const blob = new Blob([text], { type: "application/json" });
        const a = document.createElement("a");
        a.download = filename;
        a.href = URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(a.href), 2000);
      }

      function importJSON(){
        const raw = ui.importBox.value.trim();
        if (!raw) { toast("Paste JSON first", "warn"); return; }
        try{
          const obj = JSON.parse(raw);
          const incoming = obj.patterns || obj;
          if (!incoming || typeof incoming !== "object") throw new Error("bad json");
          const before = Object.keys(patterns).length;
          Object.entries(incoming).forEach(([name, snap]) => {
            const n = sanitizeName(name);
            if (!n) return;
            patterns[n] = snap;
            patterns[n].name = n;
          });
          savePatterns();
          const after = Object.keys(patterns).length;
          toast(`Imported ${after - before} pattern(s)`, "ok");
        } catch {
          toast("Invalid JSON", "bad");
        }
      }

      function wipePatterns(){
        if (!confirm("Wipe all saved patterns from this browser?")) return;
        patterns = {};
        savePatterns();
        ensureDefaultPatterns();
        state.selectedPattern = Object.keys(patterns)[0];
        applySnapshot(patterns[state.selectedPattern]);
        toast("Wiped local patterns", "warn");
      }

      // Init
      seedTimeline();
      setPaintMode(state.paintMode);

      patterns = loadPatterns();
      ensureDefaultPatterns();
      updatePatternUI();

      // Select initial pattern
      if (!patterns[state.selectedPattern]) state.selectedPattern = ui.patternSel.value || Object.keys(patterns)[0];
      applySnapshot(patterns[state.selectedPattern]);

      // Events: global controls
      ui.tempo.addEventListener("input", () => { updateMasterFromUI(); updateControlLabels(); persistDraft(true); });
      ui.swing.addEventListener("input", () => { updateMasterFromUI(); updateControlLabels(); persistDraft(true); });
      ui.volume.addEventListener("input", () => { updateMasterFromUI(); updateControlLabels(); persistDraft(true); });
      ui.space.addEventListener("input", () => { updateMasterFromUI(); updateControlLabels(); persistDraft(true); });

      ui.playBtn.addEventListener("click", () => {
        if (!audio.unlocked) { ui.arm.style.display = "flex"; return; }
        state.playing ? stopTransport() : startTransport();
      });
      ui.tapBtn.addEventListener("click", () => tapTempo());
      ui.clearBtn.addEventListener("click", () => clearGrid());
      ui.randBtn.addEventListener("click", () => randomize());
      ui.fillBtn.addEventListener("click", () => fillClassic());

      ui.newBtn.addEventListener("click", () => newPattern());
      ui.saveBtn.addEventListener("click", () => savePattern());
      ui.dupBtn.addEventListener("click", () => duplicatePattern());
      ui.delBtn.addEventListener("click", () => deletePattern());

      ui.patternSel.addEventListener("change", () => {
        const name = ui.patternSel.value;
        state.selectedPattern = name;
        ui.patternName.value = name;
        applySnapshot(patterns[name]);
        toast(`Loaded: ${name}`, "ok");
      });

      ui.patternName.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter") { ev.preventDefault(); savePattern(); }
      });

      ui.paintCycleBtn.addEventListener("click", () => setPaintMode("cycle"));
      ui.paintOnBtn.addEventListener("click", () => setPaintMode("on"));
      ui.paintOffBtn.addEventListener("click", () => setPaintMode("off"));

      // Modals
      ui.ioBtn.addEventListener("click", () => { ui.exportBox.value = JSON.stringify({ patterns }, null, 2); openModal(ui.ioModal); ui.importBox.focus(); });
      ui.ioClose.addEventListener("click", () => closeModal(ui.ioModal));
      ui.ioDone.addEventListener("click", () => closeModal(ui.ioModal));
      ui.ioModal.addEventListener("click", (ev) => { if (ev.target === ui.ioModal) closeModal(ui.ioModal); });
      ui.copyExportBtn.addEventListener("click", () => copyToClipboard(ui.exportBox.value));
      ui.downloadJsonBtn.addEventListener("click", () => downloadText(`AudioStepSequencer_patterns_${nowISO()}.json`, ui.exportBox.value));
      ui.importBtn.addEventListener("click", () => importJSON());
      ui.wipeBtn.addEventListener("click", () => wipePatterns());

      ui.wavBtn.addEventListener("click", () => { openModal(ui.wavModal); });
      ui.wavClose.addEventListener("click", () => closeModal(ui.wavModal));
      ui.wavCancel.addEventListener("click", () => closeModal(ui.wavModal));
      ui.wavModal.addEventListener("click", (ev) => { if (ev.target === ui.wavModal) closeModal(ui.wavModal); });
      ui.bars.addEventListener("input", () => { ui.barsVal.textContent = ui.bars.value; });
      ui.wavGo.addEventListener("click", async () => {
        ui.wavGo.disabled = true;
        ui.wavCancel.disabled = true;
        ui.wavClose.disabled = true;
        ui.wavProg.style.width = "0%";
        ui.wavStatus.textContent = "starting…";
        try{
          const bars = Number(ui.bars.value) | 0;
          await renderWav(clamp(bars, 1, 8));
          toast("WAV exported", "ok");
        } catch (e){
          console.error(e);
          ui.wavStatus.textContent = "failed";
          toast("WAV export failed", "bad");
        } finally {
          ui.wavGo.disabled = false;
          ui.wavCancel.disabled = false;
          ui.wavClose.disabled = false;
        }
      });

      // Arm audio
      ui.armBtn.addEventListener("click", async () => {
        try{
          const ctx = ensureAudio();
          await ctx.resume();
          audio.unlocked = true;
          setAudioStatus();
          ui.arm.style.display = "none";
          toast("Audio armed", "ok");
        } catch {
          toast("Audio unavailable", "bad");
        }
      });
      ui.arm.addEventListener("click", (ev) => {
        if (ev.target === ui.arm) ui.armBtn.click();
      });

      // Keyboard shortcuts
      window.addEventListener("keydown", (ev) => {
        if (ev.repeat) return;
        const tag = (document.activeElement?.tagName || "").toLowerCase();
        const inText = tag === "input" || tag === "textarea" || tag === "select";
        if (ev.key === " " && !inText) {
          ev.preventDefault();
          ui.playBtn.click();
        }
        if ((ev.key === "r" || ev.key === "R") && !inText) randomize();
        if ((ev.key === "c" || ev.key === "C") && !inText) clearGrid();
        if (ev.key === "Escape") {
          closeModal(ui.ioModal);
          closeModal(ui.wavModal);
          ui.arm.style.display = audio.unlocked ? "none" : "flex";
        }
      });

      // Keep audio status in sync
      document.addEventListener("visibilitychange", () => {
        if (!audio.ctx) return;
        audio.unlocked = (audio.ctx.state === "running");
        setAudioStatus();
      });

      // Initial UI
      updateMasterFromUI();
      updateControlLabels();
      syncPlayUI();
      setAudioStatus();
      ui.arm.style.display = audio.unlocked ? "none" : "flex";

      toast("Ready. Arm audio to begin.", "ok");
    })();
  </script>
</body>
</html>
