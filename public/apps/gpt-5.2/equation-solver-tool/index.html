<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>Equation Solver Tool</title>
    <style>
      :root {
        --bg: #f6f5f2;
        --panel: #ffffff;
        --ink: #1b1f24;
        --muted: #5b6672;
        --faint: #8a95a1;
        --border: #d9d4cc;
        --border-strong: #b8b0a4;
        --accent: #1f4ea8;
        --accent-2: #0b6b4e;
        --danger: #a11616;
        --shadow: 0 10px 30px rgba(14, 18, 22, 0.08);
        --radius: 14px;
        --radius-sm: 10px;
        --font-serif: ui-serif, "Iowan Old Style", "Palatino Linotype", Palatino, "URW Palladio L", Georgia, serif;
        --font-sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
        --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --line: 1.45;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #0f1113;
          --panel: #15181b;
          --ink: #e9eef3;
          --muted: #b4c0cc;
          --faint: #93a0ad;
          --border: #2a323a;
          --border-strong: #3b4651;
          --accent: #8db4ff;
          --accent-2: #77d6b0;
          --danger: #ff9c9c;
          --shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
        }
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: radial-gradient(1200px 600px at 10% -10%, rgba(31, 78, 168, 0.08), transparent 60%),
          radial-gradient(900px 500px at 100% 0%, rgba(11, 107, 78, 0.08), transparent 55%), var(--bg);
        color: var(--ink);
        font-family: var(--font-serif);
        line-height: var(--line);
      }
      a {
        color: var(--accent);
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      .wrap {
        max-width: 1040px;
        margin: 0 auto;
        padding: 28px 18px 56px;
      }
      header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 16px;
        margin: 10px 0 18px;
      }
      .title {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      h1 {
        margin: 0;
        font-weight: 700;
        letter-spacing: 0.2px;
        font-size: 28px;
      }
      .subtitle {
        font-family: var(--font-sans);
        color: var(--muted);
        font-size: 13px;
      }
      .badge {
        font-family: var(--font-mono);
        font-size: 12px;
        padding: 6px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: color-mix(in oklab, var(--panel), transparent 15%);
        color: var(--muted);
      }
      .grid {
        display: grid;
        grid-template-columns: 1.05fr 0.95fr;
        gap: 16px;
      }
      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: color-mix(in oklab, var(--panel), transparent 6%);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }
      .card-hd {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 14px 16px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(to bottom, color-mix(in oklab, var(--panel), transparent 0%), color-mix(in oklab, var(--panel), transparent 7%));
      }
      .card-hd h2 {
        margin: 0;
        font-size: 15px;
        letter-spacing: 0.2px;
        font-weight: 700;
      }
      .card-bd {
        padding: 16px;
      }
      .hint {
        font-family: var(--font-sans);
        font-size: 12px;
        color: var(--muted);
      }
      .hint code {
        font-family: var(--font-mono);
        font-size: 11px;
        padding: 1px 6px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: color-mix(in oklab, var(--panel), transparent 5%);
        color: var(--ink);
      }

      label {
        display: block;
        font-family: var(--font-sans);
        font-size: 12px;
        color: var(--muted);
        margin: 0 0 6px;
      }
      textarea,
      input,
      select {
        width: 100%;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: color-mix(in oklab, var(--panel), transparent 0%);
        color: var(--ink);
        padding: 12px 12px;
        outline: none;
        font-family: var(--font-mono);
        font-size: 13px;
        line-height: 1.35;
      }
      textarea {
        min-height: 148px;
        resize: vertical;
      }
      textarea:focus,
      input:focus,
      select:focus {
        border-color: color-mix(in oklab, var(--accent), var(--border) 60%);
        box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent), transparent 85%);
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      @media (max-width: 520px) {
        .row {
          grid-template-columns: 1fr;
        }
      }
      .row3 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
      }
      @media (max-width: 760px) {
        .row3 {
          grid-template-columns: 1fr;
        }
      }
      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        margin-top: 10px;
      }
      button {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        background: color-mix(in oklab, var(--panel), transparent 0%);
        color: var(--ink);
        font-family: var(--font-sans);
        font-size: 13px;
        cursor: pointer;
        transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      }
      button:hover {
        border-color: color-mix(in oklab, var(--border-strong), var(--border) 35%);
        transform: translateY(-1px);
      }
      button:active {
        transform: translateY(0px);
      }
      .btn-primary {
        border-color: color-mix(in oklab, var(--accent), var(--border) 50%);
        background: linear-gradient(to bottom, color-mix(in oklab, var(--accent), transparent 90%), transparent),
          color-mix(in oklab, var(--panel), transparent 0%);
      }
      .btn-primary:hover {
        border-color: color-mix(in oklab, var(--accent), var(--border-strong) 30%);
      }
      .btn-ghost {
        background: transparent;
      }
      .btn-danger {
        border-color: color-mix(in oklab, var(--danger), var(--border) 55%);
        color: color-mix(in oklab, var(--danger), var(--ink) 30%);
      }
      .small {
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 10px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-family: var(--font-sans);
        font-size: 12px;
        color: var(--muted);
      }
      .pill b {
        font-family: var(--font-mono);
        font-weight: 700;
        color: var(--ink);
      }

      .divider {
        height: 1px;
        background: var(--border);
        margin: 14px 0;
      }

      .status {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel), transparent 2%);
        font-family: var(--font-sans);
        font-size: 12px;
        color: var(--muted);
      }
      .status .right {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      .dot {
        width: 8px;
        height: 8px;
        border-radius: 99px;
        background: var(--border-strong);
      }
      .dot.ok {
        background: var(--accent-2);
      }
      .dot.warn {
        background: #c48b06;
      }
      .dot.bad {
        background: var(--danger);
      }

      .out {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .k {
        display: inline-flex;
        gap: 10px;
        align-items: baseline;
        flex-wrap: wrap;
      }
      .k .key {
        font-family: var(--font-sans);
        font-size: 12px;
        color: var(--muted);
        min-width: 92px;
      }
      .k .val {
        font-family: var(--font-mono);
        font-size: 12px;
        color: var(--ink);
        opacity: 0.95;
      }
      .math {
        padding: 12px 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel), transparent 3%);
        overflow-x: auto;
      }
      .math .mjx-container {
        overflow-x: auto;
        overflow-y: hidden;
      }
      .steps {
        margin: 0;
        padding-left: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .steps li {
        padding: 10px 10px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel), transparent 2%);
      }
      .step-reason {
        font-family: var(--font-sans);
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 8px;
      }
      .mono {
        font-family: var(--font-mono);
      }
      details {
        border: 1px solid var(--border);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel), transparent 2%);
        padding: 10px 12px;
      }
      summary {
        cursor: pointer;
        font-family: var(--font-sans);
        color: var(--muted);
        font-size: 12px;
        list-style: none;
      }
      summary::-webkit-details-marker {
        display: none;
      }
      summary:before {
        content: "▸";
        margin-right: 8px;
        color: var(--faint);
      }
      details[open] summary:before {
        content: "▾";
      }
      pre {
        margin: 10px 0 0;
        padding: 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel), transparent 3%);
        overflow: auto;
        font-family: var(--font-mono);
        font-size: 12px;
      }
      .error {
        border-color: color-mix(in oklab, var(--danger), var(--border) 55%);
        background: color-mix(in oklab, var(--danger), transparent 92%);
        color: color-mix(in oklab, var(--danger), var(--ink) 25%);
        padding: 10px 12px;
        border-radius: 12px;
        font-family: var(--font-sans);
        font-size: 12px;
      }
      .muted {
        color: var(--muted);
      }
      .history {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .hist-item {
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: color-mix(in oklab, var(--panel), transparent 2%);
        cursor: pointer;
        transition: border-color 120ms ease;
      }
      .hist-item:hover {
        border-color: color-mix(in oklab, var(--border-strong), var(--border) 40%);
      }
      .hist-item .top {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: baseline;
      }
      .hist-item .eq {
        font-family: var(--font-mono);
        font-size: 12px;
        color: var(--ink);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 560px;
      }
      .hist-item .time {
        font-family: var(--font-sans);
        font-size: 11px;
        color: var(--faint);
        white-space: nowrap;
      }
      .hist-item .sub {
        margin-top: 6px;
        font-family: var(--font-sans);
        font-size: 12px;
        color: var(--muted);
      }
      .footer {
        margin-top: 18px;
        padding-top: 12px;
        border-top: 1px solid var(--border);
        font-family: var(--font-sans);
        color: var(--faint);
        font-size: 12px;
        display: flex;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
      }
      .sr-only {
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="title">
          <h1>Equation Solver Tool</h1>
          <div class="subtitle">Solve and explain equations with symbolic + numeric checks. Export a clean report.</div>
        </div>
        <div class="badge" id="libBadge">Loading libraries…</div>
      </header>

      <div class="grid">
        <section class="card" aria-label="Input">
          <div class="card-hd">
            <h2>Problem</h2>
            <div class="pill">
              <span class="dot" id="readyDot" aria-hidden="true"></span>
              <span id="readyText">Initializing</span>
            </div>
          </div>
          <div class="card-bd">
            <label for="input">Enter an equation (or a system, one per line)</label>
            <textarea
              id="input"
              spellcheck="false"
              placeholder="Examples:
2x + 3 = 7
x^2 - 5x + 6 = 0
sin(x) = 1/2
2x + y = 5
x - y = 1"
            ></textarea>
            <div class="hint" style="margin-top: 8px">
              Syntax: <code>^</code> exponent, <code>sqrt()</code>, <code>sin()</code>, <code>cos()</code>, <code>tan()</code>, <code>ln()</code>, <code>log()</code>.
              Shortcut: <code>Ctrl</code>+<code>Enter</code> to solve.
            </div>

            <div class="divider"></div>

            <div class="row3">
              <div>
                <label for="mode">Mode</label>
                <select id="mode">
                  <option value="auto" selected>Auto (equation / system / expression)</option>
                  <option value="equation">Solve a single equation</option>
                  <option value="system">Solve a system (multiple lines)</option>
                  <option value="expression">Simplify &amp; evaluate an expression</option>
                </select>
              </div>
              <div>
                <label for="variable">Solve for</label>
                <select id="variable">
                  <option value="auto" selected>Auto-detect</option>
                  <option value="x">x</option>
                  <option value="y">y</option>
                  <option value="t">t</option>
                </select>
              </div>
              <div>
                <label for="verbosity">Explanation detail</label>
                <select id="verbosity">
                  <option value="standard" selected>Standard</option>
                  <option value="minimal">Minimal</option>
                  <option value="detailed">Detailed</option>
                </select>
              </div>
            </div>

            <details style="margin-top: 10px">
              <summary>Numeric fallback settings</summary>
              <div class="row" style="margin-top: 10px">
                <div>
                  <label for="rangeMin">Search range (min)</label>
                  <input id="rangeMin" inputmode="decimal" value="-10" />
                </div>
                <div>
                  <label for="rangeMax">Search range (max)</label>
                  <input id="rangeMax" inputmode="decimal" value="10" />
                </div>
              </div>
              <div class="row" style="margin-top: 10px">
                <div>
                  <label for="maxRoots">Max numeric roots</label>
                  <input id="maxRoots" inputmode="numeric" value="8" />
                </div>
                <div>
                  <label for="samples">Scan resolution</label>
                  <input id="samples" inputmode="numeric" value="400" />
                </div>
              </div>
              <div class="hint" style="margin-top: 10px">
                Used only if symbolic solving fails. Finds sign-changes + Newton refinement; may miss roots without sign changes.
              </div>
            </details>

            <div class="actions">
              <button class="btn-primary" id="solveBtn">Solve</button>
              <button class="btn-ghost" id="exampleBtn" title="Insert an example problem">Example</button>
              <button class="btn-ghost" id="clearBtn">Clear</button>
              <span class="pill" style="margin-left: auto">
                <span>Export:</span>
                <select id="exportFormat" style="width: 170px; padding: 8px 10px; border-radius: 10px">
                  <option value="md" selected>Markdown (.md)</option>
                  <option value="txt">Plain text (.txt)</option>
                  <option value="json">JSON (.json)</option>
                </select>
                <button class="small" id="exportBtn">Download</button>
                <button class="small" id="copyBtn">Copy</button>
                <button class="small" id="printBtn">Print</button>
              </span>
            </div>

            <div class="divider"></div>
            <div class="status" role="status" aria-live="polite">
              <div id="statusLeft">Ready.</div>
              <div class="right">
                <span class="pill"><span class="dot" id="solveDot" aria-hidden="true"></span><span id="solveMeta">Idle</span></span>
              </div>
            </div>
          </div>
        </section>

        <section class="card" aria-label="Output">
          <div class="card-hd">
            <h2>Explanation &amp; Results</h2>
            <div class="pill"><b id="methodTag">—</b></div>
          </div>
          <div class="card-bd">
            <div id="errorBox" class="error" style="display: none"></div>
            <div class="out" id="output">
              <div class="muted" id="emptyState">
                Enter an equation and press <span class="mono">Solve</span>. Results appear here with a step-by-step breakdown.
              </div>
            </div>
          </div>
        </section>
      </div>

      <section class="card" style="margin-top: 16px" aria-label="History">
        <div class="card-hd">
          <h2>Recent</h2>
          <div class="actions" style="margin: 0">
            <button class="small btn-ghost" id="clearHistoryBtn">Clear history</button>
          </div>
        </div>
        <div class="card-bd">
          <div class="history" id="history"></div>
          <div class="hint" style="margin-top: 10px">
            Stored locally in your browser. Click an entry to restore the problem and re-run.
          </div>
        </div>
      </section>

      <div class="footer">
        <div>Academic minimal UI • Symbolic (Nerdamer) + numeric (Math.js) • Typeset via MathJax</div>
        <div class="mono">No data leaves your device.</div>
      </div>
    </div>

    <!-- Libraries (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.2/lib/browser/math.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/all.min.js" crossorigin="anonymous"></script>
    <script>
      window.MathJax = {
        tex: { inlineMath: [["\\(", "\\)"]], displayMath: [["\\[", "\\]"]] },
        svg: { fontCache: "global" },
        options: { skipHtmlTags: ["script", "noscript", "style", "textarea", "pre", "code"] },
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-svg.js" crossorigin="anonymous"></script>

    <script>
      (() => {
        "use strict";

        const $ = (sel, el = document) => el.querySelector(sel);
        const $$ = (sel, el = document) => Array.from(el.querySelectorAll(sel));

        const UI = {
          input: $("#input"),
          mode: $("#mode"),
          variable: $("#variable"),
          verbosity: $("#verbosity"),
          rangeMin: $("#rangeMin"),
          rangeMax: $("#rangeMax"),
          maxRoots: $("#maxRoots"),
          samples: $("#samples"),
          solveBtn: $("#solveBtn"),
          exampleBtn: $("#exampleBtn"),
          clearBtn: $("#clearBtn"),
          exportBtn: $("#exportBtn"),
          copyBtn: $("#copyBtn"),
          printBtn: $("#printBtn"),
          exportFormat: $("#exportFormat"),
          errorBox: $("#errorBox"),
          output: $("#output"),
          emptyState: $("#emptyState"),
          history: $("#history"),
          clearHistoryBtn: $("#clearHistoryBtn"),
          statusLeft: $("#statusLeft"),
          solveDot: $("#solveDot"),
          solveMeta: $("#solveMeta"),
          methodTag: $("#methodTag"),
          readyDot: $("#readyDot"),
          readyText: $("#readyText"),
          libBadge: $("#libBadge"),
        };

        const STORAGE_KEY = "equation-solver-tool:v1";

        const KNOWN_FUNCS = new Set([
          "sin",
          "cos",
          "tan",
          "asin",
          "acos",
          "atan",
          "sinh",
          "cosh",
          "tanh",
          "log",
          "ln",
          "sqrt",
          "abs",
          "exp",
          "floor",
          "ceil",
          "round",
          "min",
          "max",
          "sign",
        ]);

        const KNOWN_CONSTS = new Set(["e", "pi", "i"]);

        const EXAMPLES = [
          {
            title: "Linear equation",
            text: "2x + 3 = 7",
          },
          {
            title: "Quadratic equation",
            text: "x^2 - 5x + 6 = 0",
          },
          {
            title: "Trigonometric equation",
            text: "sin(x) = 1/2",
          },
          {
            title: "Two-equation system",
            text: "2x + y = 5\nx - y = 1",
          },
          {
            title: "Simplify & evaluate",
            text: "(x^2 - 1)/(x - 1)",
          },
        ];

        let exampleIndex = 0;

        function nowISO() {
          return new Date().toISOString();
        }

        function fmtTime(iso) {
          try {
            const d = new Date(iso);
            return d.toLocaleString(undefined, { year: "numeric", month: "short", day: "2-digit", hour: "2-digit", minute: "2-digit" });
          } catch {
            return iso;
          }
        }

        function setStatus(text, meta = "Idle", dot = "ok") {
          UI.statusLeft.textContent = text;
          UI.solveMeta.textContent = meta;
          UI.solveDot.className = "dot " + (dot || "");
        }

        function setReady(ok, note) {
          UI.readyDot.className = "dot " + (ok ? "ok" : "warn");
          UI.readyText.textContent = note;
        }

        function showError(message) {
          UI.errorBox.style.display = "block";
          UI.errorBox.textContent = message;
        }

        function clearError() {
          UI.errorBox.style.display = "none";
          UI.errorBox.textContent = "";
        }

        function escapeHtml(str) {
          return String(str)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
        }

        function wrapDisplayTex(tex) {
          return `\\[${tex}\\]`;
        }

        function queueTypeset() {
          if (window.MathJax?.typesetPromise) {
            return window.MathJax.typesetPromise();
          }
          return Promise.resolve();
        }

        function normalizeMathInput(raw) {
          let s = String(raw || "").trim();
          s = s.replaceAll("−", "-").replaceAll("×", "*").replaceAll("÷", "/");
          s = s.replaceAll("·", "*");
          s = s.replaceAll("π", "pi");
          s = s.replaceAll("ℯ", "e");

          // Insert implied multiplication: 2x, 2(x+1), )x, x(, x2
          s = s.replace(/(\d)\s*([A-Za-z(])/g, "$1*$2");
          s = s.replace(/([A-Za-z)])\s*(\d)/g, "$1*$2");
          s = s.replace(/([A-Za-z)])\s*\(/g, "$1*(");
          s = s.replace(/\)\s*([A-Za-z])/g, ")*$1");
          return s;
        }

        function splitLines(raw) {
          return String(raw || "")
            .split(/\r?\n/)
            .map((l) => l.trim())
            .filter((l) => l.length > 0);
        }

        function isEquationLine(line) {
          return line.includes("=");
        }

        function detectVariables(text) {
          const tokens = String(text || "").match(/[A-Za-z_][A-Za-z0-9_]*/g) || [];
          const vars = new Set();
          for (const t of tokens) {
            const lower = t.toLowerCase();
            if (KNOWN_FUNCS.has(lower)) continue;
            if (KNOWN_CONSTS.has(lower)) continue;
            // Avoid matching scientific notation artifacts
            if (lower === "e" && t === "e") continue;
            vars.add(t);
          }
          return Array.from(vars);
        }

        function chooseVariable(rawInput) {
          const selected = UI.variable.value;
          if (selected !== "auto") return selected;
          const vars = detectVariables(rawInput);
          if (vars.includes("x")) return "x";
          if (vars.length > 0) return vars[0];
          return "x";
        }

        function baseScope(extra = {}) {
          return {
            e: Math.E,
            pi: Math.PI,
            ...extra,
          };
        }

        function toNumberMaybe(val) {
          if (typeof val === "number") return val;
          if (val && typeof val === "object" && val.isBigNumber) return Number(val);
          if (val && typeof val === "object" && val.isComplex) return val;
          const n = Number(val);
          return Number.isFinite(n) ? n : null;
        }

        function fmtValue(val) {
          try {
            if (val && typeof val === "object" && val.isComplex) {
              const re = math.format(val.re, { precision: 12 });
              const im = math.format(val.im, { precision: 12 });
              if (Math.abs(val.im) < 1e-14) return String(re);
              const sign = val.im >= 0 ? "+" : "-";
              const imAbs = math.format(Math.abs(val.im), { precision: 12 });
              return `${re} ${sign} ${imAbs}i`;
            }
            if (typeof val === "number") return math.format(val, { precision: 12 });
            return String(val);
          } catch {
            return String(val);
          }
        }

        function texFromExpression(expr) {
          try {
            return math.parse(expr).toTex({ parenthesis: "keep", implicit: "hide" });
          } catch {
            return `\\texttt{${escapeHtml(expr)}}`;
          }
        }

        function texFromEquation(left, right) {
          return `${texFromExpression(left)} = ${texFromExpression(right)}`;
        }

        function texFromAssignment(variable, valueExpr) {
          return `${texFromExpression(variable)} = ${texFromExpression(valueExpr)}`;
        }

        function nerdAvailable() {
          return typeof window.nerdamer === "function";
        }

        function mathAvailable() {
          return typeof window.math === "object";
        }

        function tryNerdamerEval(expr) {
          if (!nerdAvailable()) return null;
          try {
            return window.nerdamer(expr);
          } catch {
            return null;
          }
        }

        function nerdToString(x) {
          try {
            if (x == null) return "";
            if (typeof x === "string") return x;
            if (Array.isArray(x)) return x.map(nerdToString).join(",");
            if (typeof x.text === "function") return x.text();
            if (typeof x.toString === "function") return x.toString();
            return String(x);
          } catch {
            return String(x);
          }
        }

        function parseBracketList(str) {
          const s = String(str || "").trim();
          if (!s.startsWith("[") || !s.endsWith("]")) return null;
          const inner = s.slice(1, -1).trim();
          if (!inner) return [];
          // Split on commas not inside parentheses.
          const out = [];
          let depth = 0;
          let start = 0;
          for (let i = 0; i < inner.length; i++) {
            const c = inner[i];
            if (c === "(") depth++;
            if (c === ")") depth = Math.max(0, depth - 1);
            if (c === "," && depth === 0) {
              out.push(inner.slice(start, i).trim());
              start = i + 1;
            }
          }
          out.push(inner.slice(start).trim());
          return out.filter(Boolean);
        }

        function normalizeSolutions(maybe) {
          if (maybe == null) return [];
          if (Array.isArray(maybe)) {
            return maybe.map(nerdToString).filter((s) => s.length > 0);
          }
          if (typeof maybe === "string") {
            const list = parseBracketList(maybe);
            if (list) return list;
            return [maybe];
          }
          // nerdamer expression / object
          const s = nerdToString(maybe);
          const list = parseBracketList(s);
          if (list) return list;
          if (s) return [s];
          return [];
        }

        function approxResidual(leftExpr, rightExpr, variable, value) {
          try {
            const scope = baseScope({ [variable]: value });
            const L = math.evaluate(leftExpr, scope);
            const R = math.evaluate(rightExpr, scope);
            return math.subtract(L, R);
          } catch {
            return null;
          }
        }

        function magnitude(val) {
          try {
            if (val == null) return Infinity;
            if (typeof val === "number") return Math.abs(val);
            if (val && typeof val === "object" && val.isComplex) return Math.hypot(val.re, val.im);
            return Math.abs(Number(val));
          } catch {
            return Infinity;
          }
        }

        function equationToZeroForm(left, right) {
          return `(${left})-(${right})`;
        }

        function nerdSimplify(expr) {
          if (!nerdAvailable()) return expr;
          try {
            // Expand then simplify tends to normalize polynomials; keep it conservative.
            const expanded = window.nerdamer(expr).expand();
            const simplified = expanded.simplify();
            return nerdToString(simplified);
          } catch {
            try {
              return nerdToString(window.nerdamer(expr).simplify());
            } catch {
              return expr;
            }
          }
        }

        function nerdCoeffCandidates(expr, variable) {
          if (!nerdAvailable()) return null;
          const attempts = [];
          // Attempt 1: coeffs(expr, x)
          attempts.push(`coeffs(${expr},${variable})`);
          // Attempt 2: coeffs(expand(expr), x)
          attempts.push(`coeffs(expand(${expr}),${variable})`);
          for (const a of attempts) {
            const res = tryNerdamerEval(a);
            const s = res ? nerdToString(res) : "";
            const list = parseBracketList(s);
            if (list && list.length >= 2 && list.length <= 3) return list;
          }
          return null;
        }

        function polyEvalFromCoeffs(coeffs, x) {
          let y = 0;
          for (const c of coeffs) y = y * x + c;
          return y;
        }

        function interpretCoefficients(rawCoeffs, variable, expr) {
          if (!rawCoeffs || rawCoeffs.length < 2) return null;
          // Convert to numeric if possible, else keep expression strings.
          const coeffNums = rawCoeffs.map((c) => {
            try {
              const v = math.evaluate(c, baseScope());
              return v;
            } catch {
              return null;
            }
          });
          const allNumeric = coeffNums.every((v) => typeof v === "number" && Number.isFinite(v));
          if (!allNumeric) return null;

          // Determine whether coeffs are [a,b,c] descending or ascending by testing.
          const f = (x) => {
            const scope = baseScope({ [variable]: x });
            return Number(math.evaluate(expr, scope));
          };

          const candidates = [];
          // Candidate A: provided order is descending: [a,b] => a*x + b; [a,b,c] => a*x^2 + b*x + c
          candidates.push(coeffNums);
          // Candidate B: reverse order.
          candidates.push([...coeffNums].reverse());

          const testXs = [0, 1, 2];
          let best = null;
          for (const cand of candidates) {
            const err = testXs.reduce((acc, x) => acc + Math.abs(f(x) - polyEvalFromCoeffs(cand, x)), 0);
            if (!best || err < best.err) best = { err, coeffs: cand };
          }
          if (!best || !Number.isFinite(best.err) || best.err > 1e-6) return null;

          const deg = best.coeffs.length - 1;
          if (deg !== 1 && deg !== 2) return null;
          return { degree: deg, coeffs: best.coeffs };
        }

        function solvePolynomialNumerically(poly, variable) {
          const { degree, coeffs } = poly;
          if (degree === 1) {
            const [a, b] = coeffs;
            if (Math.abs(a) < 1e-14) return [];
            return [-b / a];
          }
          if (degree === 2) {
            const [a, b, c] = coeffs;
            if (Math.abs(a) < 1e-14) {
              if (Math.abs(b) < 1e-14) return [];
              return [-c / b];
            }
            const disc = b * b - 4 * a * c;
            if (disc >= 0) {
              const r = Math.sqrt(disc);
              return [(-b - r) / (2 * a), (-b + r) / (2 * a)];
            }
            // Complex roots
            const r = Math.sqrt(-disc);
            return [
              math.complex(-b / (2 * a), -r / (2 * a)),
              math.complex(-b / (2 * a), r / (2 * a)),
            ];
          }
          return [];
        }

        function trySymbolicSolve(exprZero, variable) {
          if (!nerdAvailable()) return { ok: false, error: "Symbolic engine not available.", solutions: [] };
          const errors = [];
          // API attempt 1
          try {
            if (typeof window.nerdamer.solve === "function") {
              const res = window.nerdamer.solve(exprZero, variable);
              const sols = normalizeSolutions(res);
              if (sols.length) return { ok: true, method: "nerdamer.solve", solutions: sols };
            }
          } catch (e) {
            errors.push(e?.message || String(e));
          }
          // API attempt 2: solve(expr, x) via parser
          try {
            const res = window.nerdamer(`solve(${exprZero},${variable})`);
            const sols = normalizeSolutions(res);
            if (sols.length) return { ok: true, method: "solve(expr,var)", solutions: sols };
          } catch (e) {
            errors.push(e?.message || String(e));
          }
          // API attempt 3: solve( left=right, x )
          try {
            const res = window.nerdamer(`solve(${exprZero}=0,${variable})`);
            const sols = normalizeSolutions(res);
            if (sols.length) return { ok: true, method: "solve(eq,var)", solutions: sols };
          } catch (e) {
            errors.push(e?.message || String(e));
          }
          return { ok: false, error: errors[0] || "Symbolic solve failed.", solutions: [] };
        }

        function numericSolveByScan(leftExpr, rightExpr, variable, rangeMin, rangeMax, samples, maxRoots) {
          const f = (x) => {
            const scope = baseScope({ [variable]: x });
            const L = math.evaluate(leftExpr, scope);
            const R = math.evaluate(rightExpr, scope);
            const d = math.subtract(L, R);
            if (typeof d === "number") return d;
            if (d && typeof d === "object" && d.isComplex) return d.re; // heuristic
            return Number(d);
          };
          const a = rangeMin;
          const b = rangeMax;
          const n = Math.max(20, Math.min(5000, samples));
          const xs = [];
          for (let i = 0; i <= n; i++) xs.push(a + ((b - a) * i) / n);
          const ys = xs.map((x) => {
            try {
              const y = f(x);
              return Number.isFinite(y) ? y : NaN;
            } catch {
              return NaN;
            }
          });

          const roots = [];
          function addRoot(x) {
            if (!Number.isFinite(x)) return;
            if (roots.some((r) => Math.abs(r - x) < 1e-6)) return;
            roots.push(x);
          }

          for (let i = 0; i < xs.length - 1 && roots.length < maxRoots; i++) {
            const x1 = xs[i],
              x2 = xs[i + 1];
            const y1 = ys[i],
              y2 = ys[i + 1];
            if (!Number.isFinite(y1) || !Number.isFinite(y2)) continue;
            if (Math.abs(y1) < 1e-8) addRoot(x1);
            if (y1 === 0) continue;
            if (y1 * y2 > 0) continue;
            // Bisection
            let lo = x1,
              hi = x2;
            let flo = y1,
              fhi = y2;
            for (let it = 0; it < 60; it++) {
              const mid = (lo + hi) / 2;
              let fmid;
              try {
                fmid = f(mid);
              } catch {
                break;
              }
              if (!Number.isFinite(fmid)) break;
              if (Math.abs(fmid) < 1e-10) {
                lo = hi = mid;
                break;
              }
              if (flo * fmid <= 0) {
                hi = mid;
                fhi = fmid;
              } else {
                lo = mid;
                flo = fmid;
              }
            }
            addRoot((lo + hi) / 2);
          }

          // Newton refinement
          const refined = roots.map((x0) => {
            let x = x0;
            for (let it = 0; it < 12; it++) {
              const fx = f(x);
              if (!Number.isFinite(fx)) break;
              if (Math.abs(fx) < 1e-12) break;
              const h = 1e-6 * (1 + Math.abs(x));
              const d = (f(x + h) - f(x - h)) / (2 * h);
              if (!Number.isFinite(d) || Math.abs(d) < 1e-14) break;
              const x1 = x - fx / d;
              if (!Number.isFinite(x1)) break;
              if (Math.abs(x1 - x) < 1e-12) {
                x = x1;
                break;
              }
              x = x1;
            }
            return x;
          });

          // Deduplicate again
          const uniq = [];
          for (const r of refined) {
            if (!uniq.some((u) => Math.abs(u - r) < 1e-7)) uniq.push(r);
          }
          return uniq.sort((p, q) => p - q).slice(0, maxRoots);
        }

        function buildStep(reason, latex) {
          return { reason, latex };
        }

        function renderOutput(payload) {
          UI.output.innerHTML = "";
          UI.emptyState?.remove();

          const blocks = [];

          const head = document.createElement("div");
          head.className = "out";

          const metaMethod = document.createElement("div");
          metaMethod.className = "k";
          metaMethod.innerHTML = `<span class="key">Method</span><span class="val">${escapeHtml(payload.method || "—")}</span>`;
          head.appendChild(metaMethod);

          const metaVar = document.createElement("div");
          metaVar.className = "k";
          metaVar.innerHTML = `<span class="key">Variable</span><span class="val">${escapeHtml(payload.variable || "—")}</span>`;
          head.appendChild(metaVar);

          const metaInput = document.createElement("div");
          metaInput.className = "k";
          metaInput.innerHTML = `<span class="key">Input</span><span class="val">${escapeHtml(payload.raw || "")}</span>`;
          head.appendChild(metaInput);

          blocks.push(head);

          if (payload.normalizedPreview) {
            const eqBlock = document.createElement("div");
            eqBlock.className = "math";
            eqBlock.innerHTML = payload.normalizedPreview;
            blocks.push(eqBlock);
          }

          if (payload.solutions && payload.solutions.length) {
            const solCard = document.createElement("div");
            solCard.className = "math";
            const items = payload.solutions
              .map((s) => {
                let mainTex = "";
                if (s.exact) {
                  if (payload.kind === "system") {
                    const parts = String(s.exact).split("=");
                    if (parts.length === 2) mainTex = texFromEquation(parts[0].trim(), parts[1].trim());
                    else mainTex = `\\text{solution: }${texFromExpression(String(s.exact))}`;
                  } else if (payload.kind === "expression") {
                    mainTex = `\\text{result} = ${texFromExpression(String(s.exact))}`;
                  } else {
                    mainTex = texFromAssignment(payload.variable, String(s.exact));
                  }
                }
                const exact = mainTex ? wrapDisplayTex(mainTex) : "";
                const approx = s.approx != null ? `<div class="hint">≈ <span class="mono">${escapeHtml(fmtValue(s.approx))}</span></div>` : "";
                const residual = s.residual != null ? `<div class="hint">residual: <span class="mono">${escapeHtml(fmtValue(s.residual))}</span></div>` : "";
                return `<div style="margin: 6px 0 12px">${exact}${approx}${residual}</div>`;
              })
              .join("");
            solCard.innerHTML = `<div class="step-reason">Solutions</div>${items}`;
            blocks.push(solCard);
          } else if (payload.kind !== "expression") {
            const none = document.createElement("div");
            none.className = "error";
            none.textContent =
              "No solutions were found with the available methods. Try widening the numeric range, or check the equation syntax.";
            blocks.push(none);
          }

          if (payload.steps && payload.steps.length) {
            const stepsWrap = document.createElement("div");
            stepsWrap.innerHTML = `<div class="step-reason" style="margin-bottom:8px">Step-by-step</div>`;
            const ol = document.createElement("ol");
            ol.className = "steps";
            for (const st of payload.steps) {
              const li = document.createElement("li");
              li.innerHTML = `<div class="step-reason">${escapeHtml(st.reason)}</div><div class="math">${st.latex}</div>`;
              ol.appendChild(li);
            }
            stepsWrap.appendChild(ol);
            blocks.push(stepsWrap);
          }

          const raw = document.createElement("details");
          raw.innerHTML = `<summary>Raw output</summary><pre>${escapeHtml(JSON.stringify(payload, null, 2))}</pre>`;
          blocks.push(raw);

          for (const b of blocks) UI.output.appendChild(b);

          UI.methodTag.textContent = payload.methodTag || "—";
          queueTypeset();
        }

        function buildExportPayload(last) {
          // Ensure stable order and plain data.
          return {
            app: "Equation Solver Tool",
            timestamp: last.timestamp,
            mode: last.mode,
            variable: last.variable,
            input_raw: last.raw,
            input_normalized: last.normalized,
            method: last.method,
            solutions: (last.solutions || []).map((s) => ({
              exact: s.exact ?? null,
              approx: s.approx ?? null,
              residual: s.residual ?? null,
            })),
            steps: (last.steps || []).map((st) => ({ reason: st.reason, latex: st.latexPlain ?? st.latex })),
            notes: last.notes || [],
          };
        }

        function payloadToMarkdown(p) {
          const lines = [];
          lines.push(`# Equation Solver Tool`);
          lines.push("");
          lines.push(`- Timestamp: ${p.timestamp}`);
          lines.push(`- Mode: ${p.mode}`);
          lines.push(`- Variable: \`${p.variable}\``);
          lines.push(`- Method: ${p.method}`);
          lines.push("");
          lines.push("## Input");
          lines.push("```");
          lines.push(p.input_raw || "");
          lines.push("```");
          lines.push("");
          if (p.input_normalized) {
            lines.push("## Normalized");
            lines.push("```");
            lines.push(p.input_normalized);
            lines.push("```");
            lines.push("");
          }
          lines.push("## Solutions");
          if (p.solutions && p.solutions.length) {
            for (const s of p.solutions) {
              const parts = [];
              if (s.exact) parts.push(`exact: \`${s.exact}\``);
              if (s.approx != null) parts.push(`approx: \`${fmtValue(s.approx)}\``);
              if (s.residual != null) parts.push(`residual: \`${fmtValue(s.residual)}\``);
              lines.push(`- ${parts.join(" • ")}`);
            }
          } else {
            lines.push("- (none)");
          }
          lines.push("");
          if (p.steps && p.steps.length) {
            lines.push("## Steps");
            p.steps.forEach((st, i) => {
              lines.push(`${i + 1}. ${st.reason}`);
              lines.push("```tex");
              lines.push(st.latex);
              lines.push("```");
            });
            lines.push("");
          }
          if (p.notes && p.notes.length) {
            lines.push("## Notes");
            for (const n of p.notes) lines.push(`- ${n}`);
            lines.push("");
          }
          return lines.join("\n");
        }

        function payloadToText(p) {
          const lines = [];
          lines.push("Equation Solver Tool");
          lines.push("");
          lines.push(`Timestamp: ${p.timestamp}`);
          lines.push(`Mode: ${p.mode}`);
          lines.push(`Variable: ${p.variable}`);
          lines.push(`Method: ${p.method}`);
          lines.push("");
          lines.push("Input:");
          lines.push(p.input_raw || "");
          lines.push("");
          if (p.input_normalized) {
            lines.push("Normalized:");
            lines.push(p.input_normalized);
            lines.push("");
          }
          lines.push("Solutions:");
          if (p.solutions && p.solutions.length) {
            for (const s of p.solutions) {
              const parts = [];
              if (s.exact) parts.push(`exact=${s.exact}`);
              if (s.approx != null) parts.push(`approx=${fmtValue(s.approx)}`);
              if (s.residual != null) parts.push(`residual=${fmtValue(s.residual)}`);
              lines.push("- " + parts.join(" | "));
            }
          } else {
            lines.push("- (none)");
          }
          lines.push("");
          if (p.steps && p.steps.length) {
            lines.push("Steps:");
            p.steps.forEach((st, i) => {
              lines.push(`${i + 1}. ${st.reason}`);
              lines.push("   " + st.latex.replaceAll("\n", "\n   "));
            });
            lines.push("");
          }
          if (p.notes && p.notes.length) {
            lines.push("Notes:");
            for (const n of p.notes) lines.push("- " + n);
            lines.push("");
          }
          return lines.join("\n");
        }

        function download(filename, mime, content) {
          const blob = new Blob([content], { type: mime });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 800);
        }

        async function copy(text) {
          try {
            await navigator.clipboard.writeText(text);
            setStatus("Copied report to clipboard.", "Copied", "ok");
          } catch {
            // Fallback
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.setAttribute("readonly", "true");
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            ta.remove();
            setStatus("Copied report to clipboard.", "Copied", "ok");
          }
        }

        function loadState() {
          try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return { history: [] };
            const parsed = JSON.parse(raw);
            return { history: Array.isArray(parsed.history) ? parsed.history : [] };
          } catch {
            return { history: [] };
          }
        }

        function saveState(state) {
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
          } catch {
            // ignore
          }
        }

        function pushHistory(entry) {
          const st = loadState();
          const history = [entry, ...st.history].slice(0, 10);
          saveState({ history });
          renderHistory();
        }

        function renderHistory() {
          const st = loadState();
          UI.history.innerHTML = "";
          if (!st.history.length) {
            UI.history.innerHTML = `<div class="muted">No history yet.</div>`;
            return;
          }
          for (const h of st.history) {
            const div = document.createElement("div");
            div.className = "hist-item";
            div.tabIndex = 0;
            const summary = (h.solutions && h.solutions.length ? `${h.solutions.length} solution(s)` : "no solutions") + ` • ${h.methodTag || h.method || "—"}`;
            div.innerHTML = `
              <div class="top">
                <div class="eq" title="${escapeHtml(h.raw || "")}">${escapeHtml(h.raw || "")}</div>
                <div class="time">${escapeHtml(fmtTime(h.timestamp || ""))}</div>
              </div>
              <div class="sub">${escapeHtml(summary)}</div>
            `;
            div.addEventListener("click", () => {
              UI.input.value = h.raw || "";
              UI.mode.value = h.mode || "auto";
              UI.variable.value = h.variable || "auto";
              solve();
            });
            div.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                div.click();
              }
            });
            UI.history.appendChild(div);
          }
        }

        function normalizeForReport(lines) {
          return lines.map(normalizeMathInput).join("\n");
        }

        function buildNormalizedPreview(kind, variable, data) {
          if (kind === "system") {
            const tex = data.equations
              .map((eq) => {
                const [l, r] = eq.split("=").map((s) => s.trim());
                return texFromEquation(l, r);
              })
              .join("\\\\");
            return wrapDisplayTex(`\\begin{aligned}${tex}\\end{aligned}`);
          }
          if (kind === "equation") {
            return wrapDisplayTex(texFromEquation(data.left, data.right));
          }
          if (kind === "expression") {
            return wrapDisplayTex(texFromExpression(data.expression));
          }
          return "";
        }

        function addNote(payload, note) {
          payload.notes = payload.notes || [];
          payload.notes.push(note);
        }

        function maybeUpdateVariableChoices(raw) {
          const vars = detectVariables(raw);
          const curated = new Set(["auto", "x", "y", "t", ...vars]);
          const current = UI.variable.value;
          UI.variable.innerHTML = "";
          for (const v of curated) {
            const opt = document.createElement("option");
            opt.value = v;
            opt.textContent = v === "auto" ? "Auto-detect" : v;
            UI.variable.appendChild(opt);
          }
          if (curated.has(current)) UI.variable.value = current;
        }

        function solveExpression(raw, verbosity) {
          const expr = normalizeMathInput(raw);
          const steps = [];
          const payload = {
            timestamp: nowISO(),
            kind: "expression",
            mode: UI.mode.value,
            variable: chooseVariable(raw),
            raw,
            normalized: expr,
            methodTag: "Expression",
            method: "simplify + evaluate",
            steps: [],
            solutions: [],
            notes: [],
          };

          const simplified = nerdSimplify(expr);
          if (verbosity !== "minimal") {
            steps.push(buildStep("Normalize input", wrapDisplayTex(texFromExpression(expr))));
            if (simplified !== expr) steps.push(buildStep("Simplify", wrapDisplayTex(texFromExpression(simplified))));
          } else {
            steps.push(buildStep("Simplify", wrapDisplayTex(texFromExpression(simplified))));
          }

          // Evaluate for a sample numeric substitution if variable present.
          const vars = detectVariables(expr);
          const v = payload.variable;
          if (vars.includes(v)) {
            addNote(payload, `Expression contains variable ${v}; numerical evaluation uses ${v}=2 by default.`);
            try {
              const val = math.evaluate(simplified, baseScope({ [v]: 2 }));
              payload.solutions = [{ exact: simplified, approx: val, residual: null }];
            } catch {
              payload.solutions = [{ exact: simplified, approx: null, residual: null }];
            }
          } else {
            try {
              const val = math.evaluate(simplified, baseScope());
              payload.solutions = [{ exact: simplified, approx: val, residual: null }];
            } catch {
              payload.solutions = [{ exact: simplified, approx: null, residual: null }];
            }
          }

          payload.steps = steps.map((st) => ({ ...st, latexPlain: st.latex }));
          payload.normalizedPreview = buildNormalizedPreview("expression", payload.variable, { expression: simplified });
          payload.normalized = simplified;
          return payload;
        }

        function solveSingleEquation(raw, variable, verbosity) {
          const normalized = normalizeMathInput(raw);
          const parts = normalized.split("=");
          if (parts.length !== 2) {
            throw new Error("Expected a single '=' for an equation. For systems, put one equation per line.");
          }
          const left = parts[0].trim();
          const right = parts[1].trim();
          const payload = {
            timestamp: nowISO(),
            kind: "equation",
            mode: UI.mode.value,
            variable,
            raw,
            normalized,
            methodTag: "Equation",
            method: "",
            normalizedPreview: buildNormalizedPreview("equation", variable, { left, right }),
            steps: [],
            solutions: [],
            notes: [],
          };

          const steps = [];
          const zero = equationToZeroForm(left, right);
          const simplifiedZero = nerdSimplify(zero);

          if (verbosity !== "minimal") {
            steps.push(buildStep("Start with the equation", wrapDisplayTex(texFromEquation(left, right))));
            steps.push(buildStep("Bring all terms to one side (subtract the right-hand side)", wrapDisplayTex(`${texFromExpression(simplifiedZero)} = 0`)));
          } else {
            steps.push(buildStep("Rewrite in standard form", wrapDisplayTex(`${texFromExpression(simplifiedZero)} = 0`)));
          }

          // Polynomial detection (degree 1 or 2), numeric coefficients.
          let poly = null;
          try {
            const rawCoeffs = nerdCoeffCandidates(simplifiedZero, variable);
            if (rawCoeffs) {
              poly = interpretCoefficients(rawCoeffs, variable, simplifiedZero);
            }
          } catch {
            poly = null;
          }

          if (poly) {
            const { degree, coeffs } = poly;
            if (degree === 1) {
              payload.method = "polynomial (linear) closed-form";
              payload.methodTag = "Linear";
              const [a, b] = coeffs;
              if (verbosity === "detailed") {
                steps.push(buildStep("Identify coefficients for ax + b = 0", wrapDisplayTex(`a=${texFromExpression(String(a))},\\; b=${texFromExpression(String(b))}`)));
                steps.push(buildStep("Solve ax = -b", wrapDisplayTex(`${texFromExpression(String(a))}\\,${texFromExpression(variable)} = ${texFromExpression(String(-b))}`)));
              }
              const x = -b / a;
              const res = approxResidual(left, right, variable, x);
              payload.solutions = [{ exact: fmtValue(x), approx: x, residual: res }];
              steps.push(buildStep("Divide by a", wrapDisplayTex(texFromAssignment(variable, String(x)))));
            } else {
              payload.method = "polynomial (quadratic) closed-form";
              payload.methodTag = "Quadratic";
              const [a, b, c] = coeffs;
              const disc = b * b - 4 * a * c;
              const discTex = texFromExpression(String(disc));
              if (verbosity !== "minimal") {
                steps.push(buildStep("Identify coefficients for ax^2 + bx + c = 0", wrapDisplayTex(`a=${texFromExpression(String(a))},\\; b=${texFromExpression(String(b))},\\; c=${texFromExpression(String(c))}`)));
                steps.push(buildStep("Compute the discriminant Δ = b^2 − 4ac", wrapDisplayTex(`\\Delta = ${discTex}`)));
              }
              const roots = solvePolynomialNumerically(poly, variable);
              const sols = [];
              for (const r of roots) {
                const res = approxResidual(left, right, variable, r);
                if (typeof r === "number") sols.push({ exact: fmtValue(r), approx: r, residual: res });
                else sols.push({ exact: nerdToString(r), approx: r, residual: res });
              }
              payload.solutions = sols;
              if (verbosity !== "minimal") {
                steps.push(
                  buildStep(
                    "Apply the quadratic formula",
                    wrapDisplayTex(`${texFromExpression(variable)} = \\frac{-b \\pm \\sqrt{\\Delta}}{2a}`)
                  )
                );
              }
              steps.push(buildStep("Simplify to final roots", wrapDisplayTex(`\\left\\{${sols.map((s) => texFromExpression(s.exact)).join(", ")}\\right\\}`)));
            }
            payload.steps = steps.map((st) => ({ ...st, latexPlain: st.latex }));
            payload.normalized = `${simplifiedZero}=0`;
            payload.normalizedPreview = wrapDisplayTex(`${texFromExpression(simplifiedZero)} = 0`);
            return payload;
          }

          // Symbolic solve
          const sym = trySymbolicSolve(simplifiedZero, variable);
          if (sym.ok) {
            payload.method = `symbolic (${sym.method})`;
            payload.methodTag = "Symbolic";
            const sols = [];
            for (const s of sym.solutions) {
              let approx = null;
              try {
                const v = math.evaluate(s, baseScope());
                if (typeof v === "number" || (v && typeof v === "object" && v.isComplex)) approx = v;
              } catch {
                approx = null;
              }
              const res = approx != null ? approxResidual(left, right, variable, approx) : null;
              sols.push({ exact: s, approx, residual: res });
            }
            payload.solutions = sols;
            if (verbosity === "detailed") {
              steps.push(buildStep("Solve for the variable symbolically", wrapDisplayTex(`\\text{solve}\\big(${texFromExpression(simplifiedZero)}=0,\\;${texFromExpression(variable)}\\big)`)));
            }
            steps.push(buildStep("Read off the solution set", wrapDisplayTex(`\\left\\{${sols.map((x) => texFromExpression(x.exact)).join(", ")}\\right\\}`)));
            payload.steps = steps.map((st) => ({ ...st, latexPlain: st.latex }));
            payload.normalized = `${simplifiedZero}=0`;
            payload.normalizedPreview = wrapDisplayTex(`${texFromExpression(simplifiedZero)} = 0`);
            return payload;
          }

          // Numeric fallback
          payload.method = `numeric scan + refinement (symbolic failed: ${sym.error})`;
          payload.methodTag = "Numeric";
          addNote(payload, `Symbolic solver error: ${sym.error}`);

          const rangeMin = Number(UI.rangeMin.value);
          const rangeMax = Number(UI.rangeMax.value);
          const maxRoots = Math.max(1, Math.min(50, Number(UI.maxRoots.value) || 8));
          const samples = Math.max(50, Math.min(5000, Number(UI.samples.value) || 400));

          if (!(Number.isFinite(rangeMin) && Number.isFinite(rangeMax) && rangeMin < rangeMax)) {
            throw new Error("Numeric fallback range is invalid. Ensure min < max and both are numbers.");
          }

          if (verbosity !== "minimal") {
            steps.push(buildStep("Scan for sign changes to bracket roots", wrapDisplayTex(`x \\in [${texFromExpression(String(rangeMin))},\\;${texFromExpression(String(rangeMax))}]`)));
            steps.push(buildStep("Refine each bracketed root (bisection + Newton)", wrapDisplayTex(`\\text{tolerance} \\approx 10^{-10}`)));
          }

          const roots = numericSolveByScan(left, right, variable, rangeMin, rangeMax, samples, maxRoots);
          payload.solutions = roots.map((x) => ({ exact: fmtValue(x), approx: x, residual: approxResidual(left, right, variable, x) }));
          steps.push(buildStep("Report numeric roots", wrapDisplayTex(`\\left\\{${payload.solutions.map((s) => texFromExpression(s.exact)).join(", ")}\\right\\}`)));
          payload.steps = steps.map((st) => ({ ...st, latexPlain: st.latex }));
          payload.normalized = `${simplifiedZero}=0`;
          payload.normalizedPreview = wrapDisplayTex(`${texFromExpression(simplifiedZero)} = 0`);
          return payload;
        }

        function solveSystem(raw, variable, verbosity) {
          const lines = splitLines(raw).map(normalizeMathInput);
          if (lines.length < 2) throw new Error("System mode expects at least two lines (one equation per line).");
          for (const l of lines) {
            if (!isEquationLine(l)) throw new Error("Each line in a system must be an equation containing '='.");
          }

          const payload = {
            timestamp: nowISO(),
            kind: "system",
            mode: UI.mode.value,
            variable: variable || "auto",
            raw,
            normalized: normalizeForReport(lines),
            methodTag: "System",
            method: "",
            normalizedPreview: buildNormalizedPreview("system", variable, { equations: lines }),
            steps: [],
            solutions: [],
            notes: [],
          };

          const steps = [];
          if (verbosity !== "minimal") {
            steps.push(buildStep("Write the system", payload.normalizedPreview));
          }

          if (!nerdAvailable()) {
            payload.method = "numeric only (symbolic engine missing)";
            addNote(payload, "Nerdamer is required for system solving in this tool.");
            payload.steps = steps.map((st) => ({ ...st, latexPlain: st.latex }));
            return payload;
          }

          let solutionObj = null;
          let method = "";
          const errs = [];

          // Try solveEquations
          try {
            if (typeof window.nerdamer.solveEquations === "function") {
              const res = window.nerdamer.solveEquations(lines);
              method = "nerdamer.solveEquations";
              solutionObj = res;
            }
          } catch (e) {
            errs.push(e?.message || String(e));
          }

          // Parser fallback
          if (!solutionObj) {
            try {
              const joined = lines.map((l) => `(${l})`).join(",");
              const res = window.nerdamer(`solveEquations(${joined})`);
              method = "solveEquations(...)";
              solutionObj = res;
            } catch (e) {
              errs.push(e?.message || String(e));
            }
          }

          if (!solutionObj) {
            payload.method = `system solve failed (${errs[0] || "unknown error"})`;
            addNote(payload, `Symbolic system solver error: ${errs[0] || "unknown error"}`);
            payload.steps = steps.map((st) => ({ ...st, latexPlain: st.latex }));
            return payload;
          }

          payload.method = `symbolic system (${method})`;

          // Normalize into list of assignments: [{var, exact, approx, residuals}]
          const flat = [];
          const rawSolStr = nerdToString(solutionObj);
          // Common nerdamer result: [[x,2],[y,1]] or [["x","2"],["y","1"]]
          if (Array.isArray(solutionObj)) {
            for (const pair of solutionObj) {
              if (Array.isArray(pair) && pair.length >= 2) flat.push({ v: String(pair[0]), s: nerdToString(pair[1]) });
            }
          }

          // Fallback: parse bracketed list string for pairs
          if (!flat.length && rawSolStr.includes("],[")) {
            // Strip outer brackets and split
            const outer = rawSolStr.replace(/^\[/, "").replace(/\]$/, "");
            const parts = outer.split("],[").map((p) => p.replaceAll("[", "").replaceAll("]", "").trim());
            for (const p of parts) {
              const [v, s] = p.split(",").map((x) => x.trim());
              if (v && s) flat.push({ v: v.replaceAll('"', "").replaceAll("'", ""), s });
            }
          }

          if (!flat.length) {
            payload.method = `system solved, but result shape was unexpected`;
            addNote(payload, `Raw solver output: ${rawSolStr}`);
            payload.steps = steps.map((st) => ({ ...st, latexPlain: st.latex }));
            return payload;
          }

          const scope = baseScope();
          for (const it of flat) {
            let approx = null;
            try {
              approx = math.evaluate(it.s, scope);
            } catch {
              approx = null;
            }
            scope[it.v] = approx ?? it.s;
          }

          // Build solution summary with verification residuals (vector norm)
          const residuals = [];
          for (const line of lines) {
            const [l, r] = line.split("=").map((x) => x.trim());
            try {
              const L = math.evaluate(l, scope);
              const R = math.evaluate(r, scope);
              residuals.push(math.subtract(L, R));
            } catch {
              residuals.push(null);
            }
          }

          const maxRes = residuals.reduce((m, r) => Math.max(m, magnitude(r)), 0);
          addNote(payload, `Max residual across equations (with numeric substitution): ${Number.isFinite(maxRes) ? fmtValue(maxRes) : "n/a"}.`);

          payload.solutions = flat.map((it) => ({ exact: `${it.v}=${it.s}`, approx: scope[it.v] ?? null, residual: null }));
          payload.methodTag = "System";

          const assignTex = flat.map((it) => texFromAssignment(it.v, it.s)).join("\\\\");
          steps.push(buildStep("Solve the system", wrapDisplayTex(`\\begin{aligned}${assignTex}\\end{aligned}`)));

          if (verbosity !== "minimal") {
            const resTex = residuals
              .map((r, i) => {
                if (r == null) return `r_${i + 1}=\\text{n/a}`;
                let s = "";
                try {
                  s = nerdSimplify(String(r));
                } catch {
                  s = String(r);
                }
                return `r_${i + 1}=${texFromExpression(s)}`;
              })
              .join("\\\\");
            steps.push(buildStep("Verify by substitution (residuals)", wrapDisplayTex(`\\begin{aligned}${resTex}\\end{aligned}`)));
          }

          payload.steps = steps.map((st) => ({ ...st, latexPlain: st.latex }));
          return payload;
        }

        let lastPayload = null;

        async function solve() {
          clearError();
          const raw = UI.input.value.trim();
          maybeUpdateVariableChoices(raw);
          if (!raw) {
            showError("Enter an equation or expression.");
            return;
          }

          setStatus("Solving…", "Working", "warn");
          UI.solveBtn.disabled = true;
          UI.solveBtn.textContent = "Solving…";
          await new Promise((r) => setTimeout(r, 0));

          try {
            const verbosity = UI.verbosity.value;
            const mode = UI.mode.value;
            const lines = splitLines(raw);
            const variable = chooseVariable(raw);

            let payload;
            if (mode === "expression") {
              payload = solveExpression(raw, verbosity);
            } else if (mode === "system") {
              payload = solveSystem(raw, variable, verbosity);
            } else if (mode === "equation") {
              payload = solveSingleEquation(lines.join(" "), variable, verbosity);
            } else {
              // auto
              const eqLines = lines.filter(isEquationLine);
              if (lines.length > 1 && eqLines.length === lines.length) {
                payload = solveSystem(raw, variable, verbosity);
              } else if (lines.length === 1 && isEquationLine(lines[0])) {
                payload = solveSingleEquation(lines[0], variable, verbosity);
              } else if (lines.length === 1 && !isEquationLine(lines[0])) {
                payload = solveExpression(lines[0], verbosity);
              } else {
                // Mixed: treat as system if at least two equations, otherwise error.
                if (eqLines.length >= 2 && eqLines.length === lines.length) payload = solveSystem(raw, variable, verbosity);
                else throw new Error("Auto mode could not infer intent. Use Mode to pick equation, system, or expression.");
              }
            }

            lastPayload = payload;
            renderOutput(payload);
            pushHistory({
              timestamp: payload.timestamp,
              raw: payload.raw,
              mode: payload.mode,
              variable: UI.variable.value,
              methodTag: payload.methodTag,
              method: payload.method,
              solutions: payload.solutions,
            });
            setStatus("Solved.", payload.methodTag || "Done", "ok");
          } catch (e) {
            showError(e?.message || String(e));
            setStatus("Could not solve. Check the input syntax.", "Error", "bad");
          } finally {
            UI.solveBtn.disabled = false;
            UI.solveBtn.textContent = "Solve";
          }
        }

        function exportLast(kind) {
          if (!lastPayload) {
            showError("Nothing to export yet. Solve a problem first.");
            return;
          }
          const p = buildExportPayload(lastPayload);
          const stamp = new Date(p.timestamp).toISOString().replaceAll(":", "-");
          if (kind === "json") {
            download(`equation-solver-${stamp}.json`, "application/json;charset=utf-8", JSON.stringify(p, null, 2));
          } else if (kind === "txt") {
            download(`equation-solver-${stamp}.txt`, "text/plain;charset=utf-8", payloadToText(p));
          } else {
            download(`equation-solver-${stamp}.md`, "text/markdown;charset=utf-8", payloadToMarkdown(p));
          }
          setStatus("Downloaded report.", "Exported", "ok");
        }

        async function copyLast(kind) {
          if (!lastPayload) {
            showError("Nothing to copy yet. Solve a problem first.");
            return;
          }
          const p = buildExportPayload(lastPayload);
          if (kind === "json") return copy(JSON.stringify(p, null, 2));
          if (kind === "txt") return copy(payloadToText(p));
          return copy(payloadToMarkdown(p));
        }

        function printLast() {
          if (!lastPayload) {
            showError("Nothing to print yet. Solve a problem first.");
            return;
          }
          window.print();
        }

        function insertExample() {
          const ex = EXAMPLES[exampleIndex % EXAMPLES.length];
          exampleIndex++;
          UI.input.value = ex.text;
          if (ex.text.includes("\n") && ex.text.includes("=")) UI.mode.value = "auto";
          if (!ex.text.includes("=")) UI.mode.value = "expression";
          maybeUpdateVariableChoices(UI.input.value);
          setStatus(`Inserted example: ${ex.title}.`, "Example", "ok");
          UI.input.focus();
        }

        function clearAll() {
          UI.input.value = "";
          UI.output.innerHTML = `<div class="muted" id="emptyState">Enter an equation and press <span class="mono">Solve</span>. Results appear here with a step-by-step breakdown.</div>`;
          UI.methodTag.textContent = "—";
          lastPayload = null;
          clearError();
          setStatus("Ready.", "Idle", "ok");
          maybeUpdateVariableChoices("");
        }

        function initLibrariesStatus() {
          const okMath = mathAvailable();
          const okNerd = nerdAvailable();
          const okJax = !!window.MathJax;
          const all = okMath && okNerd && okJax;
          UI.libBadge.textContent = all ? "Libraries ready" : `Math.js: ${okMath ? "ok" : "…"} • Nerdamer: ${okNerd ? "ok" : "…"} • MathJax: ${okJax ? "ok" : "…"}`;
          setReady(all, all ? "Ready" : "Loading");
        }

        function init() {
          initLibrariesStatus();
          const timer = setInterval(() => {
            initLibrariesStatus();
            if (mathAvailable() && nerdAvailable() && window.MathJax?.typesetPromise) clearInterval(timer);
          }, 250);

          renderHistory();
          maybeUpdateVariableChoices(UI.input.value);

          UI.solveBtn.addEventListener("click", solve);
          UI.exampleBtn.addEventListener("click", insertExample);
          UI.clearBtn.addEventListener("click", clearAll);
          UI.exportBtn.addEventListener("click", () => exportLast(UI.exportFormat.value));
          UI.copyBtn.addEventListener("click", () => copyLast(UI.exportFormat.value));
          UI.printBtn.addEventListener("click", printLast);
          UI.clearHistoryBtn.addEventListener("click", () => {
            saveState({ history: [] });
            renderHistory();
            setStatus("History cleared.", "Cleared", "ok");
          });

          UI.input.addEventListener("input", () => {
            maybeUpdateVariableChoices(UI.input.value);
          });

          UI.input.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
              e.preventDefault();
              solve();
            }
          });

          setStatus("Ready.", "Idle", "ok");
        }

        if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
        else init();
      })();
    </script>
  </body>
</html>
