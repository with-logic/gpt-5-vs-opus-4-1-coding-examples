<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
    />
    <meta name="theme-color" content="#070812" />
    <title>Nebula Duel — Asteroids + A.I.</title>
    <style>
      :root {
        --bg0: #04050b;
        --bg1: #070812;
        --ink: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.64);
        --faint: rgba(255, 255, 255, 0.16);
        --cyan: #7ff9ff;
        --mag: #c78bff;
        --gold: #ffd06b;
        --red: #ff4d6d;
        --good: #2dffb2;
        --panel: rgba(6, 9, 18, 0.78);
        --panel2: rgba(6, 9, 18, 0.55);
        --stroke: rgba(255, 255, 255, 0.12);
        --shadow: rgba(0, 0, 0, 0.55);
        --radius: 18px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: radial-gradient(1200px 900px at 30% 25%, #1c2658 0%, var(--bg1) 45%, var(--bg0) 100%);
        color: var(--ink);
        overflow: hidden;
        font-family: var(--sans);
      }

      canvas#game {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        display: block;
        image-rendering: auto;
        filter: drop-shadow(0 0 28px rgba(110, 232, 255, 0.14));
      }

      .ui {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 5;
      }

      .topbar {
        position: absolute;
        top: env(safe-area-inset-top, 0px);
        left: 0;
        right: 0;
        padding: 14px 18px 10px;
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
      }

      .chiprow {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .brand {
        pointer-events: none;
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 9px 12px;
        border-radius: 999px;
        background: linear-gradient(180deg, rgba(8, 10, 18, 0.75), rgba(8, 10, 18, 0.25));
        border: 1px solid var(--stroke);
        box-shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(10px);
      }

      .brand .dot {
        width: 11px;
        height: 11px;
        border-radius: 999px;
        background: radial-gradient(circle at 35% 35%, #ffffff, var(--cyan));
        box-shadow: 0 0 0 6px rgba(127, 249, 255, 0.1), 0 0 28px rgba(127, 249, 255, 0.42);
      }

      .brand .title {
        font-family: var(--mono);
        letter-spacing: 0.18em;
        font-size: 12px;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.86);
        line-height: 1.1;
      }

      .stat {
        font-family: var(--mono);
        padding: 10px 12px;
        border-radius: 999px;
        background: var(--panel2);
        border: 1px solid var(--stroke);
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        display: flex;
        gap: 10px;
        align-items: baseline;
        min-width: 160px;
        justify-content: space-between;
      }

      .stat small {
        color: rgba(255, 255, 255, 0.62);
        letter-spacing: 0.12em;
        text-transform: uppercase;
        font-size: 11px;
      }

      .stat b {
        letter-spacing: 0.08em;
        font-size: 12px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.92);
      }

      .panels {
        position: absolute;
        left: 14px;
        right: 14px;
        bottom: calc(12px + env(safe-area-inset-bottom, 0px));
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 12px;
        padding-bottom: 2px;
      }

      .hud {
        width: min(420px, calc(100vw - 28px));
        border-radius: var(--radius);
        background: linear-gradient(180deg, rgba(10, 13, 25, 0.78), rgba(6, 9, 18, 0.45));
        border: 1px solid var(--stroke);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(12px);
        padding: 12px 12px 10px;
      }

      .hud .row {
        display: grid;
        grid-template-columns: 110px 1fr 72px;
        gap: 10px;
        align-items: center;
        margin: 8px 0;
      }

      .hud .lbl {
        font-family: var(--mono);
        font-size: 11px;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.64);
      }

      .hud .val {
        font-family: var(--mono);
        font-size: 12px;
        letter-spacing: 0.1em;
        text-align: right;
        color: rgba(255, 255, 255, 0.86);
      }

      .bar {
        height: 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.12);
        overflow: hidden;
        position: relative;
      }

      .bar > i {
        position: absolute;
        inset: 0;
        width: 50%;
        transform-origin: left center;
        border-radius: 999px;
      }

      .bar.hp > i {
        background: linear-gradient(90deg, rgba(45, 255, 178, 0.85), rgba(127, 249, 255, 0.85));
        box-shadow: 0 0 18px rgba(45, 255, 178, 0.25);
      }

      .bar.sh > i {
        background: linear-gradient(90deg, rgba(127, 249, 255, 0.85), rgba(199, 139, 255, 0.85));
        box-shadow: 0 0 18px rgba(127, 249, 255, 0.2);
      }

      .bar.ht > i {
        background: linear-gradient(90deg, rgba(255, 208, 107, 0.8), rgba(255, 77, 109, 0.85));
        box-shadow: 0 0 18px rgba(255, 77, 109, 0.14);
      }

      .minimap {
        width: 170px;
        height: 170px;
        border-radius: 20px;
        background: radial-gradient(circle at 35% 35%, rgba(127, 249, 255, 0.08), rgba(10, 13, 25, 0.65));
        border: 1px solid var(--stroke);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(12px);
        display: grid;
        place-items: center;
        padding: 10px;
      }

      #map {
        width: 100%;
        height: 100%;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .toast {
        position: absolute;
        left: 50%;
        bottom: 218px;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
        text-align: center;
        padding: 0 12px;
      }

      .toast .msg {
        pointer-events: none;
        padding: 10px 14px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(6, 9, 18, 0.55);
        backdrop-filter: blur(10px);
        box-shadow: 0 16px 50px rgba(0, 0, 0, 0.35);
        font-family: var(--mono);
        font-size: 12px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.82);
        max-width: min(620px, calc(100vw - 36px));
        white-space: pre-wrap;
      }

      .overlay {
        position: fixed;
        inset: 0;
        z-index: 10;
        display: grid;
        place-items: center;
        background: radial-gradient(900px 600px at 30% 30%, rgba(25, 38, 88, 0.45), rgba(0, 0, 0, 0.78));
        backdrop-filter: blur(10px);
      }

      .overlay.hidden {
        display: none;
      }

      .panel {
        pointer-events: auto;
        width: min(860px, calc(100vw - 28px));
        border-radius: 26px;
        padding: 22px 20px 18px;
        background: linear-gradient(180deg, rgba(10, 13, 25, 0.9), rgba(6, 9, 18, 0.55));
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: 0 32px 120px rgba(0, 0, 0, 0.55);
      }

      .panel header {
        display: flex;
        gap: 14px;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .panel h1 {
        margin: 0;
        font-family: var(--mono);
        letter-spacing: 0.22em;
        text-transform: uppercase;
        font-size: clamp(22px, 3vw, 34px);
      }

      .panel p {
        margin: 8px 0 0;
        color: rgba(255, 255, 255, 0.82);
        line-height: 1.6;
        max-width: 70ch;
        white-space: pre-wrap;
      }

      .grid {
        display: grid;
        grid-template-columns: 1.35fr 1fr;
        gap: 16px;
        margin-top: 14px;
      }

      @media (max-width: 880px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.18);
        padding: 14px 14px 12px;
      }

      .card h3 {
        margin: 0 0 10px;
        font-family: var(--mono);
        font-size: 12px;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.85);
      }

      .kbd {
        font-family: var(--mono);
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(255, 255, 255, 0.06);
        color: rgba(255, 255, 255, 0.9);
        white-space: nowrap;
      }

      .list {
        display: grid;
        gap: 8px;
        margin: 0;
        padding: 0;
        list-style: none;
        color: rgba(255, 255, 255, 0.82);
        line-height: 1.55;
      }

      .list li {
        display: flex;
        gap: 10px;
        align-items: baseline;
      }

      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-end;
        margin-top: 16px;
      }

      button {
        pointer-events: auto;
        border: 0;
        border-radius: 999px;
        padding: 12px 16px;
        font-family: var(--mono);
        letter-spacing: 0.12em;
        text-transform: uppercase;
        font-weight: 700;
        font-size: 12px;
        color: rgba(0, 0, 0, 0.85);
        cursor: pointer;
        background: linear-gradient(120deg, rgba(127, 249, 255, 1), rgba(199, 139, 255, 1));
        box-shadow: 0 14px 50px rgba(127, 249, 255, 0.16);
        transition: transform 0.15s ease, filter 0.15s ease;
      }

      button.secondary {
        color: rgba(255, 255, 255, 0.88);
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: none;
      }

      button:hover {
        transform: translateY(-1px);
        filter: brightness(1.04);
      }

      button:active {
        transform: translateY(0px) scale(0.99);
      }

      .fineprint {
        margin-top: 10px;
        color: rgba(255, 255, 255, 0.58);
        font-size: 12px;
      }

      .damage {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 6;
        background: radial-gradient(1200px 700px at 50% 50%, rgba(255, 77, 109, 0), rgba(255, 77, 109, 0.22));
        opacity: 0;
        transition: opacity 0.12s ease;
        mix-blend-mode: screen;
      }

      .crosshair {
        position: fixed;
        left: 0;
        top: 0;
        width: 18px;
        height: 18px;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 7;
        opacity: 0.9;
        filter: drop-shadow(0 0 10px rgba(127, 249, 255, 0.25));
      }

      .crosshair:before,
      .crosshair:after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 999px;
        border: 1px solid rgba(127, 249, 255, 0.65);
      }

      .crosshair:after {
        inset: 5px;
        border-color: rgba(199, 139, 255, 0.6);
      }

      .mobile {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 9;
        display: none;
      }

      .stick {
        position: absolute;
        bottom: calc(18px + env(safe-area-inset-bottom, 0px));
        width: 168px;
        height: 168px;
        border-radius: 999px;
        background: radial-gradient(circle at 35% 35%, rgba(127, 249, 255, 0.08), rgba(0, 0, 0, 0.18));
        border: 1px solid rgba(255, 255, 255, 0.14);
        backdrop-filter: blur(10px);
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
      }

      .stick.left {
        left: 16px;
      }

      .stick.right {
        right: 16px;
      }

      .stick .knob {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 58px;
        height: 58px;
        transform: translate(-50%, -50%);
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: 0 0 0 10px rgba(127, 249, 255, 0.08);
      }

      .btnpad {
        position: absolute;
        right: 16px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: auto;
      }

      .btnpad button {
        width: 120px;
        justify-content: center;
        text-align: center;
      }

      @media (pointer: coarse) {
        .mobile {
          display: block;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>

    <div class="ui" id="ui">
      <div class="topbar">
        <div class="brand" aria-label="Game title">
          <div class="dot"></div>
          <div class="title">
            Nebula Duel<br />
            <span style="letter-spacing: 0.12em; color: rgba(255, 255, 255, 0.62)">Asteroids + A.I.</span>
          </div>
        </div>
        <div class="chiprow">
          <div class="stat"><small>Wave</small><b id="wave">1</b></div>
          <div class="stat"><small>Score</small><b id="score">0</b></div>
          <div class="stat"><small>Hostiles</small><b id="hostiles">0</b></div>
        </div>
      </div>

      <div class="panels">
        <div class="hud" aria-label="HUD">
          <div class="row">
            <div class="lbl">Hull</div>
            <div class="bar hp"><i id="hpFill" style="transform: scaleX(1)"></i></div>
            <div class="val" id="hpText">100</div>
          </div>
          <div class="row">
            <div class="lbl">Shield</div>
            <div class="bar sh"><i id="shFill" style="transform: scaleX(0)"></i></div>
            <div class="val" id="shText">0</div>
          </div>
          <div class="row">
            <div class="lbl">Heat</div>
            <div class="bar ht"><i id="htFill" style="transform: scaleX(0)"></i></div>
            <div class="val" id="htText">0%</div>
          </div>
          <div style="display: flex; justify-content: space-between; gap: 10px; margin-top: 10px">
            <div
              style="
                font-family: var(--mono);
                font-size: 11px;
                letter-spacing: 0.12em;
                color: rgba(255, 255, 255, 0.62);
              "
            >
              <span id="weaponLabel">PRIMARY: PULSE</span>
            </div>
            <div
              style="
                font-family: var(--mono);
                font-size: 11px;
                letter-spacing: 0.12em;
                color: rgba(255, 255, 255, 0.62);
              "
            >
              <span id="missileLabel">MISSILES: 2</span>
            </div>
          </div>
        </div>

        <div class="minimap" aria-label="Minimap">
          <canvas id="map" width="220" height="220"></canvas>
        </div>
      </div>

      <div class="toast" aria-live="polite" aria-atomic="true">
        <div class="msg" id="toast"></div>
      </div>
    </div>

    <div class="damage" id="damage"></div>
    <div class="crosshair" id="crosshair" aria-hidden="true"></div>

    <div class="overlay" id="overlay">
      <div class="panel">
        <header>
          <h1>Nebula Duel</h1>
          <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center">
            <button class="secondary" id="btnMute" type="button">Sound: On</button>
            <button class="secondary" id="btnAim" type="button">Aim: Mouse</button>
          </div>
        </header>
        <p>
          You are the <span style="color: var(--cyan); font-weight: 700">Kestrel</span>, a prototype interceptor with
          vector thrusters. Clear the field, survive the dogfight, and ride the chaos of a living asteroid belt.
        </p>
        <div class="grid">
          <div class="card">
            <h3>Controls</h3>
            <ul class="list">
              <li><span class="kbd">W A S D</span><span>Thrust (relative to your aim)</span></li>
              <li><span class="kbd">Mouse</span><span>Aim</span></li>
              <li><span class="kbd">Click / Space</span><span>Fire pulse cannon (heats up)</span></li>
              <li><span class="kbd">Shift</span><span>Boost (more heat)</span></li>
              <li><span class="kbd">Right‑Click / Q</span><span>Homing missile</span></li>
              <li><span class="kbd">E</span><span>Ion burst (knocks nearby threats)</span></li>
              <li><span class="kbd">T</span><span>Toggle mouse/keys aim</span></li>
              <li><span class="kbd">P</span><span>Pause</span></li>
              <li><span class="kbd">H</span><span>Toggle help</span></li>
            </ul>
          </div>
          <div class="card">
            <h3>Tips</h3>
            <ul class="list">
              <li><span class="kbd">Heat</span><span>Let it cool for accurate volleys</span></li>
              <li><span class="kbd">Shield</span><span>Recharges after not taking hits</span></li>
              <li><span class="kbd">Ion</span><span>Blows up bullets & nudges asteroids</span></li>
              <li><span class="kbd">Minimap</span><span>Hostiles are red; big rocks are orange</span></li>
              <li><span class="kbd">Wrap</span><span>Space folds—fly off one edge, appear on the other</span></li>
            </ul>
          </div>
        </div>
        <div class="actions">
          <button id="btnStart" type="button">Engage</button>
          <button class="secondary" id="btnReset" type="button">Reset</button>
        </div>
        <div class="fineprint">
          Built for keyboards, mice, and touch. If a browser blocks audio until interaction, press Engage first.
        </div>
      </div>
    </div>

    <div class="mobile" id="mobile">
      <div class="stick left" id="leftStick"><div class="knob" id="leftKnob"></div></div>
      <div class="stick right" id="rightStick"><div class="knob" id="rightKnob"></div></div>
      <div class="btnpad">
        <button id="btnFire" type="button">Fire</button>
        <button class="secondary" id="btnMissile" type="button">Missile</button>
        <button class="secondary" id="btnIon" type="button">Ion</button>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        const TAU = Math.PI * 2;
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const rand = (a = 0, b = 1) => a + Math.random() * (b - a);
        const randi = (a, b) => Math.floor(rand(a, b + 1));
        const pick = (arr) => arr[(Math.random() * arr.length) | 0];
        const angleOf = (x, y) => Math.atan2(y, x);
        const angleDiff = (a, b) => Math.atan2(Math.sin(a - b), Math.cos(a - b));
        const wrap = (v, m) => {
          v %= m;
          if (v < 0) v += m;
          return v;
        };
        const wrapDelta = (d, m) => {
          d = ((d + m / 2) % m) - m / 2;
          if (d < -m / 2) d += m;
          return d;
        };
        const distWrap = (ax, ay, bx, by, w, h) => {
          const dx = wrapDelta(bx - ax, w);
          const dy = wrapDelta(by - ay, h);
          return [dx, dy, Math.hypot(dx, dy)];
        };

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });
        const mapCanvas = document.getElementById("map");
        const mapCtx = mapCanvas.getContext("2d", { alpha: true });

        const el = {
          overlay: document.getElementById("overlay"),
          btnStart: document.getElementById("btnStart"),
          btnReset: document.getElementById("btnReset"),
          btnMute: document.getElementById("btnMute"),
          btnAim: document.getElementById("btnAim"),
          toast: document.getElementById("toast"),
          damage: document.getElementById("damage"),
          crosshair: document.getElementById("crosshair"),
          wave: document.getElementById("wave"),
          score: document.getElementById("score"),
          hostiles: document.getElementById("hostiles"),
          hpFill: document.getElementById("hpFill"),
          hpText: document.getElementById("hpText"),
          shFill: document.getElementById("shFill"),
          shText: document.getElementById("shText"),
          htFill: document.getElementById("htFill"),
          htText: document.getElementById("htText"),
          weaponLabel: document.getElementById("weaponLabel"),
          missileLabel: document.getElementById("missileLabel"),
          mobile: document.getElementById("mobile"),
          leftStick: document.getElementById("leftStick"),
          rightStick: document.getElementById("rightStick"),
          leftKnob: document.getElementById("leftKnob"),
          rightKnob: document.getElementById("rightKnob"),
          btnFire: document.getElementById("btnFire"),
          btnMissile: document.getElementById("btnMissile"),
          btnIon: document.getElementById("btnIon"),
        };

        // ---------- Audio ----------
        let audio = null;
        const Audio = () => {
          const ACtx = window.AudioContext || window.webkitAudioContext;
          const ctxA = new ACtx();
          const master = ctxA.createGain();
          master.gain.value = 0.75;
          master.connect(ctxA.destination);

          const now = () => ctxA.currentTime;
          const ramp = (param, v, t = 0.015) => param.setTargetAtTime(v, now(), t);

          const noiseBuffer = (() => {
            const len = ctxA.sampleRate * 1.1;
            const buf = ctxA.createBuffer(1, len, ctxA.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 0.25);
            return buf;
          })();

          const blip = (freq, dur, type = "square", vol = 0.25, bend = 0) => {
            const o = ctxA.createOscillator();
            const g = ctxA.createGain();
            o.type = type;
            o.frequency.setValueAtTime(freq, now());
            if (bend) o.frequency.exponentialRampToValueAtTime(Math.max(40, freq * bend), now() + dur);
            g.gain.setValueAtTime(0.0001, now());
            g.gain.exponentialRampToValueAtTime(vol, now() + 0.01);
            g.gain.exponentialRampToValueAtTime(0.0001, now() + dur);
            o.connect(g);
            g.connect(master);
            o.start();
            o.stop(now() + dur + 0.02);
          };

          const hiss = (dur, vol = 0.22, hp = 900, lp = 6000) => {
            const src = ctxA.createBufferSource();
            src.buffer = noiseBuffer;
            const hpf = ctxA.createBiquadFilter();
            const lpf = ctxA.createBiquadFilter();
            hpf.type = "highpass";
            lpf.type = "lowpass";
            hpf.frequency.value = hp;
            lpf.frequency.value = lp;
            const g = ctxA.createGain();
            g.gain.setValueAtTime(0.0001, now());
            g.gain.exponentialRampToValueAtTime(vol, now() + 0.02);
            g.gain.exponentialRampToValueAtTime(0.0001, now() + dur);
            src.connect(hpf);
            hpf.connect(lpf);
            lpf.connect(g);
            g.connect(master);
            src.start();
            src.stop(now() + dur + 0.05);
          };

          let thr = null;
          const thruster = (on) => {
            if (on && !thr) {
              const o = ctxA.createOscillator();
              const o2 = ctxA.createOscillator();
              o.type = "sawtooth";
              o2.type = "triangle";
              const g = ctxA.createGain();
              const g2 = ctxA.createGain();
              const f = ctxA.createBiquadFilter();
              f.type = "lowpass";
              f.frequency.value = 1200;
              g.gain.value = 0.0001;
              g2.gain.value = 0.0001;
              o.frequency.value = 58;
              o2.frequency.value = 116;
              o.connect(g);
              o2.connect(g2);
              g.connect(f);
              g2.connect(f);
              f.connect(master);
              o.start();
              o2.start();
              thr = { o, o2, g, g2, f, k: 0 };
            }
            if (!on && thr) {
              ramp(thr.g.gain, 0.0001, 0.05);
              ramp(thr.g2.gain, 0.0001, 0.05);
              setTimeout(() => {
                try {
                  thr.o.stop();
                  thr.o2.stop();
                } catch {}
                thr = null;
              }, 120);
            }
          };

          const setThr = (v) => {
            if (!thr) return;
            const t = clamp(v, 0, 1);
            thr.k = lerp(thr.k, t, 0.18);
            const k = thr.k;
            ramp(thr.g.gain, 0.0001 + k * 0.12, 0.04);
            ramp(thr.g2.gain, 0.0001 + k * 0.06, 0.04);
            ramp(thr.o.frequency, 52 + k * 120, 0.05);
            ramp(thr.o2.frequency, 110 + k * 240, 0.05);
            ramp(thr.f.frequency, 900 + k * 3200, 0.05);
          };

          return { ctxA, master, blip, hiss, thruster, setThr };
        };

        // ---------- Input ----------
        const input = {
          keys: new Set(),
          mouse: { x: 0, y: 0, down: false, rdown: false, movedAt: 0 },
          useMouseAim: true,
          touch: {
            left: { id: null, cx: 0, cy: 0, v: { x: 0, y: 0 } },
            right: { id: null, cx: 0, cy: 0, v: { x: 0, y: 0 } },
            fire: false,
            missile: false,
            ion: false,
          },
        };

        const isTypingInto = (t) => {
          const tag = (t && t.tagName ? t.tagName.toLowerCase() : "");
          return tag === "input" || tag === "textarea" || tag === "select";
        };

        window.addEventListener("keydown", (e) => {
          if (isTypingInto(e.target)) return;
          input.keys.add(e.code);
          if (e.code === "Space") e.preventDefault();
          if (e.code === "KeyP") togglePause();
          if (e.code === "KeyH") toggleHelp();
          if (e.code === "KeyM") toggleMute();
          if (e.code === "KeyT") toggleAimMode();
          if (e.code === "KeyR" && (state.gameOver || !state.running)) resetGame();
        });
        window.addEventListener("keyup", (e) => {
          input.keys.delete(e.code);
        });
        window.addEventListener("blur", () => input.keys.clear());

        canvas.addEventListener("pointermove", (e) => {
          const rect = canvas.getBoundingClientRect();
          input.mouse.x = e.clientX - rect.left;
          input.mouse.y = e.clientY - rect.top;
          input.mouse.movedAt = performance.now();
          if (e.pointerType === "mouse") {
            el.crosshair.style.left = e.clientX + "px";
            el.crosshair.style.top = e.clientY + "px";
          }
        });

        canvas.addEventListener("pointerdown", (e) => {
          if (!state.running) return;
          input.mouse.down = e.button === 0 || input.mouse.down;
          input.mouse.rdown = e.button === 2 || input.mouse.rdown;
          if (audio && audio.ctxA.state === "suspended") audio.ctxA.resume().catch(() => {});
        });
        canvas.addEventListener("pointerup", (e) => {
          if (e.button === 0) input.mouse.down = false;
          if (e.button === 2) input.mouse.rdown = false;
        });
        canvas.addEventListener("contextmenu", (e) => e.preventDefault());

        const stick = (root, knob, side) => {
          const s = input.touch[side];
          const setKnob = (x, y) => {
            knob.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
          };
          const setNeutral = () => {
            setKnob(0, 0);
            s.v.x = 0;
            s.v.y = 0;
          };
          const onDown = (e) => {
            if (!state.running) return;
            if (s.id !== null) return;
            s.id = e.pointerId;
            const r = root.getBoundingClientRect();
            s.cx = r.left + r.width / 2;
            s.cy = r.top + r.height / 2;
            root.setPointerCapture(e.pointerId);
          };
          const onMove = (e) => {
            if (s.id !== e.pointerId) return;
            const dx = e.clientX - s.cx;
            const dy = e.clientY - s.cy;
            const max = 56;
            const d = Math.hypot(dx, dy);
            const k = d > max ? max / d : 1;
            const nx = dx * k;
            const ny = dy * k;
            setKnob(nx, ny);
            s.v.x = nx / max;
            s.v.y = ny / max;
          };
          const onUp = (e) => {
            if (s.id !== e.pointerId) return;
            try {
              root.releasePointerCapture(e.pointerId);
            } catch {}
            s.id = null;
            setNeutral();
          };
          root.addEventListener("pointerdown", onDown);
          root.addEventListener("pointermove", onMove);
          root.addEventListener("pointerup", onUp);
          root.addEventListener("pointercancel", onUp);
          root.addEventListener("lostpointercapture", () => {
            s.id = null;
            setNeutral();
          });
          return { setNeutral };
        };

        const leftStick = stick(el.leftStick, el.leftKnob, "left");
        const rightStick = stick(el.rightStick, el.rightKnob, "right");

        el.btnFire.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          input.touch.fire = true;
          el.btnFire.setPointerCapture(e.pointerId);
        });
        el.btnFire.addEventListener("pointerup", () => (input.touch.fire = false));
        el.btnFire.addEventListener("pointercancel", () => (input.touch.fire = false));

        el.btnMissile.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          input.touch.missile = true;
          setTimeout(() => (input.touch.missile = false), 90);
        });

        el.btnIon.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          input.touch.ion = true;
          setTimeout(() => (input.touch.ion = false), 90);
        });

        // ---------- Game State ----------
        const WORLD = { w: 5200, h: 5200 };
        const state = {
          running: false,
          paused: false,
          showHelp: true,
          gameOver: false,
          muted: false,
          t: 0,
          dt: 0,
          score: 0,
          wave: 1,
          shake: 0,
          toast: { text: "", until: 0 },
          cam: { x: 0, y: 0, z: 1, vx: 0, vy: 0 },
        };

        const fx = { particles: [], pool: [] };

        const entities = {
          player: null,
          ships: [],
          asteroids: [],
          bullets: [],
          missiles: [],
          pickups: [],
        };

        const weaponDefs = {
          pulse: { name: "PULSE", heatPerShot: 0.085, cooldown: 0.09, speed: 1450, spread: 0.04, dmg: 12, color: [127, 249, 255] },
          scatter: { name: "SCATTER", heatPerShot: 0.11, cooldown: 0.14, speed: 1200, spread: 0.22, dmg: 8, pellets: 4, color: [255, 208, 107] },
          lance: { name: "LANCE", heatPerShot: 0.16, cooldown: 0.19, speed: 2100, spread: 0.012, dmg: 18, pierce: 1, color: [199, 139, 255] },
        };

        const shipKinds = {
          wasp: { name: "Wasp", hp: 60, accel: 820, maxSpeed: 840, turn: 7.5, weapon: "scatter", hue: 50, ai: { prefer: 540, strafe: 0.8, aggression: 0.74 } },
          manta: { name: "Manta", hp: 80, accel: 720, maxSpeed: 760, turn: 6.3, weapon: "pulse", hue: 185, ai: { prefer: 620, strafe: 0.55, aggression: 0.62 } },
          goliath: { name: "Goliath", hp: 120, accel: 600, maxSpeed: 690, turn: 5.2, weapon: "lance", hue: 345, ai: { prefer: 720, strafe: 0.35, aggression: 0.7 } },
        };

        const makePoly = (radius, points = 10, jag = 0.32) => {
          const pts = [];
          const a0 = rand(0, TAU);
          for (let i = 0; i < points; i++) {
            const t = i / points;
            const rr = radius * (1 - jag + rand(0, jag * 2));
            const aa = a0 + t * TAU;
            pts.push([Math.cos(aa) * rr, Math.sin(aa) * rr]);
          }
          return pts;
        };

        const createPlayer = () => ({
          type: "player",
          x: WORLD.w / 2,
          y: WORLD.h / 2,
          vx: 0,
          vy: 0,
          aim: 0,
          hp: 100,
          hpMax: 100,
          sh: 0,
          shMax: 75,
          shDelay: 0,
          heat: 0,
          overheat: 0,
          weapon: "pulse",
          cooldown: 0,
          missiles: 2,
          missilesMax: 2,
          missileRegen: 0,
          ion: 1,
          ionCd: 0,
          ionRegen: 0,
          inv: 0,
          combo: 0,
          comboT: 0,
        });

        const createAIShip = (kind, x, y) => {
          const k = shipKinds[kind];
          return {
            type: "ai",
            kind,
            name: k.name,
            x: x ?? rand(0, WORLD.w),
            y: y ?? rand(0, WORLD.h),
            vx: rand(-80, 80),
            vy: rand(-80, 80),
            aim: rand(0, TAU),
            hp: k.hp,
            hpMax: k.hp,
            sh: 30,
            shMax: 30,
            shDelay: 0,
            heat: 0,
            overheat: 0,
            weapon: k.weapon,
            cooldown: rand(0, 0.25),
            missiles: kind === "manta" ? 1 : 0,
            missilesMax: kind === "manta" ? 1 : 0,
            missileRegen: rand(0, 2),
            inv: 0,
            ai: { seed: Math.random(), think: rand(0.1, 0.25), desired: { f: 0, s: 0, fire: false, missile: false, aim: rand(0, TAU) } },
          };
        };

        const createAsteroid = (tier = 3, x, y, vx, vy) => {
          const base = [18, 30, 48, 76][tier] ?? 48;
          const r = base * rand(0.86, 1.16);
          return {
            type: "asteroid",
            tier,
            x: x ?? rand(0, WORLD.w),
            y: y ?? rand(0, WORLD.h),
            vx: vx ?? rand(-120, 120),
            vy: vy ?? rand(-120, 120),
            r,
            a: rand(0, TAU),
            spin: rand(-1.1, 1.1) * (1.1 / (tier + 0.6)),
            pts: makePoly(r, randi(8, 14), 0.35),
            hp: Math.round(r * 1.2),
            hpMax: Math.round(r * 1.2),
          };
        };

        const createBullet = (owner, x, y, vx, vy, dmg, color, life = 0.8, pierce = 0) => ({
          type: "bullet",
          owner,
          x,
          y,
          vx,
          vy,
          dmg,
          color,
          life,
          pierce,
          r: 2.5,
        });

        const createMissile = (owner, x, y, vx, vy, targetId) => ({
          type: "missile",
          owner,
          id: (Math.random() * 1e9) | 0,
          x,
          y,
          vx,
          vy,
          a: angleOf(vx, vy),
          life: 3.5,
          r: 7,
          turn: 7.6,
          accel: 620,
          maxSpeed: 1250,
          targetId,
          armed: 0.2,
        });

        const createPickup = (kind, x, y) => {
          const spec =
            kind === "weapon"
              ? { r: 12, col: [199, 139, 255] }
              : kind === "shield"
                ? { r: 12, col: [127, 249, 255] }
                : kind === "missile"
                  ? { r: 12, col: [255, 208, 107] }
                  : { r: 12, col: [45, 255, 178] };
          return { type: "pickup", kind, x, y, vx: rand(-40, 40), vy: rand(-40, 40), life: 12, ...spec, t: 0 };
        };

        const allocParticle =
          () =>
            fx.pool.pop() ?? {
              type: "p",
              x: 0,
              y: 0,
              vx: 0,
              vy: 0,
              life: 0,
              r: 2,
              a: 0,
              spin: 0,
              col: [255, 255, 255],
              add: 0,
              drag: 0,
            };

        const spawnParticles = (n, x, y, col, speed, life, r0, add = 0.4) => {
          for (let i = 0; i < n; i++) {
            const p = allocParticle();
            const a = rand(0, TAU);
            const s = speed * (0.3 + Math.random() * 0.9);
            p.x = x;
            p.y = y;
            p.vx = Math.cos(a) * s;
            p.vy = Math.sin(a) * s;
            p.life = life * (0.55 + Math.random() * 0.9);
            p.r = r0 * (0.6 + Math.random() * 1.2);
            p.a = rand(0, TAU);
            p.spin = rand(-8, 8);
            p.col = col;
            p.add = add;
            p.drag = rand(0.5, 1.6);
            fx.particles.push(p);
          }
        };

        const toast = (text, ms = 1400) => {
          state.toast.text = text;
          state.toast.until = performance.now() + ms;
          el.toast.textContent = text;
        };

        const setUIVisible = (v) => {
          document.getElementById("ui").style.opacity = v ? "1" : "0";
        };

        // ---------- Spawning / Progression ----------
        const safeSpawn = (minDist = 900) => {
          const p = entities.player;
          for (let tries = 0; tries < 24; tries++) {
            const x = rand(0, WORLD.w);
            const y = rand(0, WORLD.h);
            const [, , d] = distWrap(x, y, p.x, p.y, WORLD.w, WORLD.h);
            if (d > minDist) return [x, y];
          }
          return [rand(0, WORLD.w), rand(0, WORLD.h)];
        };

        const beginWave = (n) => {
          state.wave = n;
          toast(`WAVE ${n} — ENGAGE`, 1200);
          if (audio) audio.blip(140 + n * 12, 0.14, "sawtooth", 0.22, 0.75);

          const asteroidCount = Math.min(46, 10 + n * 3);
          const aiCount = Math.min(14, 2 + Math.floor(n * 0.9));

          while (entities.asteroids.length < asteroidCount) {
            const [x, y] = safeSpawn(820);
            entities.asteroids.push(createAsteroid(randi(1, 3), x, y));
          }
          while (entities.ships.length < aiCount) {
            const [x, y] = safeSpawn(920);
            const kind = pick(n < 3 ? ["wasp", "manta"] : ["wasp", "manta", "goliath"]);
            entities.ships.push(createAIShip(kind, x, y));
          }
        };

        // ---------- Mechanics ----------
        const takeDamage = (ship, dmg, fromX, fromY) => {
          if (ship.inv > 0) return 0;
          ship.shDelay = 1.6;

          let dealt = 0;
          if (ship.sh > 0) {
            const s = Math.min(ship.sh, dmg);
            ship.sh -= s;
            dmg -= s;
            dealt += s;
          }
          if (dmg > 0) {
            ship.hp = Math.max(0, ship.hp - dmg);
            dealt += dmg;
          }

          if (ship.type === "player") {
            state.shake = Math.min(18, state.shake + 6);
            el.damage.style.opacity = "1";
            setTimeout(() => (el.damage.style.opacity = "0"), 90);
            if (audio) {
              audio.hiss(0.12, 0.1, 900, 6800);
              audio.blip(170, 0.08, "square", 0.11, 0.6);
            }
          }
          if (ship.hp <= 0) explodeShip(ship, fromX, fromY);
          return dealt;
        };

        const explodeShip = (ship, fromX, fromY) => {
          ship.hp = 0;
          ship.inv = 0;
          const col =
            ship.type === "player"
              ? [127, 249, 255]
              : ship.kind === "goliath"
                ? [255, 77, 109]
                : ship.kind === "wasp"
                  ? [255, 208, 107]
                  : [127, 249, 255];

          spawnParticles(110, ship.x, ship.y, col, 560, 0.9, 3.8, 0.55);
          spawnParticles(60, ship.x, ship.y, [255, 255, 255], 820, 0.7, 2.4, 0.45);
          state.shake = Math.min(26, state.shake + 14);

          if (audio) {
            audio.hiss(0.32, 0.25, 280, 5000);
            audio.blip(90, 0.22, "sawtooth", 0.25, 0.55);
            audio.blip(180, 0.08, "square", 0.16, 0.55);
          }

          if (ship.type === "player") {
            state.gameOver = true;
            state.running = false;
            showOverlay("Ship lost.", `Score: ${state.score}\nWave: ${state.wave}\n\nPress R to retry.`);
          } else {
            state.score += 150;
            if (entities.player) {
              entities.player.combo = Math.min(10, entities.player.combo + 1);
              entities.player.comboT = 2.2;
            }
          }
        };

        const explodeAsteroid = (a, hitX, hitY, impulseX, impulseY) => {
          spawnParticles(80, a.x, a.y, [255, 208, 107], 360, 0.85, 3.2, 0.35);
          spawnParticles(40, a.x, a.y, [255, 255, 255], 520, 0.65, 2.2, 0.25);
          state.shake = Math.min(20, state.shake + 7);

          if (audio) {
            audio.hiss(0.18, 0.15, 420, 3200);
            audio.blip(110, 0.12, "triangle", 0.15, 0.72);
          }

          state.score += 25 + a.tier * 10;

          if (a.tier > 1) {
            const pieces = randi(2, 3);
            for (let i = 0; i < pieces; i++) {
              const t2 = a.tier - 1;
              const ang = rand(0, TAU);
              const sp = rand(100, 260);
              const nx = wrap(a.x + Math.cos(ang) * a.r * 0.22, WORLD.w);
              const ny = wrap(a.y + Math.sin(ang) * a.r * 0.22, WORLD.h);
              const nvx = a.vx + Math.cos(ang) * sp + impulseX * 0.12;
              const nvy = a.vy + Math.sin(ang) * sp + impulseY * 0.12;
              entities.asteroids.push(createAsteroid(t2, nx, ny, nvx, nvy));
            }
          } else if (Math.random() < 0.14) {
            const kind = pick(["shield", "missile", "weapon", "heal"]);
            entities.pickups.push(createPickup(kind, a.x, a.y));
          }
        };

        const fireWeapon = (ship, isPlayer = false, allowSound = true) => {
          if (ship.cooldown > 0 || ship.overheat > 0) return;
          const w = weaponDefs[ship.weapon];
          if (!w) return;

          const heatMult = isPlayer && (input.keys.has("ShiftLeft") || input.keys.has("ShiftRight")) ? 1.18 : 1;
          ship.heat = clamp(ship.heat + w.heatPerShot * heatMult, 0, 1.35);
          ship.cooldown = w.cooldown;

          const px = ship.x;
          const py = ship.y;
          const muzzle = 18;
          const pelletCount = w.pellets ?? 1;

          for (let i = 0; i < pelletCount; i++) {
            const sp = w.spread * (pelletCount > 1 ? 1.05 : 1);
            const spread = rand(-sp, sp);
            const ang = ship.aim + spread;
            const bx = wrap(px + Math.cos(ang) * muzzle, WORLD.w);
            const by = wrap(py + Math.sin(ang) * muzzle, WORLD.h);
            const bvx = ship.vx + Math.cos(ang) * w.speed;
            const bvy = ship.vy + Math.sin(ang) * w.speed;
            entities.bullets.push(createBullet(ship.type === "player" ? "player" : ship, bx, by, bvx, bvy, w.dmg, w.color, 0.85, w.pierce ?? 0));
          }

          if (allowSound && audio) {
            const f = ship.weapon === "lance" ? 300 : ship.weapon === "scatter" ? 220 : 260;
            const v = ship.weapon === "lance" ? 0.2 : ship.weapon === "scatter" ? 0.16 : 0.14;
            audio.blip(f, 0.06, ship.weapon === "lance" ? "triangle" : "square", v, 0.72);
          }
          spawnParticles(8, px + Math.cos(ship.aim) * muzzle, py + Math.sin(ship.aim) * muzzle, w.color, 160, 0.26, 2.2, 0.5);
        };

        let nextId = 1;
        const ensureIds = () => {
          if (entities.player && !entities.player._id) entities.player._id = nextId++;
          for (const a of entities.asteroids) if (!a._id) a._id = nextId++;
          for (const s of entities.ships) if (!s._id) s._id = nextId++;
        };
        const findShipById = (id) => {
          if (!id) return null;
          const p = entities.player;
          if (p && p._id === id) return p;
          for (const s of entities.ships) if (s._id === id) return s;
          return null;
        };

        const leadAim = (sx, sy, svx, svy, tx, ty, tvx, tvy, projectileSpeed) => {
          const rx = tx - sx;
          const ry = ty - sy;
          const rvx = tvx - svx;
          const rvy = tvy - svy;
          const a = rvx * rvx + rvy * rvy - projectileSpeed * projectileSpeed;
          const b = 2 * (rx * rvx + ry * rvy);
          const c = rx * rx + ry * ry;
          let t = 0;
          if (Math.abs(a) < 1e-6) t = -c / (b || 1e-6);
          else {
            const disc = b * b - 4 * a * c;
            if (disc >= 0) {
              const s = Math.sqrt(disc);
              const t1 = (-b - s) / (2 * a);
              const t2 = (-b + s) / (2 * a);
              t = Math.min(t1, t2);
              if (t < 0) t = Math.max(t1, t2);
            } else t = 0;
          }
          t = clamp(t, 0, 1.2);
          return angleOf(rx + rvx * t, ry + rvy * t);
        };

        const nearestHostile = (p) => {
          let best = null;
          let bestD = Infinity;
          for (const s of entities.ships) {
            if (s.hp <= 0) continue;
            const [, , d] = distWrap(p.x, p.y, s.x, s.y, WORLD.w, WORLD.h);
            if (d < bestD) (bestD = d), (best = s);
          }
          return best;
        };

        const fireMissile = (ship, target) => {
          if (ship.missiles <= 0) return false;
          if (ship.missileRegen > 0.2) return false;
          ship.missiles -= 1;
          ship.missileRegen = 3.6;

          const ax = Math.cos(ship.aim);
          const ay = Math.sin(ship.aim);
          const speed = 520;
          const m = createMissile(
            ship.type === "player" ? "player" : ship,
            wrap(ship.x + ax * 18, WORLD.w),
            wrap(ship.y + ay * 18, WORLD.h),
            ship.vx + ax * speed,
            ship.vy + ay * speed,
            target ? target._id : null
          );
          entities.missiles.push(m);
          spawnParticles(14, m.x, m.y, [255, 208, 107], 240, 0.36, 2.8, 0.35);

          if (audio) {
            audio.blip(140, 0.09, "sawtooth", 0.18, 1.25);
            audio.hiss(0.12, 0.08, 1400, 8200);
          }
          return true;
        };

        const ionBurst = (ship) => {
          if (ship.ionCd > 0 || ship.ion <= 0) return false;
          ship.ion -= 1;
          ship.ionCd = 2.4;
          ship.ionRegen = 8.5;
          const R = 320;

          spawnParticles(90, ship.x, ship.y, [127, 249, 255], 520, 0.55, 3.2, 0.55);
          state.shake = Math.min(22, state.shake + 8);

          if (audio) {
            audio.hiss(0.18, 0.2, 320, 5000);
            audio.blip(520, 0.08, "triangle", 0.18, 0.5);
            audio.blip(260, 0.12, "sine", 0.12, 0.5);
          }

          for (let i = entities.bullets.length - 1; i >= 0; i--) {
            const b = entities.bullets[i];
            const [, , d] = distWrap(ship.x, ship.y, b.x, b.y, WORLD.w, WORLD.h);
            if (d < R) {
              entities.bullets.splice(i, 1);
              spawnParticles(8, b.x, b.y, b.color, 220, 0.25, 2.2, 0.55);
            }
          }
          for (let i = entities.missiles.length - 1; i >= 0; i--) {
            const m = entities.missiles[i];
            const [dx, dy, d] = distWrap(ship.x, ship.y, m.x, m.y, WORLD.w, WORLD.h);
            if (d < R) {
              const k = 1 - d / R;
              m.vx += (dx / (d + 1e-6)) * 520 * k;
              m.vy += (dy / (d + 1e-6)) * 520 * k;
              m.armed = 0.05;
            }
          }
          for (const a of entities.asteroids) {
            const [dx, dy, d] = distWrap(ship.x, ship.y, a.x, a.y, WORLD.w, WORLD.h);
            if (d < R) {
              const k = 1 - d / R;
              a.vx += (dx / (d + 1e-6)) * 340 * k;
              a.vy += (dy / (d + 1e-6)) * 340 * k;
            }
          }
          for (const s of entities.ships) {
            const [dx, dy, d] = distWrap(ship.x, ship.y, s.x, s.y, WORLD.w, WORLD.h);
            if (d < R) {
              const k = 1 - d / R;
              s.vx += (dx / (d + 1e-6)) * 420 * k;
              s.vy += (dy / (d + 1e-6)) * 420 * k;
              s.heat = clamp(s.heat + 0.12 * k, 0, 1.35);
            }
          }
          return true;
        };

        // ---------- Rendering helpers ----------
        const rgb = (c, a = 1) => `rgba(${c[0]},${c[1]},${c[2]},${a})`;

        // Star layers
        const starLayers = [];
        const makeStarfield = () => {
          starLayers.length = 0;
          const layers = [
            { n: 520, s: 0.18, a: 0.6 },
            { n: 360, s: 0.32, a: 0.75 },
            { n: 220, s: 0.52, a: 0.9 },
          ];
          for (const L of layers) {
            const pts = [];
            for (let i = 0; i < L.n; i++) {
              pts.push({ x: Math.random() * WORLD.w, y: Math.random() * WORLD.h, r: rand(0.4, 1.4) * (0.8 + L.s), tw: rand(0, 1) });
            }
            starLayers.push({ ...L, pts });
          }
        };

        const nebulaCanvas = document.createElement("canvas");
        const nebulaCtx = nebulaCanvas.getContext("2d", { alpha: true });
        const makeNebula = () => {
          nebulaCanvas.width = 640;
          nebulaCanvas.height = 640;
          const w = nebulaCanvas.width;
          const h = nebulaCanvas.height;
          const img = nebulaCtx.createImageData(w, h);
          const d = img.data;
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const i = (y * w + x) * 4;
              const nx = (x / w) * 2 - 1;
              const ny = (y / h) * 2 - 1;
              const r = Math.hypot(nx, ny);
              const v = Math.pow(1 - clamp(r, 0, 1), 1.65);
              const n = (Math.random() * 2 - 1) * 0.12 + Math.sin((x + y) * 0.02) * 0.06;
              const k = clamp(v + n, 0, 1);
              d[i + 0] = 40 + k * 90;
              d[i + 1] = 20 + k * 65;
              d[i + 2] = 70 + k * 110;
              d[i + 3] = Math.floor(k * 110);
            }
          }
          nebulaCtx.putImageData(img, 0, 0);
        };

        // ---------- Camera ----------
        let dpr = 1;
        const resize = () => {
          dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1));
          canvas.width = Math.floor(window.innerWidth * dpr);
          canvas.height = Math.floor(window.innerHeight * dpr);
        };
        window.addEventListener("resize", resize, { passive: true });
        window.addEventListener("orientationchange", resize, { passive: true });

        const updateCamera = (dt) => {
          const p = entities.player;
          if (!p) return;
          const cam = state.cam;
          const dx = wrapDelta(p.x - cam.x, WORLD.w);
          const dy = wrapDelta(p.y - cam.y, WORLD.h);
          const la = 120;
          const lx = Math.cos(p.aim) * la;
          const ly = Math.sin(p.aim) * la;
          cam.x = wrap(cam.x + (dx + lx) * (1 - Math.exp(-6.0 * dt)), WORLD.w);
          cam.y = wrap(cam.y + (dy + ly) * (1 - Math.exp(-6.0 * dt)), WORLD.h);
          const sp = Math.hypot(p.vx, p.vy);
          const zTarget = lerp(1.05, 0.92, clamp((sp - 180) / 900, 0, 1));
          cam.z = lerp(cam.z, zTarget, 1 - Math.exp(-2.2 * dt));
        };

        const worldToScreen = (x, y) => {
          const cam = state.cam;
          const dx = wrapDelta(x - cam.x, WORLD.w);
          const dy = wrapDelta(y - cam.y, WORLD.h);
          const s = cam.z * dpr;
          return { x: canvas.width * 0.5 + dx * s, y: canvas.height * 0.5 + dy * s, s, dx, dy };
        };

        // ---------- AI ----------
        const aiThink = (s, dt) => {
          s.ai.think -= dt;
          if (s.ai.think > 0) return;
          s.ai.think = rand(0.12, 0.26);

          const p = entities.player;
          if (!p) return;

          const [dx, dy, d] = distWrap(s.x, s.y, p.x, p.y, WORLD.w, WORLD.h);
          const kind = shipKinds[s.kind];
          const w = weaponDefs[s.weapon];

          // Avoid asteroids
          let avx = 0, avy = 0;
          for (const a of entities.asteroids) {
            const [ax, ay, ad] = distWrap(s.x, s.y, a.x, a.y, WORLD.w, WORLD.h);
            const rr = a.r + 34;
            if (ad < rr + 120) {
              const k = (rr + 120 - ad) / (rr + 120);
              avx -= (ax / (ad + 1e-6)) * (k * k) * 1.8;
              avy -= (ay / (ad + 1e-6)) * (k * k) * 1.8;
            }
          }
          const am = Math.hypot(avx, avy);
          if (am > 1) (avx /= am), (avy /= am);

          const prefer = kind.ai.prefer;
          const rangeErr = (d - prefer) / prefer;
          const forward = clamp(rangeErr * 1.1, -1, 1) * (kind.ai.aggression > 0.65 ? 1 : 0.85);
          const strafeSign = Math.sin(state.t * 0.8 + s.ai.seed * 10) > 0 ? 1 : -1;
          const strafe = clamp(kind.ai.strafe * strafeSign + avx * 0.85, -1, 1);

          const desiredAim = leadAim(s.x, s.y, s.vx, s.vy, s.x + dx, s.y + dy, p.vx, p.vy, w.speed);
          const hasLOS = d < 1300;
          const fire = hasLOS && d > 140 && Math.random() < 0.9;
          const missile = s.missiles > 0 && s.missileRegen <= 0 && d > 520 && d < 1150 && Math.random() < 0.22;

          s.ai.desired.aim = desiredAim;
          s.ai.desired.f = forward + avy * 0.75;
          s.ai.desired.s = strafe;
          s.ai.desired.fire = fire;
          s.ai.desired.missile = missile;
        };

        const updateAIShip = (s, dt) => {
          if (s.hp <= 0) return;
          aiThink(s, dt);

          s.heat = Math.max(0, s.heat - 0.3 * dt);
          if (s.heat > 1) s.overheat = Math.max(s.overheat, 0.7);
          s.overheat = Math.max(0, s.overheat - dt);
          s.cooldown = Math.max(0, s.cooldown - dt);
          s.shDelay = Math.max(0, s.shDelay - dt);
          if (s.shDelay <= 0 && s.sh < s.shMax) s.sh = Math.min(s.shMax, s.sh + 18 * dt);

          s.missileRegen = Math.max(0, s.missileRegen - dt);
          if (s.missileRegen <= 0 && s.missiles < s.missilesMax) {
            s.missiles++;
            s.missileRegen = 6.2;
          }

          const kind = shipKinds[s.kind];
          const desiredAim = s.ai.desired.aim ?? s.aim;
          const da = angleDiff(desiredAim, s.aim);
          s.aim += clamp(da, -kind.turn * dt, kind.turn * dt);

          const f = clamp(s.ai.desired.f, -1, 1);
          const st = clamp(s.ai.desired.s, -1, 1);
          const ax = Math.cos(s.aim);
          const ay = Math.sin(s.aim);
          const rx = -ay;
          const ry = ax;

          let tx = ax * f + rx * st;
          let ty = ay * f + ry * st;
          const mag = Math.hypot(tx, ty);
          if (mag > 1) (tx /= mag), (ty /= mag);

          s.vx += tx * kind.accel * dt;
          s.vy += ty * kind.accel * dt;
          s.vx *= Math.exp(-0.26 * dt);
          s.vy *= Math.exp(-0.26 * dt);

          const sp = Math.hypot(s.vx, s.vy);
          if (sp > kind.maxSpeed) {
            const k = kind.maxSpeed / sp;
            s.vx *= k;
            s.vy *= k;
          }

          const w = weaponDefs[s.weapon];
          const aimErr = Math.abs(angleDiff(desiredAim, s.aim));
          const aligned = aimErr < (w.spread * 1.9 + 0.12);

          if (s.ai.desired.fire && aligned) fireWeapon(s, false, false);
          if (s.ai.desired.missile && aimErr < 0.55) {
            fireMissile(s, entities.player);
            s.ai.desired.missile = false;
          }

          s.x = wrap(s.x + s.vx * dt, WORLD.w);
          s.y = wrap(s.y + s.vy * dt, WORLD.h);
        };

        // ---------- Player update ----------
        const updatePlayer = (dt) => {
          const p = entities.player;
          if (!p) return;

          let aimAngle = p.aim;
          const now = performance.now();
          const rv = input.touch.right.v;
          if (Math.hypot(rv.x, rv.y) > 0.12) {
            aimAngle = angleOf(rv.x, rv.y);
          } else {
            const mouseRecent = now - input.mouse.movedAt < 1400;
            if (input.useMouseAim && mouseRecent) {
              const cx = canvas.width * 0.5;
              const cy = canvas.height * 0.5;
              const dx = (input.mouse.x * dpr - cx) / dpr;
              const dy = (input.mouse.y * dpr - cy) / dpr;
              aimAngle = angleOf(dx, dy);
            } else {
              const ax = (input.keys.has("ArrowRight") ? 1 : 0) - (input.keys.has("ArrowLeft") ? 1 : 0);
              const ay = (input.keys.has("ArrowDown") ? 1 : 0) - (input.keys.has("ArrowUp") ? 1 : 0);
              if (ax || ay) aimAngle = angleOf(ax, ay);
            }
          }
          p.aim = aimAngle;

          const f = (input.keys.has("KeyW") ? 1 : 0) - (input.keys.has("KeyS") ? 1 : 0);
          const s = (input.keys.has("KeyD") ? 1 : 0) - (input.keys.has("KeyA") ? 1 : 0);
          let mvx = f, mvy = s;

          const tv = input.touch.left.v;
          if (Math.hypot(tv.x, tv.y) > 0.05) {
            const dir = angleOf(tv.x, tv.y);
            const mag = clamp(Math.hypot(tv.x, tv.y), 0, 1);
            const rel = dir - aimAngle;
            mvx = Math.cos(rel) * mag;
            mvy = Math.sin(rel) * mag;
          }

          const boost = input.keys.has("ShiftLeft") || input.keys.has("ShiftRight");
          const ax = Math.cos(aimAngle);
          const ay = Math.sin(aimAngle);
          const rx = -ay;
          const ry = ax;

          let tx = ax * mvx + rx * mvy;
          let ty = ay * mvx + ry * mvy;
          const tmag = Math.hypot(tx, ty);
          if (tmag > 1) (tx /= tmag), (ty /= tmag);

          const accel = 920 * (boost ? 1.25 : 1);
          p.vx += tx * accel * dt;
          p.vy += ty * accel * dt;

          const drag = 0.28 + (boost ? 0.12 : 0);
          p.vx *= Math.exp(-drag * dt);
          p.vy *= Math.exp(-drag * dt);

          const sp = Math.hypot(p.vx, p.vy);
          const maxSp = boost ? 1120 : 980;
          if (sp > maxSp) {
            const k = maxSp / sp;
            p.vx *= k;
            p.vy *= k;
          }

          p.heat = Math.max(0, p.heat - 0.38 * dt);
          if (p.heat > 1) p.overheat = Math.max(p.overheat, 0.8);
          if (p.overheat > 0) p.overheat = Math.max(0, p.overheat - dt);

          p.shDelay = Math.max(0, p.shDelay - dt);
          if (p.shDelay <= 0 && p.sh < p.shMax) p.sh = Math.min(p.shMax, p.sh + 24 * dt);

          p.missileRegen = Math.max(0, p.missileRegen - dt);
          if (p.missileRegen <= 0 && p.missiles < p.missilesMax) {
            p.missiles = Math.min(p.missilesMax, p.missiles + 1);
            p.missileRegen = 5.4;
            toast("Missile reloaded", 900);
          }

          p.ionCd = Math.max(0, p.ionCd - dt);
          p.ionRegen = Math.max(0, p.ionRegen - dt);
          if (p.ionRegen <= 0 && p.ion < 1) {
            p.ion = 1;
            toast("Ion ready", 900);
          }

          p.cooldown = Math.max(0, p.cooldown - dt);

          const wantsFire = input.mouse.down || input.keys.has("Space") || input.touch.fire;
          if (wantsFire) fireWeapon(p, true, true);

          const wantsMissile = input.mouse.rdown || input.keys.has("KeyQ") || input.touch.missile;
          if (wantsMissile && p.missiles > 0) {
            const target = nearestHostile(p);
            fireMissile(p, target);
            input.touch.missile = false;
          }

          const wantsIon = input.keys.has("KeyE") || input.touch.ion;
          if (wantsIon) {
            ionBurst(p);
            input.touch.ion = false;
          }

          if (audio) {
            const thr = clamp(tmag, 0, 1) * (boost ? 1 : 0.86);
            audio.thruster(thr > 0.04);
            audio.setThr(thr);
          }

          p.x = wrap(p.x + p.vx * dt, WORLD.w);
          p.y = wrap(p.y + p.vy * dt, WORLD.h);

          p.comboT = Math.max(0, p.comboT - dt);
          if (p.comboT <= 0) p.combo = 0;
        };

        // ---------- World updates ----------
        const updateAsteroids = (dt) => {
          for (const a of entities.asteroids) {
            a.a += a.spin * dt;
            a.x = wrap(a.x + a.vx * dt, WORLD.w);
            a.y = wrap(a.y + a.vy * dt, WORLD.h);
            a.vx *= Math.exp(-0.02 * dt);
            a.vy *= Math.exp(-0.02 * dt);
          }
        };

        const updateBullets = (dt) => {
          for (let i = entities.bullets.length - 1; i >= 0; i--) {
            const b = entities.bullets[i];
            b.life -= dt;
            if (b.life <= 0) {
              entities.bullets.splice(i, 1);
              continue;
            }
            b.x = wrap(b.x + b.vx * dt, WORLD.w);
            b.y = wrap(b.y + b.vy * dt, WORLD.h);
          }
        };

        const updateMissiles = (dt) => {
          for (let i = entities.missiles.length - 1; i >= 0; i--) {
            const m = entities.missiles[i];
            m.life -= dt;
            m.armed = Math.max(0, m.armed - dt);
            if (m.life <= 0) {
              entities.missiles.splice(i, 1);
              continue;
            }
            let target = findShipById(m.targetId);
            if (!target || target.hp <= 0) {
              const owner = m.owner === "player" ? entities.player : m.owner;
              if (owner && owner.type) {
                target = owner.type === "player" ? nearestHostile(owner) : entities.player;
                if (target) m.targetId = target._id;
              }
            }

            let desiredA = m.a;
            if (target && target.hp > 0) {
              const [dx, dy, d] = distWrap(m.x, m.y, target.x, target.y, WORLD.w, WORLD.h);
              desiredA = leadAim(m.x, m.y, m.vx, m.vy, m.x + dx, m.y + dy, target.vx, target.vy, 960);
              if (d < 120) m.armed = 0;
            }

            let da = angleDiff(desiredA, m.a);
            da = clamp(da, -m.turn * dt, m.turn * dt);
            m.a += da;

            const ax = Math.cos(m.a);
            const ay = Math.sin(m.a);
            m.vx += ax * m.accel * dt;
            m.vy += ay * m.accel * dt;

            const sp = Math.hypot(m.vx, m.vy);
            if (sp > m.maxSpeed) {
              const k = m.maxSpeed / sp;
              m.vx *= k;
              m.vy *= k;
            }
            m.vx *= Math.exp(-0.06 * dt);
            m.vy *= Math.exp(-0.06 * dt);

            m.x = wrap(m.x + m.vx * dt, WORLD.w);
            m.y = wrap(m.y + m.vy * dt, WORLD.h);
          }
        };

        const updatePickups = (dt) => {
          for (let i = entities.pickups.length - 1; i >= 0; i--) {
            const p = entities.pickups[i];
            p.life -= dt;
            p.t += dt;
            if (p.life <= 0) {
              entities.pickups.splice(i, 1);
              continue;
            }
            p.vx *= Math.exp(-0.15 * dt);
            p.vy *= Math.exp(-0.15 * dt);
            p.x = wrap(p.x + p.vx * dt, WORLD.w);
            p.y = wrap(p.y + p.vy * dt, WORLD.h);
          }

          const pl = entities.player;
          if (!pl) return;
          for (let i = entities.pickups.length - 1; i >= 0; i--) {
            const pk = entities.pickups[i];
            const [, , d] = distWrap(pl.x, pl.y, pk.x, pk.y, WORLD.w, WORLD.h);
            if (d < 22) {
              entities.pickups.splice(i, 1);
              applyPickup(pl, pk.kind);
            }
          }
        };

        const applyPickup = (p, kind) => {
          if (kind === "shield") {
            p.sh = Math.min(p.shMax, p.sh + 35);
            p.shDelay = 0.4;
            toast("Shield surge", 900);
            if (audio) audio.blip(540, 0.08, "triangle", 0.18, 0.7);
          } else if (kind === "missile") {
            p.missiles = Math.min(p.missilesMax, p.missiles + 1);
            toast("Missile +1", 900);
            if (audio) audio.blip(260, 0.09, "square", 0.14, 1.1);
          } else if (kind === "heal") {
            p.hp = Math.min(p.hpMax, p.hp + 24);
            toast("Hull repaired", 900);
            if (audio) audio.blip(390, 0.08, "sine", 0.16, 0.7);
          } else if (kind === "weapon") {
            const order = ["pulse", "scatter", "lance"];
            const idx = order.indexOf(p.weapon);
            p.weapon = order[(idx + 1) % order.length];
            toast(`Weapon: ${weaponDefs[p.weapon].name}`, 1100);
            if (audio) audio.blip(620, 0.08, "triangle", 0.18, 0.55);
          }
        };

        const updateParticles = (dt) => {
          for (let i = fx.particles.length - 1; i >= 0; i--) {
            const p = fx.particles[i];
            p.life -= dt;
            if (p.life <= 0.02) {
              fx.particles.splice(i, 1);
              fx.pool.push(p);
              continue;
            }
            p.a += p.spin * dt;
            const drag = 0.1 + p.drag * 0.25;
            p.vx *= Math.exp(-drag * dt);
            p.vy *= Math.exp(-drag * dt);
            p.x = wrap(p.x + p.vx * dt, WORLD.w);
            p.y = wrap(p.y + p.vy * dt, WORLD.h);
          }
        };

        // ---------- Collisions ----------
        const collide = () => {
          const pl = entities.player;
          if (!pl) return;

          // Bullets
          for (let i = entities.bullets.length - 1; i >= 0; i--) {
            const b = entities.bullets[i];
            let removed = false;

            for (let j = entities.asteroids.length - 1; j >= 0; j--) {
              const a = entities.asteroids[j];
              const [dx, dy, d] = distWrap(b.x, b.y, a.x, a.y, WORLD.w, WORLD.h);
              if (d < a.r + b.r) {
                a.hp -= b.dmg;
                spawnParticles(10, b.x, b.y, b.color, 260, 0.26, 2.2, 0.55);
                if (a.hp <= 0) {
                  entities.asteroids.splice(j, 1);
                  explodeAsteroid(a, b.x, b.y, b.vx, b.vy);
                } else {
                  a.vx += (dx / (d + 1e-6)) * 90;
                  a.vy += (dy / (d + 1e-6)) * 90;
                }
                if (b.pierce > 0) b.pierce--;
                else {
                  entities.bullets.splice(i, 1);
                  removed = true;
                }
                break;
              }
            }
            if (removed) continue;

            if (b.owner === "player") {
              for (let j = entities.ships.length - 1; j >= 0; j--) {
                const s = entities.ships[j];
                if (s.hp <= 0) continue;
                const [, , d] = distWrap(b.x, b.y, s.x, s.y, WORLD.w, WORLD.h);
                if (d < 18) {
                  takeDamage(s, b.dmg, b.x, b.y);
                  spawnParticles(12, b.x, b.y, b.color, 320, 0.26, 2.4, 0.55);
                  entities.bullets.splice(i, 1);
                  break;
                }
              }
            } else {
              const [, , d] = distWrap(b.x, b.y, pl.x, pl.y, WORLD.w, WORLD.h);
              if (d < 18) {
                takeDamage(pl, b.dmg, b.x, b.y);
                spawnParticles(12, b.x, b.y, b.color, 320, 0.26, 2.4, 0.55);
                entities.bullets.splice(i, 1);
              }
            }
          }

          // Missiles
          for (let i = entities.missiles.length - 1; i >= 0; i--) {
            const m = entities.missiles[i];
            const targets = m.owner === "player" ? entities.ships : [entities.player];
            for (const t of targets) {
              if (!t || t.hp <= 0) continue;
              const [, , d] = distWrap(m.x, m.y, t.x, t.y, WORLD.w, WORLD.h);
              if (d < 22 && m.armed <= 0) {
                const R = 140;
                spawnParticles(110, m.x, m.y, [255, 208, 107], 620, 0.75, 3.2, 0.55);
                spawnParticles(60, m.x, m.y, [255, 255, 255], 820, 0.65, 2.2, 0.45);
                if (audio) {
                  audio.hiss(0.22, 0.22, 240, 4200);
                  audio.blip(90, 0.2, "sawtooth", 0.22, 0.6);
                }
                state.shake = Math.min(26, state.shake + 12);

                const apply = (ship) => {
                  const [sx, sy, sd] = distWrap(m.x, m.y, ship.x, ship.y, WORLD.w, WORLD.h);
                  if (sd < R) {
                    const k = 1 - sd / R;
                    takeDamage(ship, 34 * k + 10, m.x, m.y);
                    ship.vx += (sx / (sd + 1e-6)) * 420 * k;
                    ship.vy += (sy / (sd + 1e-6)) * 420 * k;
                  }
                };

                if (m.owner === "player") for (const s of entities.ships) apply(s);
                else if (entities.player) apply(entities.player);

                for (let j = entities.asteroids.length - 1; j >= 0; j--) {
                  const a = entities.asteroids[j];
                  const [ax, ay, ad] = distWrap(m.x, m.y, a.x, a.y, WORLD.w, WORLD.h);
                  if (ad < R + a.r) {
                    const k = 1 - ad / (R + a.r);
                    a.hp -= (28 * k) | 0;
                    a.vx += (ax / (ad + 1e-6)) * 280 * k;
                    a.vy += (ay / (ad + 1e-6)) * 280 * k;
                    if (a.hp <= 0) {
                      entities.asteroids.splice(j, 1);
                      explodeAsteroid(a, m.x, m.y, m.vx, m.vy);
                    }
                  }
                }

                entities.missiles.splice(i, 1);
                break;
              }
            }
          }

          // Ships vs asteroids
          const shipList = [entities.player, ...entities.ships];
          for (const s of shipList) {
            if (!s || s.hp <= 0) continue;
            for (const a of entities.asteroids) {
              const [dx, dy, d] = distWrap(s.x, s.y, a.x, a.y, WORLD.w, WORLD.h);
              const rr = a.r + 18;
              if (d < rr) {
                const k = (rr - d) / rr;
                takeDamage(s, 16 * k + 6, a.x, a.y);
                const nx = dx / (d + 1e-6);
                const ny = dy / (d + 1e-6);
                s.vx -= nx * 520 * k;
                s.vy -= ny * 520 * k;
                a.vx += nx * 220 * k;
                a.vy += ny * 220 * k;
              }
            }
          }
        };

        // ---------- Draw ----------
        const drawStars = () => {
          ctx.save();
          ctx.globalCompositeOperation = "source-over";
          for (const L of starLayers) {
            const par = 1 - L.s * 0.72;
            for (const s of L.pts) {
              const dx = wrapDelta(s.x - state.cam.x * par, WORLD.w);
              const dy = wrapDelta(s.y - state.cam.y * par, WORLD.h);
              const x = canvas.width * 0.5 + dx * state.cam.z * dpr;
              const y = canvas.height * 0.5 + dy * state.cam.z * dpr;
              if (x < -20 || y < -20 || x > canvas.width + 20 || y > canvas.height + 20) continue;
              const tw = 0.6 + 0.4 * Math.sin(state.t * 2.0 + s.tw * 10);
              ctx.fillStyle = `rgba(255,255,255,${0.15 + tw * 0.25 * L.a})`;
              ctx.fillRect(x, y, s.r * dpr, s.r * dpr);
            }
          }
          ctx.restore();
        };

        const drawNebula = () => {
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          const t = state.t * 0.02;
          const ox = ((state.cam.x / WORLD.w) * 180 + t * 60) % 180;
          const oy = ((state.cam.y / WORLD.h) * 180 + t * 40) % 180;
          ctx.globalAlpha = 0.22;
          ctx.drawImage(nebulaCanvas, -ox * dpr, -oy * dpr, canvas.width + 240 * dpr, canvas.height + 240 * dpr);
          ctx.globalAlpha = 0.12;
          const scale = 1.6;
          ctx.drawImage(
            nebulaCanvas,
            (-ox * 0.6 - 80) * dpr,
            (-oy * 0.6 - 40) * dpr,
            (canvas.width + 360 * dpr) * scale,
            (canvas.height + 360 * dpr) * scale
          );
          ctx.restore();
        };

        const drawAsteroid = (a) => {
          const p = worldToScreen(a.x, a.y);
          const R = a.r * p.s;
          if (p.x + R < -80 || p.y + R < -80 || p.x - R > canvas.width + 80 || p.y - R > canvas.height + 80) return;

          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(a.a);
          ctx.lineWidth = Math.max(1, 1.2 * dpr);
          ctx.beginPath();
          const pts = a.pts;
          ctx.moveTo(pts[0][0] * p.s, pts[0][1] * p.s);
          for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0] * p.s, pts[i][1] * p.s);
          ctx.closePath();

          const shade = clamp(0.5 + (a.vx + a.vy) / 820, 0.2, 0.85);
          ctx.fillStyle = `rgba(${Math.floor(70 + 40 * shade)},${Math.floor(54 + 35 * shade)},${Math.floor(100 + 60 * shade)},0.95)`;
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.09)";
          ctx.stroke();

          ctx.globalCompositeOperation = "screen";
          ctx.strokeStyle = "rgba(255,208,107,0.12)";
          ctx.lineWidth = 1.1 * dpr;
          ctx.beginPath();
          for (let i = 0; i < 4; i++) {
            const aa = (i / 4) * TAU + a.a * 0.35;
            ctx.moveTo(Math.cos(aa) * R * 0.25, Math.sin(aa) * R * 0.25);
            ctx.lineTo(Math.cos(aa) * R * 0.75, Math.sin(aa) * R * 0.75);
          }
          ctx.stroke();
          ctx.restore();
        };

        const drawShip = (s, isPlayer) => {
          if (!s || s.hp <= 0) return;
          const p = worldToScreen(s.x, s.y);
          const size = isPlayer ? 18 : 16;
          const R = size * p.s;
          if (p.x + R < -120 || p.y + R < -120 || p.x - R > canvas.width + 120 || p.y - R > canvas.height + 120) return;

          const col = isPlayer ? [127, 249, 255] : s.kind === "goliath" ? [255, 77, 109] : s.kind === "wasp" ? [255, 208, 107] : [127, 249, 255];

          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(s.aim);
          ctx.lineJoin = "round";
          ctx.lineCap = "round";

          const shieldK = clamp(s.sh / (s.shMax || 1), 0, 1);
          if (shieldK > 0.02) {
            ctx.globalCompositeOperation = "screen";
            ctx.strokeStyle = `rgba(${col[0]},${col[1]},${col[2]},${0.12 + 0.18 * shieldK})`;
            ctx.lineWidth = (2.2 + 2.4 * shieldK) * dpr;
            ctx.beginPath();
            ctx.arc(0, 0, R * (1.35 + 0.22 * Math.sin(state.t * 3.2 + s._id * 0.2)), 0, TAU);
            ctx.stroke();
            ctx.globalCompositeOperation = "source-over";
          }

          ctx.beginPath();
          if (isPlayer) {
            ctx.moveTo(R * 1.15, 0);
            ctx.lineTo(-R * 0.8, -R * 0.58);
            ctx.lineTo(-R * 0.5, 0);
            ctx.lineTo(-R * 0.8, R * 0.58);
            ctx.closePath();
          } else if (s.kind === "wasp") {
            ctx.moveTo(R * 1.18, 0);
            ctx.lineTo(-R * 0.62, -R * 0.45);
            ctx.lineTo(-R * 0.28, 0);
            ctx.lineTo(-R * 0.62, R * 0.45);
            ctx.closePath();
            ctx.moveTo(-R * 0.1, -R * 0.14);
            ctx.lineTo(R * 0.22, 0);
            ctx.lineTo(-R * 0.1, R * 0.14);
          } else if (s.kind === "manta") {
            ctx.moveTo(R * 1.08, 0);
            ctx.quadraticCurveTo(0, -R * 0.2, -R * 0.95, -R * 0.7);
            ctx.quadraticCurveTo(-R * 0.35, 0, -R * 0.95, R * 0.7);
            ctx.quadraticCurveTo(0, R * 0.2, R * 1.08, 0);
            ctx.closePath();
          } else {
            ctx.moveTo(R * 1.05, 0);
            ctx.lineTo(-R * 0.75, -R * 0.65);
            ctx.lineTo(-R * 0.95, 0);
            ctx.lineTo(-R * 0.75, R * 0.65);
            ctx.closePath();
            ctx.moveTo(-R * 0.25, -R * 0.2);
            ctx.lineTo(R * 0.25, 0);
            ctx.lineTo(-R * 0.25, R * 0.2);
          }

          ctx.fillStyle = `rgba(10, 12, 22, 0.85)`;
          ctx.fill();
          ctx.lineWidth = 1.5 * dpr;
          ctx.strokeStyle = `rgba(255,255,255,0.18)`;
          ctx.stroke();

          ctx.globalCompositeOperation = "screen";
          ctx.strokeStyle = `rgba(${col[0]},${col[1]},${col[2]},0.26)`;
          ctx.lineWidth = 1.2 * dpr;
          ctx.beginPath();
          ctx.moveTo(-R * 0.55, 0);
          ctx.lineTo(R * 0.8, 0);
          ctx.stroke();
          ctx.globalCompositeOperation = "source-over";

          const sp = Math.hypot(s.vx, s.vy);
          const plume = clamp(sp / 980, 0, 1) * (isPlayer ? 1 : 0.75);
          if (plume > 0.04) {
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            const g = ctx.createRadialGradient(-R * 0.85, 0, 0, -R * 0.85, 0, R * 1.1);
            g.addColorStop(0, `rgba(${col[0]},${col[1]},${col[2]},${0.18 + 0.35 * plume})`);
            g.addColorStop(1, `rgba(${col[0]},${col[1]},${col[2]},0)`);
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.ellipse(-R * 0.95, 0, R * (0.9 + plume * 0.9), R * (0.35 + plume * 0.25), 0, 0, TAU);
            ctx.fill();
            ctx.restore();
          }

          ctx.globalCompositeOperation = "screen";
          ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},0.55)`;
          ctx.beginPath();
          ctx.arc(R * 0.25, 0, R * 0.14, 0, TAU);
          ctx.fill();
          ctx.globalCompositeOperation = "source-over";

          ctx.restore();
        };

        const drawBullets = () => {
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          for (const b of entities.bullets) {
            const p = worldToScreen(b.x, b.y);
            const r = b.r * p.s;
            if (p.x + r < -40 || p.y + r < -40 || p.x - r > canvas.width + 40 || p.y - r > canvas.height + 40) continue;
            const v = Math.hypot(b.vx, b.vy);
            const lx = (b.vx / (v + 1e-6)) * 16 * p.s;
            const ly = (b.vy / (v + 1e-6)) * 16 * p.s;
            ctx.strokeStyle = rgb(b.color, 0.8);
            ctx.lineWidth = 2.2 * dpr;
            ctx.beginPath();
            ctx.moveTo(p.x - lx, p.y - ly);
            ctx.lineTo(p.x + lx * 0.2, p.y + ly * 0.2);
            ctx.stroke();
            ctx.fillStyle = rgb(b.color, 0.45);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r * 1.2, 0, TAU);
            ctx.fill();
          }
          ctx.restore();
        };

        const drawMissiles = () => {
          ctx.save();
          for (const m of entities.missiles) {
            const p = worldToScreen(m.x, m.y);
            const R = 10 * p.s;
            if (p.x + R < -80 || p.y + R < -80 || p.x - R > canvas.width + 80 || p.y - R > canvas.height + 80) continue;
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(m.a);
            ctx.fillStyle = "rgba(10,12,22,0.8)";
            ctx.strokeStyle = "rgba(255,255,255,0.16)";
            ctx.lineWidth = 1.3 * dpr;
            ctx.beginPath();
            ctx.moveTo(R * 1.1, 0);
            ctx.lineTo(-R * 0.8, -R * 0.45);
            ctx.lineTo(-R * 0.55, 0);
            ctx.lineTo(-R * 0.8, R * 0.45);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.globalCompositeOperation = "screen";
            ctx.fillStyle = "rgba(255,208,107,0.55)";
            ctx.beginPath();
            ctx.arc(-R * 0.72, 0, R * 0.15, 0, TAU);
            ctx.fill();
            ctx.restore();
          }
          ctx.restore();
        };

        const drawPickups = () => {
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          for (const p of entities.pickups) {
            const s = worldToScreen(p.x, p.y);
            const R = p.r * s.s;
            if (s.x + R < -80 || s.y + R < -80 || s.x - R > canvas.width + 80 || s.y - R > canvas.height + 80) continue;
            const k = 0.6 + 0.4 * Math.sin(p.t * 3.1);
            ctx.fillStyle = rgb(p.col, 0.24 + 0.18 * k);
            ctx.beginPath();
            ctx.arc(s.x, s.y, R * (1.6 + 0.25 * k), 0, TAU);
            ctx.fill();
            ctx.strokeStyle = rgb(p.col, 0.65);
            ctx.lineWidth = 1.2 * dpr;
            ctx.beginPath();
            ctx.arc(s.x, s.y, R * (0.9 + 0.06 * k), 0, TAU);
            ctx.stroke();
          }
          ctx.restore();
        };

        const drawParticles = () => {
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          for (const p of fx.particles) {
            const s = worldToScreen(p.x, p.y);
            const k = clamp(p.life / 0.9, 0, 1);
            const r = p.r * s.s * (0.6 + 0.8 * (1 - k));
            if (s.x + r < -60 || s.y + r < -60 || s.x - r > canvas.width + 60 || s.y - r > canvas.height + 60) continue;
            ctx.globalAlpha = clamp(k, 0, 1) * (0.6 + p.add);
            ctx.fillStyle = rgb(p.col, 0.85);
            ctx.beginPath();
            ctx.arc(s.x, s.y, r, 0, TAU);
            ctx.fill();
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        };

        const drawVignette = () => {
          ctx.save();
          const g = ctx.createRadialGradient(
            canvas.width * 0.5,
            canvas.height * 0.5,
            Math.min(canvas.width, canvas.height) * 0.25,
            canvas.width * 0.5,
            canvas.height * 0.5,
            Math.max(canvas.width, canvas.height) * 0.7
          );
          g.addColorStop(0, "rgba(0,0,0,0)");
          g.addColorStop(1, "rgba(0,0,0,0.45)");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        };

        const drawScanlines = () => {
          ctx.save();
          ctx.globalCompositeOperation = "overlay";
          ctx.globalAlpha = 0.08;
          ctx.fillStyle = "rgba(255,255,255,0.12)";
          for (let y = 0; y < canvas.height; y += 3 * dpr) ctx.fillRect(0, y, canvas.width, 1 * dpr);
          ctx.restore();
          ctx.globalAlpha = 1;
        };

        const drawMinimap = () => {
          const w = mapCanvas.width;
          const h = mapCanvas.height;
          mapCtx.clearRect(0, 0, w, h);
          const cx = w / 2;
          const cy = h / 2;
          const r = Math.min(w, h) * 0.46;

          const grd = mapCtx.createRadialGradient(cx, cy, 0, cx, cy, r * 1.1);
          grd.addColorStop(0, "rgba(127,249,255,0.06)");
          grd.addColorStop(1, "rgba(0,0,0,0.35)");
          mapCtx.fillStyle = grd;
          mapCtx.beginPath();
          mapCtx.arc(cx, cy, r * 1.04, 0, TAU);
          mapCtx.fill();
          mapCtx.strokeStyle = "rgba(255,255,255,0.12)";
          mapCtx.lineWidth = 1;
          mapCtx.stroke();

          const p = entities.player;
          if (!p) return;

          const scale = r / (Math.max(WORLD.w, WORLD.h) * 0.5);
          const dot = (x, y, rr, col) => {
            mapCtx.fillStyle = col;
            mapCtx.beginPath();
            mapCtx.arc(cx + x * scale, cy + y * scale, rr, 0, TAU);
            mapCtx.fill();
          };

          for (const a of entities.asteroids) {
            const dx = wrapDelta(a.x - p.x, WORLD.w);
            const dy = wrapDelta(a.y - p.y, WORLD.h);
            dot(dx, dy, clamp(a.r / 22, 1, 3), "rgba(255,208,107,0.65)");
          }
          for (const s of entities.ships) {
            if (s.hp <= 0) continue;
            const dx = wrapDelta(s.x - p.x, WORLD.w);
            const dy = wrapDelta(s.y - p.y, WORLD.h);
            dot(dx, dy, 2.6, "rgba(255,77,109,0.85)");
          }
          dot(0, 0, 3.2, "rgba(127,249,255,0.9)");

          mapCtx.save();
          mapCtx.translate(cx, cy);
          mapCtx.rotate(p.aim);
          mapCtx.strokeStyle = "rgba(127,249,255,0.35)";
          mapCtx.lineWidth = 1;
          mapCtx.beginPath();
          mapCtx.moveTo(0, 0);
          mapCtx.lineTo(r * 0.25, 0);
          mapCtx.stroke();
          mapCtx.restore();
        };

        // ---------- Loop ----------
        const clear = () => {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const g = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
          g.addColorStop(0, "rgba(5,6,12,1)");
          g.addColorStop(0.55, "rgba(7,8,18,1)");
          g.addColorStop(1, "rgba(4,5,10,1)");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        };

        const drawScene = () => {
          drawStars();
          drawNebula();
          for (const a of entities.asteroids) drawAsteroid(a);
          drawPickups();
          drawMissiles();
          drawBullets();
          drawShip(entities.player, true);
          for (const s of entities.ships) drawShip(s, false);
          drawParticles();
          drawVignette();
          drawScanlines();
          drawMinimap();
        };

        const render = () => {
          clear();
          const sh = state.shake;
          if (sh > 0.01) {
            ctx.save();
            ctx.translate(rand(-1, 1) * sh * dpr * 0.9, rand(-1, 1) * sh * dpr * 0.9);
            drawScene();
            ctx.restore();
            state.shake = Math.max(0, state.shake - 32 * state.dt);
          } else {
            drawScene();
          }
        };

        const pruneDead = () => {
          entities.ships = entities.ships.filter((s) => s.hp > 0);
        };

        const checkWave = () => {
          if (!state.running) return;
          const hostiles = entities.ships.filter((s) => s.hp > 0).length;
          const rocks = entities.asteroids.length;
          if (hostiles <= 0 && rocks <= 0) {
            beginWave(state.wave + 1);
            const p = entities.player;
            if (p) {
              p.hp = Math.min(p.hpMax, p.hp + 18);
              p.sh = Math.min(p.shMax, p.sh + 22);
              p.missiles = Math.min(p.missilesMax, p.missiles + 1);
            }
          }
        };

        const updateHUD = () => {
          const p = entities.player;
          if (!p) return;
          el.wave.textContent = String(state.wave);
          el.score.textContent = String(state.score);
          el.hostiles.textContent = String(entities.ships.filter((s) => s.hp > 0).length);
          el.hpFill.style.transform = `scaleX(${clamp(p.hp / p.hpMax, 0, 1)})`;
          el.hpText.textContent = String(Math.ceil(p.hp));
          el.shFill.style.transform = `scaleX(${clamp(p.sh / p.shMax, 0, 1)})`;
          el.shText.textContent = String(Math.ceil(p.sh));
          el.htFill.style.transform = `scaleX(${clamp(p.heat, 0, 1)})`;
          el.htText.textContent = p.overheat > 0 ? "OVER" : `${Math.floor(clamp(p.heat, 0, 1) * 100)}%`;
          el.weaponLabel.textContent = `PRIMARY: ${weaponDefs[p.weapon].name}`;
          el.missileLabel.textContent = `MISSILES: ${p.missiles}`;

          if (state.toast.until < performance.now()) {
            if (el.toast.textContent) el.toast.textContent = "";
          } else {
            el.toast.textContent = state.toast.text;
          }
        };

        const update = (dt) => {
          state.dt = dt;
          state.t += dt;
          ensureIds();
          updatePlayer(dt);
          for (const s of entities.ships) updateAIShip(s, dt);
          updateAsteroids(dt);
          updateBullets(dt);
          updateMissiles(dt);
          updatePickups(dt);
          updateParticles(dt);
          collide();
          updateCamera(dt);
          pruneDead();
          updateHUD();
          checkWave();
        };

        // ---------- Overlay / UI ----------
        const showOverlay = (headline, body) => {
          el.overlay.classList.remove("hidden");
          el.overlay.querySelector("h1").textContent = headline;
          el.overlay.querySelector("p").textContent = body;
          setUIVisible(false);
        };
        const hideOverlay = () => {
          el.overlay.classList.add("hidden");
          setUIVisible(true);
        };

        const togglePause = () => {
          if (!state.running) return;
          state.paused = !state.paused;
          if (state.paused) {
            state.running = false;
            showOverlay("Paused", "Press P to resume.\n\nTip: T toggles mouse/keys aim.");
          } else {
            hideOverlay();
            state.running = true;
            lastFrame = performance.now();
          }
        };

        const toggleHelp = () => {
          state.showHelp = !state.showHelp;
          if (state.showHelp) {
            showOverlay(
              "Nebula Duel",
              "Controls:\nWASD thrust • Mouse/Keys aim • Click/Space fire • Shift boost • Q/Right-click missile • E ion • P pause\n\nPress Engage to start."
            );
          } else {
            hideOverlay();
          }
        };

        const setMute = (muted) => {
          state.muted = muted;
          if (audio) audio.master.gain.value = muted ? 0 : 0.75;
          el.btnMute.textContent = `Sound: ${muted ? "Off" : "On"}`;
        };
        const toggleMute = () => setMute(!state.muted);

        const toggleAimMode = () => {
          input.useMouseAim = !input.useMouseAim;
          el.btnAim.textContent = `Aim: ${input.useMouseAim ? "Mouse" : "Keys"}`;
          toast(input.useMouseAim ? "Mouse aim" : "Keyboard aim", 900);
        };

        el.btnMute.addEventListener("click", () => toggleMute());
        el.btnAim.addEventListener("click", () => toggleAimMode());
        el.btnReset.addEventListener("click", () => resetGame());
        el.btnStart.addEventListener("click", () => startGame());

        // ---------- Lifecycle ----------
        const resetGame = () => {
          entities.player = createPlayer();
          entities.ships = [];
          entities.asteroids = [];
          entities.bullets = [];
          entities.missiles = [];
          entities.pickups = [];
          fx.particles.length = 0;

          state.score = 0;
          state.wave = 1;
          state.shake = 0;
          state.gameOver = false;
          state.paused = false;
          state.running = false;
          state.t = 0;
          state.cam.x = entities.player.x;
          state.cam.y = entities.player.y;
          state.cam.z = 1.05;

          leftStick.setNeutral();
          rightStick.setNeutral();
          toast("Ready", 800);
          beginWave(1);
          updateHUD();
        };

        const startGame = () => {
          if (!audio) audio = Audio();
          if (audio && audio.ctxA.state === "suspended") audio.ctxA.resume().catch(() => {});
          hideOverlay();
          state.running = true;
          state.paused = false;
          lastFrame = performance.now();
          toast("Good hunting, Kestrel.", 1000);
        };

        let lastFrame = performance.now();
        const frame = (t) => {
          requestAnimationFrame(frame);
          const dt = Math.min(0.033, Math.max(0.001, (t - lastFrame) / 1000));
          lastFrame = t;
          if (!state.running) {
            render();
            return;
          }
          update(dt);
          render();
        };

        // ---------- Init ----------
        const boot = () => {
          resize();
          makeStarfield();
          makeNebula();
          resetGame();
          setMute(false);
          el.btnAim.textContent = `Aim: ${input.useMouseAim ? "Mouse" : "Keys"}`;
          setUIVisible(false);
          requestAnimationFrame(frame);

          const centerCrosshair = () => {
            if (input.useMouseAim) return;
            el.crosshair.style.left = window.innerWidth / 2 + "px";
            el.crosshair.style.top = window.innerHeight / 2 + "px";
          };
          window.addEventListener("resize", centerCrosshair, { passive: true });
          centerCrosshair();

          if (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) {
            el.crosshair.style.opacity = "0";
          }
        };

        boot();
      })();
    </script>
  </body>
</html>
