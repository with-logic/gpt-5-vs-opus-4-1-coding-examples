<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Customer Journey Flow</title>
  <style>
    :root{
      --bg: #0b1220;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.14);
      --muted: rgba(255,255,255,.70);
      --text: rgba(255,255,255,.92);
      --shadow: 0 16px 40px rgba(0,0,0,.35);
      --shadow2: 0 10px 24px rgba(0,0,0,.25);
      --accent: #6ee7ff;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --grid: rgba(255,255,255,.045);
      --grid2: rgba(255,255,255,.070);
      --radius: 14px;
      --radius2: 12px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    [data-theme="light"]{
      --bg: #f7f8fb;
      --panel: rgba(255,255,255,.80);
      --panel2: rgba(255,255,255,.92);
      --stroke: rgba(15,23,42,.10);
      --muted: rgba(15,23,42,.70);
      --text: rgba(15,23,42,.92);
      --shadow: 0 18px 48px rgba(2,6,23,.10);
      --shadow2: 0 10px 24px rgba(2,6,23,.10);
      --grid: rgba(15,23,42,.05);
      --grid2: rgba(15,23,42,.08);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--font);
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 25% 20%, rgba(110,231,255,.18), transparent 60%),
        radial-gradient(900px 650px at 70% 20%, rgba(167,139,250,.18), transparent 65%),
        radial-gradient(900px 650px at 60% 80%, rgba(52,211,153,.10), transparent 60%),
        var(--bg);
      overflow:hidden;
    }

    .app{
      height:100%;
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 14px;
      padding: 14px;
    }

    .sidebar{
      display:flex;
      flex-direction:column;
      gap: 12px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      overflow:hidden;
      min-width: 280px;
    }

    .side-head{
      padding: 16px 16px 12px 16px;
      border-bottom: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));
    }
    .brand{
      display:flex;
      align-items:center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .logo{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      display:grid;
      place-items:center;
      border: 1px solid var(--stroke);
      background: radial-gradient(18px 18px at 30% 30%, rgba(110,231,255,.35), rgba(167,139,250,.18)),
                  rgba(255,255,255,.05);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
    }
    .brand h1{
      font-size: 15px;
      margin:0;
      letter-spacing: .2px;
      line-height: 1.1;
    }
    .brand .sub{
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .pillrow{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
    }
    .pill{
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      color: var(--muted);
      user-select:none;
    }
    .pill kbd{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text);
      padding: 1px 5px;
      border: 1px solid var(--stroke);
      border-bottom-color: rgba(0,0,0,.25);
      border-radius: 7px;
      background: rgba(255,255,255,.07);
      margin-left: 6px;
    }

    .side-body{
      padding: 0 12px 12px 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      overflow:auto;
      min-height: 0;
    }

    .section-title{
      margin: 12px 4px 6px 4px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .12em;
      text-transform: uppercase;
    }

    .btnrow{ display:flex; gap:8px; flex-wrap:wrap; }
    button, .btn{
      appearance:none;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 9px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size: 12.5px;
      line-height: 1;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      user-select:none;
      transition: transform .05s ease, background .18s ease, border-color .18s ease;
    }
    button:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.22); }
    button:active{ transform: translateY(1px); }
    button:focus-visible{ outline: 3px solid rgba(110,231,255,.35); outline-offset: 2px; }
    button.primary{
      background: linear-gradient(135deg, rgba(110,231,255,.18), rgba(167,139,250,.12));
      border-color: rgba(110,231,255,.45);
    }
    button.danger{
      border-color: rgba(251,113,133,.55);
      background: rgba(251,113,133,.12);
    }

    .list{
      display:flex;
      flex-direction:column;
      gap: 8px;
      margin-bottom: 2px;
    }
    .list-item{
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background: rgba(255,255,255,.05);
      padding: 10px 10px;
      display:flex;
      gap: 10px;
      align-items:flex-start;
      cursor:pointer;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .list-item:hover{ background: rgba(255,255,255,.08); }
    .list-item.selected{
      border-color: rgba(110,231,255,.55);
      background: rgba(110,231,255,.10);
    }
    .badge{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      margin-top: 4px;
      background: rgba(110,231,255,.9);
      box-shadow: 0 0 0 4px rgba(110,231,255,.12);
      flex: 0 0 auto;
    }
    .badge.alt{ background: rgba(167,139,250,.9); box-shadow: 0 0 0 4px rgba(167,139,250,.12);}
    .li-title{ font-size: 13px; margin:0; }
    .li-desc{ font-size: 12px; color: var(--muted); margin: 4px 0 0 0; line-height: 1.35; }

    .prop{
      border: 1px solid var(--stroke);
      border-radius: var(--radius2);
      background: rgba(255,255,255,.05);
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .prop .row{ display:flex; gap:10px; align-items:center; }
    .prop label{
      font-size: 12px;
      color: var(--muted);
      min-width: 70px;
    }
    input[type="text"], textarea{
      width:100%;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 10px;
      font-family: var(--font);
      font-size: 13px;
      outline:none;
    }
    textarea{ resize: vertical; min-height: 84px; }
    input[type="text"]:focus, textarea:focus{
      border-color: rgba(110,231,255,.55);
      box-shadow: 0 0 0 4px rgba(110,231,255,.12);
    }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      padding: 4px 2px 0 2px;
    }
    .hint code{
      font-family: var(--mono);
      font-size: 11.5px;
      padding: 0 6px;
      border-radius: 8px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
    }

    .main{
      position:relative;
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      overflow:hidden;
      background:
        radial-gradient(900px 650px at 70% 10%, rgba(110,231,255,.14), transparent 60%),
        radial-gradient(800px 600px at 20% 20%, rgba(167,139,250,.12), transparent 60%),
        rgba(255,255,255,.02);
      box-shadow: var(--shadow);
      min-width: 0;
    }

    .topbar{
      position:absolute;
      left: 12px;
      right: 12px;
      top: 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      pointer-events:none;
      z-index: 30;
    }
    .topbar .group{
      pointer-events:auto;
      display:flex;
      gap: 8px;
      align-items:center;
      padding: 8px;
      border: 1px solid var(--stroke);
      border-radius: 14px;
      background: rgba(10, 14, 24, .25);
      backdrop-filter: blur(10px);
    }
    [data-theme="light"] .topbar .group{
      background: rgba(255,255,255,.55);
    }
    .topbar .meta{
      font-size: 12px;
      color: var(--muted);
      user-select:none;
    }
    .divider{
      width: 1px;
      height: 20px;
      background: var(--stroke);
      margin: 0 2px;
    }

    .canvas{
      position:absolute;
      inset: 0;
      overflow:hidden;
      user-select:none;
      touch-action:none;
    }
    .grid{
      position:absolute;
      inset: 0;
      background-image:
        linear-gradient(to right, var(--grid) 1px, transparent 1px),
        linear-gradient(to bottom, var(--grid) 1px, transparent 1px),
        linear-gradient(to right, var(--grid2) 1px, transparent 1px),
        linear-gradient(to bottom, var(--grid2) 1px, transparent 1px);
      background-size: 24px 24px, 24px 24px, 120px 120px, 120px 120px;
      background-position: 0 0, 0 0, 0 0, 0 0;
      opacity: .9;
      pointer-events:none;
    }
    .grid.off{ display:none; }

    .stage-layer{
      position:absolute;
      left: 0;
      top: 0;
      width: 5000px;
      height: 3200px;
      transform-origin: 0 0;
      will-change: transform;
    }

    svg.wires{
      position:absolute;
      inset: 0;
      width: 5000px;
      height: 3200px;
      overflow: visible;
      pointer-events:none;
    }
    .wire-hit{
      pointer-events: stroke;
      cursor: pointer;
    }
    .wire{
      fill:none;
      stroke: rgba(110,231,255,.75);
      stroke-width: 2.2;
      stroke-linecap: round;
      filter: drop-shadow(0 6px 8px rgba(0,0,0,.22));
    }
    .wire.alt{ stroke: rgba(167,139,250,.70); }
    .wire.selected{ stroke: rgba(52,211,153,.95); stroke-width: 2.8; }
    .wire-hit{
      fill:none;
      stroke: rgba(0,0,0,0);
      stroke-width: 14;
    }
    .wire.temp{
      stroke: rgba(251,191,36,.90);
      stroke-dasharray: 6 7;
    }

    .nodes{
      position:absolute;
      inset: 0;
    }

    .node{
      position:absolute;
      width: 270px;
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background:
        linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
      box-shadow: var(--shadow2);
      color: var(--text);
    }
    [data-theme="light"] .node{
      background:
        linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.74));
    }
    .node.selected{
      border-color: rgba(110,231,255,.65);
      box-shadow: 0 18px 48px rgba(0,0,0,.25), 0 0 0 4px rgba(110,231,255,.10);
    }
    .node .head{
      padding: 12px 12px 10px 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      cursor: grab;
    }
    .node.dragging .head{ cursor: grabbing; }
    .node .title{
      font-weight: 640;
      font-size: 13.5px;
      letter-spacing: .15px;
      margin:0;
      line-height: 1.2;
    }
    .node .mini{
      font-size: 11.5px;
      color: var(--muted);
      margin-top: 3px;
      line-height: 1.2;
    }
    .node .body{
      padding: 0 12px 12px 12px;
      font-size: 12.5px;
      color: var(--muted);
      line-height: 1.35;
      white-space: pre-wrap;
    }
    .node .tools{
      display:flex;
      gap: 6px;
      align-items:center;
      opacity: .85;
    }
    .iconbtn{
      width: 30px;
      height: 30px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      display:grid;
      place-items:center;
      cursor:pointer;
      transition: transform .05s ease, background .18s ease, border-color .18s ease, opacity .18s ease;
      padding:0;
    }
    .iconbtn:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22); opacity:1; }
    .iconbtn:active{ transform: translateY(1px); }
    .iconbtn svg{ width: 16px; height: 16px; opacity:.9; }

    .port{
      position:absolute;
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.30);
      background: rgba(255,255,255,.10);
      box-shadow: 0 0 0 6px rgba(110,231,255,.10);
      top: 50%;
      transform: translateY(-50%);
      cursor: crosshair;
    }
    .port::after{
      content:"";
      position:absolute;
      inset: 3px;
      border-radius: 999px;
      background: rgba(110,231,255,.95);
    }
    .port.in{
      left: -8px;
      box-shadow: 0 0 0 6px rgba(167,139,250,.10);
    }
    .port.in::after{ background: rgba(167,139,250,.92); }
    .port.out{ right: -8px; }
    .port:focus-visible{ outline: 3px solid rgba(110,231,255,.35); outline-offset: 2px; }
    .node:hover .port{ background: rgba(255,255,255,.14); }

    .toast{
      position:absolute;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(10, 14, 24, .35);
      backdrop-filter: blur(10px);
      color: var(--text);
      font-size: 12.5px;
      box-shadow: var(--shadow2);
      opacity: 0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      z-index: 40;
      white-space: nowrap;
    }
    [data-theme="light"] .toast{ background: rgba(255,255,255,.65); }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-2px); }

    .modal-backdrop{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.35);
      z-index: 60;
      padding: 18px;
    }
    .modal-backdrop.show{ display:flex; }
    .modal{
      width: min(780px, 100%);
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(10, 14, 24, .40);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    [data-theme="light"] .modal{
      background: rgba(255,255,255,.78);
    }
    .modal .mh{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom: 1px solid var(--stroke);
    }
    .modal .mh h2{
      margin:0;
      font-size: 13.5px;
      letter-spacing: .2px;
    }
    .modal .mb{
      padding: 12px 14px 14px 14px;
      color: var(--muted);
      line-height: 1.55;
      font-size: 12.8px;
    }
    .modal .mb ul{ margin: 10px 0 0 18px; padding:0; }
    .modal .mb li{ margin: 6px 0; }
    .modal code{
      font-family: var(--mono);
      font-size: 12px;
      padding: 1px 6px;
      border-radius: 8px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
    }

    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      .sidebar{ height: 38%; }
      .main{ height: calc(62% - 14px); }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar" aria-label="Controls and stage editor">
      <div class="side-head">
        <div class="brand">
          <div class="logo" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M5.5 7.5c2.2-3 10.8-3 13 0 1.8 2.5 1.8 6.5 0 9-2.2 3-10.8 3-13 0-1.8-2.5-1.8-6.5 0-9Z" stroke="rgba(255,255,255,.82)" stroke-width="1.4"/>
              <path d="M8 12h8" stroke="rgba(110,231,255,.9)" stroke-width="1.8" stroke-linecap="round"/>
              <path d="M12 8v8" stroke="rgba(167,139,250,.88)" stroke-width="1.8" stroke-linecap="round" opacity=".9"/>
            </svg>
          </div>
          <div>
            <h1>Customer Journey Flow</h1>
            <div class="sub">Diagram stages and drag connections</div>
          </div>
        </div>
        <div class="pillrow" aria-label="Quick tips">
          <div class="pill">Add stage <kbd>N</kbd></div>
          <div class="pill">Pan <kbd>Space</kbd> + drag</div>
          <div class="pill">Delete <kbd>Del</kbd></div>
        </div>
      </div>

      <div class="side-body">
        <div class="section-title">Actions</div>
        <div class="btnrow">
          <button class="primary" id="addStageBtn" type="button" title="Add a new stage (N)">
            <span aria-hidden="true">＋</span> Add stage
          </button>
          <button id="autoLayoutBtn" type="button" title="Arrange stages into a clean left-to-right flow">
            <span aria-hidden="true">↔</span> Auto-layout
          </button>
          <button id="fitBtn" type="button" title="Fit diagram to view">
            <span aria-hidden="true">⤢</span> Fit
          </button>
        </div>
        <div class="btnrow">
          <button id="exportBtn" type="button" title="Download as JSON">
            <span aria-hidden="true">⤓</span> Export
          </button>
          <label class="btn" for="importFile" title="Import a previously exported JSON">
            <span aria-hidden="true">⤒</span> Import
          </label>
          <input id="importFile" type="file" accept="application/json" style="display:none" />
          <button class="danger" id="resetBtn" type="button" title="Reset to a fresh template">
            <span aria-hidden="true">↺</span> Reset
          </button>
        </div>

        <div class="section-title">Stages</div>
        <div class="list" id="stageList" role="list"></div>

        <div class="section-title">Selected</div>
        <div class="prop" id="propPanel" aria-live="polite">
          <div class="hint">Click a card in the diagram to edit. Double-click a title or description to edit in-place.</div>
        </div>

        <div class="section-title">How to connect</div>
        <div class="hint">
          Drag from a stage’s <code>●</code> (right port) to another stage’s <code>●</code> (left port) to create a connection.
          Click a line to select it, then press <code>Del</code> to remove.
        </div>
      </div>
    </aside>

    <main class="main" aria-label="Diagram canvas">
      <div class="topbar" aria-hidden="false">
        <div class="group" role="toolbar" aria-label="Canvas toolbar">
          <button id="zoomOutBtn" type="button" title="Zoom out (-)">−</button>
          <button id="zoomInBtn" type="button" title="Zoom in (+)">＋</button>
          <div class="divider" aria-hidden="true"></div>
          <button id="toggleGridBtn" type="button" title="Toggle grid">Grid</button>
          <button id="themeBtn" type="button" title="Toggle theme">Theme</button>
          <div class="divider" aria-hidden="true"></div>
          <button id="helpBtn" type="button" title="Help">Help</button>
        </div>
        <div class="group">
          <div class="meta" id="metaText">0 stages • 0 connections</div>
        </div>
      </div>

      <div class="canvas" id="canvas">
        <div class="grid" id="grid"></div>
        <div class="stage-layer" id="stageLayer">
          <svg class="wires" id="wires" viewBox="0 0 5000 3200" preserveAspectRatio="none" aria-label="Connections">
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(110,231,255,.90)"></path>
              </marker>
              <marker id="arrowAlt" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(167,139,250,.88)"></path>
              </marker>
              <marker id="arrowSel" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(52,211,153,.95)"></path>
              </marker>
            </defs>
          </svg>
          <div class="nodes" id="nodes"></div>
        </div>
      </div>

      <div class="toast" id="toast" role="status" aria-live="polite"></div>

      <div class="modal-backdrop" id="helpModal" role="dialog" aria-modal="true" aria-label="Help">
        <div class="modal">
          <div class="mh">
            <h2>Shortcuts & gestures</h2>
            <button id="closeHelpBtn" type="button" title="Close">Close</button>
          </div>
          <div class="mb">
            <ul>
              <li><code>N</code> add stage • <code>Del</code> delete selected stage/connection • <code>Esc</code> clear selection</li>
              <li><code>Space</code> + drag to pan • Mouse wheel to zoom (zoom anchors to cursor)</li>
              <li>Drag cards by their header • Drag from right port to left port to connect</li>
              <li>Double-click title or description to edit in-place</li>
              <li><code>Ctrl</code>/<code>⌘</code> + <code>S</code> saves to local storage (auto-saves anyway)</li>
              <li>Arrow keys nudge selected stage (hold <code>Shift</code> for 10px)</li>
            </ul>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    (() => {
      const STORAGE_KEY = "customer-journey-flow:v1";

      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

      const ui = {
        app: $("#app"),
        canvas: $("#canvas"),
        grid: $("#grid"),
        stageLayer: $("#stageLayer"),
        nodes: $("#nodes"),
        wires: $("#wires"),
        metaText: $("#metaText"),
        stageList: $("#stageList"),
        propPanel: $("#propPanel"),
        toast: $("#toast"),
        helpModal: $("#helpModal"),
        importFile: $("#importFile"),
        addStageBtn: $("#addStageBtn"),
        autoLayoutBtn: $("#autoLayoutBtn"),
        fitBtn: $("#fitBtn"),
        exportBtn: $("#exportBtn"),
        resetBtn: $("#resetBtn"),
        zoomInBtn: $("#zoomInBtn"),
        zoomOutBtn: $("#zoomOutBtn"),
        toggleGridBtn: $("#toggleGridBtn"),
        themeBtn: $("#themeBtn"),
        helpBtn: $("#helpBtn"),
        closeHelpBtn: $("#closeHelpBtn"),
      };

      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
      const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : "id_" + Math.random().toString(16).slice(2) + Date.now().toString(16));

      const defaultState = () => {
        const baseX = 420, baseY = 220, gapX = 330;
        const stages = [
          { id: uid(), title: "Awareness", desc: "Customer discovers your brand via ads, social, SEO, or word of mouth.", x: baseX + 0*gapX, y: baseY, color: "a" },
          { id: uid(), title: "Consideration", desc: "They compare options, read reviews, and evaluate value.", x: baseX + 1*gapX, y: baseY, color: "b" },
          { id: uid(), title: "Intent", desc: "They show buying signals: trials, demos, pricing page visits.", x: baseX + 2*gapX, y: baseY, color: "a" },
          { id: uid(), title: "Purchase", desc: "Checkout and payment. Reduce friction and build trust.", x: baseX + 3*gapX, y: baseY, color: "b" },
          { id: uid(), title: "Retention", desc: "Onboarding, support, and value realization drive repeat purchases.", x: baseX + 4*gapX, y: baseY, color: "a" },
        ];
        const connections = [
          { id: uid(), from: stages[0].id, to: stages[1].id },
          { id: uid(), from: stages[1].id, to: stages[2].id },
          { id: uid(), from: stages[2].id, to: stages[3].id },
          { id: uid(), from: stages[3].id, to: stages[4].id },
        ];
        return {
          version: 1,
          theme: "dark",
          grid: true,
          view: { scale: 1, tx: 0, ty: 0 },
          stages,
          connections,
          selected: { type: null, id: null },
        };
      };

      let state = defaultState();
      let rafScheduled = false;
      let saveTimer = null;

      const toast = (msg) => {
        ui.toast.textContent = msg;
        ui.toast.classList.add("show");
        window.clearTimeout(ui.toast._t);
        ui.toast._t = window.setTimeout(() => ui.toast.classList.remove("show"), 1200);
      };

      const scheduleSave = (msg) => {
        if (saveTimer) window.clearTimeout(saveTimer);
        saveTimer = window.setTimeout(() => {
          try {
            const toStore = {
              version: state.version,
              theme: state.theme,
              grid: state.grid,
              view: state.view,
              stages: state.stages,
              connections: state.connections,
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(toStore));
            if (msg) toast(msg);
          } catch (e) {
            console.warn(e);
          }
        }, 220);
      };

      const load = () => {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return false;
          const parsed = JSON.parse(raw);
          if (!parsed || parsed.version !== 1) return false;
          state = {
            ...defaultState(),
            ...parsed,
            selected: { type: null, id: null },
          };
          return true;
        } catch {
          return false;
        }
      };

      const setTheme = (theme) => {
        state.theme = theme;
        document.documentElement.setAttribute("data-theme", theme === "light" ? "light" : "dark");
        scheduleSave();
      };

      const setGrid = (on) => {
        state.grid = !!on;
        ui.grid.classList.toggle("off", !state.grid);
        scheduleSave();
      };

      const setView = (view) => {
        state.view = { ...state.view, ...view };
        const { scale, tx, ty } = state.view;
        ui.stageLayer.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
        requestRender();
      };

      const requestRender = () => {
        if (rafScheduled) return;
        rafScheduled = true;
        requestAnimationFrame(() => {
          rafScheduled = false;
          render();
        });
      };

      const byId = (id) => state.stages.find(s => s.id === id);
      const selected = () => state.selected;

      const select = (type, id) => {
        state.selected = { type, id };
        requestRender();
      };

      const clearSelection = () => select(null, null);

      const clientToWorld = (clientX, clientY) => {
        const rect = ui.canvas.getBoundingClientRect();
        const x = (clientX - rect.left - state.view.tx) / state.view.scale;
        const y = (clientY - rect.top - state.view.ty) / state.view.scale;
        return { x, y };
      };

      const worldToClient = (x, y) => {
        const rect = ui.canvas.getBoundingClientRect();
        return {
          x: rect.left + state.view.tx + x * state.view.scale,
          y: rect.top + state.view.ty + y * state.view.scale,
        };
      };

      const computePathD = (x1, y1, x2, y2) => {
        const dx = clamp(Math.abs(x2 - x1) * 0.55, 70, 260);
        const c1x = x1 + dx;
        const c2x = x2 - dx;
        return `M ${x1.toFixed(2)} ${y1.toFixed(2)} C ${c1x.toFixed(2)} ${y1.toFixed(2)} ${c2x.toFixed(2)} ${y2.toFixed(2)} ${x2.toFixed(2)} ${y2.toFixed(2)}`;
      };

      const getPortWorldCenter = (el) => {
        const r = el.getBoundingClientRect();
        const cx = r.left + r.width/2;
        const cy = r.top + r.height/2;
        return clientToWorld(cx, cy);
      };

      const renderStageList = () => {
        ui.stageList.innerHTML = "";
        const sel = selected();
        state.stages.forEach((s, idx) => {
          const item = document.createElement("div");
          item.className = "list-item" + (sel.type === "stage" && sel.id === s.id ? " selected" : "");
          item.setAttribute("role", "listitem");
          item.dataset.stageId = s.id;

          const badge = document.createElement("div");
          badge.className = "badge" + (s.color === "b" ? " alt" : "");

          const wrap = document.createElement("div");
          const title = document.createElement("p");
          title.className = "li-title";
          title.textContent = s.title || ("Stage " + (idx + 1));
          const desc = document.createElement("p");
          desc.className = "li-desc";
          desc.textContent = (s.desc || "").slice(0, 90) + ((s.desc || "").length > 90 ? "…" : "");
          wrap.appendChild(title);
          wrap.appendChild(desc);

          item.appendChild(badge);
          item.appendChild(wrap);
          ui.stageList.appendChild(item);
        });
      };

      const renderPropPanel = () => {
        const sel = selected();
        ui.propPanel.innerHTML = "";
        if (!sel.type) {
          const div = document.createElement("div");
          div.className = "hint";
          div.innerHTML = `Select a stage or connection to edit. Tip: Drag from the right port to the left port to connect stages.`;
          ui.propPanel.appendChild(div);
          return;
        }
        if (sel.type === "stage") {
          const s = byId(sel.id);
          if (!s) return;
          const row1 = document.createElement("div");
          row1.className = "row";
          row1.innerHTML = `<label>Title</label>`;
          const titleInput = document.createElement("input");
          titleInput.type = "text";
          titleInput.value = s.title || "";
          titleInput.addEventListener("input", () => {
            s.title = titleInput.value;
            scheduleSave();
            requestRender();
          });
          row1.appendChild(titleInput);

          const row2 = document.createElement("div");
          row2.className = "row";
          row2.style.alignItems = "flex-start";
          row2.innerHTML = `<label>Description</label>`;
          const descArea = document.createElement("textarea");
          descArea.value = s.desc || "";
          descArea.addEventListener("input", () => {
            s.desc = descArea.value;
            scheduleSave();
            requestRender();
          });
          row2.appendChild(descArea);

          const row3 = document.createElement("div");
          row3.className = "row";
          row3.innerHTML = `<label>Color</label>`;
          const colorA = document.createElement("button");
          colorA.type = "button";
          colorA.textContent = "Cyan";
          const colorB = document.createElement("button");
          colorB.type = "button";
          colorB.textContent = "Violet";
          const setC = (c) => {
            s.color = c;
            scheduleSave();
            requestRender();
          };
          colorA.addEventListener("click", () => setC("a"));
          colorB.addEventListener("click", () => setC("b"));
          row3.appendChild(colorA);
          row3.appendChild(colorB);

          const row4 = document.createElement("div");
          row4.className = "row";
          row4.innerHTML = `<label></label>`;
          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.className = "danger";
          delBtn.textContent = "Delete stage";
          delBtn.addEventListener("click", () => deleteStage(s.id));
          row4.appendChild(delBtn);

          ui.propPanel.appendChild(row1);
          ui.propPanel.appendChild(row2);
          ui.propPanel.appendChild(row3);
          ui.propPanel.appendChild(row4);
          return;
        }
        if (sel.type === "connection") {
          const c = state.connections.find(x => x.id === sel.id);
          const div = document.createElement("div");
          div.className = "hint";
          if (!c) {
            div.textContent = "Connection not found.";
            ui.propPanel.appendChild(div);
            return;
          }
          const from = byId(c.from)?.title || "Unknown";
          const to = byId(c.to)?.title || "Unknown";
          div.innerHTML = `Connection: <code>${escapeHtml(from)}</code> → <code>${escapeHtml(to)}</code>`;
          ui.propPanel.appendChild(div);

          const row = document.createElement("div");
          row.className = "row";
          row.innerHTML = `<label></label>`;
          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.className = "danger";
          delBtn.textContent = "Delete connection";
          delBtn.addEventListener("click", () => deleteConnection(c.id));
          row.appendChild(delBtn);
          ui.propPanel.appendChild(row);
        }
      };

      const escapeHtml = (s) => (s ?? "").replace(/[&<>"']/g, (ch) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[ch]));

      const renderNodes = () => {
        ui.nodes.innerHTML = "";
        const sel = selected();

        for (const s of state.stages) {
          const node = document.createElement("div");
          node.className = "node" + (sel.type === "stage" && sel.id === s.id ? " selected" : "");
          node.dataset.stageId = s.id;
          node.style.left = `${s.x}px`;
          node.style.top = `${s.y}px`;

          const inPort = document.createElement("div");
          inPort.className = "port in";
          inPort.tabIndex = 0;
          inPort.title = "Drop target";
          inPort.dataset.port = "in";
          inPort.dataset.stageId = s.id;

          const outPort = document.createElement("div");
          outPort.className = "port out";
          outPort.tabIndex = 0;
          outPort.title = "Drag to connect";
          outPort.dataset.port = "out";
          outPort.dataset.stageId = s.id;

          const head = document.createElement("div");
          head.className = "head";
          head.dataset.dragHandle = "1";

          const left = document.createElement("div");
          const title = document.createElement("p");
          title.className = "title";
          title.textContent = s.title || "Untitled stage";
          title.dataset.inlineEdit = "title";
          const mini = document.createElement("div");
          mini.className = "mini";
          mini.textContent = s.color === "b" ? "Touchpoint • Violet" : "Touchpoint • Cyan";
          left.appendChild(title);
          left.appendChild(mini);

          const tools = document.createElement("div");
          tools.className = "tools";
          const dup = iconButton("Duplicate", duplicateIcon(), () => duplicateStage(s.id));
          const del = iconButton("Delete", trashIcon(), () => deleteStage(s.id));
          tools.appendChild(dup);
          tools.appendChild(del);

          head.appendChild(left);
          head.appendChild(tools);

          const body = document.createElement("div");
          body.className = "body";
          body.textContent = s.desc || "";
          body.dataset.inlineEdit = "desc";

          node.appendChild(inPort);
          node.appendChild(outPort);
          node.appendChild(head);
          node.appendChild(body);
          ui.nodes.appendChild(node);
        }
      };

      const iconButton = (title, svgEl, onClick) => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "iconbtn";
        b.title = title;
        b.appendChild(svgEl);
        b.addEventListener("click", (e) => { e.stopPropagation(); onClick(); });
        return b;
      };

      const duplicateIcon = () => {
        const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
        svg.setAttribute("viewBox","0 0 24 24");
        svg.setAttribute("fill","none");
        svg.innerHTML = `<path d="M9 9h10v10H9V9Z" stroke="rgba(255,255,255,.82)" stroke-width="1.6" />
                         <path d="M5 15H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v1" stroke="rgba(255,255,255,.62)" stroke-width="1.6" stroke-linecap="round"/>`;
        return svg;
      };
      const trashIcon = () => {
        const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
        svg.setAttribute("viewBox","0 0 24 24");
        svg.setAttribute("fill","none");
        svg.innerHTML = `<path d="M9 3h6l1 2h4" stroke="rgba(255,255,255,.78)" stroke-width="1.6" stroke-linecap="round"/>
                         <path d="M6 7h12l-1 14H7L6 7Z" stroke="rgba(255,255,255,.78)" stroke-width="1.6" stroke-linejoin="round"/>
                         <path d="M10 11v6M14 11v6" stroke="rgba(255,255,255,.62)" stroke-width="1.6" stroke-linecap="round"/>`;
        return svg;
      };

      const renderWires = () => {
        const sel = selected();
        const frag = document.createDocumentFragment();

        const defs = ui.wires.querySelector("defs");
        ui.wires.innerHTML = "";
        if (defs) ui.wires.appendChild(defs);

        const getStageEl = (id) => ui.nodes.querySelector(`.node[data-stage-id="${CSS.escape(id)}"]`);
        const colorFor = (fromId) => (byId(fromId)?.color === "b" ? "alt" : "");

        for (const c of state.connections) {
          const fromEl = getStageEl(c.from);
          const toEl = getStageEl(c.to);
          if (!fromEl || !toEl) continue;
          const outEl = fromEl.querySelector(".port.out");
          const inEl = toEl.querySelector(".port.in");
          const p1 = getPortWorldCenter(outEl);
          const p2 = getPortWorldCenter(inEl);

          const d = computePathD(p1.x, p1.y, p2.x, p2.y);
          const group = document.createElementNS("http://www.w3.org/2000/svg","g");
          group.dataset.connectionId = c.id;
          const wire = document.createElementNS("http://www.w3.org/2000/svg","path");
          wire.setAttribute("d", d);
          const isSel = (sel.type === "connection" && sel.id === c.id);
          wire.setAttribute("class", "wire " + colorFor(c.from) + (isSel ? " selected" : ""));
          wire.setAttribute("marker-end", isSel ? "url(#arrowSel)" : (colorFor(c.from) ? "url(#arrowAlt)" : "url(#arrow)"));

          const hit = document.createElementNS("http://www.w3.org/2000/svg","path");
          hit.setAttribute("d", d);
          hit.setAttribute("class", "wire-hit");
          hit.style.pointerEvents = "stroke";
          hit.addEventListener("pointerdown", (e) => {
            e.stopPropagation();
            select("connection", c.id);
          });

          group.appendChild(hit);
          group.appendChild(wire);
          frag.appendChild(group);
        }
        ui.wires.appendChild(frag);
      };

      const renderMeta = () => {
        ui.metaText.textContent = `${state.stages.length} stages • ${state.connections.length} connections`;
      };

      const render = () => {
        renderNodes();
        renderWires();
        renderStageList();
        renderPropPanel();
        renderMeta();
      };

      const addStage = (partial = {}) => {
        const id = uid();
        const nextIdx = state.stages.length + 1;
        const center = clientToWorld(window.innerWidth * 0.65, window.innerHeight * 0.50);
        const s = {
          id,
          title: partial.title ?? `New stage ${nextIdx}`,
          desc: partial.desc ?? "Describe what the customer is doing, thinking, and feeling here.",
          x: partial.x ?? center.x + (Math.random() * 80 - 40),
          y: partial.y ?? center.y + (Math.random() * 60 - 30),
          color: partial.color ?? (nextIdx % 2 ? "a" : "b"),
        };
        state.stages.push(s);
        select("stage", id);
        scheduleSave("Stage added");
        requestRender();
      };

      const deleteStage = (stageId) => {
        const idx = state.stages.findIndex(s => s.id === stageId);
        if (idx < 0) return;
        state.stages.splice(idx, 1);
        state.connections = state.connections.filter(c => c.from !== stageId && c.to !== stageId);
        if (state.selected.type === "stage" && state.selected.id === stageId) clearSelection();
        scheduleSave("Stage deleted");
        requestRender();
      };

      const duplicateStage = (stageId) => {
        const s = byId(stageId);
        if (!s) return;
        addStage({
          title: (s.title || "Stage") + " (copy)",
          desc: s.desc || "",
          x: s.x + 34,
          y: s.y + 26,
          color: s.color,
        });
      };

      const deleteConnection = (connId) => {
        const idx = state.connections.findIndex(c => c.id === connId);
        if (idx < 0) return;
        state.connections.splice(idx, 1);
        if (state.selected.type === "connection" && state.selected.id === connId) clearSelection();
        scheduleSave("Connection deleted");
        requestRender();
      };

      const addConnection = (fromId, toId) => {
        if (!fromId || !toId || fromId === toId) return false;
        if (!byId(fromId) || !byId(toId)) return false;
        const exists = state.connections.some(c => c.from === fromId && c.to === toId);
        if (exists) return false;
        state.connections.push({ id: uid(), from: fromId, to: toId });
        scheduleSave("Connection added");
        requestRender();
        return true;
      };

      const autoLayout = () => {
        const order = inferOrder();
        const startX = 420, startY = 220;
        const gapX = 330, gapY = 190;
        const cols = Math.max(3, Math.min(7, order.length));
        order.forEach((id, i) => {
          const s = byId(id);
          if (!s) return;
          const col = i % cols;
          const row = Math.floor(i / cols);
          s.x = startX + col * gapX;
          s.y = startY + row * gapY;
        });
        scheduleSave("Auto-layout");
        requestRender();
      };

      const inferOrder = () => {
        const ids = state.stages.map(s => s.id);
        if (!state.connections.length) return ids;

        // Kahn topological sort with stable fallback.
        const indeg = new Map(ids.map(id => [id, 0]));
        const adj = new Map(ids.map(id => [id, []]));
        for (const c of state.connections) {
          if (!adj.has(c.from) || !indeg.has(c.to)) continue;
          adj.get(c.from).push(c.to);
          indeg.set(c.to, (indeg.get(c.to) || 0) + 1);
        }
        const queue = ids.filter(id => (indeg.get(id) || 0) === 0);
        const out = [];
        while (queue.length) {
          const id = queue.shift();
          out.push(id);
          for (const to of adj.get(id) || []) {
            indeg.set(to, (indeg.get(to) || 0) - 1);
            if ((indeg.get(to) || 0) === 0) queue.push(to);
          }
        }
        // If cycles exist, append remaining by original order.
        const remaining = ids.filter(id => !out.includes(id));
        return out.concat(remaining);
      };

      const fitToView = () => {
        // Compute bounds in world coordinates from stage positions.
        if (!state.stages.length) return;
        const pad = 140;
        const stageRects = $$(".node", ui.nodes).map(el => {
          const sId = el.dataset.stageId;
          const s = byId(sId);
          return s ? { x: s.x, y: s.y, w: el.offsetWidth, h: el.offsetHeight } : null;
        }).filter(Boolean);
        if (!stageRects.length) return;
        const minX = Math.min(...stageRects.map(r => r.x));
        const minY = Math.min(...stageRects.map(r => r.y));
        const maxX = Math.max(...stageRects.map(r => r.x + r.w));
        const maxY = Math.max(...stageRects.map(r => r.y + r.h));
        const rect = ui.canvas.getBoundingClientRect();
        const w = maxX - minX + pad*2;
        const h = maxY - minY + pad*2;
        const scale = clamp(Math.min(rect.width / w, rect.height / h), 0.35, 1.6);
        const tx = (rect.width - (minX - pad) * scale - w * scale / 2) + (w * scale / 2) - (w * scale / 2);
        const ty = (rect.height - (minY - pad) * scale - h * scale / 2) + (h * scale / 2) - (h * scale / 2);
        // More directly: place top-left (minX-pad, minY-pad) at (margin)
        const marginX = 40, marginY = 70;
        setView({
          scale,
          tx: marginX - (minX - pad) * scale,
          ty: marginY - (minY - pad) * scale,
        });
        scheduleSave();
      };

      // --- Inline editing (double click) ---
      const startInlineEdit = (stageId, field) => {
        const s = byId(stageId);
        if (!s) return;
        const node = ui.nodes.querySelector(`.node[data-stage-id="${CSS.escape(stageId)}"]`);
        if (!node) return;
        const target = node.querySelector(`[data-inline-edit="${field}"]`);
        if (!target) return;

        const isTitle = field === "title";
        const current = isTitle ? (s.title || "") : (s.desc || "");

        const input = document.createElement(isTitle ? "input" : "textarea");
        if (isTitle) input.type = "text";
        input.value = current;
        input.style.width = "100%";
        input.style.marginTop = isTitle ? "0" : "0";
        input.style.fontSize = isTitle ? "13.5px" : "12.5px";
        input.style.lineHeight = isTitle ? "1.2" : "1.35";
        input.style.background = "rgba(255,255,255,.08)";
        input.style.border = "1px solid rgba(110,231,255,.55)";
        input.style.borderRadius = "10px";
        input.style.color = "inherit";
        input.style.padding = isTitle ? "7px 8px" : "8px 8px";
        input.style.fontFamily = "inherit";
        input.style.outline = "none";
        input.style.boxShadow = "0 0 0 4px rgba(110,231,255,.12)";
        input.addEventListener("pointerdown", (e) => e.stopPropagation());

        const commit = () => {
          const v = input.value.trim();
          if (isTitle) s.title = v || "Untitled stage";
          else s.desc = input.value;
          scheduleSave("Updated");
          requestRender();
        };
        const cancel = () => requestRender();

        input.addEventListener("keydown", (e) => {
          if (e.key === "Escape") { e.preventDefault(); cancel(); }
          if (isTitle && e.key === "Enter") { e.preventDefault(); commit(); }
          if (!isTitle && (e.key === "Enter" && (e.ctrlKey || e.metaKey))) { e.preventDefault(); commit(); }
        });
        input.addEventListener("blur", commit, { once: true });

        target.replaceWith(input);
        input.focus();
        if (isTitle) input.select();
      };

      // --- Dragging nodes ---
      let drag = null;
      const startDragStage = (stageId, clientX, clientY) => {
        const s = byId(stageId);
        if (!s) return;
        const w = clientToWorld(clientX, clientY);
        drag = {
          type: "stage",
          stageId,
          startWorld: w,
          startPos: { x: s.x, y: s.y },
          pointerId: null,
        };
        const node = ui.nodes.querySelector(`.node[data-stage-id="${CSS.escape(stageId)}"]`);
        if (node) node.classList.add("dragging");
      };
      const moveDragStage = (clientX, clientY) => {
        if (!drag || drag.type !== "stage") return;
        const s = byId(drag.stageId);
        if (!s) return;
        const w = clientToWorld(clientX, clientY);
        const dx = w.x - drag.startWorld.x;
        const dy = w.y - drag.startWorld.y;
        s.x = Math.round(drag.startPos.x + dx);
        s.y = Math.round(drag.startPos.y + dy);
        requestRender();
      };
      const endDragStage = () => {
        if (!drag || drag.type !== "stage") return;
        const node = ui.nodes.querySelector(`.node[data-stage-id="${CSS.escape(drag.stageId)}"]`);
        if (node) node.classList.remove("dragging");
        drag = null;
        scheduleSave();
      };

      // --- Panning & zooming ---
      let pan = null;
      const startPan = (clientX, clientY) => {
        pan = { startX: clientX, startY: clientY, tx: state.view.tx, ty: state.view.ty };
        ui.canvas.style.cursor = "grabbing";
      };
      const movePan = (clientX, clientY) => {
        if (!pan) return;
        const dx = clientX - pan.startX;
        const dy = clientY - pan.startY;
        setView({ tx: pan.tx + dx, ty: pan.ty + dy });
      };
      const endPan = () => {
        if (!pan) return;
        pan = null;
        ui.canvas.style.cursor = "";
        scheduleSave();
      };

      const zoomAtClient = (factor, clientX, clientY) => {
        const before = clientToWorld(clientX, clientY);
        const nextScale = clamp(state.view.scale * factor, 0.35, 2.1);
        const after = before; // same world point should stay under cursor
        const rect = ui.canvas.getBoundingClientRect();
        const nextTx = (clientX - rect.left) - after.x * nextScale;
        const nextTy = (clientY - rect.top) - after.y * nextScale;
        setView({ scale: nextScale, tx: nextTx, ty: nextTy });
        scheduleSave();
      };

      // --- Creating connections ---
      let connect = null;
      const beginConnect = (fromStageId, fromPortEl, clientX, clientY) => {
        const start = getPortWorldCenter(fromPortEl);
        connect = {
          from: fromStageId,
          start,
          tempId: "temp",
        };
        select(null, null);
        renderTempWire(start.x, start.y, clientToWorld(clientX, clientY));
      };
      const updateConnect = (clientX, clientY) => {
        if (!connect) return;
        renderTempWire(connect.start.x, connect.start.y, clientToWorld(clientX, clientY));
      };
      const endConnect = (toStageId) => {
        if (!connect) return;
        const from = connect.from;
        connect = null;
        removeTempWire();
        if (!toStageId) return;
        if (addConnection(from, toStageId)) {
          select("stage", toStageId);
        }
      };
      const renderTempWire = (x1, y1, p2) => {
        const existing = ui.wires.querySelector('path[data-temp="1"]');
        const d = computePathD(x1, y1, p2.x, p2.y);
        let wire = existing;
        if (!wire) {
          wire = document.createElementNS("http://www.w3.org/2000/svg","path");
          wire.dataset.temp = "1";
          wire.setAttribute("class", "wire temp");
          ui.wires.appendChild(wire);
        }
        wire.setAttribute("d", d);
      };
      const removeTempWire = () => {
        const wire = ui.wires.querySelector('path[data-temp="1"]');
        if (wire) wire.remove();
      };

      // --- Export / Import ---
      const exportJson = () => {
        const payload = {
          version: 1,
          theme: state.theme,
          grid: state.grid,
          view: state.view,
          stages: state.stages,
          connections: state.connections,
          exportedAt: new Date().toISOString(),
          name: "Customer Journey Flow",
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "customer-journey-flow.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(a.href), 800);
        toast("Exported JSON");
      };

      const importJsonFile = async (file) => {
        const text = await file.text();
        let parsed;
        try { parsed = JSON.parse(text); } catch { toast("Invalid JSON"); return; }
        if (!parsed || parsed.version !== 1 || !Array.isArray(parsed.stages) || !Array.isArray(parsed.connections)) {
          toast("Unexpected format");
          return;
        }
        state = {
          ...defaultState(),
          theme: parsed.theme || "dark",
          grid: typeof parsed.grid === "boolean" ? parsed.grid : true,
          view: parsed.view || { scale: 1, tx: 0, ty: 0 },
          stages: parsed.stages,
          connections: parsed.connections,
          selected: { type: null, id: null },
        };
        setTheme(state.theme);
        setGrid(state.grid);
        setView(state.view);
        scheduleSave("Imported");
        requestRender();
      };

      // --- Event wiring ---
      ui.addStageBtn.addEventListener("click", () => addStage());
      ui.autoLayoutBtn.addEventListener("click", autoLayout);
      ui.fitBtn.addEventListener("click", () => { requestRender(); setTimeout(fitToView, 0); });
      ui.exportBtn.addEventListener("click", exportJson);
      ui.importFile.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        await importJsonFile(file);
        ui.importFile.value = "";
      });
      ui.resetBtn.addEventListener("click", () => {
        state = defaultState();
        setTheme(state.theme);
        setGrid(state.grid);
        setView(state.view);
        scheduleSave("Reset");
        requestRender();
      });

      ui.zoomInBtn.addEventListener("click", () => zoomAtClient(1.12, ui.canvas.getBoundingClientRect().left + ui.canvas.clientWidth/2, ui.canvas.getBoundingClientRect().top + ui.canvas.clientHeight/2));
      ui.zoomOutBtn.addEventListener("click", () => zoomAtClient(1/1.12, ui.canvas.getBoundingClientRect().left + ui.canvas.clientWidth/2, ui.canvas.getBoundingClientRect().top + ui.canvas.clientHeight/2));
      ui.toggleGridBtn.addEventListener("click", () => setGrid(!state.grid));
      ui.themeBtn.addEventListener("click", () => setTheme(state.theme === "light" ? "dark" : "light"));
      ui.helpBtn.addEventListener("click", () => ui.helpModal.classList.add("show"));
      ui.closeHelpBtn.addEventListener("click", () => ui.helpModal.classList.remove("show"));
      ui.helpModal.addEventListener("pointerdown", (e) => { if (e.target === ui.helpModal) ui.helpModal.classList.remove("show"); });

      ui.stageList.addEventListener("click", (e) => {
        const item = e.target.closest(".list-item");
        if (!item) return;
        select("stage", item.dataset.stageId);
      });

      ui.canvas.addEventListener("pointerdown", (e) => {
        const port = e.target.closest(".port");
        const node = e.target.closest(".node");

        if (port && port.dataset.port === "out") {
          e.preventDefault();
          e.stopPropagation();
          beginConnect(port.dataset.stageId, port, e.clientX, e.clientY);
          ui.canvas.setPointerCapture(e.pointerId);
          return;
        }

        if (node) {
          const stageId = node.dataset.stageId;
          select("stage", stageId);
          // Drag only when pressing on header area.
          const handle = e.target.closest('[data-drag-handle="1"]');
          if (handle) {
            e.preventDefault();
            e.stopPropagation();
            startDragStage(stageId, e.clientX, e.clientY);
            drag.pointerId = e.pointerId;
            ui.canvas.setPointerCapture(e.pointerId);
          }
          return;
        }

        // Background: clear selection or pan if space held.
        if (!e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey) clearSelection();
        if (keyState.space || e.button === 1) {
          startPan(e.clientX, e.clientY);
          ui.canvas.setPointerCapture(e.pointerId);
        }
      });

      ui.canvas.addEventListener("pointermove", (e) => {
        if (drag && drag.type === "stage") moveDragStage(e.clientX, e.clientY);
        if (pan) movePan(e.clientX, e.clientY);
        if (connect) updateConnect(e.clientX, e.clientY);
      });

      ui.canvas.addEventListener("pointerup", (e) => {
        if (drag && drag.type === "stage") endDragStage();
        if (pan) endPan();
        if (connect) {
          const targetPort = document.elementFromPoint(e.clientX, e.clientY)?.closest?.(".port.in");
          const toStageId = targetPort?.dataset?.stageId || null;
          endConnect(toStageId);
        }
      });
      ui.canvas.addEventListener("pointercancel", () => {
        if (drag) endDragStage();
        if (pan) endPan();
        if (connect) { connect = null; removeTempWire(); }
      });

      ui.canvas.addEventListener("dblclick", (e) => {
        const el = e.target.closest("[data-inline-edit]");
        const node = e.target.closest(".node");
        if (!el || !node) return;
        const stageId = node.dataset.stageId;
        const field = el.dataset.inlineEdit;
        select("stage", stageId);
        startInlineEdit(stageId, field);
      });

      ui.canvas.addEventListener("wheel", (e) => {
        // Zoom: wheel. (Trackpads feel good here; we keep it direct.)
        e.preventDefault();
        const delta = e.deltaY;
        const factor = delta > 0 ? 1/1.07 : 1.07;
        zoomAtClient(factor, e.clientX, e.clientY);
      }, { passive: false });

      const keyState = { space: false };
      window.addEventListener("keydown", (e) => {
        if (e.key === " " && !e.repeat) keyState.space = true;
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
          e.preventDefault();
          scheduleSave("Saved");
        }
        if (e.key === "Escape") {
          ui.helpModal.classList.remove("show");
          clearSelection();
          if (connect) { connect = null; removeTempWire(); }
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey) {
          if (e.key.toLowerCase() === "n") {
            e.preventDefault();
            addStage();
          }
        }

        if (e.key === "Delete" || e.key === "Backspace") {
          const sel = selected();
          if (sel.type === "stage") { e.preventDefault(); deleteStage(sel.id); }
          if (sel.type === "connection") { e.preventDefault(); deleteConnection(sel.id); }
        }

        const sel = selected();
        if (sel.type === "stage") {
          const s = byId(sel.id);
          if (!s) return;
          const step = e.shiftKey ? 10 : 1;
          let moved = false;
          if (e.key === "ArrowLeft") { s.x -= step; moved = true; }
          if (e.key === "ArrowRight") { s.x += step; moved = true; }
          if (e.key === "ArrowUp") { s.y -= step; moved = true; }
          if (e.key === "ArrowDown") { s.y += step; moved = true; }
          if (moved) { e.preventDefault(); scheduleSave(); requestRender(); }
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === " ") keyState.space = false;
      });

      // Keep view stable on resize.
      window.addEventListener("resize", () => requestRender());

      // Initial boot
      const hadState = load();
      setTheme(state.theme);
      setGrid(state.grid);
      setView(state.view);
      requestRender();
      setTimeout(() => {
        requestRender();
        if (!hadState) fitToView();
      }, 50);
    })();
  </script>
</body>
</html>
