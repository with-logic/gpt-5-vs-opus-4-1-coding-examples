<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>Customer Journey Flow</title>
    <style>
      :root {
        --bg: #0b1020;
        --panel: rgba(18, 24, 44, 0.72);
        --panel-2: rgba(18, 24, 44, 0.88);
        --text: rgba(248, 250, 252, 0.92);
        --muted: rgba(226, 232, 240, 0.72);
        --faint: rgba(226, 232, 240, 0.36);
        --border: rgba(148, 163, 184, 0.24);
        --border-2: rgba(148, 163, 184, 0.16);
        --shadow: 0 18px 65px rgba(0, 0, 0, 0.45);
        --shadow-soft: 0 10px 30px rgba(0, 0, 0, 0.28);
        --accent: #7c3aed;
        --accent-2: #22c55e;
        --danger: #ef4444;
        --warn: #f59e0b;
        --grid: rgba(148, 163, 184, 0.12);
        --grid-bold: rgba(148, 163, 184, 0.18);
        --node: rgba(255, 255, 255, 0.06);
        --node-border: rgba(148, 163, 184, 0.22);
        --node-border-strong: rgba(148, 163, 184, 0.38);
        --node-header: rgba(255, 255, 255, 0.06);
        --node-focus: rgba(124, 58, 237, 0.42);
        --radius: 16px;
        --radius-sm: 12px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }
      :root[data-theme="light"] {
        --bg: #f6f7fb;
        --panel: rgba(255, 255, 255, 0.72);
        --panel-2: rgba(255, 255, 255, 0.92);
        --text: rgba(15, 23, 42, 0.92);
        --muted: rgba(15, 23, 42, 0.64);
        --faint: rgba(15, 23, 42, 0.28);
        --border: rgba(15, 23, 42, 0.12);
        --border-2: rgba(15, 23, 42, 0.08);
        --shadow: 0 18px 65px rgba(15, 23, 42, 0.14);
        --shadow-soft: 0 10px 30px rgba(15, 23, 42, 0.12);
        --grid: rgba(15, 23, 42, 0.09);
        --grid-bold: rgba(15, 23, 42, 0.12);
        --node: rgba(15, 23, 42, 0.03);
        --node-border: rgba(15, 23, 42, 0.14);
        --node-border-strong: rgba(15, 23, 42, 0.22);
        --node-header: rgba(15, 23, 42, 0.035);
        --node-focus: rgba(124, 58, 237, 0.26);
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: var(--sans);
        background: radial-gradient(1200px 600px at 30% 10%, rgba(124, 58, 237, 0.22), transparent 70%),
          radial-gradient(900px 450px at 85% 18%, rgba(34, 197, 94, 0.16), transparent 70%),
          radial-gradient(900px 450px at 70% 85%, rgba(59, 130, 246, 0.14), transparent 60%), var(--bg);
        color: var(--text);
        overflow: hidden;
      }
      a {
        color: inherit;
      }

      .app {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      .topbar {
        padding: 14px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(to bottom, rgba(0, 0, 0, 0.16), transparent), var(--panel);
        backdrop-filter: blur(12px);
      }
      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 260px;
      }
      .logo {
        width: 36px;
        height: 36px;
        border-radius: 12px;
        background: radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.16), transparent 45%),
          linear-gradient(135deg, rgba(124, 58, 237, 0.95), rgba(34, 197, 94, 0.92));
        box-shadow: 0 16px 50px rgba(124, 58, 237, 0.28);
        position: relative;
        overflow: hidden;
      }
      .logo:before {
        content: "";
        position: absolute;
        inset: -40%;
        transform: rotate(25deg);
        background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.24), transparent);
        animation: sheen 5.5s ease-in-out infinite;
      }
      @keyframes sheen {
        0%,
        30% {
          translate: -40% 0;
          opacity: 0;
        }
        55% {
          translate: 40% 0;
          opacity: 1;
        }
        100% {
          translate: 120% 0;
          opacity: 0;
        }
      }
      .brand h1 {
        margin: 0;
        font-size: 14px;
        line-height: 1.1;
        letter-spacing: 0.2px;
        font-weight: 720;
      }
      .brand .sub {
        margin-top: 2px;
        color: var(--muted);
        font-size: 12px;
      }

      .toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      .btn {
        appearance: none;
        border: 1px solid var(--border);
        background: var(--node);
        color: var(--text);
        padding: 9px 10px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 650;
        letter-spacing: 0.15px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        box-shadow: 0 1px 0 rgba(255, 255, 255, 0.06) inset;
        transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      }
      .btn:hover {
        transform: translateY(-1px);
        border-color: var(--node-border-strong);
      }
      .btn:active {
        transform: translateY(0);
      }
      .btn.primary {
        background: linear-gradient(135deg, rgba(124, 58, 237, 0.95), rgba(99, 102, 241, 0.82));
        border-color: rgba(124, 58, 237, 0.5);
        box-shadow: 0 14px 60px rgba(124, 58, 237, 0.2);
      }
      .btn.ghost {
        background: transparent;
      }
      .btn.danger {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(244, 63, 94, 0.74));
        border-color: rgba(239, 68, 68, 0.5);
      }
      .btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        transform: none;
      }
      .btn .ic {
        width: 16px;
        height: 16px;
        display: inline-block;
      }
      .spacer {
        width: 1px;
        height: 26px;
        background: var(--border);
        margin: 0 2px;
      }

      .main {
        flex: 1;
        display: grid;
        grid-template-columns: 1fr 340px;
        gap: 12px;
        padding: 12px;
        min-height: 0;
      }
      @media (max-width: 980px) {
        .main {
          grid-template-columns: 1fr;
        }
        .sidebar {
          display: none;
        }
        .brand {
          min-width: unset;
        }
      }

      .canvasWrap {
        position: relative;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        overflow: hidden;
        min-height: 0;
        box-shadow: var(--shadow);
        background: linear-gradient(to bottom, rgba(0, 0, 0, 0.18), transparent 70%), var(--panel);
        backdrop-filter: blur(10px);
      }
      .canvas {
        position: absolute;
        inset: 0;
        cursor: default;
        user-select: none;
        touch-action: none;
        background-image: linear-gradient(to right, var(--grid) 1px, transparent 1px),
          linear-gradient(to bottom, var(--grid) 1px, transparent 1px),
          linear-gradient(to right, var(--grid-bold) 1px, transparent 1px),
          linear-gradient(to bottom, var(--grid-bold) 1px, transparent 1px);
        background-size: 24px 24px, 24px 24px, 120px 120px, 120px 120px;
        background-position: 0 0, 0 0, 0 0, 0 0;
      }
      .world {
        position: absolute;
        inset: 0;
        transform-origin: 0 0;
      }
      .edges {
        position: absolute;
        inset: 0;
        overflow: visible;
        pointer-events: none;
      }
      .edges path.edge {
        pointer-events: stroke;
        cursor: pointer;
      }
      .edges path.edge:hover {
        filter: drop-shadow(0 10px 25px rgba(0, 0, 0, 0.25));
      }

      .hud {
        position: absolute;
        left: 12px;
        bottom: 12px;
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 8px 10px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: var(--panel-2);
        backdrop-filter: blur(10px);
        box-shadow: var(--shadow-soft);
        color: var(--muted);
        font-size: 12px;
      }
      .hud kbd {
        font-family: var(--mono);
        font-size: 11px;
        padding: 2px 6px;
        border: 1px solid var(--border);
        border-bottom-color: var(--border-2);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.14);
        color: var(--text);
      }
      :root[data-theme="light"] .hud kbd {
        background: rgba(15, 23, 42, 0.06);
      }
      .badge {
        display: inline-flex;
        gap: 8px;
        align-items: center;
      }
      .dot {
        width: 7px;
        height: 7px;
        border-radius: 999px;
        background: var(--accent);
        box-shadow: 0 0 0 6px rgba(124, 58, 237, 0.16);
      }
      .status {
        position: absolute;
        right: 12px;
        bottom: 12px;
        padding: 8px 10px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: var(--panel-2);
        backdrop-filter: blur(10px);
        box-shadow: var(--shadow-soft);
        display: flex;
        gap: 10px;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
      }
      .status .pill {
        padding: 3px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        color: var(--text);
        background: rgba(255, 255, 255, 0.04);
        font-family: var(--mono);
        font-size: 11px;
      }

      .node {
        position: absolute;
        width: 240px;
        min-height: 132px;
        border-radius: 18px;
        border: 1px solid var(--node-border);
        background: rgba(0, 0, 0, 0.14);
        background: color-mix(in srgb, var(--node) 86%, transparent);
        box-shadow: 0 14px 50px rgba(0, 0, 0, 0.26);
        overflow: hidden;
        transform: translateZ(0);
      }
      :root[data-theme="light"] .node {
        background: color-mix(in srgb, white 86%, transparent);
        box-shadow: 0 14px 50px rgba(15, 23, 42, 0.12);
      }
      .node.selected {
        border-color: color-mix(in srgb, var(--accent) 70%, var(--node-border-strong));
        box-shadow: 0 0 0 4px var(--node-focus), 0 16px 55px rgba(0, 0, 0, 0.3);
      }
      .node.connectTarget {
        border-color: color-mix(in srgb, var(--accent-2) 65%, var(--node-border-strong));
        box-shadow: 0 0 0 4px color-mix(in srgb, var(--accent-2) 18%, transparent),
          0 18px 60px rgba(0, 0, 0, 0.25);
      }
      .nodeHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 10px 8px;
        background: linear-gradient(to bottom, var(--node-header), transparent);
        border-bottom: 1px solid var(--border-2);
        cursor: grab;
      }
      .nodeHeader:active {
        cursor: grabbing;
      }
      .nodeTitle {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
      }
      .nodeTitle .swatch {
        width: 10px;
        height: 10px;
        border-radius: 4px;
        background: var(--accent);
        box-shadow: 0 0 0 5px rgba(124, 58, 237, 0.14);
      }
      .nodeTitle [contenteditable] {
        min-width: 0;
        outline: none;
        border-radius: 8px;
        padding: 2px 6px;
        font-weight: 750;
        font-size: 13px;
        letter-spacing: 0.15px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .nodeTitle [contenteditable]:focus {
        box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.22);
        background: rgba(124, 58, 237, 0.08);
      }
      .nodeActions {
        display: flex;
        gap: 6px;
      }
      .iconBtn {
        appearance: none;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        width: 30px;
        height: 30px;
        border-radius: 12px;
        cursor: pointer;
        display: grid;
        place-items: center;
        transition: border-color 120ms ease, transform 120ms ease, background 120ms ease;
      }
      .iconBtn:hover {
        transform: translateY(-1px);
        border-color: var(--node-border-strong);
      }
      .iconBtn:active {
        transform: translateY(0);
      }
      .iconBtn svg {
        width: 16px;
        height: 16px;
      }

      .nodeBody {
        padding: 8px 10px 10px;
      }
      .nodeBody textarea {
        width: 100%;
        resize: none;
        min-height: 76px;
        border: 1px solid var(--border-2);
        background: rgba(0, 0, 0, 0.12);
        color: var(--text);
        border-radius: 14px;
        padding: 10px 10px;
        font-size: 12px;
        line-height: 1.35;
        outline: none;
      }
      :root[data-theme="light"] .nodeBody textarea {
        background: rgba(15, 23, 42, 0.04);
      }
      .nodeBody textarea:focus {
        border-color: rgba(124, 58, 237, 0.45);
        box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.16);
      }

      .port {
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.32);
        background: rgba(0, 0, 0, 0.2);
        display: grid;
        place-items: center;
        cursor: crosshair;
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      }
      :root[data-theme="light"] .port {
        border-color: rgba(15, 23, 42, 0.22);
        background: rgba(255, 255, 255, 0.8);
      }
      .port::before {
        content: "";
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.72);
      }
      :root[data-theme="light"] .port::before {
        background: rgba(15, 23, 42, 0.42);
      }
      .port:hover {
        transform: scale(1.12);
        border-color: rgba(34, 197, 94, 0.7);
        background: rgba(34, 197, 94, 0.12);
      }
      .port.in {
        left: -8px;
        top: 50%;
        translate: 0 -50%;
      }
      .port.out {
        right: -8px;
        top: 50%;
        translate: 0 -50%;
      }

      .sidebar {
        border: 1px solid var(--border);
        border-radius: var(--radius);
        overflow: hidden;
        box-shadow: var(--shadow);
        background: var(--panel);
        backdrop-filter: blur(12px);
        min-height: 0;
        display: flex;
        flex-direction: column;
      }
      .sideHeader {
        padding: 14px 14px 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .sideHeader h2 {
        margin: 0;
        font-size: 13px;
        letter-spacing: 0.2px;
        font-weight: 780;
      }
      .sideHeader .meta {
        font-size: 12px;
        color: var(--muted);
      }
      .sideBody {
        padding: 12px 14px 14px;
        overflow: auto;
      }
      .formRow {
        display: grid;
        gap: 8px;
        margin-bottom: 10px;
      }
      .labelRow {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
      }
      .labelRow label {
        font-size: 12px;
        color: var(--muted);
        font-weight: 650;
      }
      .helpText {
        color: var(--faint);
        font-size: 11px;
      }
      input[type="text"],
      textarea,
      select {
        width: 100%;
        border-radius: 14px;
        border: 1px solid var(--border);
        padding: 10px 10px;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        outline: none;
      }
      :root[data-theme="light"] input[type="text"],
      :root[data-theme="light"] textarea,
      :root[data-theme="light"] select {
        background: rgba(15, 23, 42, 0.03);
      }
      input[type="text"]:focus,
      textarea:focus,
      select:focus {
        border-color: rgba(124, 58, 237, 0.45);
        box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.16);
      }
      .row2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .swatches {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .swatchBtn {
        width: 26px;
        height: 26px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        cursor: pointer;
        position: relative;
      }
      .swatchBtn::before {
        content: "";
        position: absolute;
        inset: 5px;
        border-radius: 7px;
        background: var(--c, var(--accent));
      }
      .swatchBtn[aria-checked="true"] {
        border-color: color-mix(in srgb, var(--c, var(--accent)) 55%, var(--border));
        box-shadow: 0 0 0 4px color-mix(in srgb, var(--c, var(--accent)) 22%, transparent);
      }
      .emptyState {
        padding: 12px;
        border: 1px dashed var(--border);
        border-radius: 16px;
        color: var(--muted);
        background: rgba(255, 255, 255, 0.03);
      }
      .list {
        margin-top: 12px;
        border-top: 1px solid var(--border);
        padding-top: 12px;
      }
      .listItem {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 9px 10px;
        border-radius: 14px;
        border: 1px solid transparent;
        cursor: pointer;
        color: var(--muted);
      }
      .listItem:hover {
        border-color: var(--border);
        background: rgba(255, 255, 255, 0.03);
        color: var(--text);
      }
      .listItem .left {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
      }
      .listItem .mini {
        width: 10px;
        height: 10px;
        border-radius: 4px;
        background: var(--c, var(--accent));
      }
      .listItem .name {
        font-weight: 680;
        font-size: 12px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .listItem .tag {
        font-family: var(--mono);
        font-size: 11px;
        padding: 2px 7px;
        border: 1px solid var(--border);
        border-radius: 999px;
        color: var(--muted);
      }

      dialog {
        border: none;
        padding: 0;
        border-radius: 18px;
        width: min(720px, calc(100vw - 28px));
        background: var(--panel-2);
        color: var(--text);
        box-shadow: var(--shadow);
        backdrop-filter: blur(12px);
      }
      dialog::backdrop {
        background: rgba(0, 0, 0, 0.52);
        backdrop-filter: blur(4px);
      }
      .modalHeader {
        padding: 14px 14px 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .modalHeader .title {
        margin: 0;
        font-size: 13px;
        font-weight: 780;
        letter-spacing: 0.2px;
      }
      .modalBody {
        padding: 12px 14px 14px;
        display: grid;
        gap: 10px;
      }
      .modalFooter {
        padding: 12px 14px 14px;
        border-top: 1px solid var(--border);
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }
      .tip {
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.03);
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }
      .mono {
        font-family: var(--mono);
      }

      .toast {
        position: fixed;
        left: 50%;
        bottom: 16px;
        translate: -50% 0;
        background: var(--panel-2);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 10px 12px;
        box-shadow: var(--shadow-soft);
        color: var(--text);
        display: flex;
        gap: 10px;
        align-items: center;
        max-width: min(820px, calc(100vw - 24px));
        pointer-events: none;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 160ms ease, transform 160ms ease;
      }
      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }
      .toast .msg {
        font-size: 12px;
        color: var(--muted);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .toast .chip {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 2px 8px;
        background: rgba(255, 255, 255, 0.04);
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          animation: none !important;
          transition: none !important;
          scroll-behavior: auto !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="topbar">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1>Customer Journey Flow</h1>
            <div class="sub">Diagram your stages from awareness to purchase — editable nodes, drag-to-connect</div>
          </div>
        </div>

        <div class="toolbar" role="toolbar" aria-label="Actions">
          <button class="btn primary" id="btnAdd" title="Add a new stage (A)">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
              </svg>
            </span>
            Add stage
          </button>
          <button class="btn" id="btnAuto" title="Auto arrange stages">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M7 7h10M7 12h6M7 17h10"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
            </span>
            Auto layout
          </button>
          <button class="btn" id="btnFit" title="Fit diagram to view (F)">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M4 9V6a2 2 0 0 1 2-2h3M20 9V6a2 2 0 0 0-2-2h-3M4 15v3a2 2 0 0 0 2 2h3M20 15v3a2 2 0 0 1-2 2h-3"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
            </span>
            Fit
          </button>
          <div class="spacer" aria-hidden="true"></div>
          <button class="btn ghost" id="btnUndo" title="Undo (Ctrl/⌘ Z)">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M9 14l-4-4 4-4"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M20 20a8 8 0 0 0-8-8H5"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
            </span>
            Undo
          </button>
          <button class="btn ghost" id="btnRedo" title="Redo (Ctrl/⌘ Shift Z)">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M15 14l4-4-4-4"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M4 20a8 8 0 0 1 8-8h7"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
            </span>
            Redo
          </button>
          <div class="spacer" aria-hidden="true"></div>
          <button class="btn" id="btnExport" title="Export diagram JSON">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M12 3v10m0 0 4-4m-4 4-4-4"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M5 14v5a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-5"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
            </span>
            Export
          </button>
          <button class="btn" id="btnImport" title="Import diagram JSON">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M12 21V11m0 0 4 4m-4-4-4 4"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M5 10V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v5"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
            </span>
            Import
          </button>
          <button class="btn" id="btnTheme" title="Toggle theme">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M21 12.6A8.6 8.6 0 1 1 11.4 3a7 7 0 0 0 9.6 9.6Z"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linejoin="round"
                />
              </svg>
            </span>
            Theme
          </button>
          <button class="btn ghost" id="btnHelp" title="Help / shortcuts (?)">
            <span class="ic" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M12 17h.01"
                  stroke="currentColor"
                  stroke-width="3"
                  stroke-linecap="round"
                />
                <path
                  d="M9.5 9.5a2.7 2.7 0 1 1 3.7 2.5c-.9.4-1.2 1-1.2 2"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                  stroke="currentColor"
                  stroke-width="2"
                />
              </svg>
            </span>
            Help
          </button>
        </div>
      </header>

      <main class="main">
        <section class="canvasWrap" aria-label="Diagram canvas">
          <div class="canvas" id="canvas">
            <div class="world" id="world">
              <svg class="edges" id="edgesSvg" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <marker
                    id="arrow"
                    viewBox="0 0 10 10"
                    refX="9.5"
                    refY="5"
                    markerWidth="8"
                    markerHeight="8"
                    orient="auto-start-reverse"
                  >
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(226,232,240,0.75)"></path>
                  </marker>
                  <marker
                    id="arrowSelected"
                    viewBox="0 0 10 10"
                    refX="9.5"
                    refY="5"
                    markerWidth="8"
                    markerHeight="8"
                    orient="auto-start-reverse"
                  >
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(124,58,237,0.95)"></path>
                  </marker>
                </defs>
                <g id="edgesLayer"></g>
                <g id="tempLayer"></g>
              </svg>
              <div id="nodesLayer"></div>
            </div>
          </div>

          <div class="hud" aria-live="polite">
            <span class="badge"><span class="dot" aria-hidden="true"></span>Drag nodes, connect with dots</span>
            <span class="badge"><kbd>Space</kbd> pan</span>
            <span class="badge"><kbd>Ctrl</kbd> + <kbd>Wheel</kbd> zoom</span>
            <span class="badge"><kbd>Del</kbd> delete</span>
          </div>
          <div class="status" id="status">
            <span class="pill" id="statusScale">100%</span>
            <span class="pill" id="statusCounts">0 stages • 0 links</span>
          </div>
        </section>

        <aside class="sidebar" aria-label="Properties">
          <div class="sideHeader">
            <div>
              <h2>Properties</h2>
              <div class="meta" id="sideMeta">Select a stage or connection</div>
            </div>
            <button class="iconBtn" id="btnDelete" title="Delete selection (Del)" aria-label="Delete selection">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M9 3h6m-8 4h10m-9 0 1 14h6l1-14"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
          </div>
          <div class="sideBody" id="sideBody">
            <div class="emptyState">
              Tip: Double-click a stage title to rename it. Drag from a stage’s right dot to another stage’s left dot
              to create a connection.
            </div>

            <div class="list" aria-label="Stages list">
              <div class="labelRow" style="margin-bottom: 8px">
                <label>Stages</label>
                <span class="helpText mono" id="stageCount">0</span>
              </div>
              <div id="stageList"></div>
            </div>
          </div>
        </aside>
      </main>
    </div>

    <dialog id="dlgAdd">
      <div class="modalHeader">
        <div class="title">Add stage</div>
        <button class="iconBtn" data-close title="Close" aria-label="Close">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path
              d="M18 6 6 18M6 6l12 12"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
            />
          </svg>
        </button>
      </div>
      <div class="modalBody">
        <div class="row2">
          <div class="formRow">
            <div class="labelRow">
              <label for="addTitle">Title</label>
              <span class="helpText">Required</span>
            </div>
            <input id="addTitle" type="text" placeholder="e.g., Awareness" />
          </div>
          <div class="formRow">
            <div class="labelRow">
              <label for="addTemplate">Quick templates</label>
              <span class="helpText">Optional</span>
            </div>
            <select id="addTemplate">
              <option value="">Custom…</option>
              <option value="Awareness|Customer discovers you via ads, social, or search.">Awareness</option>
              <option value="Consideration|They compare options, read reviews, and evaluate fit.">Consideration</option>
              <option value="Intent|They shortlist and look for proof, pricing, or demos.">Intent</option>
              <option value="Purchase|Checkout, signup, or contract — remove friction.">Purchase</option>
              <option value="Onboarding|Help them get value fast with guidance and milestones.">Onboarding</option>
              <option value="Retention|Keep delivering value; nudge healthy usage habits.">Retention</option>
              <option value="Advocacy|They recommend you, leave reviews, or share results.">Advocacy</option>
            </select>
          </div>
        </div>
        <div class="formRow">
          <div class="labelRow">
            <label for="addDesc">Notes</label>
            <span class="helpText">Shown on the stage card</span>
          </div>
          <textarea id="addDesc" rows="4" placeholder="Describe the customer action, goal, and key touchpoints."></textarea>
        </div>
        <div class="formRow">
          <div class="labelRow">
            <label>Accent color</label>
            <span class="helpText">Helps segment phases</span>
          </div>
          <div class="swatches" id="addSwatches"></div>
        </div>
        <div class="tip">
          You can always reposition the stage after adding. New stages appear near the center of the view.
        </div>
      </div>
      <div class="modalFooter">
        <button class="btn ghost" data-close>Cancel</button>
        <button class="btn primary" id="btnAddConfirm">Add</button>
      </div>
    </dialog>

    <dialog id="dlgIO">
      <div class="modalHeader">
        <div class="title" id="ioTitle">Export</div>
        <button class="iconBtn" data-close title="Close" aria-label="Close">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path
              d="M18 6 6 18M6 6l12 12"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
            />
          </svg>
        </button>
      </div>
      <div class="modalBody">
        <div class="formRow">
          <div class="labelRow">
            <label for="ioArea">Diagram JSON</label>
            <span class="helpText mono" id="ioMeta"></span>
          </div>
          <textarea id="ioArea" rows="12" class="mono" spellcheck="false"></textarea>
        </div>
        <div class="tip" id="ioTip">
          Export lets you save and share your diagram. Import replaces the current diagram.
        </div>
      </div>
      <div class="modalFooter" id="ioFooter"></div>
    </dialog>

    <dialog id="dlgHelp">
      <div class="modalHeader">
        <div class="title">Help & shortcuts</div>
        <button class="iconBtn" data-close title="Close" aria-label="Close">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path
              d="M18 6 6 18M6 6l12 12"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
            />
          </svg>
        </button>
      </div>
      <div class="modalBody">
        <div class="tip">
          <div style="font-weight: 750; margin-bottom: 6px">Connecting stages</div>
          Drag from a stage’s <span class="mono">right</span> dot to another stage’s <span class="mono">left</span> dot.
          Click a connection to select it.
        </div>
        <div class="tip">
          <div style="font-weight: 750; margin-bottom: 6px">Navigation</div>
          Hold <span class="mono">Space</span> and drag to pan. Use <span class="mono">Ctrl</span>/<span class="mono">⌘</span> +
          mouse wheel to zoom. Use <span class="mono">Fit</span> to frame your diagram.
        </div>
        <div class="tip">
          <div style="font-weight: 750; margin-bottom: 6px">Shortcuts</div>
          <div class="mono" style="line-height: 1.55">
            A — add stage<br />
            F — fit diagram<br />
            Del — delete selected stage/connection<br />
            Ctrl/⌘ Z — undo<br />
            Ctrl/⌘ Shift Z — redo
          </div>
        </div>
      </div>
      <div class="modalFooter">
        <button class="btn primary" data-close>Got it</button>
      </div>
    </dialog>

    <div class="toast" id="toast" role="status" aria-live="polite">
      <span class="chip" id="toastChip">Tip</span>
      <div class="msg" id="toastMsg"></div>
    </div>

    <script>
      (() => {
        "use strict";

        const STORAGE_KEY = "customerJourneyFlow.v1";
        const THEME_KEY = "customerJourneyFlow.theme";
        const $$ = (sel, root = document) => root.querySelector(sel);
        const $$$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
        const round = (n, p = 2) => Math.round(n * 10 ** p) / 10 ** p;
        const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

        const COLORS = [
          "#7c3aed",
          "#3b82f6",
          "#06b6d4",
          "#22c55e",
          "#84cc16",
          "#f59e0b",
          "#f97316",
          "#ef4444",
          "#ec4899",
          "#a855f7",
        ];

        const el = {
          canvas: $("#canvas"),
          world: $("#world"),
          nodesLayer: $("#nodesLayer"),
          edgesSvg: $("#edgesSvg"),
          edgesLayer: $("#edgesLayer"),
          tempLayer: $("#tempLayer"),
          statusScale: $("#statusScale"),
          statusCounts: $("#statusCounts"),
          sideMeta: $("#sideMeta"),
          sideBody: $("#sideBody"),
          stageList: $("#stageList"),
          stageCount: $("#stageCount"),
          btnAdd: $("#btnAdd"),
          btnAuto: $("#btnAuto"),
          btnFit: $("#btnFit"),
          btnUndo: $("#btnUndo"),
          btnRedo: $("#btnRedo"),
          btnExport: $("#btnExport"),
          btnImport: $("#btnImport"),
          btnHelp: $("#btnHelp"),
          btnTheme: $("#btnTheme"),
          btnDelete: $("#btnDelete"),
          dlgAdd: $("#dlgAdd"),
          dlgIO: $("#dlgIO"),
          dlgHelp: $("#dlgHelp"),
          addTitle: $("#addTitle"),
          addDesc: $("#addDesc"),
          addTemplate: $("#addTemplate"),
          addSwatches: $("#addSwatches"),
          btnAddConfirm: $("#btnAddConfirm"),
          ioTitle: $("#ioTitle"),
          ioArea: $("#ioArea"),
          ioMeta: $("#ioMeta"),
          ioTip: $("#ioTip"),
          ioFooter: $("#ioFooter"),
          toast: $("#toast"),
          toastMsg: $("#toastMsg"),
          toastChip: $("#toastChip"),
        };

        const state = {
          nodes: [],
          edges: [],
          selection: { type: null, id: null },
          viewport: { x: 120, y: 120, scale: 1 },
          interaction: null,
          history: { undo: [], redo: [] },
          ui: { addColor: COLORS[0] },
          dirty: false,
        };

        const byId = (arr, id) => arr.find((x) => x.id === id) || null;

        function uid(prefix) {
          const r = Math.random().toString(16).slice(2);
          return `${prefix}_${Date.now().toString(16)}_${r}`;
        }

        function showToast(message, chip = "Tip", ms = 1800) {
          el.toastChip.textContent = chip;
          el.toastMsg.textContent = message;
          el.toast.classList.add("show");
          clearTimeout(showToast._t);
          showToast._t = setTimeout(() => el.toast.classList.remove("show"), ms);
        }

        function safeParseJSON(text) {
          try {
            return { ok: true, value: JSON.parse(text) };
          } catch (err) {
            return { ok: false, error: String(err && err.message ? err.message : err) };
          }
        }

        function canvasRect() {
          return el.canvas.getBoundingClientRect();
        }

        function clientToWorld(clientX, clientY) {
          const r = canvasRect();
          const x = (clientX - r.left - state.viewport.x) / state.viewport.scale;
          const y = (clientY - r.top - state.viewport.y) / state.viewport.scale;
          return { x, y };
        }

        function worldToClient(x, y) {
          const r = canvasRect();
          return {
            x: r.left + state.viewport.x + x * state.viewport.scale,
            y: r.top + state.viewport.y + y * state.viewport.scale,
          };
        }

        function getNodeBounds(node) {
          return {
            x: node.x,
            y: node.y,
            w: node.w,
            h: node.h,
            x2: node.x + node.w,
            y2: node.y + node.h,
          };
        }

        function setTheme(theme) {
          document.documentElement.dataset.theme = theme;
          localStorage.setItem(THEME_KEY, theme);
          // update arrow colors to match theme better
          const arrow = el.edgesSvg.querySelector("#arrow path");
          const isLight = theme === "light";
          arrow.setAttribute("fill", isLight ? "rgba(15,23,42,0.55)" : "rgba(226,232,240,0.75)");
        }

        function toggleTheme() {
          const cur = document.documentElement.dataset.theme || "dark";
          setTheme(cur === "dark" ? "light" : "dark");
          showToast(`Theme: ${document.documentElement.dataset.theme}`, "Theme");
        }

        function openDialog(dlg) {
          if (typeof dlg.showModal === "function") dlg.showModal();
          else dlg.setAttribute("open", "open");
          const closeBtns = $$$("[data-close]", dlg);
          for (const b of closeBtns) {
            b.onclick = () => closeDialog(dlg);
          }
        }
        function closeDialog(dlg) {
          if (typeof dlg.close === "function") dlg.close();
          else dlg.removeAttribute("open");
        }

        function pushHistory(label = "Change") {
          state.history.undo.push({
            label,
            snapshot: deepClone({ nodes: state.nodes, edges: state.edges, viewport: state.viewport }),
          });
          state.history.redo = [];
          updateUndoRedoUI();
          state.dirty = true;
        }

        function canUndo() {
          return state.history.undo.length > 0;
        }
        function canRedo() {
          return state.history.redo.length > 0;
        }

        function applySnapshot(snap) {
          state.nodes = deepClone(snap.nodes);
          state.edges = deepClone(snap.edges);
          state.viewport = deepClone(snap.viewport);
          state.selection = { type: null, id: null };
          ensureIntegrity();
          scheduleRender();
        }

        function undo() {
          if (!canUndo()) return;
          const cur = deepClone({ nodes: state.nodes, edges: state.edges, viewport: state.viewport });
          const item = state.history.undo.pop();
          state.history.redo.push({ label: item.label, snapshot: cur });
          applySnapshot(item.snapshot);
          updateUndoRedoUI();
          showToast(`Undo: ${item.label}`, "Undo");
        }

        function redo() {
          if (!canRedo()) return;
          const cur = deepClone({ nodes: state.nodes, edges: state.edges, viewport: state.viewport });
          const item = state.history.redo.pop();
          state.history.undo.push({ label: item.label, snapshot: cur });
          applySnapshot(item.snapshot);
          updateUndoRedoUI();
          showToast(`Redo: ${item.label}`, "Redo");
        }

        function updateUndoRedoUI() {
          el.btnUndo.disabled = !canUndo();
          el.btnRedo.disabled = !canRedo();
        }

        function ensureIntegrity() {
          const ids = new Set(state.nodes.map((n) => n.id));
          state.edges = state.edges.filter((e) => ids.has(e.from) && ids.has(e.to) && e.from !== e.to);
          // Deduplicate edges
          const seen = new Set();
          state.edges = state.edges.filter((e) => {
            const key = `${e.from}->${e.to}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          });
        }

        function persist() {
          const payload = {
            v: 1,
            savedAt: new Date().toISOString(),
            nodes: state.nodes,
            edges: state.edges,
            viewport: state.viewport,
          };
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
            state.dirty = false;
          } catch {
            // ignore quota
          }
        }

        function load() {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return false;
          const parsed = safeParseJSON(raw);
          if (!parsed.ok) return false;
          const data = parsed.value || {};
          if (!data || data.v !== 1 || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) return false;
          state.nodes = data.nodes;
          state.edges = data.edges;
          if (data.viewport && typeof data.viewport === "object") state.viewport = data.viewport;
          ensureIntegrity();
          state.history = { undo: [], redo: [] };
          updateUndoRedoUI();
          return true;
        }

        function seed() {
          const stages = [
            {
              title: "Awareness",
              desc: "Customer discovers you via ads, social, or search.\nGoal: capture attention with a clear promise.",
              color: "#3b82f6",
            },
            {
              title: "Consideration",
              desc: "They compare options, read reviews, and evaluate fit.\nGoal: answer objections and show differentiation.",
              color: "#7c3aed",
            },
            {
              title: "Intent",
              desc: "They shortlist and look for proof, pricing, or demos.\nGoal: make the next step obvious and low risk.",
              color: "#06b6d4",
            },
            {
              title: "Purchase",
              desc: "Checkout, signup, or contract.\nGoal: remove friction and reassure.",
              color: "#22c55e",
            },
            {
              title: "Onboarding",
              desc: "Help them get value fast with guidance and milestones.\nGoal: first success within minutes/days.",
              color: "#f59e0b",
            },
          ];

          const startX = 120;
          const startY = 180;
          const gapX = 300;
          state.nodes = stages.map((s, i) => ({
            id: uid("n"),
            x: startX + i * gapX,
            y: startY + (i % 2 === 1 ? 34 : 0),
            w: 240,
            h: 150,
            title: s.title,
            desc: s.desc,
            color: s.color,
          }));
          state.edges = [
            { id: uid("e"), from: state.nodes[0].id, to: state.nodes[1].id },
            { id: uid("e"), from: state.nodes[1].id, to: state.nodes[2].id },
            { id: uid("e"), from: state.nodes[2].id, to: state.nodes[3].id },
            { id: uid("e"), from: state.nodes[3].id, to: state.nodes[4].id },
          ];
          state.viewport = { x: 80, y: 90, scale: 1 };
        }

        // Rendering
        let raf = 0;
        function scheduleRender() {
          if (raf) return;
          raf = requestAnimationFrame(() => {
            raf = 0;
            render();
          });
        }

        function render() {
          const { x, y, scale } = state.viewport;
          el.world.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
          el.statusScale.textContent = `${Math.round(scale * 100)}%`;
          el.statusCounts.textContent = `${state.nodes.length} stages • ${state.edges.length} links`;
          el.stageCount.textContent = String(state.nodes.length);
          renderNodes();
          renderEdges();
          renderSidebar();
          if (state.dirty) schedulePersistSoon();
        }

        const nodeEls = new Map();
        function renderNodes() {
          const ids = new Set(state.nodes.map((n) => n.id));
          for (const [id, nodeEl] of nodeEls.entries()) {
            if (!ids.has(id)) {
              nodeEl.remove();
              nodeEls.delete(id);
            }
          }
          for (const node of state.nodes) {
            let nodeEl = nodeEls.get(node.id);
            if (!nodeEl) {
              nodeEl = createNodeElement(node);
              nodeEls.set(node.id, nodeEl);
              el.nodesLayer.appendChild(nodeEl);
            }
            nodeEl.style.left = `${node.x}px`;
            nodeEl.style.top = `${node.y}px`;
            nodeEl.style.width = `${node.w}px`;
            nodeEl.style.minHeight = `${node.h}px`;
            nodeEl.dataset.color = node.color;
            nodeEl.classList.toggle("selected", state.selection.type === "node" && state.selection.id === node.id);
            const swatch = nodeEl.querySelector(".swatch");
            swatch.style.background = node.color;
            swatch.style.boxShadow = `0 0 0 5px color-mix(in srgb, ${node.color} 18%, transparent)`;

            const titleEl = nodeEl.querySelector("[data-field='title']");
            if (document.activeElement !== titleEl && titleEl.textContent !== node.title) titleEl.textContent = node.title;
            const descEl = nodeEl.querySelector("textarea");
            if (document.activeElement !== descEl && descEl.value !== node.desc) descEl.value = node.desc;
          }
        }

        const edgeEls = new Map();
        function renderEdges() {
          const theme = document.documentElement.dataset.theme || "dark";
          const baseStroke = theme === "light" ? "rgba(15,23,42,0.42)" : "rgba(226,232,240,0.55)";
          const ids = new Set(state.edges.map((e) => e.id));
          for (const [id, edgeEl] of edgeEls.entries()) {
            if (!ids.has(id)) {
              edgeEl.remove();
              edgeEls.delete(id);
            }
          }
          for (const edge of state.edges) {
            let path = edgeEls.get(edge.id);
            if (!path) {
              path = document.createElementNS("http://www.w3.org/2000/svg", "path");
              path.classList.add("edge");
              path.dataset.id = edge.id;
              path.setAttribute("fill", "none");
              path.setAttribute("stroke-width", "2.2");
              path.setAttribute("stroke-linecap", "round");
              path.setAttribute("stroke", baseStroke);
              path.setAttribute("marker-end", "url(#arrow)");
              path.style.pointerEvents = "stroke";
              path.addEventListener("pointerdown", (ev) => {
                ev.stopPropagation();
                select({ type: "edge", id: edge.id });
              });
              el.edgesLayer.appendChild(path);
              edgeEls.set(edge.id, path);
            }
            const a = byId(state.nodes, edge.from);
            const b = byId(state.nodes, edge.to);
            if (!a || !b) continue;
            const d = edgePath(a, b);
            path.setAttribute("d", d);
            const selected = state.selection.type === "edge" && state.selection.id === edge.id;
            if (selected) {
              path.setAttribute("stroke", "rgba(124,58,237,0.95)");
              path.setAttribute("stroke-width", "3.2");
              path.setAttribute("marker-end", "url(#arrowSelected)");
            } else {
              path.setAttribute("stroke", baseStroke);
              path.setAttribute("stroke-width", "2.2");
              path.setAttribute("marker-end", "url(#arrow)");
            }
          }
          // temp connection
          el.tempLayer.replaceChildren();
          if (state.interaction && state.interaction.type === "connect") {
            const { fromId, toWorld } = state.interaction;
            const fromNode = byId(state.nodes, fromId);
            if (fromNode && toWorld) {
              const temp = document.createElementNS("http://www.w3.org/2000/svg", "path");
              temp.setAttribute("fill", "none");
              temp.setAttribute("stroke-width", "2.4");
              temp.setAttribute("stroke-linecap", "round");
              temp.setAttribute("stroke", "rgba(34,197,94,0.9)");
              temp.setAttribute("stroke-dasharray", "5 5");
              temp.setAttribute("marker-end", "url(#arrowSelected)");
              temp.setAttribute("d", edgePathFromPoint(fromNode, toWorld.x, toWorld.y));
              el.tempLayer.appendChild(temp);
            }
          }
        }

        function edgePath(fromNode, toNode) {
          const from = portOut(fromNode);
          const to = portIn(toNode);
          const dx = Math.max(80, Math.abs(to.x - from.x) * 0.5);
          const c1x = from.x + dx;
          const c2x = to.x - dx;
          return `M ${from.x} ${from.y} C ${c1x} ${from.y}, ${c2x} ${to.y}, ${to.x} ${to.y}`;
        }

        function edgePathFromPoint(fromNode, toX, toY) {
          const from = portOut(fromNode);
          const dx = Math.max(80, Math.abs(toX - from.x) * 0.5);
          const c1x = from.x + dx;
          const c2x = toX - dx;
          return `M ${from.x} ${from.y} C ${c1x} ${from.y}, ${c2x} ${toY}, ${toX} ${toY}`;
        }

        function portOut(node) {
          return { x: node.x + node.w, y: node.y + node.h / 2 };
        }
        function portIn(node) {
          return { x: node.x, y: node.y + node.h / 2 };
        }

        function renderSidebar() {
          // Stage list
          el.stageList.replaceChildren();
          for (const node of state.nodes) {
            const item = document.createElement("div");
            item.className = "listItem";
            item.tabIndex = 0;
            item.setAttribute("role", "button");
            item.title = "Select stage";
            item.innerHTML = `
              <div class="left">
                <div class="mini" style="--c:${escapeAttr(node.color)}"></div>
                <div class="name"></div>
              </div>
              <div class="tag">#${escapeHtml(node.id.slice(-4))}</div>
            `;
            item.querySelector(".name").textContent = node.title || "(Untitled)";
            item.addEventListener("click", () => {
              select({ type: "node", id: node.id });
              centerOnNode(node.id, { animate: true });
            });
            item.addEventListener("keydown", (ev) => {
              if (ev.key === "Enter" || ev.key === " ") {
                ev.preventDefault();
                item.click();
              }
            });
            el.stageList.appendChild(item);
          }

          const s = state.selection;
          if (!s.type) {
            el.sideMeta.textContent = "Select a stage or connection";
            el.btnDelete.disabled = true;
            return;
          }
          el.btnDelete.disabled = false;

          if (s.type === "node") {
            const node = byId(state.nodes, s.id);
            if (!node) return;
            el.sideMeta.textContent = `Stage • ${node.title || "Untitled"}`;
            el.sideBody.replaceChildren();
            const wrap = document.createElement("div");
            wrap.innerHTML = `
              <div class="formRow">
                <div class="labelRow">
                  <label for="pTitle">Title</label>
                  <span class="helpText">Stage name</span>
                </div>
                <input id="pTitle" type="text" />
              </div>
              <div class="formRow">
                <div class="labelRow">
                  <label for="pDesc">Notes</label>
                  <span class="helpText">Customer action, goal, touchpoints</span>
                </div>
                <textarea id="pDesc" rows="6"></textarea>
              </div>
              <div class="row2">
                <div class="formRow">
                  <div class="labelRow">
                    <label for="pW">Width</label>
                    <span class="helpText mono">px</span>
                  </div>
                  <input id="pW" type="text" inputmode="numeric" />
                </div>
                <div class="formRow">
                  <div class="labelRow">
                    <label for="pH">Min height</label>
                    <span class="helpText mono">px</span>
                  </div>
                  <input id="pH" type="text" inputmode="numeric" />
                </div>
              </div>
              <div class="formRow">
                <div class="labelRow">
                  <label>Accent color</label>
                  <span class="helpText">Matches header swatch</span>
                </div>
                <div class="swatches" id="pSwatches"></div>
              </div>
              <div class="row2">
                <button class="btn" id="pCenter" title="Center view on this stage">Center</button>
                <button class="btn" id="pDuplicate" title="Duplicate this stage">Duplicate</button>
              </div>
              <div class="tip">
                <div style="font-weight:750;margin-bottom:6px">Tip</div>
                You can also rename inline: double-click the title on the card.
              </div>
              <div class="list" style="margin-top:14px">
                <div class="labelRow" style="margin-bottom:8px">
                  <label>Connections</label>
                  <span class="helpText mono" id="pLinks"></span>
                </div>
                <div id="pLinksList"></div>
              </div>
            `;
            el.sideBody.appendChild(wrap);

            const pTitle = $("#pTitle", wrap);
            const pDesc = $("#pDesc", wrap);
            const pW = $("#pW", wrap);
            const pH = $("#pH", wrap);
            pTitle.value = node.title;
            pDesc.value = node.desc;
            pW.value = String(node.w);
            pH.value = String(node.h);

            const updateNode = (patch, label) => {
              pushHistory(label);
              Object.assign(node, patch);
              scheduleRender();
            };

            let t1 = 0;
            pTitle.addEventListener("input", () => {
              clearTimeout(t1);
              t1 = setTimeout(() => updateNode({ title: pTitle.value }, "Edit title"), 220);
            });
            let t2 = 0;
            pDesc.addEventListener("input", () => {
              clearTimeout(t2);
              t2 = setTimeout(() => updateNode({ desc: pDesc.value }, "Edit notes"), 260);
            });
            const parsePx = (v, fallback) => {
              const n = Number(String(v).trim());
              if (!Number.isFinite(n)) return fallback;
              return Math.round(clamp(n, 160, 560));
            };
            let t3 = 0;
            pW.addEventListener("input", () => {
              clearTimeout(t3);
              t3 = setTimeout(() => updateNode({ w: parsePx(pW.value, node.w) }, "Resize stage"), 260);
            });
            let t4 = 0;
            pH.addEventListener("input", () => {
              clearTimeout(t4);
              t4 = setTimeout(() => updateNode({ h: parsePx(pH.value, node.h) }, "Resize stage"), 260);
            });

            const sw = $("#pSwatches", wrap);
            sw.replaceChildren();
            for (const c of COLORS) {
              const b = document.createElement("button");
              b.className = "swatchBtn";
              b.style.setProperty("--c", c);
              b.setAttribute("aria-label", `Set color ${c}`);
              b.setAttribute("aria-checked", c === node.color ? "true" : "false");
              b.addEventListener("click", () => updateNode({ color: c }, "Change color"));
              sw.appendChild(b);
            }
            $("#pCenter", wrap).addEventListener("click", () => centerOnNode(node.id, { animate: true }));
            $("#pDuplicate", wrap).addEventListener("click", () => duplicateNode(node.id));

            const links = state.edges.filter((e) => e.from === node.id || e.to === node.id);
            $("#pLinks", wrap).textContent = `${links.length}`;
            const list = $("#pLinksList", wrap);
            list.replaceChildren();
            if (links.length === 0) {
              const empty = document.createElement("div");
              empty.className = "emptyState";
              empty.textContent = "No connections yet. Drag from the right dot to connect.";
              list.appendChild(empty);
            } else {
              for (const e of links) {
                const otherId = e.from === node.id ? e.to : e.from;
                const other = byId(state.nodes, otherId);
                const row = document.createElement("div");
                row.className = "listItem";
                row.title = "Select connection";
                row.innerHTML = `
                  <div class="left">
                    <div class="mini" style="--c:${escapeAttr(other?.color || "#94a3b8")}"></div>
                    <div class="name"></div>
                  </div>
                  <div class="tag">${e.from === node.id ? "out" : "in"}</div>
                `;
                row.querySelector(".name").textContent = other ? other.title : "Missing stage";
                row.addEventListener("click", () => select({ type: "edge", id: e.id }));
                list.appendChild(row);
              }
            }
            return;
          }

          if (s.type === "edge") {
            const edge = byId(state.edges, s.id);
            if (!edge) return;
            const from = byId(state.nodes, edge.from);
            const to = byId(state.nodes, edge.to);
            el.sideMeta.textContent = "Connection";
            el.sideBody.replaceChildren();
            const wrap = document.createElement("div");
            wrap.innerHTML = `
              <div class="tip">
                <div style="font-weight:750;margin-bottom:6px">From → To</div>
                <div style="display:grid;gap:6px">
                  <div><span class="mono">From</span>: <span id="fromName"></span></div>
                  <div><span class="mono">To</span>: <span id="toName"></span></div>
                </div>
              </div>
              <div class="formRow">
                <div class="labelRow">
                  <label for="eReroute">Reroute</label>
                  <span class="helpText">Choose a new target</span>
                </div>
                <select id="eReroute"></select>
              </div>
              <div class="row2">
                <button class="btn" id="eFocusFrom">Center “From”</button>
                <button class="btn" id="eFocusTo">Center “To”</button>
              </div>
              <div class="tip">
                Tip: Press <span class="mono">Del</span> to remove this connection.
              </div>
            `;
            el.sideBody.appendChild(wrap);
            $("#fromName", wrap).textContent = from ? from.title : "(Missing)";
            $("#toName", wrap).textContent = to ? to.title : "(Missing)";
            const sel = $("#eReroute", wrap);
            sel.appendChild(new Option("(Select new target…)", ""));
            for (const n of state.nodes) {
              if (n.id === edge.from) continue;
              const o = new Option(n.title || "Untitled", n.id);
              if (n.id === edge.to) o.text = `${o.text} (current)`;
              sel.appendChild(o);
            }
            sel.addEventListener("change", () => {
              const newTo = sel.value;
              if (!newTo) return;
              if (newTo === edge.from) return;
              pushHistory("Reroute connection");
              edge.to = newTo;
              ensureIntegrity();
              scheduleRender();
              showToast("Connection rerouted", "Link");
            });
            $("#eFocusFrom", wrap).addEventListener("click", () => centerOnNode(edge.from, { animate: true }));
            $("#eFocusTo", wrap).addEventListener("click", () => centerOnNode(edge.to, { animate: true }));
          }
        }

        function escapeHtml(s) {
          return String(s).replace(/[&<>"']/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c]));
        }
        function escapeAttr(s) {
          return escapeHtml(s).replace(/`/g, "&#96;");
        }

        function createNodeElement(node) {
          const nodeEl = document.createElement("div");
          nodeEl.className = "node";
          nodeEl.dataset.id = node.id;
          nodeEl.innerHTML = `
            <div class="port in" data-port="in" title="Input"></div>
            <div class="port out" data-port="out" title="Drag to connect"></div>
            <div class="nodeHeader">
              <div class="nodeTitle">
                <div class="swatch" aria-hidden="true"></div>
                <div data-field="title" contenteditable="true" spellcheck="false"></div>
              </div>
              <div class="nodeActions">
                <button class="iconBtn" data-action="center" title="Center on stage" aria-label="Center">
                  <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M12 7v10M7 12h10"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                    />
                    <path
                      d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                      stroke="currentColor"
                      stroke-width="2"
                    />
                  </svg>
                </button>
                <button class="iconBtn" data-action="duplicate" title="Duplicate stage" aria-label="Duplicate">
                  <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M9 9h10v10H9z"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linejoin="round"
                    />
                    <path
                      d="M5 15H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v1"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                    />
                  </svg>
                </button>
              </div>
            </div>
            <div class="nodeBody">
              <textarea placeholder="Notes… (touchpoints, channel, friction, KPI)"></textarea>
            </div>
          `;

          const titleEl = nodeEl.querySelector("[data-field='title']");
          titleEl.textContent = node.title;
          titleEl.addEventListener("focus", () => select({ type: "node", id: node.id }));
          titleEl.addEventListener("blur", () => {
            const next = titleEl.textContent.trim() || "Untitled";
            if (next !== node.title) {
              pushHistory("Edit title");
              node.title = next;
              scheduleRender();
            }
          });
          titleEl.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault();
              titleEl.blur();
            }
            if ((ev.metaKey || ev.ctrlKey) && ev.key.toLowerCase() === "a") {
              // allow text selection inside
              ev.stopPropagation();
            }
          });

          const descEl = nodeEl.querySelector("textarea");
          descEl.value = node.desc || "";
          let descTimer = 0;
          descEl.addEventListener("input", () => {
            clearTimeout(descTimer);
            descTimer = setTimeout(() => {
              if (descEl.value !== node.desc) {
                pushHistory("Edit notes");
                node.desc = descEl.value;
                scheduleRender();
              }
            }, 300);
          });
          descEl.addEventListener("focus", () => select({ type: "node", id: node.id }));

          nodeEl.addEventListener("pointerdown", (ev) => {
            const portEl = ev.target.closest?.(".port");
            if (portEl) return; // handled below
            const header = ev.target.closest?.(".nodeHeader");
            if (!header) return;
            if (ev.button !== 0) return;
            if (isEditableTarget(ev.target)) return;
            if (document.activeElement && (document.activeElement === titleEl || document.activeElement === descEl)) return;
            ev.stopPropagation();
            select({ type: "node", id: node.id });
            const start = clientToWorld(ev.clientX, ev.clientY);
            state.interaction = {
              type: "dragNode",
              id: node.id,
              startWorld: start,
              startNode: { x: node.x, y: node.y },
              pointerId: ev.pointerId,
            };
            nodeEl.setPointerCapture(ev.pointerId);
          });

          nodeEl.addEventListener("pointermove", (ev) => {
            if (!state.interaction) return;
            if (state.interaction.pointerId !== ev.pointerId) return;
            if (state.interaction.type === "dragNode" && state.interaction.id === node.id) {
              const cur = clientToWorld(ev.clientX, ev.clientY);
              const dx = cur.x - state.interaction.startWorld.x;
              const dy = cur.y - state.interaction.startWorld.y;
              node.x = Math.round(state.interaction.startNode.x + dx);
              node.y = Math.round(state.interaction.startNode.y + dy);
              scheduleRender();
              return;
            }
            if (state.interaction.type === "connect") {
              state.interaction.toWorld = clientToWorld(ev.clientX, ev.clientY);
              scheduleConnectHover(ev.clientX, ev.clientY);
              scheduleRender();
            }
          });

          nodeEl.addEventListener("pointerup", (ev) => {
            if (!state.interaction) return;
            if (state.interaction.pointerId !== ev.pointerId) return;
            if (state.interaction.type === "dragNode" && state.interaction.id === node.id) {
              nodeEl.releasePointerCapture(ev.pointerId);
              const moved =
                Math.abs(node.x - state.interaction.startNode.x) + Math.abs(node.y - state.interaction.startNode.y) > 0;
              if (moved) pushHistory("Move stage");
              state.interaction = null;
              scheduleRender();
              return;
            }
            if (state.interaction.type === "connect" && state.interaction.fromId === node.id) {
              nodeEl.releasePointerCapture(ev.pointerId);
              const targetNodeId = nodeIdFromPoint(ev.clientX, ev.clientY, { expectPort: "in" });
              const fromId = state.interaction.fromId;
              clearConnectTargets();
              state.interaction = null;
              if (targetNodeId && targetNodeId !== fromId) {
                addEdge(fromId, targetNodeId);
              } else {
                showToast("Drop on another stage’s left dot to connect.", "Connect", 2000);
                scheduleRender();
              }
            }
          });

          nodeEl.addEventListener("pointercancel", (ev) => {
            if (state.interaction && state.interaction.pointerId === ev.pointerId) state.interaction = null;
            scheduleRender();
          });

          nodeEl.querySelector("[data-action='center']").addEventListener("click", (ev) => {
            ev.stopPropagation();
            select({ type: "node", id: node.id });
            centerOnNode(node.id, { animate: true });
          });
          nodeEl.querySelector("[data-action='duplicate']").addEventListener("click", (ev) => {
            ev.stopPropagation();
            select({ type: "node", id: node.id });
            duplicateNode(node.id);
          });

          // Connection port
          const out = nodeEl.querySelector(".port.out");
          out.addEventListener("pointerdown", (ev) => {
            if (ev.button !== 0) return;
            ev.stopPropagation();
            select({ type: "node", id: node.id });
            const pt = clientToWorld(ev.clientX, ev.clientY);
            state.interaction = { type: "connect", fromId: node.id, toWorld: pt, pointerId: ev.pointerId };
            nodeEl.setPointerCapture(ev.pointerId);
            scheduleRender();
          });

          const inp = nodeEl.querySelector(".port.in");
          inp.addEventListener("pointerdown", (ev) => {
            // allow selecting node when grabbing input port
            ev.stopPropagation();
            select({ type: "node", id: node.id });
          });

          nodeEl.addEventListener("click", (ev) => {
            if (ev.target.closest(".iconBtn")) return;
            select({ type: "node", id: node.id });
          });

          return nodeEl;
        }

        function select(sel) {
          if (sel.type === state.selection.type && sel.id === state.selection.id) return;
          state.selection = sel;
          scheduleRender();
        }

        function clearSelection() {
          state.selection = { type: null, id: null };
          scheduleRender();
        }

        function addNode({ title, desc, color }) {
          pushHistory("Add stage");
          const center = viewCenterWorld();
          const node = {
            id: uid("n"),
            x: Math.round(center.x - 120 + (Math.random() * 60 - 30)),
            y: Math.round(center.y - 70 + (Math.random() * 60 - 30)),
            w: 240,
            h: 150,
            title: String(title || "Untitled").trim() || "Untitled",
            desc: String(desc || "").trim(),
            color: color || COLORS[0],
          };
          state.nodes.push(node);
          select({ type: "node", id: node.id });
          scheduleRender();
          centerOnNode(node.id, { animate: true });
          showToast("Stage added. Drag the right dot to connect.", "Stage");
        }

        function duplicateNode(nodeId) {
          const src = byId(state.nodes, nodeId);
          if (!src) return;
          pushHistory("Duplicate stage");
          const node = deepClone(src);
          node.id = uid("n");
          node.x = Math.round(src.x + 40);
          node.y = Math.round(src.y + 32);
          node.title = `${src.title || "Stage"} (copy)`;
          state.nodes.push(node);
          select({ type: "node", id: node.id });
          scheduleRender();
          showToast("Stage duplicated", "Stage");
        }

        function removeNode(nodeId) {
          const idx = state.nodes.findIndex((n) => n.id === nodeId);
          if (idx === -1) return;
          pushHistory("Delete stage");
          state.nodes.splice(idx, 1);
          state.edges = state.edges.filter((e) => e.from !== nodeId && e.to !== nodeId);
          clearSelection();
          scheduleRender();
        }

        function addEdge(fromId, toId) {
          if (fromId === toId) return;
          const exists = state.edges.some((e) => e.from === fromId && e.to === toId);
          if (exists) {
            showToast("That connection already exists.", "Link");
            return;
          }
          pushHistory("Add connection");
          state.edges.push({ id: uid("e"), from: fromId, to: toId });
          ensureIntegrity();
          select({ type: "edge", id: state.edges[state.edges.length - 1].id });
          scheduleRender();
          showToast("Connected", "Link");
        }

        function removeEdge(edgeId) {
          const idx = state.edges.findIndex((e) => e.id === edgeId);
          if (idx === -1) return;
          pushHistory("Delete connection");
          state.edges.splice(idx, 1);
          clearSelection();
          scheduleRender();
        }

        function viewCenterWorld() {
          const r = canvasRect();
          return {
            x: (r.width / 2 - state.viewport.x) / state.viewport.scale,
            y: (r.height / 2 - state.viewport.y) / state.viewport.scale,
          };
        }

        function centerOnNode(nodeId, { animate } = {}) {
          const n = byId(state.nodes, nodeId);
          if (!n) return;
          const r = canvasRect();
          const targetScale = state.viewport.scale;
          const cx = n.x + n.w / 2;
          const cy = n.y + n.h / 2;
          const tx = Math.round(r.width / 2 - cx * targetScale);
          const ty = Math.round(r.height / 2 - cy * targetScale);
          if (!animate) {
            state.viewport.x = tx;
            state.viewport.y = ty;
            scheduleRender();
            return;
          }
          const start = { x: state.viewport.x, y: state.viewport.y };
          const end = { x: tx, y: ty };
          animateViewport(start, end, state.viewport.scale, state.viewport.scale, 260);
        }

        function fitToView({ animate } = {}) {
          if (state.nodes.length === 0) return;
          const r = canvasRect();
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          for (const n of state.nodes) {
            const b = getNodeBounds(n);
            minX = Math.min(minX, b.x);
            minY = Math.min(minY, b.y);
            maxX = Math.max(maxX, b.x2);
            maxY = Math.max(maxY, b.y2);
          }
          const pad = 90;
          const w = Math.max(1, maxX - minX + pad * 2);
          const h = Math.max(1, maxY - minY + pad * 2);
          const scale = clamp(Math.min(r.width / w, r.height / h), 0.35, 1.6);
          const cx = (minX + maxX) / 2;
          const cy = (minY + maxY) / 2;
          const tx = Math.round(r.width / 2 - cx * scale);
          const ty = Math.round(r.height / 2 - cy * scale);
          const start = deepClone(state.viewport);
          const end = { x: tx, y: ty, scale };
          if (!animate) {
            state.viewport = end;
            scheduleRender();
            return;
          }
          animateViewport({ x: start.x, y: start.y }, { x: end.x, y: end.y }, start.scale, end.scale, 320);
        }

        function animateViewport(startPos, endPos, startScale, endScale, duration) {
          const t0 = performance.now();
          const ease = (t) => 1 - Math.pow(1 - t, 3);
          const step = (now) => {
            const t = clamp((now - t0) / duration, 0, 1);
            const k = ease(t);
            state.viewport.x = Math.round(startPos.x + (endPos.x - startPos.x) * k);
            state.viewport.y = Math.round(startPos.y + (endPos.y - startPos.y) * k);
            state.viewport.scale = startScale + (endScale - startScale) * k;
            scheduleRender();
            if (t < 1) requestAnimationFrame(step);
          };
          requestAnimationFrame(step);
        }

        function autoLayout() {
          if (state.nodes.length === 0) return;
          pushHistory("Auto layout");
          const sorted = [...state.nodes].sort((a, b) => a.x - b.x);
          const start = { x: sorted[0].x, y: sorted[0].y };
          const gap = 290;
          for (let i = 0; i < sorted.length; i++) {
            sorted[i].x = Math.round(start.x + i * gap);
            sorted[i].y = Math.round(start.y + (i % 2 === 1 ? 40 : 0));
          }
          scheduleRender();
          fitToView({ animate: true });
          showToast("Auto layout applied", "Layout");
        }

        // Canvas interactions: pan, zoom, selection clearing, connect hover
        let persistTimer = 0;
        function schedulePersistSoon() {
          clearTimeout(persistTimer);
          persistTimer = setTimeout(() => persist(), 500);
        }

        function clearConnectTargets() {
          for (const nodeEl of nodeEls.values()) nodeEl.classList.remove("connectTarget");
        }

        function nodeIdFromPoint(clientX, clientY, { expectPort } = {}) {
          const hit = document.elementFromPoint(clientX, clientY);
          if (!hit) return null;
          if (expectPort) {
            const port = hit.closest?.(".port");
            if (!port) return null;
            if (port.dataset.port !== expectPort) return null;
            const nodeEl = port.closest(".node");
            return nodeEl?.dataset.id || null;
          }
          const nodeEl = hit.closest?.(".node");
          return nodeEl?.dataset.id || null;
        }

        let hoverRaf = 0;
        function scheduleConnectHover(clientX, clientY) {
          if (hoverRaf) return;
          hoverRaf = requestAnimationFrame(() => {
            hoverRaf = 0;
            clearConnectTargets();
            const targetId = nodeIdFromPoint(clientX, clientY, { expectPort: "in" });
            if (!targetId) return;
            const nodeEl = nodeEls.get(targetId);
            if (nodeEl) nodeEl.classList.add("connectTarget");
          });
        }

        function deleteSelection() {
          const s = state.selection;
          if (!s.type) return;
          if (s.type === "node") return removeNode(s.id);
          if (s.type === "edge") return removeEdge(s.id);
        }

        function isEditableTarget(target) {
          if (!target) return false;
          return Boolean(target.closest?.("[contenteditable],textarea,input,select,option,button,dialog"));
        }

        el.canvas.addEventListener("pointerdown", (ev) => {
          if (ev.button !== 0 && ev.button !== 1) return;
          if (isEditableTarget(ev.target)) return;
          if (ev.target.closest(".node")) return;
          ev.preventDefault();
          clearSelection();
          const allowPan = ev.button === 1 || window.__spaceDown;
          if (!allowPan) return;
          const startClient = { x: ev.clientX, y: ev.clientY };
          state.interaction = {
            type: "pan",
            startClient,
            startViewport: { x: state.viewport.x, y: state.viewport.y },
            pointerId: ev.pointerId,
          };
          el.canvas.setPointerCapture(ev.pointerId);
        });

        el.canvas.addEventListener("pointermove", (ev) => {
          if (!state.interaction) return;
          if (state.interaction.pointerId !== ev.pointerId) return;
          if (state.interaction.type === "pan") {
            const dx = ev.clientX - state.interaction.startClient.x;
            const dy = ev.clientY - state.interaction.startClient.y;
            state.viewport.x = Math.round(state.interaction.startViewport.x + dx);
            state.viewport.y = Math.round(state.interaction.startViewport.y + dy);
            scheduleRender();
          }
        });

        el.canvas.addEventListener("pointerup", (ev) => {
          if (!state.interaction) return;
          if (state.interaction.pointerId !== ev.pointerId) return;
          if (state.interaction.type === "pan") {
            el.canvas.releasePointerCapture(ev.pointerId);
            state.interaction = null;
            scheduleRender();
          }
        });

        el.canvas.addEventListener("pointercancel", () => {
          state.interaction = null;
          clearConnectTargets();
          scheduleRender();
        });

        el.canvas.addEventListener(
          "wheel",
          (ev) => {
            if (isEditableTarget(ev.target)) return;
            const zooming = ev.ctrlKey || ev.metaKey;
            if (!zooming) return;
            ev.preventDefault();
            const { x: wx, y: wy } = clientToWorld(ev.clientX, ev.clientY);
            const dir = ev.deltaY > 0 ? -1 : 1;
            const factor = dir > 0 ? 1.12 : 0.89;
            const nextScale = clamp(state.viewport.scale * factor, 0.25, 2.1);
            const before = worldToClient(wx, wy);
            state.viewport.scale = nextScale;
            const after = worldToClient(wx, wy);
            state.viewport.x += Math.round(before.x - after.x);
            state.viewport.y += Math.round(before.y - after.y);
            scheduleRender();
          },
          { passive: false }
        );

        // Keyboard shortcuts
        window.__spaceDown = false;
        window.addEventListener("keydown", (ev) => {
          if (ev.key === " " && !isEditableTarget(ev.target)) window.__spaceDown = true;
          if (ev.key === "Escape") {
            clearConnectTargets();
            if (state.interaction && state.interaction.type === "connect") {
              state.interaction = null;
              scheduleRender();
              showToast("Connection canceled", "Connect");
              return;
            }
            if (el.dlgAdd.open) return closeDialog(el.dlgAdd);
            if (el.dlgIO.open) return closeDialog(el.dlgIO);
            if (el.dlgHelp.open) return closeDialog(el.dlgHelp);
            clearSelection();
          }

          const key = ev.key.toLowerCase();
          const meta = ev.metaKey || ev.ctrlKey;
          if (meta && key === "z" && !ev.shiftKey) {
            if (isEditableTarget(ev.target)) return;
            ev.preventDefault();
            undo();
            return;
          }
          if (meta && ((key === "z" && ev.shiftKey) || key === "y")) {
            if (isEditableTarget(ev.target)) return;
            ev.preventDefault();
            redo();
            return;
          }
          if (key === "delete" || key === "backspace") {
            if (isEditableTarget(ev.target)) return;
            ev.preventDefault();
            deleteSelection();
          }
          if (!meta && !ev.altKey && !ev.shiftKey) {
            if (key === "a" && !isEditableTarget(ev.target)) {
              ev.preventDefault();
              openAddDialog();
              return;
            }
            if (key === "f" && !isEditableTarget(ev.target)) {
              ev.preventDefault();
              fitToView({ animate: true });
            }
            if (key === "?") {
              ev.preventDefault();
              openDialog(el.dlgHelp);
            }
          }
        });
        window.addEventListener("keyup", (ev) => {
          if (ev.key === " ") window.__spaceDown = false;
        });

        // Buttons and dialogs
        function openAddDialog() {
          el.addTitle.value = "";
          el.addDesc.value = "";
          el.addTemplate.value = "";
          renderAddSwatches();
          openDialog(el.dlgAdd);
          setTimeout(() => el.addTitle.focus(), 50);
        }

        function renderAddSwatches() {
          el.addSwatches.replaceChildren();
          for (const c of COLORS) {
            const b = document.createElement("button");
            b.type = "button";
            b.className = "swatchBtn";
            b.style.setProperty("--c", c);
            b.setAttribute("aria-label", `Select color ${c}`);
            b.setAttribute("aria-checked", c === state.ui.addColor ? "true" : "false");
            b.addEventListener("click", () => {
              state.ui.addColor = c;
              renderAddSwatches();
            });
            el.addSwatches.appendChild(b);
          }
        }

        el.addTemplate.addEventListener("change", () => {
          const v = el.addTemplate.value;
          if (!v) return;
          const [title, desc] = v.split("|");
          el.addTitle.value = title || "";
          el.addDesc.value = desc || "";
        });

        el.btnAdd.addEventListener("click", openAddDialog);
        el.btnAddConfirm.addEventListener("click", () => {
          const title = el.addTitle.value.trim();
          if (!title) {
            showToast("Please enter a title.", "Add");
            el.addTitle.focus();
            return;
          }
          addNode({ title, desc: el.addDesc.value, color: state.ui.addColor });
          closeDialog(el.dlgAdd);
        });

        el.btnAuto.addEventListener("click", autoLayout);
        el.btnFit.addEventListener("click", () => fitToView({ animate: true }));
        el.btnUndo.addEventListener("click", undo);
        el.btnRedo.addEventListener("click", redo);
        el.btnTheme.addEventListener("click", toggleTheme);
        el.btnHelp.addEventListener("click", () => openDialog(el.dlgHelp));
        el.btnDelete.addEventListener("click", deleteSelection);

        function openExportDialog() {
          const payload = {
            v: 1,
            exportedAt: new Date().toISOString(),
            nodes: state.nodes,
            edges: state.edges,
            viewport: state.viewport,
          };
          const text = JSON.stringify(payload, null, 2);
          el.ioTitle.textContent = "Export diagram";
          el.ioArea.value = text;
          el.ioMeta.textContent = `${state.nodes.length} stages • ${state.edges.length} links`;
          el.ioTip.textContent = "Copy this JSON to save/share. Import replaces the current diagram.";
          el.ioFooter.replaceChildren();
          const btnCopy = document.createElement("button");
          btnCopy.className = "btn";
          btnCopy.textContent = "Copy";
          btnCopy.addEventListener("click", async () => {
            try {
              await navigator.clipboard.writeText(el.ioArea.value);
              showToast("Copied to clipboard", "Export");
            } catch {
              el.ioArea.select();
              showToast("Select + copy manually", "Export");
            }
          });
          const btnDownload = document.createElement("button");
          btnDownload.className = "btn";
          btnDownload.textContent = "Download";
          btnDownload.addEventListener("click", () => {
            const blob = new Blob([el.ioArea.value], { type: "application/json" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "customer-journey-flow.json";
            a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 4000);
          });
          const btnClose = document.createElement("button");
          btnClose.className = "btn primary";
          btnClose.textContent = "Done";
          btnClose.addEventListener("click", () => closeDialog(el.dlgIO));
          el.ioFooter.append(btnCopy, btnDownload, btnClose);
          openDialog(el.dlgIO);
          setTimeout(() => el.ioArea.focus(), 60);
        }

        function openImportDialog() {
          el.ioTitle.textContent = "Import diagram";
          el.ioArea.value = "";
          el.ioMeta.textContent = "Paste JSON here";
          el.ioTip.textContent = "Import replaces the current diagram. Tip: export first if you want a backup.";
          el.ioFooter.replaceChildren();
          const btnPasteExample = document.createElement("button");
          btnPasteExample.className = "btn";
          btnPasteExample.textContent = "Paste current";
          btnPasteExample.addEventListener("click", () => {
            const payload = {
              v: 1,
              exportedAt: new Date().toISOString(),
              nodes: state.nodes,
              edges: state.edges,
              viewport: state.viewport,
            };
            el.ioArea.value = JSON.stringify(payload, null, 2);
            showToast("Pasted current diagram JSON", "Import");
          });
          const btnCancel = document.createElement("button");
          btnCancel.className = "btn ghost";
          btnCancel.textContent = "Cancel";
          btnCancel.addEventListener("click", () => closeDialog(el.dlgIO));
          const btnImport = document.createElement("button");
          btnImport.className = "btn primary";
          btnImport.textContent = "Import";
          btnImport.addEventListener("click", () => {
            const parsed = safeParseJSON(el.ioArea.value);
            if (!parsed.ok) {
              showToast(parsed.error, "Import", 2600);
              return;
            }
            const data = parsed.value || {};
            if (!data || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
              showToast("Invalid format: expected {nodes, edges}.", "Import", 2600);
              return;
            }
            pushHistory("Import diagram");
            state.nodes = deepClone(data.nodes);
            state.edges = deepClone(data.edges);
            if (data.viewport) state.viewport = deepClone(data.viewport);
            ensureIntegrity();
            clearSelection();
            scheduleRender();
            closeDialog(el.dlgIO);
            showToast("Imported", "Import");
          });
          el.ioFooter.append(btnCancel, btnImport);
          openDialog(el.dlgIO);
          setTimeout(() => el.ioArea.focus(), 60);
        }

        el.btnExport.addEventListener("click", openExportDialog);
        el.btnImport.addEventListener("click", openImportDialog);

        // Clicking empty canvas clears selection
        el.canvas.addEventListener("click", (ev) => {
          if (isEditableTarget(ev.target)) return;
          if (ev.target.closest(".node")) return;
          clearSelection();
        });

        // Window resize: keep rendering correct
        window.addEventListener("resize", () => scheduleRender());

        // Persist on tab close
        window.addEventListener("beforeunload", () => persist());

        // Seed data, theme, initial render
        const savedTheme = localStorage.getItem(THEME_KEY);
        if (savedTheme === "light" || savedTheme === "dark") setTheme(savedTheme);
        else {
          const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
          setTheme(prefersLight ? "light" : "dark");
        }

        const loaded = load();
        if (!loaded) seed();
        ensureIntegrity();
        updateUndoRedoUI();
        scheduleRender();
        setTimeout(() => {
          if (!loaded) showToast("Tip: Drag from the right dot to connect stages.", "Welcome", 2600);
        }, 450);

        // Fit at start for nicer framing (don’t override saved viewport)
        if (!loaded) setTimeout(() => fitToView({ animate: true }), 350);
      })();
    </script>
  </body>
</html>
