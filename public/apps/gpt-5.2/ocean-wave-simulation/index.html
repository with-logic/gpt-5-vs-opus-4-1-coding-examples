<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="dark" />
    <title>Ocean Wave Simulation</title>
    <style>
      :root {
        --bg: #04070c;
        --panel: rgba(12, 18, 28, 0.58);
        --panel-2: rgba(12, 18, 28, 0.38);
        --stroke: rgba(190, 215, 255, 0.18);
        --stroke-2: rgba(190, 215, 255, 0.10);
        --text: rgba(235, 245, 255, 0.92);
        --muted: rgba(235, 245, 255, 0.64);
        --muted2: rgba(235, 245, 255, 0.50);
        --accent: rgba(140, 214, 255, 0.92);
        --accent2: rgba(0, 180, 255, 0.52);
        --danger: rgba(255, 110, 132, 0.9);
        --shadow: 0 18px 55px rgba(0, 0, 0, 0.55);
        --radius: 18px;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: radial-gradient(1200px 900px at 50% 20%, #0b1421, var(--bg));
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
        overflow: hidden;
      }

      #stage {
        position: fixed;
        inset: 0;
      }

      #ui {
        position: fixed;
        top: max(14px, env(safe-area-inset-top));
        left: max(14px, env(safe-area-inset-left));
        width: min(390px, calc(100vw - 28px));
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border: 1px solid var(--stroke);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        backdrop-filter: blur(18px) saturate(150%);
        -webkit-backdrop-filter: blur(18px) saturate(150%);
        overflow: hidden;
        user-select: none;
      }

      @supports not ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
        #ui {
          background: rgba(10, 16, 26, 0.92);
        }
      }

      .ui-top {
        padding: 16px 16px 12px 16px;
        border-bottom: 1px solid var(--stroke-2);
      }

      .title {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
      }

      h1 {
        font-size: 15px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        margin: 0;
        color: rgba(235, 245, 255, 0.9);
      }

      .badge {
        font-size: 11px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.04);
        color: var(--muted);
      }

      .subtitle {
        margin: 10px 0 0 0;
        font-size: 13px;
        line-height: 1.35;
        color: var(--muted);
      }

      .controls {
        padding: 12px 16px 14px 16px;
        display: grid;
        gap: 12px;
      }

      .row {
        display: grid;
        gap: 8px;
      }

      .row-head {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
      }

      label {
        font-size: 13px;
        color: rgba(235, 245, 255, 0.84);
      }

      .value {
        font-variant-numeric: tabular-nums;
        font-size: 12px;
        color: var(--muted);
      }

      input[type="range"] {
        width: 100%;
        accent-color: rgba(110, 210, 255, 0.95);
      }

      .range-wrap {
        position: relative;
        padding: 8px 10px;
        border-radius: 14px;
        border: 1px solid var(--stroke-2);
        background: rgba(255, 255, 255, 0.03);
      }

      .actions {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-top: 1px solid var(--stroke-2);
        background: rgba(0, 0, 0, 0.08);
      }

      .hint {
        font-size: 12px;
        color: var(--muted2);
        line-height: 1.3;
      }

      .buttons {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      button {
        appearance: none;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
        padding: 9px 12px;
        border-radius: 12px;
        font-size: 12px;
        letter-spacing: 0.02em;
        cursor: pointer;
        transition: transform 120ms ease, background 180ms ease, border-color 180ms ease;
      }

      button:hover {
        background: rgba(140, 214, 255, 0.08);
        border-color: rgba(140, 214, 255, 0.28);
      }

      button:active {
        transform: translateY(1px);
      }

      .ghost {
        color: var(--muted);
      }

      #ui.collapsed .subtitle,
      #ui.collapsed .controls,
      #ui.collapsed #reset,
      #ui.collapsed .hint {
        display: none !important;
      }

      #ui.collapsed .actions {
        padding: 10px 16px;
      }

      .hidden {
        display: none !important;
      }

      #toast {
        position: fixed;
        left: 50%;
        top: max(14px, env(safe-area-inset-top));
        transform: translateX(-50%);
        width: min(520px, calc(100vw - 28px));
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(15, 18, 26, 0.9);
        box-shadow: var(--shadow);
        color: rgba(235, 245, 255, 0.9);
        font-size: 13px;
        line-height: 1.35;
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
      }

      #toast strong {
        color: rgba(255, 170, 182, 0.95);
      }

      @media (max-width: 760px) {
        #ui {
          left: 50%;
          transform: translateX(-50%);
          top: auto;
          bottom: max(14px, env(safe-area-inset-bottom));
          width: min(520px, calc(100vw - 28px));
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .hint span[data-motion] {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="stage" aria-hidden="true"></div>

    <section id="ui" aria-label="Ocean controls">
      <div class="ui-top">
        <div class="title">
          <h1>Ocean Wave Simulation</h1>
          <div class="badge" id="qualityBadge" title="Auto quality based on device performance">Quality: Auto</div>
        </div>
        <p class="subtitle">
          Physically-inspired Gerstner waves with soft sky reflections. Adjust wind, height, and sunlight for a calming
          sea state.
        </p>
      </div>

      <div class="controls">
        <div class="row">
          <div class="row-head">
            <label for="wind">Wind speed</label>
            <div class="value" id="windVal">—</div>
          </div>
          <div class="range-wrap">
            <input id="wind" type="range" min="0" max="25" step="0.1" value="8.0" />
          </div>
        </div>

        <div class="row">
          <div class="row-head">
            <label for="height">Wave height</label>
            <div class="value" id="heightVal">—</div>
          </div>
          <div class="range-wrap">
            <input id="height" type="range" min="0" max="5" step="0.05" value="1.3" />
          </div>
        </div>

        <div class="row">
          <div class="row-head">
            <label for="light">Lighting</label>
            <div class="value" id="lightVal">—</div>
          </div>
          <div class="range-wrap">
            <input id="light" type="range" min="0" max="100" step="1" value="62" />
          </div>
        </div>
      </div>

      <div class="actions">
        <div class="hint">
          Drag to look around · Scroll to zoom <span data-motion>· Waves pause when tab is hidden</span>
        </div>
        <div class="buttons">
          <button id="toggleUi" class="ghost" type="button" title="Show/hide panel">Hide</button>
          <button id="reset" type="button">Reset</button>
        </div>
      </div>
    </section>

    <div id="toast" class="hidden" role="status" aria-live="polite"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      const ui = {
        root: document.getElementById("ui"),
        toast: document.getElementById("toast"),
        stage: document.getElementById("stage"),
        wind: document.getElementById("wind"),
        height: document.getElementById("height"),
        light: document.getElementById("light"),
        windVal: document.getElementById("windVal"),
        heightVal: document.getElementById("heightVal"),
        lightVal: document.getElementById("lightVal"),
        reset: document.getElementById("reset"),
        toggleUi: document.getElementById("toggleUi"),
        qualityBadge: document.getElementById("qualityBadge")
      };

      const defaults = {
        wind: 8.0,
        height: 1.3,
        light: 62
      };

      const clamp01 = (x) => Math.min(1, Math.max(0, x));
      const lerp = (a, b, t) => a + (b - a) * t;

      function formatWind(v) {
        return `${v.toFixed(1)} m/s`;
      }
      function formatHeight(v) {
        return `${v.toFixed(2)} m`;
      }
      function formatLight(v) {
        if (v < 20) return `Dusk (${v}%)`;
        if (v < 45) return `Morning (${v}%)`;
        if (v < 75) return `Daylight (${v}%)`;
        return `Bright (${v}%)`;
      }

      function setToast(html, isError = false) {
        ui.toast.innerHTML = isError ? `<strong>Notice:</strong> ${html}` : html;
        ui.toast.classList.remove("hidden");
      }

      let renderer;
      try {
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: "high-performance"
        });
      } catch (err) {
        setToast("This browser/device can’t create a WebGL context. Try a different browser.", true);
        throw err;
      }

      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const smallScreen = Math.min(window.innerWidth, window.innerHeight) < 720;
      const reducedMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      const quality = {
        pixelRatio: reducedMotion ? Math.min(1.25, dpr) : dpr,
        segments: reducedMotion ? 160 : smallScreen ? 192 : 256
      };
      ui.qualityBadge.textContent = `Quality: ${quality.segments >= 256 ? "High" : quality.segments >= 192 ? "Medium" : "Low"}`;

      renderer.setPixelRatio(quality.pixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight, false);
      renderer.setClearColor(new THREE.Color(0x04070c), 1);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
      ui.stage.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x88a9c0, 0.00085);

      const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 20000);
      camera.position.set(0, 20, 58);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.enablePan = false;
      controls.minDistance = 22;
      controls.maxDistance = 120;
      controls.minPolarAngle = Math.PI * 0.12;
      controls.maxPolarAngle = Math.PI * 0.48;
      controls.rotateSpeed = 0.65;
      controls.target.set(0, 0.2, 0);
      controls.update();

      const skyVertex = /* glsl */ `
        varying vec3 vDir;
        void main() {
          vec4 worldPos = modelMatrix * vec4(position, 1.0);
          vDir = normalize(worldPos.xyz - cameraPosition);
          gl_Position = projectionMatrix * viewMatrix * worldPos;
        }
      `;

      const skyFragment = /* glsl */ `
        precision highp float;
        varying vec3 vDir;
        uniform vec3 uSunDir;
        uniform vec3 uSkyTop;
        uniform vec3 uSkyHorizon;
        uniform vec3 uSunTint;
        uniform float uSunGlow;

        float saturate(float x) { return clamp(x, 0.0, 1.0); }

        void main() {
          vec3 d = normalize(vDir);
          float h = saturate(d.y * 0.5 + 0.5);
          float haze = pow(saturate(1.0 - h), 2.6);
          vec3 col = mix(uSkyHorizon, uSkyTop, pow(h, 1.25));
          col += haze * vec3(0.06, 0.08, 0.11);

          float sunAmount = saturate(dot(d, normalize(uSunDir)));
          float sunDisc = smoothstep(0.9996, 1.0, sunAmount);
          float sunHalo = pow(sunAmount, 220.0) * uSunGlow;
          col += uSunTint * (sunDisc * 1.2 + sunHalo * 0.65);

          gl_FragColor = vec4(col, 1.0);
        }
      `;

      const skyUniforms = {
        uSunDir: { value: new THREE.Vector3(0.2, 0.8, -0.55).normalize() },
        uSkyTop: { value: new THREE.Color(0.06, 0.15, 0.26) },
        uSkyHorizon: { value: new THREE.Color(0.45, 0.60, 0.70) },
        uSunTint: { value: new THREE.Color(1.0, 0.9, 0.75) },
        uSunGlow: { value: 1.0 }
      };

      const skyGeo = new THREE.SphereGeometry(9000, 48, 32);
      const skyMat = new THREE.ShaderMaterial({
        uniforms: skyUniforms,
        vertexShader: skyVertex,
        fragmentShader: skyFragment,
        side: THREE.BackSide,
        depthWrite: false
      });
      const sky = new THREE.Mesh(skyGeo, skyMat);
      sky.frustumCulled = false;
      scene.add(sky);

      const waterVertex = /* glsl */ `
        precision highp float;
        #define NUM_WAVES 8

        uniform float uTime;
        uniform float uTimeScale;
        uniform float uWaveHeight;
        uniform float uChoppiness;
        uniform vec4 uWaves[NUM_WAVES]; // dir.x, dir.y, amp, steep
        uniform vec2 uKw[NUM_WAVES];    // k, omega

        varying vec3 vWorldPos;
        varying vec3 vNormalW;
        varying float vFoam;

        float saturate(float x) { return clamp(x, 0.0, 1.0); }

        void main() {
          vec3 p = position;
          vec3 tangentX = vec3(1.0, 0.0, 0.0);
          vec3 tangentZ = vec3(0.0, 0.0, 1.0);

          float foamAcc = 0.0;
          float t = uTime * uTimeScale;

          for (int i = 0; i < NUM_WAVES; i++) {
            vec2 d = normalize(uWaves[i].xy);
            float baseAmp = uWaves[i].z;
            float A = baseAmp * uWaveHeight;
            float steep = uWaves[i].w;
            float k = uKw[i].x;
            float w = uKw[i].y;

            float denom = max(0.001, k * A * float(NUM_WAVES));
            float q = clamp(steep / denom, 0.0, 1.25) * uChoppiness;

            float phase = k * dot(d, p.xz) - w * t;
            float s = sin(phase);
            float c = cos(phase);

            p.x += d.x * (q * A) * c;
            p.z += d.y * (q * A) * c;
            p.y += A * s;

            float wa = k * A;
            float dx = d.x;
            float dz = d.y;

            tangentX += vec3(
              -dx * dx * (q * wa) * s,
              dx * wa * c,
              -dx * dz * (q * wa) * s
            );
            tangentZ += vec3(
              -dx * dz * (q * wa) * s,
              dz * wa * c,
              -dz * dz * (q * wa) * s
            );

            float crest = saturate((s + 0.2) * 0.9);
            foamAcc += pow(crest, 3.0) * saturate(wa * 0.45) * steep;
          }

          vec3 n = normalize(cross(tangentZ, tangentX));
          vNormalW = normalize((modelMatrix * vec4(n, 0.0)).xyz);
          vec4 world = modelMatrix * vec4(p, 1.0);
          vWorldPos = world.xyz;

          vFoam = saturate(foamAcc * 0.9);
          gl_Position = projectionMatrix * viewMatrix * world;
        }
      `;

      const waterFragment = /* glsl */ `
        precision highp float;
        varying vec3 vWorldPos;
        varying vec3 vNormalW;
        varying float vFoam;

        uniform vec3 uSunDir;
        uniform vec3 uSunColor;
        uniform float uSunIntensity;
        uniform vec3 uSkyTop;
        uniform vec3 uSkyHorizon;
        uniform vec3 uWaterDeep;
        uniform vec3 uWaterShallow;
        uniform float uRoughness;
        uniform float uFoamStrength;
        uniform float uWind;
        uniform float uTime;

        float saturate(float x) { return clamp(x, 0.0, 1.0); }

        float hash21(vec2 p) {
          p = fract(p * vec2(123.34, 456.21));
          p += dot(p, p + 34.345);
          return fract(p.x * p.y);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash21(i);
          float b = hash21(i + vec2(1.0, 0.0));
          float c = hash21(i + vec2(0.0, 1.0));
          float d = hash21(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
        }

        float fbm(vec2 p) {
          float v = 0.0;
          float a = 0.5;
          mat2 m = mat2(1.7, -1.2, 1.2, 1.7);
          for (int i = 0; i < 4; i++) {
            v += a * noise(p);
            p = m * p;
            a *= 0.5;
          }
          return v;
        }

        vec3 sampleSky(vec3 dir) {
          dir = normalize(dir);
          float h = saturate(dir.y * 0.5 + 0.5);
          vec3 col = mix(uSkyHorizon, uSkyTop, pow(h, 1.2));
          float sunAmount = saturate(dot(dir, normalize(uSunDir)));
          float sunGlow = pow(sunAmount, 140.0) * 1.2 + smoothstep(0.9997, 1.0, sunAmount) * 3.0;
          col += uSunColor * (sunGlow * 0.85) * (0.6 + 0.4 * uSunIntensity);
          return col;
        }

        void main() {
          vec3 N = normalize(vNormalW);
          vec3 V = normalize(cameraPosition - vWorldPos);
          vec3 L = normalize(uSunDir);

          float wind01 = saturate(uWind / 25.0);
          float rippleScale = mix(0.16, 0.32, wind01);
          float rippleSpeed = mix(0.22, 0.55, wind01);

          vec2 p = vWorldPos.xz * rippleScale + vec2(uTime * rippleSpeed, -uTime * rippleSpeed * 0.77);
          float r = fbm(p);
          float e = 0.42;
          float rx = fbm(p + vec2(e, 0.0));
          float rz = fbm(p + vec2(0.0, e));
          vec2 grad = vec2(rx - r, rz - r);
          vec3 bump = normalize(vec3(-grad.x, 1.0, -grad.y));
          N = normalize(mix(N, bump, 0.12 + 0.08 * wind01));

          float NdotV = saturate(dot(N, V));
          float NdotL = saturate(dot(N, L));
          vec3 R = reflect(-V, N);

          vec3 skyRefl = sampleSky(R);

          float fresnel = pow(1.0 - NdotV, 5.0);
          vec3 F0 = vec3(0.02);
          vec3 F = F0 + (1.0 - F0) * fresnel;

          float dist = length(vWorldPos.xz - cameraPosition.xz);
          float depthish = saturate(dist / 900.0);

          vec3 waterCol = mix(uWaterShallow, uWaterDeep, saturate(depthish * 0.85 + pow(NdotV, 0.35) * 0.25));

          vec3 H = normalize(V + L);
          float NdotH = saturate(dot(N, H));
          float VdotH = saturate(dot(V, H));
          float rough = clamp(uRoughness, 0.03, 0.6);
          float shininess = mix(1100.0, 70.0, rough);
          float spec = pow(NdotH, shininess) * (0.35 + 0.65 * (1.0 - rough));
          vec3 Fh = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);
          vec3 specCol = uSunColor * uSunIntensity * spec * Fh * (0.25 + 0.75 * NdotL);

          vec3 col = mix(waterCol, skyRefl, F);
          col += specCol;

          float foam = smoothstep(0.40, 1.0, vFoam) * uFoamStrength;
          vec3 foamCol = vec3(0.92, 0.95, 0.99);
          col = mix(col, foamCol, foam);

          float subsurface = pow(saturate(dot(-L, N)), 2.2) * 0.08 * (0.35 + 0.65 * (1.0 - depthish));
          col += uWaterShallow * subsurface * uSunIntensity;

          float horizonHaze = smoothstep(0.0, 1.0, dist / 1200.0) * 0.22;
          col = mix(col, uSkyHorizon, horizonHaze);

          gl_FragColor = vec4(col, 1.0);
        }
      `;

      const waveCount = 8;
      const waterUniforms = {
        uTime: { value: 0 },
        uTimeScale: { value: 1.0 },
        uWaveHeight: { value: 1.0 },
        uChoppiness: { value: 1.0 },
        uWaves: { value: new Array(waveCount).fill(0).map(() => new THREE.Vector4()) },
        uKw: { value: new Array(waveCount).fill(0).map(() => new THREE.Vector2()) },
        uSunDir: skyUniforms.uSunDir,
        uSunColor: { value: new THREE.Color(1.0, 0.93, 0.80) },
        uSunIntensity: { value: 1.0 },
        uSkyTop: skyUniforms.uSkyTop,
        uSkyHorizon: skyUniforms.uSkyHorizon,
        uWaterDeep: { value: new THREE.Color(0.02, 0.20, 0.30) },
        uWaterShallow: { value: new THREE.Color(0.08, 0.45, 0.52) },
        uRoughness: { value: 0.14 },
        uFoamStrength: { value: 0.65 },
        uWind: { value: defaults.wind }
      };

      const waterMat = new THREE.ShaderMaterial({
        uniforms: waterUniforms,
        vertexShader: waterVertex,
        fragmentShader: waterFragment,
        fog: true
      });

      const oceanSize = 2400;
      const oceanGeo = new THREE.PlaneGeometry(oceanSize, oceanSize, quality.segments, quality.segments);
      oceanGeo.rotateX(-Math.PI / 2);
      const ocean = new THREE.Mesh(oceanGeo, waterMat);
      ocean.frustumCulled = false;
      scene.add(ocean);

      const windDir = new THREE.Vector2(0.86, 0.52).normalize();

      function updateWaveField() {
        const wind = Number(ui.wind.value);
        const height = Number(ui.height.value);
        const lightPct = Number(ui.light.value);

        ui.windVal.textContent = formatWind(wind);
        ui.heightVal.textContent = formatHeight(height);
        ui.lightVal.textContent = formatLight(lightPct);

        const wind01 = clamp01(wind / 25);
        const height01 = clamp01(height / 5);

        waterUniforms.uWind.value = wind;
        waterUniforms.uWaveHeight.value = lerp(0.35, 2.15, Math.pow(height01, 0.85));
        waterUniforms.uTimeScale.value = lerp(0.55, 1.65, Math.pow(wind01, 0.85));
        waterUniforms.uChoppiness.value = lerp(0.55, 1.20, Math.pow(wind01, 0.9));
        waterUniforms.uRoughness.value = lerp(0.06, 0.28, Math.pow(wind01, 0.8));
        waterUniforms.uFoamStrength.value = lerp(0.18, 0.92, Math.pow(wind01 * height01, 0.85));

        const g = 9.81;
        const waves = [
          { dir: 0.0, wl: lerp(140, 70, wind01), amp: 0.62, steep: lerp(0.18, 0.58, wind01) },
          { dir: 0.10, wl: lerp(95, 44, wind01), amp: 0.36, steep: lerp(0.18, 0.62, wind01) },
          { dir: -0.28, wl: lerp(72, 34, wind01), amp: 0.28, steep: lerp(0.16, 0.66, wind01) },
          { dir: 0.42, wl: lerp(42, 22, wind01), amp: 0.18, steep: lerp(0.14, 0.70, wind01) },
          { dir: -0.65, wl: lerp(18, 10, wind01), amp: 0.09, steep: lerp(0.12, 0.74, wind01) },
          { dir: 0.78, wl: lerp(11, 6, wind01), amp: 0.06, steep: lerp(0.10, 0.78, wind01) },
          { dir: -1.12, wl: lerp(7.5, 4.0, wind01), amp: 0.045, steep: lerp(0.10, 0.82, wind01) },
          { dir: 1.55, wl: lerp(4.5, 2.4, wind01), amp: 0.030, steep: lerp(0.10, 0.88, wind01) }
        ];

        for (let i = 0; i < waveCount; i++) {
          const w = waves[i];
          const angle = Math.atan2(windDir.y, windDir.x) + w.dir;
          const d = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
          const k = (Math.PI * 2) / Math.max(0.5, w.wl);
          const omega = Math.sqrt(g * k);

          waterUniforms.uWaves.value[i].set(d.x, d.y, w.amp, w.steep);
          waterUniforms.uKw.value[i].set(k, omega);
        }

        const lighting = clamp01(lightPct / 100);
        const sunElev = lerp(0.12, 0.78, Math.pow(lighting, 0.85));
        const sunAz = lerp(-0.6, -1.2, lighting);
        const sunDir3 = new THREE.Vector3(Math.cos(sunAz), sunElev, Math.sin(sunAz)).normalize();
        skyUniforms.uSunDir.value.copy(sunDir3);

        const warm = new THREE.Color(1.0, 0.74, 0.52);
        const neutral = new THREE.Color(1.0, 0.93, 0.80);
        const cool = new THREE.Color(0.90, 0.98, 1.0);
        const tint = lighting < 0.35 ? warm.clone().lerp(neutral, lighting / 0.35) : neutral.clone().lerp(cool, (lighting - 0.35) / 0.65);

        waterUniforms.uSunColor.value.copy(tint);
        skyUniforms.uSunTint.value.copy(tint);

        const intensity = lerp(0.35, 1.35, Math.pow(lighting, 0.75));
        waterUniforms.uSunIntensity.value = intensity;
        skyUniforms.uSunGlow.value = lerp(0.7, 1.15, lighting);

        const skyTop = new THREE.Color(0.03, 0.09, 0.16).lerp(new THREE.Color(0.08, 0.18, 0.30), lighting);
        const skyHz = new THREE.Color(0.26, 0.34, 0.46).lerp(new THREE.Color(0.54, 0.70, 0.78), lighting);
        skyUniforms.uSkyTop.value.copy(skyTop);
        skyUniforms.uSkyHorizon.value.copy(skyHz);

        const deep = new THREE.Color(0.01, 0.16, 0.25).lerp(new THREE.Color(0.02, 0.26, 0.34), lighting);
        const shallow = new THREE.Color(0.06, 0.40, 0.48).lerp(new THREE.Color(0.10, 0.52, 0.58), lighting);
        waterUniforms.uWaterDeep.value.copy(deep);
        waterUniforms.uWaterShallow.value.copy(shallow);

        scene.fog.color.copy(skyHz.clone().multiplyScalar(0.92));
        scene.fog.density = lerp(0.00105, 0.00072, lighting);
        renderer.toneMappingExposure = lerp(0.92, 1.12, lighting);
      }

      function setDefaults() {
        ui.wind.value = String(defaults.wind);
        ui.height.value = String(defaults.height);
        ui.light.value = String(defaults.light);
        updateWaveField();
      }

      ui.wind.addEventListener("input", updateWaveField, { passive: true });
      ui.height.addEventListener("input", updateWaveField, { passive: true });
      ui.light.addEventListener("input", updateWaveField, { passive: true });
      ui.reset.addEventListener("click", setDefaults);

      let uiVisible = true;
      ui.toggleUi.addEventListener("click", () => {
        uiVisible = !uiVisible;
        ui.root.classList.toggle("collapsed", !uiVisible);
        ui.toggleUi.textContent = uiVisible ? "Hide" : "Show";
      });

      setDefaults();

      const clock = new THREE.Clock();
      let paused = false;
      const baseCamY = camera.position.y;

      document.addEventListener(
        "visibilitychange",
        () => {
          paused = document.hidden;
          if (!paused) clock.getDelta();
        },
        { passive: true }
      );

      function resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h, false);
      }
      window.addEventListener("resize", resize, { passive: true });

      renderer.setAnimationLoop(() => {
        if (paused) return;

        const t = clock.getElapsedTime();

        controls.update();
        sky.position.copy(camera.position);

        waterUniforms.uTime.value = t;

        const bob = reducedMotion ? 0.0 : 0.08;
        camera.position.y = baseCamY + Math.sin(t * 0.35) * bob;

        renderer.render(scene, camera);
      });

      // Subtle instruction if the device is very constrained.
      if (quality.segments <= 160) {
        setToast("Reduced motion/quality is enabled for comfort or performance. You can still adjust wind, height, and lighting.");
        setTimeout(() => ui.toast.classList.add("hidden"), 4500);
      }
    </script>
  </body>
</html>
