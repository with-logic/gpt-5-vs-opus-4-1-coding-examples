<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark" />
    <title>Ocean Wave Simulation</title>
    <style>
      :root {
        --bg0: #050a12;
        --bg1: #07111f;
        --panel: rgba(10, 18, 30, 0.55);
        --panel2: rgba(10, 18, 30, 0.35);
        --stroke: rgba(255, 255, 255, 0.10);
        --stroke2: rgba(255, 255, 255, 0.06);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.70);
        --muted2: rgba(255, 255, 255, 0.52);
        --accent: #69d2ff;
        --accent2: #82ffb5;
        --shadow: rgba(0, 0, 0, 0.45);
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        overflow: hidden;
        background: radial-gradient(1200px 800px at 60% -10%, #1b2b45 0%, var(--bg1) 40%, var(--bg0) 100%);
        color: var(--text);
        font: 14px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      #app {
        position: fixed;
        inset: 0;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      /* soft vignette + film grain */
      #overlayFX {
        position: fixed;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(1200px 900px at 45% 35%, rgba(0,0,0,0) 35%, rgba(0,0,0,0.35) 78%, rgba(0,0,0,0.62) 100%),
          linear-gradient(180deg, rgba(10,14,18,0.10), rgba(0,0,0,0.18));
        mix-blend-mode: multiply;
      }
      #overlayFX::after{
        content:"";
        position:absolute;
        inset:0;
        opacity:0.14;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='0.55'/%3E%3C/svg%3E");
        background-size: 220px 220px;
        mix-blend-mode: overlay;
      }

      #ui {
        position: fixed;
        left: 18px;
        top: 18px;
        width: min(420px, calc(100vw - 36px));
        padding: 14px 14px 12px;
        border-radius: 18px;
        background: linear-gradient(180deg, var(--panel), var(--panel2));
        border: 1px solid var(--stroke);
        box-shadow: 0 18px 50px var(--shadow);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      #titleRow {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
      }
      #title {
        font-size: 14px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255,255,255,0.86);
      }
      #subtitle {
        font-size: 12px;
        color: var(--muted2);
        white-space: nowrap;
      }

      .control {
        padding: 10px 10px 10px;
        border-radius: 14px;
        border: 1px solid var(--stroke2);
        background: rgba(255,255,255,0.03);
        margin: 10px 0;
      }

      .labelRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 8px;
      }
      .label {
        display: flex;
        gap: 10px;
        align-items: center;
        color: rgba(255,255,255,0.9);
        font-weight: 560;
      }
      .label small {
        color: var(--muted2);
        font-weight: 520;
        letter-spacing: 0.02em;
      }
      .value {
        color: rgba(255,255,255,0.85);
        font-variant-numeric: tabular-nums;
        min-width: 84px;
        text-align: right;
      }

      input[type="range"] {
        width: 100%;
        appearance: none;
        height: 8px;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(105,210,255,0.55), rgba(130,255,181,0.45));
        outline: none;
      }
      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: radial-gradient(circle at 35% 30%, rgba(255,255,255,0.96), rgba(255,255,255,0.55));
        border: 1px solid rgba(255,255,255,0.28);
        box-shadow: 0 10px 25px rgba(0,0,0,0.38);
        cursor: pointer;
      }
      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: radial-gradient(circle at 35% 30%, rgba(255,255,255,0.96), rgba(255,255,255,0.55));
        border: 1px solid rgba(255,255,255,0.28);
        box-shadow: 0 10px 25px rgba(0,0,0,0.38);
        cursor: pointer;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        margin-top: 10px;
      }
      .btn {
        appearance: none;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(255,255,255,0.04);
        color: rgba(255,255,255,0.88);
        border-radius: 12px;
        padding: 10px 12px;
        cursor: pointer;
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
        user-select: none;
      }
      .btn:hover { background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.20); }
      .btn:active { transform: translateY(1px); }
      .btn.primary {
        border-color: rgba(105,210,255,0.28);
        background: rgba(105,210,255,0.08);
      }

      #help {
        margin-top: 10px;
        color: var(--muted2);
        font-size: 12px;
      }
      #help kbd {
        font: inherit;
        font-size: 12px;
        padding: 2px 6px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(0,0,0,0.18);
        color: rgba(255,255,255,0.84);
      }

      #corner {
        position: fixed;
        right: 18px;
        bottom: 16px;
        color: rgba(255,255,255,0.50);
        font-size: 12px;
        text-shadow: 0 6px 22px rgba(0,0,0,0.30);
        pointer-events: none;
      }

      #fallback {
        position: fixed;
        inset: 0;
        display: none;
        place-items: center;
        padding: 24px;
        background: radial-gradient(1000px 900px at 50% 20%, #243550, #070b12);
        color: rgba(255,255,255,0.9);
      }
      #fallback .card{
        max-width: 620px;
        border-radius: 18px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(0,0,0,0.30);
        padding: 18px;
        box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      }
      #fallback h1 { margin: 0 0 8px 0; font-size: 18px; letter-spacing: 0.02em; }
      #fallback p { margin: 6px 0; color: rgba(255,255,255,0.72); }

      @media (max-width: 520px) {
        #subtitle { display: none; }
        .value { min-width: 72px; }
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div id="overlayFX" aria-hidden="true"></div>

    <section id="ui" aria-label="Ocean controls">
      <div id="titleRow">
        <div id="title">Ocean Wave Simulation</div>
        <div id="subtitle">calm, realistic, responsive</div>
      </div>

      <div class="control">
        <div class="labelRow">
          <div class="label">Wind <small>(speed)</small></div>
          <div class="value" id="windVal">—</div>
        </div>
        <input id="wind" type="range" min="0" max="30" value="12" step="0.1" />
      </div>

      <div class="control">
        <div class="labelRow">
          <div class="label">Waves <small>(height)</small></div>
          <div class="value" id="heightVal">—</div>
        </div>
        <input id="height" type="range" min="0" max="3.5" value="1.3" step="0.01" />
      </div>

      <div class="control">
        <div class="labelRow">
          <div class="label">Light <small>(time of day)</small></div>
          <div class="value" id="lightVal">—</div>
        </div>
        <input id="light" type="range" min="0" max="1" value="0.62" step="0.001" />
      </div>

      <div class="row">
        <button class="btn primary" id="presetCalm" type="button" title="Gentle swell">Calm</button>
        <button class="btn" id="presetBreeze" type="button" title="Typical sea breeze">Breeze</button>
        <button class="btn" id="presetStorm" type="button" title="Rising wind and larger waves">Storm</button>
        <button class="btn" id="resetView" type="button" title="Reset camera">Reset view</button>
      </div>

      <div id="help">
        Drag to look • Scroll to zoom • <kbd>Space</kbd> pause • <kbd>F</kbd> fullscreen
      </div>
    </section>

    <div id="corner">procedural ocean • Gerstner waves • Fresnel lighting</div>

    <div id="fallback">
      <div class="card">
        <h1>Ocean Wave Simulation</h1>
        <p>This demo needs WebGL. If you’re seeing this message, your browser/device may have WebGL disabled.</p>
        <p>Try a modern browser (Chrome/Edge/Firefox/Safari) and make sure hardware acceleration is enabled.</p>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

      const app = document.getElementById("app");
      const fallback = document.getElementById("fallback");

      const windEl = document.getElementById("wind");
      const heightEl = document.getElementById("height");
      const lightEl = document.getElementById("light");
      const windVal = document.getElementById("windVal");
      const heightVal = document.getElementById("heightVal");
      const lightVal = document.getElementById("lightVal");

      const presetCalm = document.getElementById("presetCalm");
      const presetBreeze = document.getElementById("presetBreeze");
      const presetStorm = document.getElementById("presetStorm");
      const resetView = document.getElementById("resetView");

      const clamp01 = (x) => Math.min(1, Math.max(0, x));
      const lerp = (a, b, t) => a + (b - a) * t;
      const smoothstep = (e0, e1, x) => {
        const t = clamp01((x - e0) / (e1 - e0));
        return t * t * (3 - 2 * t);
      };

      const formatWind = (v) => `${v.toFixed(1)} m/s`;
      const formatHeight = (v) => `${v.toFixed(2)} m`;
      const lightLabel = (t) => {
        if (t < 0.18) return "Dawn";
        if (t < 0.40) return "Morning";
        if (t < 0.64) return "Day";
        if (t < 0.82) return "Evening";
        return "Dusk";
      };

      function setControlsUI() {
        const w = Number(windEl.value);
        const h = Number(heightEl.value);
        const l = Number(lightEl.value);
        windVal.textContent = formatWind(w);
        heightVal.textContent = formatHeight(h);
        lightVal.textContent = `${lightLabel(l)} • ${(l * 100).toFixed(0)}%`;
      }
      setControlsUI();

      // Basic WebGL capability check
      const testCanvas = document.createElement("canvas");
      const gl = testCanvas.getContext("webgl") || testCanvas.getContext("experimental-webgl");
      if (!gl) {
        fallback.style.display = "grid";
        throw new Error("WebGL unavailable");
      }

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050a12, 0.012);

      const camera = new THREE.PerspectiveCamera(52, 1, 0.1, 2000);
      const initialCam = {
        pos: new THREE.Vector3(0, 10.5, 22),
        target: new THREE.Vector3(0, 2.0, 0),
      };
      camera.position.copy(initialCam.pos);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
        powerPreference: "high-performance",
      });
      renderer.setClearColor(0x050a12, 1);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.shadowMap.enabled = false;
      renderer.useLegacyLights = false;
      app.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = false;
      controls.minDistance = 10;
      controls.maxDistance = 85;
      controls.minPolarAngle = 0.32;
      controls.maxPolarAngle = Math.PI * 0.48;
      controls.target.copy(initialCam.target);
      controls.update();

      // Lighting
      const sun = new THREE.DirectionalLight(0xffffff, 2.2);
      sun.position.set(40, 55, 22);
      scene.add(sun);
      const ambient = new THREE.AmbientLight(0x9bb4c8, 0.20);
      scene.add(ambient);

      const sharedUniforms = {
        uLighting: { value: Number(lightEl.value) },
        uSunDir: { value: new THREE.Vector3(0.4, 1.0, 0.2).normalize() },
      };

      // Sky dome (procedural gradient + sun glow)
      const skyGeo = new THREE.SphereGeometry(900, 64, 32);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        depthWrite: false,
        uniforms: {
          uSunDir: sharedUniforms.uSunDir,
          uLighting: sharedUniforms.uLighting,
        },
        vertexShader: `
          varying vec3 vDir;
          void main() {
            vDir = normalize(position);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          precision highp float;
          uniform vec3 uSunDir;
          uniform float uLighting;
          varying vec3 vDir;

          vec3 skyColor(vec3 dir, float t) {
            float day = smoothstep(0.22, 0.70, t);
            float dusk = smoothstep(0.72, 0.96, t);
            float dawn = 1.0 - smoothstep(0.04, 0.22, t);

            vec3 zenithDay = vec3(0.14, 0.44, 0.86);
            vec3 zenithNight = vec3(0.02, 0.07, 0.16);
            vec3 zenith = mix(zenithNight, zenithDay, day);

            vec3 horizonDay = vec3(0.55, 0.76, 0.92);
            vec3 horizonNight = vec3(0.06, 0.10, 0.16);
            vec3 horizon = mix(horizonNight, horizonDay, day);

            vec3 warm = vec3(1.0, 0.55, 0.23);
            float warmAmt = (dawn + dusk) * 0.65;

            float h = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0);
            float haze = smoothstep(0.0, 0.35, h);
            vec3 base = mix(horizon, zenith, pow(h, 1.35));
            base = mix(base, mix(base, warm, 0.75), warmAmt * (1.0 - haze));

            float sunDot = max(dot(normalize(dir), normalize(uSunDir)), 0.0);
            float sun = pow(sunDot, 680.0) * (0.95 + 0.8 * day);
            float corona = pow(sunDot, 26.0) * (0.18 + 0.75 * day);
            base += vec3(1.0, 0.90, 0.72) * (sun + corona);

            // Slight darkening overhead at dusk/dawn to keep calm contrast
            base *= 0.96 + 0.08 * day;
            return base;
          }

          void main() {
            vec3 dir = normalize(vDir);
            vec3 col = skyColor(dir, uLighting);

            // Extra horizon haze band for depth
            float band = smoothstep(-0.04, 0.12, dir.y) * (1.0 - smoothstep(0.12, 0.28, dir.y));
            col = mix(col, col + vec3(0.18, 0.22, 0.28), band * 0.18);

            gl_FragColor = vec4(col, 1.0);
          }
        `,
      });
      const sky = new THREE.Mesh(skyGeo, skyMat);
      scene.add(sky);

      // Ocean mesh (procedural Gerstner waves + Fresnel shading)
      const oceanSize = 520;
      const oceanSegments = 340; // balances quality/perf for most machines
      const oceanGeo = new THREE.PlaneGeometry(oceanSize, oceanSize, oceanSegments, oceanSegments);
      oceanGeo.rotateX(-Math.PI / 2);

      // Wave set (GPU Gems style)
      const WAVE_COUNT = 6;
      const waveDir = [
        new THREE.Vector2(1.0, 0.05).normalize(),
        new THREE.Vector2(0.8, 0.6).normalize(),
        new THREE.Vector2(0.2, 1.0).normalize(),
        new THREE.Vector2(-0.6, 0.8).normalize(),
        new THREE.Vector2(-1.0, 0.2).normalize(),
        new THREE.Vector2(0.4, -0.9).normalize(),
      ];
      const waveLengthBase = [18, 11, 7.5, 28, 44, 15];
      const waveAmpBase = [0.55, 0.22, 0.10, 0.40, 0.26, 0.16];
      const waveSteep = [0.45, 0.35, 0.25, 0.38, 0.26, 0.30];

      const uniforms = {
        // Required when `fog: true` on ShaderMaterial; three.js updates these each frame.
        fogColor: { value: new THREE.Color(0x050a12) },
        fogDensity: { value: 0.012 },
        uTime: { value: 0 },
        uWind: { value: 12.0 }, // m/s
        uWaveHeight: { value: 1.3 }, // meters (scales set)
        uLighting: sharedUniforms.uLighting, // 0..1
        uCameraPos: { value: new THREE.Vector3() },
        uSunDir: sharedUniforms.uSunDir,
        uWaveDir: { value: waveDir },
        uWaveLength: { value: new Array(WAVE_COUNT).fill(1).map((_, i) => waveLengthBase[i]) },
        uWaveAmp: { value: new Array(WAVE_COUNT).fill(1).map((_, i) => waveAmpBase[i]) },
        uWaveSteep: { value: new Array(WAVE_COUNT).fill(1).map((_, i) => waveSteep[i]) },
      };

      const oceanMat = new THREE.ShaderMaterial({
        uniforms,
        fog: true,
        transparent: false,
        vertexShader: `
          #define WAVE_COUNT ${WAVE_COUNT}
          uniform float uTime;
          uniform float uWind;
          uniform float uWaveHeight;
          uniform vec2 uWaveDir[WAVE_COUNT];
          uniform float uWaveLength[WAVE_COUNT];
          uniform float uWaveAmp[WAVE_COUNT];
          uniform float uWaveSteep[WAVE_COUNT];

          varying vec3 vWorldPos;
          varying vec3 vNormalW;
          varying float vCrest;

          #include <fog_pars_vertex>

          void main() {
            vec3 p = position;

            float wind01 = clamp(uWind / 30.0, 0.0, 1.0);
            float heightScale = max(0.0, uWaveHeight);

            // GPU Gems: build tangents/bitangents to derive normals
            vec3 T = vec3(1.0, 0.0, 0.0);
            vec3 B = vec3(0.0, 0.0, 1.0);
            float crest = 0.0;

            // Gravity controls dispersion; scale slightly with wind for a more "alive" sea.
            float g = 9.81;

            for (int i = 0; i < WAVE_COUNT; i++) {
              vec2 D = normalize(uWaveDir[i]);
              float L = mix(uWaveLength[i] * 0.70, uWaveLength[i] * 1.55, wind01);
              float k = 6.28318530718 / max(0.001, L);

              float A = uWaveAmp[i] * heightScale * mix(0.65, 1.35, wind01);
              float Q = clamp(uWaveSteep[i] * mix(0.78, 1.15, wind01), 0.05, 0.95);

              // Dispersion relation approximation; keep stable and smooth.
              float c = sqrt(g / max(0.0001, k)) * mix(0.55, 1.05, wind01);
              float w = c * k;

              float f = k * dot(D, p.xz) - w * uTime;
              float cosf = cos(f);
              float sinf = sin(f);

              float QA = Q * A;
              // Horizontal displacement for realism (kept small via Q)
              p.x += D.x * QA * cosf;
              p.z += D.y * QA * cosf;
              p.y += A * sinf;

              // Tangent/bitangent contributions
              T += vec3(
                -D.x * D.x * QA * k * sinf,
                 D.x * A * k * cosf,
                -D.x * D.y * QA * k * sinf
              );
              B += vec3(
                -D.x * D.y * QA * k * sinf,
                 D.y * A * k * cosf,
                -D.y * D.y * QA * k * sinf
              );

              crest += A * (sinf * 0.5 + 0.5);
            }

            vec3 n = normalize(cross(B, T));
            crest /= float(WAVE_COUNT);

            vec4 worldPos = modelMatrix * vec4(p, 1.0);
            vWorldPos = worldPos.xyz;
            vNormalW = normalize(mat3(modelMatrix) * n);
            vCrest = crest;

            vec4 mvPosition = viewMatrix * worldPos;
            gl_Position = projectionMatrix * mvPosition;

            #include <fog_vertex>
          }
        `,
        fragmentShader: `
          precision highp float;
          #define WAVE_COUNT ${WAVE_COUNT}

          uniform float uTime;
          uniform float uWind;
          uniform float uLighting;
          uniform vec3 uCameraPos;
          uniform vec3 uSunDir;

          varying vec3 vWorldPos;
          varying vec3 vNormalW;
          varying float vCrest;

          #include <fog_pars_fragment>

          float hash12(vec2 p) {
            vec3 p3 = fract(vec3(p.xyx) * 0.1031);
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
          }

          float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash12(i);
            float b = hash12(i + vec2(1.0, 0.0));
            float c = hash12(i + vec2(0.0, 1.0));
            float d = hash12(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
          }

          vec3 skyColor(vec3 dir, float t) {
            // t: 0..1 "time of day" (warm dawn/dusk, cooler midday)
            float day = smoothstep(0.22, 0.70, t);
            float dusk = smoothstep(0.72, 0.96, t);
            float dawn = 1.0 - smoothstep(0.04, 0.22, t);

            vec3 zenithDay = vec3(0.14, 0.44, 0.86);
            vec3 zenithNight = vec3(0.02, 0.07, 0.16);
            vec3 zenith = mix(zenithNight, zenithDay, day);

            vec3 horizonDay = vec3(0.55, 0.76, 0.92);
            vec3 horizonNight = vec3(0.06, 0.10, 0.16);
            vec3 horizon = mix(horizonNight, horizonDay, day);

            vec3 warm = vec3(1.0, 0.55, 0.23);
            float warmAmt = (dawn + dusk) * 0.65;

            float h = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0);
            float haze = smoothstep(0.0, 0.35, h);

            vec3 base = mix(horizon, zenith, pow(h, 1.35));
            base = mix(base, mix(base, warm, 0.75), warmAmt * (1.0 - haze));

            // Sun glow
            float sunDot = max(dot(normalize(dir), normalize(uSunDir)), 0.0);
            float sun = pow(sunDot, 420.0) * (0.9 + 0.8 * day);
            float corona = pow(sunDot, 28.0) * (0.22 + 0.65 * day);
            base += vec3(1.0, 0.88, 0.70) * (sun + corona);

            return base;
          }

          void main() {
            vec3 N = normalize(vNormalW);
            vec3 V = normalize(uCameraPos - vWorldPos);

            float wind01 = clamp(uWind / 30.0, 0.0, 1.0);

            vec3 L = normalize(uSunDir);
            vec3 H = normalize(L + V);

            // Fresnel (Schlick)
            float NoV = clamp(dot(N, V), 0.0, 1.0);
            float fresnel = pow(1.0 - NoV, 5.0);

            // Procedural sky reflection
            vec3 R = reflect(-V, N);
            vec3 sky = skyColor(R, uLighting);

            // Water base (absorption) shifts with lighting
            float day = smoothstep(0.22, 0.70, uLighting);
            vec3 deep = mix(vec3(0.01, 0.07, 0.09), vec3(0.01, 0.16, 0.20), day);
            vec3 shallow = mix(vec3(0.03, 0.14, 0.16), vec3(0.04, 0.22, 0.24), day);

            // Fake depth/attenuation using angle and small-scale noise
            float micro = noise(vWorldPos.xz * 0.06 + vec2(uTime * 0.02, -uTime * 0.018));
            float depthMix = clamp(0.25 + 0.85 * (1.0 - N.y) + 0.15 * micro, 0.0, 1.0);
            vec3 water = mix(shallow, deep, depthMix);

            // Sun highlights: tighter when calm, broader when windy
            float roughness = mix(0.08, 0.22, wind01);
            float shininess = mix(220.0, 90.0, roughness);
            float spec = pow(max(dot(N, H), 0.0), shininess);
            float NoL = max(dot(N, L), 0.0);
            vec3 specCol = vec3(1.0, 0.95, 0.86) * spec * (0.55 + 1.25 * day) * (0.35 + 0.65 * NoL);

            // Foam at crests + where surface is steep
            float steep = clamp(1.0 - N.y, 0.0, 1.0);
            float foamNoise = noise(vWorldPos.xz * 0.18 + vec2(uTime * 0.03, uTime * 0.018));
            float foamBase = smoothstep(0.58, 0.92, vCrest) * smoothstep(0.16, 0.55, steep);
            float foam = clamp(foamBase + (foamNoise - 0.5) * 0.22, 0.0, 1.0);
            foam *= mix(0.55, 1.0, wind01);
            vec3 foamCol = mix(vec3(0.88, 0.93, 0.96), vec3(0.98, 0.98, 0.98), day);

            // Combine: absorption + reflection + foam + spec
            vec3 col = water;
            col = mix(col, sky, clamp(0.06 + 0.94 * fresnel, 0.0, 1.0));
            col += specCol;
            col = mix(col, foamCol, foam);

            // Gentle horizon brightening (aerial perspective)
            float horizon = smoothstep(-0.02, 0.22, N.y) * (1.0 - smoothstep(0.0, 0.35, V.y));
            col += skyColor(vec3(0.0, 0.02, 1.0), uLighting) * horizon * 0.06;

            // Subtle desaturation in shadows
            float lum = dot(col, vec3(0.2126, 0.7152, 0.0722));
            col = mix(vec3(lum), col, 0.92);

            gl_FragColor = vec4(col, 1.0);
            #include <fog_fragment>
          }
        `,
      });

      const ocean = new THREE.Mesh(oceanGeo, oceanMat);
      ocean.frustumCulled = false;
      scene.add(ocean);

      // Horizon "mist" plane (cheap depth cue; keeps calming realism)
      const mistGeo = new THREE.CylinderGeometry(140, 220, 55, 96, 1, true);
      const mistMat = new THREE.MeshBasicMaterial({
        color: 0x0b1622,
        transparent: true,
        opacity: 0.22,
        side: THREE.DoubleSide,
        depthWrite: false,
      });
      const mist = new THREE.Mesh(mistGeo, mistMat);
      mist.position.y = 12;
      scene.add(mist);

      function updateSunFromLighting(t) {
        // Sun path: low at dawn/dusk, higher at midday; subtle azimuth sweep.
        const day = smoothstep(0.22, 0.70, t);
        const nearEnds = Math.abs(t - 0.5) * 2.0; // 0 at noon, 1 at edges
        const elevDeg = lerp(10, 64, 1.0 - smoothstep(0.0, 1.0, nearEnds));
        const elev = (elevDeg * Math.PI) / 180;

        const az = lerp(1.15, 2.55, t); // radians
        const dir = new THREE.Vector3(Math.cos(az) * Math.cos(elev), Math.sin(elev), Math.sin(az) * Math.cos(elev)).normalize();

        uniforms.uSunDir.value.copy(dir);

        // Light color warms near dawn/dusk
        const warm = new THREE.Color(0xffd2a1);
        const cool = new THREE.Color(0xffffff);
        const warmAmt = clamp01(1.0 - day) * 0.78;
        sun.color.copy(cool).lerp(warm, warmAmt);

        sun.intensity = lerp(0.75, 2.25, day) * lerp(1.05, 0.90, warmAmt);
        ambient.intensity = lerp(0.10, 0.26, day);

        // Fog density and mist opacity shift with lighting
        scene.fog.density = lerp(0.015, 0.010, day);
        mistMat.opacity = lerp(0.26, 0.18, day);

        renderer.toneMappingExposure = lerp(0.92, 1.08, day);
      }

      function applyInputsToUniforms() {
        const wind = Number(windEl.value);
        const height = Number(heightEl.value);
        const lighting = Number(lightEl.value);
        uniforms.uWind.value = wind;
        uniforms.uWaveHeight.value = height;
        uniforms.uLighting.value = lighting;
        updateSunFromLighting(lighting);
        setControlsUI();
      }

      windEl.addEventListener("input", applyInputsToUniforms);
      heightEl.addEventListener("input", applyInputsToUniforms);
      lightEl.addEventListener("input", applyInputsToUniforms);

      function tweenInputs(target, ms = 520) {
        const start = performance.now();
        const from = {
          wind: Number(windEl.value),
          height: Number(heightEl.value),
          light: Number(lightEl.value),
        };
        const to = { ...from, ...target };

        function easeOutCubic(x) {
          return 1 - Math.pow(1 - x, 3);
        }

        function frame(now) {
          const t = clamp01((now - start) / ms);
          const e = easeOutCubic(t);
          windEl.value = String(lerp(from.wind, to.wind, e));
          heightEl.value = String(lerp(from.height, to.height, e));
          lightEl.value = String(lerp(from.light, to.light, e));
          applyInputsToUniforms();
          if (t < 1) requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }

      presetCalm.addEventListener("click", () => tweenInputs({ wind: 6.5, height: 0.75, light: 0.62 }));
      presetBreeze.addEventListener("click", () => tweenInputs({ wind: 12.0, height: 1.30, light: 0.62 }));
      presetStorm.addEventListener("click", () => tweenInputs({ wind: 22.0, height: 2.45, light: 0.52 }));
      resetView.addEventListener("click", () => {
        tweenInputs({}); // no-op but keeps consistent feel
        camera.position.copy(initialCam.pos);
        controls.target.copy(initialCam.target);
        controls.update();
      });

      let paused = false;
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          paused = !paused;
        } else if (e.key.toLowerCase() === "f") {
          const el = document.documentElement;
          if (!document.fullscreenElement) el.requestFullscreen?.();
          else document.exitFullscreen?.();
        }
      }, { passive: false });

      function onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      }
      window.addEventListener("resize", onResize);
      onResize();

      // Animate
      const clock = new THREE.Clock();
      applyInputsToUniforms();

      // Keep ocean centered on camera to avoid precision artifacts while moving
      function centerOceanOnCamera() {
        const cx = camera.position.x;
        const cz = camera.position.z;
        ocean.position.x = Math.round(cx / 4) * 4;
        ocean.position.z = Math.round(cz / 4) * 4;
        mist.position.x = ocean.position.x;
        mist.position.z = ocean.position.z;
      }

      function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(0.033, clock.getDelta());
        if (!paused) uniforms.uTime.value += dt;
        uniforms.uCameraPos.value.copy(camera.position);

        sky.position.copy(camera.position);

        // Subtle breathing in mist for calmness
        const t = uniforms.uTime.value;
        mist.rotation.y = t * 0.02;
        mist.position.y = 11.5 + Math.sin(t * 0.35) * 0.15;

        controls.update();
        centerOceanOnCamera();
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
