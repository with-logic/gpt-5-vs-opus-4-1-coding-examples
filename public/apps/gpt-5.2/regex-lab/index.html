<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark light" />
    <title>Regex Lab</title>
    <style>
      :root {
        --bg: #070a12;
        --bg2: #0b1020;
        --panel: #0f172a;
        --panel2: #0b1226;
        --border: rgba(148, 163, 184, 0.18);
        --border2: rgba(148, 163, 184, 0.12);
        --text: #e5e7eb;
        --muted: rgba(229, 231, 235, 0.7);
        --muted2: rgba(229, 231, 235, 0.55);
        --shadow: rgba(0, 0, 0, 0.35);
        --accent: #38bdf8;
        --accent2: #a78bfa;
        --danger: #fb7185;
        --warn: #fbbf24;
        --ok: #34d399;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
        --r: 14px;
        --pad: 14px;
        --line: rgba(56, 189, 248, 0.2);
        --scan: rgba(56, 189, 248, 0.08);
        --g1: rgba(56, 189, 248, 0.36);
        --g2: rgba(167, 139, 250, 0.36);
        --g3: rgba(52, 211, 153, 0.32);
        --g4: rgba(251, 191, 36, 0.3);
        --g5: rgba(251, 113, 133, 0.3);
        --g6: rgba(244, 114, 182, 0.3);
        --g7: rgba(34, 211, 238, 0.32);
        --g8: rgba(148, 163, 184, 0.28);
      }
      html[data-theme="light"] {
        --bg: #f6f7fb;
        --bg2: #eef1f7;
        --panel: #ffffff;
        --panel2: #fbfcff;
        --border: rgba(15, 23, 42, 0.14);
        --border2: rgba(15, 23, 42, 0.1);
        --text: #0f172a;
        --muted: rgba(15, 23, 42, 0.66);
        --muted2: rgba(15, 23, 42, 0.52);
        --shadow: rgba(2, 6, 23, 0.12);
        --line: rgba(2, 132, 199, 0.16);
        --scan: rgba(2, 132, 199, 0.06);
        --g1: rgba(2, 132, 199, 0.22);
        --g2: rgba(109, 40, 217, 0.19);
        --g3: rgba(5, 150, 105, 0.18);
        --g4: rgba(217, 119, 6, 0.18);
        --g5: rgba(225, 29, 72, 0.16);
        --g6: rgba(190, 24, 93, 0.16);
        --g7: rgba(14, 116, 144, 0.16);
        --g8: rgba(71, 85, 105, 0.13);
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: var(--sans);
        background: radial-gradient(1200px 900px at 20% -10%, rgba(56, 189, 248, 0.18), transparent 60%),
          radial-gradient(900px 700px at 110% 10%, rgba(167, 139, 250, 0.18), transparent 55%),
          linear-gradient(180deg, var(--bg), var(--bg2));
        color: var(--text);
      }
      a {
        color: inherit;
      }
      .wrap {
        max-width: 1250px;
        margin: 0 auto;
        padding: 18px 16px 26px;
      }
      .window {
        border: 1px solid var(--border);
        border-radius: var(--r);
        overflow: hidden;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), transparent 50%), var(--panel);
        box-shadow: 0 18px 50px var(--shadow);
      }
      .titlebar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(56, 189, 248, 0.08), transparent 70%);
      }
      .dots {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .dot {
        width: 11px;
        height: 11px;
        border-radius: 50%;
        opacity: 0.85;
      }
      .dot.red {
        background: #ff5f57;
      }
      .dot.yellow {
        background: #febc2e;
      }
      .dot.green {
        background: #28c840;
      }
      .brand {
        display: flex;
        align-items: baseline;
        gap: 10px;
        min-width: 0;
      }
      .brand h1 {
        font-size: 14px;
        margin: 0;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-weight: 700;
      }
      .brand .sub {
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0.03));
        color: var(--text);
        font-size: 12px;
        cursor: pointer;
        user-select: none;
      }
      .btn:hover {
        border-color: rgba(56, 189, 248, 0.38);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.12);
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.primary {
        border-color: rgba(56, 189, 248, 0.5);
        background: linear-gradient(180deg, rgba(56, 189, 248, 0.22), rgba(56, 189, 248, 0.08));
      }
      .btn.danger {
        border-color: rgba(251, 113, 133, 0.42);
        background: linear-gradient(180deg, rgba(251, 113, 133, 0.18), rgba(251, 113, 133, 0.06));
      }
      .btn:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.18);
      }
      .btn svg {
        width: 16px;
        height: 16px;
        opacity: 0.9;
      }
      .grid {
        display: grid;
        gap: 12px;
        padding: 12px;
        grid-template-columns: 420px 1fr;
      }
      @media (max-width: 1050px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
      .card {
        border: 1px solid var(--border);
        border-radius: var(--r);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), transparent 45%), var(--panel2);
        overflow: hidden;
        position: relative;
      }
      .card::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, transparent, var(--scan), transparent);
        transform: translateX(-70%);
        pointer-events: none;
        opacity: 0.6;
        animation: scan 10s linear infinite;
      }
      @keyframes scan {
        0% {
          transform: translateX(-70%);
        }
        100% {
          transform: translateX(70%);
        }
      }
      html[data-theme="light"] .card::before {
        opacity: 0.4;
      }
      .card > * {
        position: relative;
      }
      .cardhead {
        padding: 10px 12px;
        border-bottom: 1px solid var(--border2);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .cardtitle {
        display: flex;
        flex-direction: column;
        gap: 2px;
        min-width: 0;
      }
      .cardtitle strong {
        font-size: 12px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }
      .cardtitle span {
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .cardbody {
        padding: var(--pad);
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .field {
        display: grid;
        gap: 6px;
      }
      label {
        font-size: 12px;
        color: var(--muted);
      }
      .input,
      textarea {
        width: 100%;
        background: rgba(15, 23, 42, 0.22);
        border: 1px solid var(--border);
        border-radius: 12px;
        color: var(--text);
        font-family: var(--mono);
        font-size: 13px;
        padding: 10px 12px;
        outline: none;
      }
      html[data-theme="light"] .input,
      html[data-theme="light"] textarea {
        background: rgba(2, 6, 23, 0.03);
      }
      .input:focus,
      textarea:focus {
        border-color: rgba(56, 189, 248, 0.5);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.12);
      }
      textarea {
        min-height: 220px;
        resize: vertical;
        line-height: 1.45;
        tab-size: 2;
      }
      .flags {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .flag {
        display: inline-flex;
        align-items: center;
        gap: 7px;
        padding: 7px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        font-size: 12px;
        cursor: pointer;
        user-select: none;
        background: rgba(255, 255, 255, 0.02);
      }
      .flag input {
        accent-color: var(--accent);
      }
      .flag code {
        font-family: var(--mono);
        font-size: 12px;
      }
      .hint {
        font-size: 12px;
        color: var(--muted2);
        line-height: 1.4;
      }
      .regex-preview {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--muted);
      }
      .regex-preview code {
        color: var(--text);
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.02);
        font-size: 12px;
      }
      .pill .kbd {
        font-family: var(--mono);
        opacity: 0.9;
        border: 1px solid var(--border2);
        background: rgba(255, 255, 255, 0.02);
        padding: 2px 6px;
        border-radius: 8px;
      }
      .inserts {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
        margin-top: 10px;
      }
      @media (max-width: 420px) {
        .inserts {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
      .chip {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 8px 10px;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .chip:hover {
        border-color: rgba(56, 189, 248, 0.35);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.1);
      }
      .chip:active {
        transform: translateY(1px);
      }
      .chip code {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--text);
      }
      .chip span {
        font-size: 11px;
        color: var(--muted2);
        white-space: nowrap;
      }
      .outputs {
        display: grid;
        gap: 12px;
        grid-template-rows: 1fr auto;
      }
      @media (max-width: 1050px) {
        .outputs {
          grid-template-rows: auto;
        }
      }
      .bottom {
        display: grid;
        gap: 12px;
        grid-template-columns: 1.2fr 1fr;
      }
      @media (max-width: 1050px) {
        .bottom {
          grid-template-columns: 1fr;
        }
      }
      .pre {
        font-family: var(--mono);
        font-size: 13px;
        line-height: 1.55;
        white-space: pre-wrap;
        word-break: break-word;
        margin: 0;
        padding: 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.02);
        min-height: 190px;
        overflow: auto;
      }
      .muted {
        color: var(--muted);
      }
      .errorbox {
        border: 1px solid rgba(251, 113, 133, 0.38);
        background: rgba(251, 113, 133, 0.09);
        color: var(--text);
        border-radius: 12px;
        padding: 10px 12px;
        font-family: var(--mono);
        font-size: 12px;
        margin-top: 10px;
      }
      .errorbox .title {
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: var(--sans);
        font-size: 12px;
        margin-bottom: 6px;
        color: rgba(251, 113, 133, 0.95);
        letter-spacing: 0.02em;
      }
      .marker {
        color: rgba(251, 113, 133, 0.95);
      }
      .hl {
        border-radius: 8px;
        padding: 0 2px;
        box-decoration-break: clone;
        -webkit-box-decoration-break: clone;
      }
      .hl.match {
        background: rgba(56, 189, 248, 0.12);
        outline: 1px solid rgba(56, 189, 248, 0.22);
      }
      .hl.match.focus {
        outline-color: rgba(56, 189, 248, 0.55);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.14);
      }
      .seg {
        border-bottom: 2px solid transparent;
      }
      .seg.g1 {
        background: var(--g1);
        border-bottom-color: rgba(56, 189, 248, 0.7);
      }
      .seg.g2 {
        background: var(--g2);
        border-bottom-color: rgba(167, 139, 250, 0.7);
      }
      .seg.g3 {
        background: var(--g3);
        border-bottom-color: rgba(52, 211, 153, 0.7);
      }
      .seg.g4 {
        background: var(--g4);
        border-bottom-color: rgba(251, 191, 36, 0.75);
      }
      .seg.g5 {
        background: var(--g5);
        border-bottom-color: rgba(251, 113, 133, 0.78);
      }
      .seg.g6 {
        background: var(--g6);
        border-bottom-color: rgba(244, 114, 182, 0.76);
      }
      .seg.g7 {
        background: var(--g7);
        border-bottom-color: rgba(34, 211, 238, 0.76);
      }
      .seg.g8 {
        background: var(--g8);
        border-bottom-color: rgba(148, 163, 184, 0.72);
      }
      .empty {
        display: inline-block;
        width: 10px;
        height: 1.2em;
        vertical-align: text-bottom;
        border-left: 2px dashed rgba(56, 189, 248, 0.6);
        margin: 0 1px;
        opacity: 0.85;
      }
      .tablewrap {
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.02);
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-family: var(--mono);
        font-size: 12px;
      }
      thead th {
        position: sticky;
        top: 0;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
        backdrop-filter: blur(8px);
        border-bottom: 1px solid var(--border);
        text-align: left;
        padding: 10px 10px;
        font-family: var(--sans);
        font-size: 12px;
        letter-spacing: 0.03em;
        text-transform: uppercase;
      }
      tbody td {
        border-top: 1px solid var(--border2);
        padding: 10px 10px;
        vertical-align: top;
      }
      tbody tr:hover td {
        background: rgba(56, 189, 248, 0.05);
      }
      .mono {
        font-family: var(--mono);
      }
      .tag {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.02);
        margin: 2px 6px 0 0;
        white-space: nowrap;
      }
      .tag i {
        width: 8px;
        height: 8px;
        border-radius: 3px;
        display: inline-block;
        background: var(--g8);
        border: 1px solid rgba(148, 163, 184, 0.38);
      }
      .tag .k {
        font-family: var(--sans);
        font-size: 11px;
        color: var(--muted);
      }
      .tag .v {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--text);
      }
      .tag.g1 i {
        background: var(--g1);
        border-color: rgba(56, 189, 248, 0.55);
      }
      .tag.g2 i {
        background: var(--g2);
        border-color: rgba(167, 139, 250, 0.55);
      }
      .tag.g3 i {
        background: var(--g3);
        border-color: rgba(52, 211, 153, 0.55);
      }
      .tag.g4 i {
        background: var(--g4);
        border-color: rgba(251, 191, 36, 0.6);
      }
      .tag.g5 i {
        background: var(--g5);
        border-color: rgba(251, 113, 133, 0.62);
      }
      .tag.g6 i {
        background: var(--g6);
        border-color: rgba(244, 114, 182, 0.6);
      }
      .tag.g7 i {
        background: var(--g7);
        border-color: rgba(34, 211, 238, 0.6);
      }
      .tag.g8 i {
        background: var(--g8);
        border-color: rgba(148, 163, 184, 0.55);
      }
      .explain {
        display: grid;
        gap: 10px;
      }
      .explain .tokens {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .tok {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.02);
        border-radius: 12px;
        padding: 8px 10px;
        min-width: min(260px, 100%);
        flex: 1 1 260px;
      }
      .tok code {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--text);
      }
      .tok p {
        margin: 6px 0 0;
        font-size: 12px;
        line-height: 1.4;
        color: var(--muted);
      }
      .statusbar {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        border-top: 1px solid var(--border);
        background: linear-gradient(180deg, transparent, rgba(255, 255, 255, 0.03));
        font-size: 12px;
        color: var(--muted);
      }
      .statusbar .left {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }
      .statusbar .right {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .toast {
        position: fixed;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        z-index: 999;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(15, 23, 42, 0.65);
        backdrop-filter: blur(10px);
        color: var(--text);
        box-shadow: 0 16px 40px var(--shadow);
        opacity: 0;
        pointer-events: none;
        transition: opacity 160ms ease, transform 160ms ease;
        font-size: 12px;
      }
      html[data-theme="light"] .toast {
        background: rgba(255, 255, 255, 0.72);
      }
      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-2px);
      }
      .sr {
        position: absolute !important;
        height: 1px;
        width: 1px;
        overflow: hidden;
        clip: rect(1px, 1px, 1px, 1px);
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="window" role="application" aria-label="Regex Lab">
        <div class="titlebar">
          <div class="brand" aria-label="Window title">
            <div class="dots" aria-hidden="true">
              <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
            </div>
            <h1>Regex Lab</h1>
            <div class="sub" id="subtitle">Learn · Test · Explain · Share</div>
          </div>
          <div class="toolbar">
            <button class="btn" id="btnTheme" type="button" title="Toggle theme">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z"
                  stroke="currentColor"
                  stroke-width="1.8"
                />
                <path
                  d="M12 2.5v2.2M12 19.3v2.2M21.5 12h-2.2M4.7 12H2.5M18.9 5.1l-1.6 1.6M6.7 17.3l-1.6 1.6M18.9 18.9l-1.6-1.6M6.7 6.7 5.1 5.1"
                  stroke="currentColor"
                  stroke-width="1.8"
                  stroke-linecap="round"
                />
              </svg>
              Theme
            </button>
            <button class="btn primary" id="btnCopyLink" type="button" title="Copy share link (pattern + flags)">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M10 13a5 5 0 0 1 0-7l.7-.7a5 5 0 0 1 7 7l-1 1"
                  stroke="currentColor"
                  stroke-width="1.8"
                  stroke-linecap="round"
                />
                <path
                  d="M14 11a5 5 0 0 1 0 7l-.7.7a5 5 0 0 1-7-7l1-1"
                  stroke="currentColor"
                  stroke-width="1.8"
                  stroke-linecap="round"
                />
              </svg>
              Share
            </button>
            <button class="btn" id="btnCopyRegex" type="button" title="Copy /pattern/flags">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M9 9h10v10H9V9Z"
                  stroke="currentColor"
                  stroke-width="1.8"
                  stroke-linejoin="round"
                />
                <path
                  d="M5 15H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v1"
                  stroke="currentColor"
                  stroke-width="1.8"
                  stroke-linecap="round"
                />
              </svg>
              Copy
            </button>
            <button class="btn danger" id="btnClear" type="button" title="Clear everything (Ctrl/⌘+K)">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M7 7h10M10 7V5.5A1.5 1.5 0 0 1 11.5 4h1A1.5 1.5 0 0 1 14 5.5V7"
                  stroke="currentColor"
                  stroke-width="1.8"
                  stroke-linecap="round"
                />
                <path
                  d="M9 10v8M15 10v8M6 7l1 14h10l1-14"
                  stroke="currentColor"
                  stroke-width="1.8"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
              Clear
            </button>
          </div>
        </div>

        <div class="grid">
          <section class="card" aria-label="Inputs">
            <div class="cardhead">
              <div class="cardtitle">
                <strong>Regex</strong>
                <span id="regexSummary">Type a pattern and watch results update live</span>
              </div>
              <div class="pill" title="Keyboard shortcuts">
                <span class="kbd">Ctrl/⌘+L</span><span class="muted">focus pattern</span>
              </div>
            </div>
            <div class="cardbody">
              <div class="field" style="margin-bottom: 10px">
                <label for="pattern">Pattern</label>
                <input
                  id="pattern"
                  class="input"
                  spellcheck="false"
                  autocomplete="off"
                  autocapitalize="off"
                  inputmode="text"
                  placeholder="e.g. (?&lt;user&gt;\\w+)@(?&lt;host&gt;[\\w.-]+)"
                />
                <div class="regex-preview" id="regexPreview"><span class="muted">Regex:</span> <code>//</code></div>
              </div>

              <div class="field" style="margin-bottom: 10px">
                <label>Flags</label>
                <div class="flags" id="flags">
                  <label class="flag" title="Global: find all matches">
                    <input type="checkbox" data-flag="g" />
                    <code>g</code><span class="muted">global</span>
                  </label>
                  <label class="flag" title="Ignore case">
                    <input type="checkbox" data-flag="i" />
                    <code>i</code><span class="muted">case-insensitive</span>
                  </label>
                  <label class="flag" title="Multiline: ^ and $ match line boundaries">
                    <input type="checkbox" data-flag="m" />
                    <code>m</code><span class="muted">multiline</span>
                  </label>
                  <label class="flag" title="DotAll: . matches newlines">
                    <input type="checkbox" data-flag="s" />
                    <code>s</code><span class="muted">dotAll</span>
                  </label>
                  <label class="flag" title="Unicode mode">
                    <input type="checkbox" data-flag="u" />
                    <code>u</code><span class="muted">unicode</span>
                  </label>
                  <label class="flag" title="Sticky: match only at lastIndex">
                    <input type="checkbox" data-flag="y" />
                    <code>y</code><span class="muted">sticky</span>
                  </label>
                </div>
                <div class="hint">
                  Tip: turn on <code class="mono">g</code> to see all matches. Sticky <code class="mono">y</code> steps through
                  contiguous matches via <code class="mono">lastIndex</code>.
                </div>
              </div>

              <div class="field">
                <label>Quick inserts</label>
                <div class="inserts" id="inserts" aria-label="Quick inserts"></div>
                <div class="hint" style="margin-top: 8px">
                  Inserts at the cursor in the pattern box. Most buttons place the caret inside the token.
                </div>
              </div>

              <div id="error" class="errorbox" style="display: none"></div>
            </div>
          </section>

          <section class="outputs" aria-label="Outputs">
            <section class="card" aria-label="Test text and highlight">
              <div class="cardhead">
                <div class="cardtitle">
                  <strong>Test Text</strong>
                  <span>Write text → see highlighted matches and groups</span>
                </div>
                <div class="row">
                  <span class="pill" title="Copy share link">
                    <span class="kbd">Ctrl/⌘+Shift+C</span><span class="muted">copy link</span>
                  </span>
                </div>
              </div>
              <div class="cardbody" style="display: grid; gap: 10px">
                <textarea
                  id="text"
                  spellcheck="false"
                  autocomplete="off"
                  autocapitalize="off"
                  placeholder="Paste or type test text here…"
                ></textarea>
                <div class="field">
                  <label>Highlighted matches</label>
                  <pre class="pre" id="highlight" aria-live="polite"></pre>
                </div>
              </div>
            </section>

            <section class="bottom" aria-label="Details">
              <section class="card" aria-label="Matches">
                <div class="cardhead">
                  <div class="cardtitle">
                    <strong>Matches</strong>
                    <span id="matchesSub">No matches yet</span>
                  </div>
                  <div class="row">
                    <button class="btn" id="btnCopyJSON" type="button" title="Copy match results as JSON">
                      <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                        <path
                          d="M7 7h10v10H7V7Z"
                          stroke="currentColor"
                          stroke-width="1.8"
                          stroke-linejoin="round"
                        />
                        <path
                          d="M8 12h8M8 15h6M8 9h7"
                          stroke="currentColor"
                          stroke-width="1.8"
                          stroke-linecap="round"
                        />
                      </svg>
                      JSON
                    </button>
                  </div>
                </div>
                <div class="cardbody">
                  <div class="tablewrap" style="max-height: 320px; overflow: auto">
                    <table aria-label="Match table">
                      <thead>
                        <tr>
                          <th style="width: 62px">#</th>
                          <th style="width: 110px">Index</th>
                          <th style="width: 110px">End</th>
                          <th>Match + Groups</th>
                        </tr>
                      </thead>
                      <tbody id="matchRows">
                        <tr>
                          <td colspan="4" class="muted" style="padding: 14px 10px">Run a regex to populate results.</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <div class="hint" id="indicesHint" style="margin-top: 10px"></div>
                </div>
              </section>

              <section class="card" aria-label="Explain">
                <div class="cardhead">
                  <div class="cardtitle">
                    <strong>Explain</strong>
                    <span>Common tokens, groups, and quantifiers (best-effort)</span>
                  </div>
                  <div class="row">
                    <span class="pill" title="This panel is a helper, not a full parser">
                      <span class="kbd">?</span><span class="muted">token guide</span>
                    </span>
                  </div>
                </div>
                <div class="cardbody">
                  <div class="explain">
                    <div class="hint" id="explainSummary"></div>
                    <div class="tokens" id="explainTokens"></div>
                  </div>
                </div>
              </section>
            </section>
          </section>
        </div>

        <div class="statusbar" role="status" aria-live="polite">
          <div class="left">
            <span id="statusMain">Ready.</span>
            <span id="statusFlags" class="muted"></span>
          </div>
          <div class="right">
            <span class="pill"><span class="kbd">Ctrl/⌘+K</span><span class="muted">clear</span></span>
            <span class="pill"><span class="kbd">Ctrl/⌘+Enter</span><span class="muted">copy regex</span></span>
          </div>
        </div>
      </div>
    </div>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <script>
      (() => {
        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

        const els = {
          html: document.documentElement,
          pattern: $("#pattern"),
          text: $("#text"),
          flagsWrap: $("#flags"),
          regexPreview: $("#regexPreview"),
          regexSummary: $("#regexSummary"),
          error: $("#error"),
          highlight: $("#highlight"),
          matchRows: $("#matchRows"),
          matchesSub: $("#matchesSub"),
          explainSummary: $("#explainSummary"),
          explainTokens: $("#explainTokens"),
          indicesHint: $("#indicesHint"),
          statusMain: $("#statusMain"),
          statusFlags: $("#statusFlags"),
          subtitle: $("#subtitle"),
          btnTheme: $("#btnTheme"),
          btnCopyLink: $("#btnCopyLink"),
          btnCopyRegex: $("#btnCopyRegex"),
          btnCopyJSON: $("#btnCopyJSON"),
          btnClear: $("#btnClear"),
          inserts: $("#inserts"),
          toast: $("#toast"),
        };

        const FLAG_ORDER = ["g", "i", "m", "s", "u", "y"];
        const FLAG_DESC = {
          g: "global",
          i: "ignoreCase",
          m: "multiline",
          s: "dotAll",
          u: "unicode",
          y: "sticky",
        };

        const supportsIndices = (() => {
          try {
            // eslint-disable-next-line no-new
            new RegExp("", "d");
            return true;
          } catch {
            return false;
          }
        })();

        const PALETTE_CLASS = (n) => `g${((n - 1) % 8) + 1}`;

        function escapeHTML(s) {
          return String(s)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
        }

        function toast(msg) {
          els.toast.textContent = msg;
          els.toast.classList.add("show");
          window.clearTimeout(toast._t);
          toast._t = window.setTimeout(() => els.toast.classList.remove("show"), 1200);
        }

        async function copyToClipboard(text) {
          try {
            await navigator.clipboard.writeText(text);
            toast("Copied.");
            return true;
          } catch {
            // Fallback for older browsers / sandboxed clipboard.
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.setAttribute("readonly", "");
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            document.body.appendChild(ta);
            ta.select();
            try {
              document.execCommand("copy");
              toast("Copied.");
              return true;
            } catch {
              toast("Copy failed.");
              return false;
            } finally {
              document.body.removeChild(ta);
            }
          }
        }

        function base64UrlEncode(str) {
          const bytes = new TextEncoder().encode(str);
          let bin = "";
          for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
          return btoa(bin).replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
        }

        function base64UrlDecode(str) {
          const pad = str.length % 4 === 0 ? "" : "=".repeat(4 - (str.length % 4));
          const b64 = (str + pad).replaceAll("-", "+").replaceAll("_", "/");
          const bin = atob(b64);
          const bytes = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
          return new TextDecoder().decode(bytes);
        }

        function getFlagsFromUI() {
          const picked = [];
          for (const f of FLAG_ORDER) {
            const cb = els.flagsWrap.querySelector(`input[data-flag="${f}"]`);
            if (cb?.checked) picked.push(f);
          }
          return picked.join("");
        }

        function setFlagsUI(flags) {
          const set = new Set(String(flags || "").split(""));
          for (const f of FLAG_ORDER) {
            const cb = els.flagsWrap.querySelector(`input[data-flag="${f}"]`);
            if (cb) cb.checked = set.has(f);
          }
        }

        function canonicalizeFlags(flags) {
          const set = new Set();
          for (const ch of String(flags || "")) {
            if (FLAG_ORDER.includes(ch)) set.add(ch);
          }
          return FLAG_ORDER.filter((f) => set.has(f)).join("");
        }

        function updateRegexPreview(pattern, flags) {
          const shown = `/${pattern || ""}/${flags || ""}`;
          els.regexPreview.innerHTML = `<span class="muted">Regex:</span> <code>${escapeHTML(shown)}</code>`;
          els.statusFlags.textContent = flags
            ? `flags: ${flags.split("").map((f) => `${f}=${FLAG_DESC[f]}`).join(", ")}`
            : "flags: (none)";
        }

        function setError(err, pattern) {
          if (!err) {
            els.error.style.display = "none";
            els.error.innerHTML = "";
            return;
          }
          const msg = String(err && err.message ? err.message : err);
          const pos = extractErrorPosition(msg);
          let markerBlock = "";
          if (typeof pos === "number" && pos >= 0) {
            const clipped = String(pattern || "");
            const caret = Math.min(pos, clipped.length);
            markerBlock = `\n\n${escapeHTML(clipped)}\n${" ".repeat(caret)}<span class="marker">^</span>`;
          }
          els.error.style.display = "block";
          els.error.innerHTML =
            `<div class="title">Invalid pattern</div>` +
            `<div>${escapeHTML(msg)}${markerBlock}</div>` +
            (supportsIndices
              ? ""
              : `<div class="hint" style="margin-top:8px">Tip: your browser may not support match indices (<code class="mono">/d</code>). Group highlighting and group ranges are best-effort.</div>`);
        }

        function extractErrorPosition(message) {
          // V8 often includes: "Invalid regular expression: ...: ... at position N"
          const m1 = /position\s+(\d+)/i.exec(message);
          if (m1) return Number(m1[1]);
          const m2 = /at\s+(\d+)/i.exec(message);
          if (m2) return Number(m2[1]);
          return null;
        }

        function buildRegex(pattern, flags) {
          const cleaned = canonicalizeFlags(flags);
          const extra = supportsIndices && !cleaned.includes("d") ? "d" : "";
          return { re: new RegExp(pattern, cleaned + extra), cleaned };
        }

        function safeExecAll(re, text, cleanedFlags) {
          const matches = [];
          re.lastIndex = 0;

          const iterative = cleanedFlags.includes("g") || cleanedFlags.includes("y");
          if (!iterative) {
            const m = re.exec(text);
            if (m) matches.push(m);
            return matches;
          }

          const max = 20000; // safety cap
          for (let step = 0; step < max; step++) {
            const m = re.exec(text);
            if (!m) break;
            matches.push(m);
            // Avoid infinite loops on empty matches
            if (m[0] === "") {
              re.lastIndex = Math.min(text.length, re.lastIndex + 1);
            }
          }
          return matches;
        }

        function getGroupRangesFromMatch(m) {
          // Returns array of { groupIndex, startRel, endRel, name? }
          const ranges = [];
          if (m.indices && Array.isArray(m.indices)) {
            const base = m.indices[0]?.[0] ?? m.index ?? 0;
            for (let gi = 1; gi < m.indices.length; gi++) {
              const r = m.indices[gi];
              if (!r || r[0] < 0 || r[1] < 0) continue;
              ranges.push({ groupIndex: gi, startRel: r[0] - base, endRel: r[1] - base });
            }
            if (m.indices.groups && typeof m.indices.groups === "object") {
              for (const [name, r] of Object.entries(m.indices.groups)) {
                if (!r || r[0] < 0 || r[1] < 0) continue;
                const rel = { startRel: r[0] - base, endRel: r[1] - base };
                // Attach name to the matching group index if possible
                const idx = ranges.findIndex(
                  (x) => x.startRel === rel.startRel && x.endRel === rel.endRel && !x.name
                );
                if (idx >= 0) ranges[idx].name = name;
                else ranges.push({ groupIndex: -1, ...rel, name });
              }
            }
            return ranges;
          }

          // Best-effort fallback: locate group strings sequentially within the full match.
          const full = String(m[0] ?? "");
          let cursor = 0;
          for (let gi = 1; gi < m.length; gi++) {
            const g = m[gi];
            if (g == null) continue;
            const str = String(g);
            const idx = full.indexOf(str, cursor);
            if (idx >= 0) {
              ranges.push({ groupIndex: gi, startRel: idx, endRel: idx + str.length });
              cursor = idx + str.length;
            }
          }
          if (m.groups && typeof m.groups === "object") {
            for (const [name, value] of Object.entries(m.groups)) {
              if (value == null) continue;
              const str = String(value);
              const idx = full.indexOf(str, 0);
              if (idx >= 0) ranges.push({ groupIndex: -1, startRel: idx, endRel: idx + str.length, name });
            }
          }
          return ranges;
        }

        function renderHighlighted(text, matches) {
          if (!text) return `<span class="muted">Type test text to see highlights.</span>`;
          if (!matches.length) return `<span class="muted">No matches.</span>\n\n${escapeHTML(text)}`;

          let out = "";
          let cursor = 0;
          for (let mi = 0; mi < matches.length; mi++) {
            const m = matches[mi];
            const start = m.indices?.[0]?.[0] ?? m.index ?? 0;
            const end = m.indices?.[0]?.[1] ?? start + String(m[0] ?? "").length;
            if (start > cursor) out += escapeHTML(text.slice(cursor, start));
            out += renderOneMatch(text.slice(start, end), getGroupRangesFromMatch(m), { mi, absStart: start, absEnd: end });
            cursor = end;
          }
          if (cursor < text.length) out += escapeHTML(text.slice(cursor));
          return out;
        }

        function renderOneMatch(matchedText, groupRanges, meta) {
          const s = String(matchedText);
          const id = meta && typeof meta.mi === "number" ? `hl-m${meta.mi}` : "";
          const rangeTitle =
            meta && typeof meta.absStart === "number" && typeof meta.absEnd === "number"
              ? `match [${meta.absStart}, ${meta.absEnd})`
              : "match";
          if (s === "")
            return `<span class="hl match" ${id ? `id="${id}"` : ""} title="${escapeHTML(
              rangeTitle
            )}"><span class="empty" title="Empty match"></span></span>`;

          const boundaries = new Set([0, s.length]);
          for (const r of groupRanges) {
            const a = Math.max(0, Math.min(s.length, r.startRel));
            const b = Math.max(0, Math.min(s.length, r.endRel));
            if (a !== b) {
              boundaries.add(a);
              boundaries.add(b);
            }
          }
          const points = Array.from(boundaries).sort((a, b) => a - b);

          const segments = [];
          for (let i = 0; i < points.length - 1; i++) {
            const a = points[i];
            const b = points[i + 1];
            if (a === b) continue;
            const best = pickBestRange(groupRanges, a, b);
            const cls = best ? `seg ${PALETTE_CLASS(best.groupIndex > 0 ? best.groupIndex : 8)}` : "seg";
            segments.push(`<span class="${cls}" title="${best ? groupTitle(best) : "match"}">${escapeHTML(s.slice(a, b))}</span>`);
          }
          return `<span class="hl match" ${id ? `id="${id}"` : ""} title="${escapeHTML(rangeTitle)}">${segments.join(
            ""
          )}</span>`;
        }

        function pickBestRange(ranges, a, b) {
          let best = null;
          for (const r of ranges) {
            if (typeof r.startRel !== "number" || typeof r.endRel !== "number") continue;
            if (a >= r.startRel && b <= r.endRel) {
              if (!best) best = r;
              else {
                const len = r.endRel - r.startRel;
                const bestLen = best.endRel - best.startRel;
                if (len < bestLen) best = r;
              }
            }
          }
          return best;
        }

        function groupTitle(r) {
          const label =
            r.groupIndex > 0 ? `Group ${r.groupIndex}${r.name ? ` (${r.name})` : ""}` : r.name ? `Group (${r.name})` : "Group";
          return `${label}: [${r.startRel}, ${r.endRel})`;
        }

        function renderMatchTable(matches, text) {
          if (!matches.length) {
            els.matchRows.innerHTML = `<tr><td colspan="4" class="muted" style="padding: 14px 10px">No matches.</td></tr>`;
            return;
          }
          const rows = [];
          for (let i = 0; i < matches.length; i++) {
            const m = matches[i];
            const start = m.indices?.[0]?.[0] ?? m.index ?? 0;
            const end = m.indices?.[0]?.[1] ?? start + String(m[0] ?? "").length;

            const parts = [];
            parts.push(`<span class="tag ${PALETTE_CLASS(8)}"><i></i><span class="k">match</span><span class="v">${escapeHTML(String(m[0] ?? ""))}</span></span>`);

            const namedGroups = m.groups && typeof m.groups === "object" ? m.groups : null;
            const ranges = getGroupRangesFromMatch(m);

            for (let gi = 1; gi < m.length; gi++) {
              const v = m[gi];
              const name = namedGroups
                ? Object.entries(namedGroups).find(([, val]) => val === v)?.[0]
                : null;
              const range = ranges.find((r) => r.groupIndex === gi) || null;
              const cls = PALETTE_CLASS(gi);
              const label = name ? `${gi}:${name}` : `${gi}`;
              const valText = v == null ? "∅" : String(v);
              const rangeText = range ? ` [${start + range.startRel}, ${start + range.endRel})` : "";
              parts.push(
                `<span class="tag ${cls}" title="${escapeHTML(`Group ${label}${rangeText}`)}"><i></i><span class="k">g${escapeHTML(label)}</span><span class="v">${escapeHTML(valText)}</span></span>`
              );
            }

            if (namedGroups) {
              for (const [name, v] of Object.entries(namedGroups)) {
                // Avoid duplicating groups already displayed by index lookup above
                if (m.includes(v)) continue;
                const cls = PALETTE_CLASS(7);
                const valText = v == null ? "∅" : String(v);
                parts.push(
                  `<span class="tag ${cls}" title="${escapeHTML(`Named group ${name}`)}"><i></i><span class="k">:${escapeHTML(
                    name
                  )}</span><span class="v">${escapeHTML(valText)}</span></span>`
                );
              }
            }

            rows.push(
              `<tr>
                <td>${i + 1}</td>
                <td>${start}</td>
                <td>${end}</td>
                <td>${parts.join("")}</td>
              </tr>`
            );
          }
          // Attach a stable click target for scrolling to the corresponding highlight.
          els.matchRows.innerHTML = rows
            .map((row, i) => row.replace("<tr>", `<tr data-mi="${i}" style="cursor:pointer">`))
            .join("");
        }

        function explainPattern(pattern) {
          const p = String(pattern ?? "");
          if (!p) return { summary: "Enter a pattern to see a token guide.", tokens: [] };

          let i = 0;
          const tokens = [];
          let groups = 0;
          let classes = 0;
          let alternations = 0;
          let escapes = 0;

          const push = (tok, desc) => tokens.push({ tok, desc });
          const readUntilUnescaped = (endCh) => {
            const start = i;
            i++; // skip opening char
            let escaped = false;
            for (; i < p.length; i++) {
              const ch = p[i];
              if (escaped) {
                escaped = false;
                continue;
              }
              if (ch === "\\") {
                escaped = true;
                continue;
              }
              if (ch === endCh) {
                i++; // include endCh
                return p.slice(start, i);
              }
            }
            return p.slice(start); // unterminated
          };

          while (i < p.length) {
            const ch = p[i];
            if (ch === "\\") {
              escapes++;
              const next = p[i + 1] ?? "";
              const two = `\\${next}`;
              const desc =
                next === "d"
                  ? "digit [0-9]"
                  : next === "D"
                    ? "non-digit"
                    : next === "w"
                      ? "word character [A-Za-z0-9_]"
                      : next === "W"
                        ? "non-word"
                        : next === "s"
                          ? "whitespace"
                          : next === "S"
                            ? "non-whitespace"
                            : next === "b"
                              ? "word boundary"
                              : next === "B"
                                ? "non-word boundary"
                                : /^[1-9]$/.test(next)
                                  ? "backreference"
                                  : next === "n"
                                    ? "newline"
                                    : next === "t"
                                      ? "tab"
                                      : next === "r"
                                        ? "carriage return"
                                        : next === "x"
                                          ? "hex escape (\\xHH)"
                                          : next === "u"
                                            ? "unicode escape (\\uHHHH or \\u{...})"
                                            : "escaped character";
              push(two, desc);
              i += 2;
              continue;
            }
            if (ch === "[") {
              classes++;
              const cls = readUntilUnescaped("]");
              const neg = cls.startsWith("[^") ? " (negated)" : "";
              push(cls.length > 44 ? cls.slice(0, 41) + "…]" : cls, "character class" + neg);
              continue;
            }
            if (ch === "(") {
              groups++;
              const ahead = p.slice(i, i + 4);
              if (ahead.startsWith("(?:")) {
                push("(?:…)", "non-capturing group");
                i += 3;
                continue;
              }
              if (p.slice(i, i + 4) === "(?=") {
                push("(?=…)", "positive lookahead");
                i += 3;
                continue;
              }
              if (p.slice(i, i + 4) === "(?!") {
                push("(?!…)", "negative lookahead");
                i += 3;
                continue;
              }
              if (p.slice(i, i + 4) === "(?<") {
                // Named capturing group or lookbehind
                if (p.slice(i, i + 5) === "(?<=") {
                  push("(?<=…)", "positive lookbehind");
                  i += 4;
                  continue;
                }
                if (p.slice(i, i + 5) === "(?<!") {
                  push("(?<!…)", "negative lookbehind");
                  i += 4;
                  continue;
                }
                push("(?<name>…)", "named capturing group");
                i += 3;
                continue;
              }
              push("(…)", "capturing group");
              i++;
              continue;
            }
            if (ch === "^") {
              push("^", "start of input (or line with m)");
              i++;
              continue;
            }
            if (ch === "$") {
              push("$", "end of input (or line with m)");
              i++;
              continue;
            }
            if (ch === ".") {
              push(".", "any character (except newline, unless s)");
              i++;
              continue;
            }
            if (ch === "|") {
              alternations++;
              push("|", "alternation (OR)");
              i++;
              continue;
            }
            if (ch === "*" || ch === "+" || ch === "?") {
              const lazy = p[i + 1] === "?" ? " (lazy)" : "";
              push(ch + (lazy ? "?" : ""), ch === "*" ? "0+ repeats" + lazy : ch === "+" ? "1+ repeats" + lazy : "optional" + lazy);
              i += lazy ? 2 : 1;
              continue;
            }
            if (ch === "{") {
              const m = /^\{(\d+)(,(\d+)?)?\}\??/.exec(p.slice(i));
              if (m) {
                const tok = m[0];
                const lazy = tok.endsWith("?") ? " (lazy)" : "";
                push(tok, "quantifier" + lazy);
                i += tok.length;
                continue;
              }
            }
            // default: literal
            if (ch === ")") {
              // group close; omit as token noise
              i++;
              continue;
            }
            push(ch, "literal");
            i++;
          }

          const summary = `${tokens.length} token(s) • ${groups} group(s) • ${classes} class(es) • ${alternations} alternation(s) • ${escapes} escape(s)`;
          // De-duplicate very noisy "literal" tokens, keep a curated list
          const curated = [];
          const seen = new Set();
          for (const t of tokens) {
            const key = `${t.tok}|${t.desc}`;
            if (t.desc === "literal" && t.tok.length === 1) continue;
            if (seen.has(key)) continue;
            seen.add(key);
            curated.push(t);
          }
          return { summary, tokens: curated.slice(0, 24) };
        }

        function renderExplain(pattern, flags) {
          const { summary, tokens } = explainPattern(pattern);
          els.explainSummary.innerHTML = `<span class="muted">${escapeHTML(summary)}</span>`;
          if (!pattern) {
            els.explainTokens.innerHTML =
              `<div class="tok"><code>\\d \\w \\s</code><p>Use quick inserts to explore common tokens.</p></div>` +
              `<div class="tok"><code>(?&lt;name&gt;…)</code><p>Named groups let you label captures; access via <span class="mono">match.groups</span>.</p></div>` +
              `<div class="tok"><code>^ $</code><p>Anchors match boundaries (line boundaries with <span class="mono">m</span>).</p></div>`;
            return;
          }
          const list = tokens.length
            ? tokens
                .map(
                  (t) =>
                    `<div class="tok"><code>${escapeHTML(t.tok)}</code><p>${escapeHTML(t.desc)}</p></div>`
                )
                .join("")
            : `<div class="tok"><code>${escapeHTML(pattern)}</code><p>No recognizable tokens (or pattern is all literals).</p></div>`;
          els.explainTokens.innerHTML = list;
          els.subtitle.textContent = flags ? `/${pattern}/${flags}` : `/${pattern}/`;
        }

        function updateIndicesHint(cleanedFlags) {
          const bits = [];
          bits.push(
            supportsIndices
              ? `Your browser supports match indices, so group ranges can be shown precisely.`
              : `Your browser doesn't support match indices (RegExp /d). Group highlighting is best-effort.`
          );
          if (!cleanedFlags.includes("g") && !cleanedFlags.includes("y")) {
            bits.push(`Tip: enable g to list all matches.`);
          }
          els.indicesHint.innerHTML = `<span class="muted">${escapeHTML(bits.join(" "))}</span>`;
        }

        function setStatus(ok, msg) {
          els.statusMain.textContent = msg;
          els.statusMain.style.color = ok ? "var(--muted)" : "var(--danger)";
        }

        let lastResult = { pattern: "", flags: "", matches: [], compiled: null, cleanedFlags: "", text: "" };
        let raf = 0;
        function schedule() {
          cancelAnimationFrame(raf);
          raf = requestAnimationFrame(run);
        }

        function run() {
          const pattern = els.pattern.value ?? "";
          const flags = getFlagsFromUI();
          const cleanedFlags = canonicalizeFlags(flags);
          const text = els.text.value ?? "";

          updateRegexPreview(pattern, cleanedFlags);
          updateIndicesHint(cleanedFlags);
          renderExplain(pattern, cleanedFlags);

          if (!pattern) {
            setError(null);
            setStatus(true, "Ready.");
            els.highlight.innerHTML = escapeHTML(text || "") || `<span class="muted">Type test text to see highlights.</span>`;
            els.matchesSub.textContent = "No pattern yet";
            renderMatchTable([], text);
            lastResult = { pattern, flags: cleanedFlags, matches: [], compiled: null, cleanedFlags, text };
            return;
          }

          let re;
          const t0 = performance.now();
          try {
            const built = buildRegex(pattern, cleanedFlags);
            re = built.re;
            setError(null);
          } catch (e) {
            setError(e, pattern);
            setStatus(false, "Pattern error.");
            els.highlight.innerHTML = `<span class="muted">Fix the pattern to see matches.</span>\n\n${escapeHTML(text || "")}`;
            els.matchesSub.textContent = "Invalid pattern";
            renderMatchTable([], text);
            lastResult = { pattern, flags: cleanedFlags, matches: [], compiled: null, cleanedFlags, text };
            return;
          }

          const matches = safeExecAll(re, text, cleanedFlags);
          const t1 = performance.now();

          els.highlight.innerHTML = renderHighlighted(text, matches);
          renderMatchTable(matches, text);

          const ms = Math.max(0, t1 - t0);
          const groupCount = matches.reduce((acc, m) => Math.max(acc, (m.length || 1) - 1), 0);
          const matchCount = matches.length;
          els.matchesSub.textContent = `${matchCount} match(es) • up to ${groupCount} capture group(s)`;
          setStatus(true, `Matched ${matchCount} time(s) in ${ms.toFixed(1)}ms.`);

          els.regexSummary.textContent = pattern.length ? "Live results (no run button needed)" : "Type a pattern to begin";
          lastResult = { pattern, flags: cleanedFlags, matches, compiled: re, cleanedFlags, text };

          // Keep permalink in sync (pattern + flags only, per spec)
          const hash = makeHash(pattern, cleanedFlags);
          const current = window.location.hash || "";
          if (current !== hash) {
            history.replaceState(null, "", hash);
          }
        }

        function makeHash(pattern, flags) {
          const payload = JSON.stringify({ p: pattern || "", f: flags || "" });
          return `#r=${base64UrlEncode(payload)}`;
        }

        function readHash() {
          const h = String(window.location.hash || "");
          const m = /^#r=([A-Za-z0-9_-]+)$/.exec(h);
          if (!m) return null;
          try {
            const obj = JSON.parse(base64UrlDecode(m[1]));
            if (!obj || typeof obj !== "object") return null;
            return { pattern: String(obj.p ?? ""), flags: canonicalizeFlags(obj.f ?? "") };
          } catch {
            return null;
          }
        }

        function setFromHashIfPresent() {
          const data = readHash();
          if (!data) return false;
          els.pattern.value = data.pattern;
          setFlagsUI(data.flags);
          schedule();
          return true;
        }

        function insertIntoPattern({ text, selectRel }) {
          const input = els.pattern;
          input.focus();
          const start = input.selectionStart ?? input.value.length;
          const end = input.selectionEnd ?? input.value.length;
          const before = input.value.slice(0, start);
          const after = input.value.slice(end);
          input.value = before + text + after;

          const base = before.length;
          if (selectRel && Array.isArray(selectRel) && selectRel.length === 2) {
            const [a, b] = selectRel;
            input.setSelectionRange(base + a, base + b);
          } else {
            const caret = base + text.length;
            input.setSelectionRange(caret, caret);
          }
          schedule();
        }

        function setupInserts() {
          const items = [
            { code: "\\d", label: "digit", text: "\\d" },
            { code: "\\w", label: "word", text: "\\w" },
            { code: "\\s", label: "space", text: "\\s" },
            { code: "[A-Z]", label: "class", text: "[A-Z]", selectRel: [1, 4] },
            { code: "(…)", label: "group", text: "()", selectRel: [1, 1] },
            { code: "(?:…)", label: "noncap", text: "(?:)", selectRel: [3, 3] },
            { code: "(?=…)", label: "ahead", text: "(?=)", selectRel: [3, 3] },
            { code: "(?!…)", label: "no-ahead", text: "(?!)", selectRel: [3, 3] },
            { code: "(?<name>…)", label: "named", text: "(?<name>)", selectRel: [3, 7] },
            { code: "{n,m}", label: "quant", text: "{1,3}", selectRel: [1, 4] },
            { code: "^", label: "start", text: "^" },
            { code: "$", label: "end", text: "$" },
          ];
          els.inserts.innerHTML = items
            .map(
              (it, idx) =>
                `<button class="chip" type="button" data-idx="${idx}" title="Insert ${escapeHTML(it.code)}">
                  <code>${escapeHTML(it.code)}</code><span>${escapeHTML(it.label)}</span>
                </button>`
            )
            .join("");
          els.inserts.addEventListener("click", (e) => {
            const btn = e.target.closest("button[data-idx]");
            if (!btn) return;
            const it = items[Number(btn.dataset.idx)];
            insertIntoPattern({ text: it.text, selectRel: it.selectRel });
          });
        }

        function setTheme(theme) {
          const t = theme === "light" ? "light" : "dark";
          els.html.setAttribute("data-theme", t);
          localStorage.setItem("regexlab-theme", t);
        }

        function toggleTheme() {
          const t = els.html.getAttribute("data-theme") === "light" ? "dark" : "light";
          setTheme(t);
          toast(t === "light" ? "Light theme" : "Dark theme");
        }

        function setDefaults() {
          const samplePattern = String.raw`(?<user>[A-Za-z0-9._%+-]+)@(?<host>[A-Za-z0-9.-]+\.[A-Za-z]{2,})`;
          const sampleText = [
            "Contacts:",
            "  admin@example.com",
            "  jane_doe+test@sub.domain.co",
            "  not-an-email@",
            "",
            "Try toggling flags (i, m, s, u, y) and editing the pattern.",
            "Tip: wrap with anchors ^...$ to validate full lines.",
          ].join("\n");
          els.pattern.value = samplePattern;
          setFlagsUI("g");
          els.text.value = sampleText;
        }

        function clearAll() {
          els.pattern.value = "";
          setFlagsUI("");
          els.text.value = "";
          history.replaceState(null, "", "#");
          els.subtitle.textContent = "Learn · Test · Explain · Share";
          schedule();
          toast("Cleared.");
        }

        function getShareUrl() {
          const pattern = els.pattern.value ?? "";
          const flags = canonicalizeFlags(getFlagsFromUI());
          const base = window.location.href.split("#")[0];
          return base + makeHash(pattern, flags);
        }

        function getRegexLiteral() {
          const pattern = els.pattern.value ?? "";
          const flags = canonicalizeFlags(getFlagsFromUI());
          // Not escaping slashes here; it's a learning tool and this is just a copy helper.
          return `/${pattern}/${flags}`;
        }

        function resultsAsJSON() {
          const out = [];
          for (const m of lastResult.matches) {
            const start = m.indices?.[0]?.[0] ?? m.index ?? 0;
            const end = m.indices?.[0]?.[1] ?? start + String(m[0] ?? "").length;
            const groups = [];
            for (let gi = 1; gi < m.length; gi++) {
              const value = m[gi] == null ? null : String(m[gi]);
              const r = m.indices?.[gi];
              groups.push({
                index: gi,
                value,
                start: r?.[0] ?? null,
                end: r?.[1] ?? null,
              });
            }
            out.push({
              match: String(m[0] ?? ""),
              start,
              end,
              groups,
              namedGroups: m.groups && typeof m.groups === "object" ? m.groups : null,
            });
          }
          return JSON.stringify(
            {
              pattern: lastResult.pattern,
              flags: lastResult.flags,
              count: out.length,
              matches: out,
            },
            null,
            2
          );
        }

        function setupEvents() {
          els.pattern.addEventListener("input", schedule);
          els.text.addEventListener("input", schedule);
          els.flagsWrap.addEventListener("change", schedule);

          els.btnTheme.addEventListener("click", toggleTheme);
          els.btnCopyLink.addEventListener("click", () => copyToClipboard(getShareUrl()));
          els.btnCopyRegex.addEventListener("click", () => copyToClipboard(getRegexLiteral()));
          els.btnCopyJSON.addEventListener("click", () => copyToClipboard(resultsAsJSON()));
          els.btnClear.addEventListener("click", clearAll);

          els.matchRows.addEventListener("click", (e) => {
            const row = e.target.closest("tr[data-mi]");
            if (!row) return;
            const mi = Number(row.dataset.mi);
            const target = document.getElementById(`hl-m${mi}`);
            if (!target) return;
            // Remove prior focus mark
            for (const el of $$(".hl.match.focus", els.highlight)) el.classList.remove("focus");
            target.classList.add("focus");
            target.scrollIntoView({ behavior: "smooth", block: "center", inline: "nearest" });
          });

          window.addEventListener("hashchange", () => {
            if (setFromHashIfPresent()) toast("Loaded from link.");
          });

          document.addEventListener("keydown", (e) => {
            const meta = e.ctrlKey || e.metaKey;
            if (!meta) return;
            if (e.key.toLowerCase() === "l") {
              e.preventDefault();
              els.pattern.focus();
              els.pattern.select();
            } else if (e.key.toLowerCase() === "k") {
              e.preventDefault();
              clearAll();
            } else if (e.key === "Enter") {
              e.preventDefault();
              copyToClipboard(getRegexLiteral());
            } else if (e.shiftKey && e.key.toLowerCase() === "c") {
              e.preventDefault();
              copyToClipboard(getShareUrl());
            }
          });
        }

        function init() {
          setupInserts();
          setupEvents();

          const storedTheme = localStorage.getItem("regexlab-theme");
          setTheme(storedTheme || "dark");

          const loaded = setFromHashIfPresent();
          if (!loaded) setDefaults();

          schedule();
        }

        init();
      })();
    </script>
  </body>
</html>
