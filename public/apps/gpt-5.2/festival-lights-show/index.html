<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="dark" />
    <title>Festival Lights Show</title>
    <style>
      :root {
        --bg0: #050511;
        --bg1: #0a0820;
        --ink: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.66);
        --faint: rgba(255, 255, 255, 0.12);
        --panel: rgba(12, 10, 28, 0.62);
        --panel2: rgba(18, 14, 42, 0.54);
        --stroke: rgba(255, 255, 255, 0.12);
        --stroke2: rgba(255, 255, 255, 0.18);
        --glow: 0 0 18px rgba(120, 72, 255, 0.26), 0 0 60px rgba(0, 230, 255, 0.16);
        --glow2: 0 0 16px rgba(255, 76, 220, 0.22), 0 0 54px rgba(255, 204, 0, 0.12);
        --radius: 16px;
        --radius2: 22px;
        --shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
        --shadow2: 0 10px 28px rgba(0, 0, 0, 0.4);
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: var(--sans);
        background: radial-gradient(1200px 900px at 12% 14%, rgba(90, 64, 255, 0.18), transparent 55%),
          radial-gradient(900px 700px at 84% 22%, rgba(0, 255, 210, 0.12), transparent 55%),
          radial-gradient(900px 700px at 48% 88%, rgba(255, 76, 220, 0.12), transparent 55%),
          linear-gradient(160deg, var(--bg0), var(--bg1));
        color: var(--ink);
        overflow: hidden;
      }

      #app {
        position: fixed;
        inset: 0;
      }

      canvas#stage {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        background: radial-gradient(1400px 900px at 50% 50%, rgba(255, 255, 255, 0.03), transparent 60%);
        cursor: crosshair;
      }

      .grain {
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0.08;
        mix-blend-mode: overlay;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='140' height='140'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='140' height='140' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
        background-size: 180px 180px;
      }

      .topbar {
        position: absolute;
        top: 14px;
        left: 14px;
        right: 14px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: center;
        pointer-events: none;
      }

      .brand {
        pointer-events: auto;
        display: inline-flex;
        align-items: center;
        gap: 12px;
        padding: 10px 12px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(22, 14, 52, 0.62), rgba(12, 10, 28, 0.42));
        box-shadow: var(--shadow2), var(--glow);
        backdrop-filter: blur(10px) saturate(1.2);
        -webkit-backdrop-filter: blur(10px) saturate(1.2);
        max-width: min(620px, 100%);
      }
      .logo {
        width: 34px;
        height: 34px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: radial-gradient(circle at 20% 30%, rgba(0, 255, 234, 0.9), transparent 55%),
          radial-gradient(circle at 70% 35%, rgba(255, 76, 220, 0.92), transparent 52%),
          radial-gradient(circle at 40% 75%, rgba(255, 224, 0, 0.75), transparent 55%),
          linear-gradient(135deg, rgba(90, 64, 255, 0.6), rgba(0, 0, 0, 0));
        box-shadow: 0 0 20px rgba(0, 255, 234, 0.22), 0 0 28px rgba(255, 76, 220, 0.14);
      }
      .brand h1 {
        margin: 0;
        font-size: 14px;
        line-height: 1.15;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .brand .sub {
        display: block;
        margin-top: 2px;
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.01em;
        text-transform: none;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .statusPills {
        pointer-events: auto;
        display: inline-flex;
        gap: 10px;
        align-items: center;
        justify-content: flex-end;
      }
      .pill {
        padding: 8px 10px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(22, 14, 52, 0.52), rgba(12, 10, 28, 0.36));
        box-shadow: var(--shadow2);
        backdrop-filter: blur(10px) saturate(1.2);
        -webkit-backdrop-filter: blur(10px) saturate(1.2);
        font-size: 12px;
        color: var(--muted);
        display: inline-flex;
        align-items: center;
        gap: 10px;
        user-select: none;
      }
      .dot {
        width: 9px;
        height: 9px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.18);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      }
      .dot.live {
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.95), rgba(0, 255, 210, 0.5));
        box-shadow: 0 0 16px rgba(0, 255, 210, 0.22), 0 0 30px rgba(120, 72, 255, 0.15);
      }
      .meter {
        width: 120px;
        height: 7px;
        border-radius: 99px;
        background: rgba(255, 255, 255, 0.08);
        overflow: hidden;
        position: relative;
      }
      .meter > i {
        position: absolute;
        inset: 0 auto 0 0;
        width: 0%;
        border-radius: 99px;
        background: linear-gradient(90deg, rgba(0, 255, 210, 0.75), rgba(255, 76, 220, 0.85), rgba(255, 224, 0, 0.7));
        box-shadow: 0 0 18px rgba(255, 76, 220, 0.2);
        transition: width 60ms linear;
      }

      .panel {
        position: absolute;
        right: 14px;
        bottom: 14px;
        width: min(520px, calc(100vw - 28px));
        max-height: min(74vh, 760px);
        border-radius: var(--radius2);
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(20, 14, 48, 0.68), rgba(12, 10, 28, 0.48));
        box-shadow: var(--shadow), var(--glow2);
        backdrop-filter: blur(14px) saturate(1.25);
        -webkit-backdrop-filter: blur(14px) saturate(1.25);
        overflow: hidden;
        pointer-events: auto;
      }
      .panelHeader {
        padding: 12px 14px 10px 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        background: linear-gradient(90deg, rgba(255, 76, 220, 0.12), rgba(0, 255, 210, 0.1), rgba(90, 64, 255, 0.1));
      }
      .panelHeader .title {
        display: flex;
        align-items: baseline;
        gap: 10px;
        min-width: 0;
      }
      .panelHeader .title b {
        font-size: 13px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .panelHeader .title span {
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 260px;
      }
      .panelHeader .right {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .grid {
        padding: 12px 14px 14px 14px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        overflow: auto;
        max-height: inherit;
      }
      .card {
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
        border-radius: var(--radius);
        padding: 12px;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
        position: relative;
        overflow: hidden;
      }
      .card::before {
        content: "";
        position: absolute;
        inset: -2px;
        background: radial-gradient(420px 220px at 12% 18%, rgba(0, 255, 210, 0.14), transparent 62%),
          radial-gradient(420px 220px at 90% 18%, rgba(255, 76, 220, 0.12), transparent 60%),
          radial-gradient(420px 260px at 50% 100%, rgba(255, 224, 0, 0.1), transparent 60%);
        opacity: 0.7;
        pointer-events: none;
      }
      .card > * {
        position: relative;
      }
      .card h3 {
        margin: 0 0 10px 0;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.86);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .badge {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.72);
        border: 1px solid rgba(255, 255, 255, 0.14);
        padding: 4px 8px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.2);
        font-family: var(--mono);
      }

      label {
        display: grid;
        gap: 6px;
        margin-top: 10px;
        font-size: 12px;
        color: var(--muted);
        user-select: none;
      }
      label:first-of-type {
        margin-top: 0;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .row > * {
        flex: 1;
      }

      select,
      button,
      input[type="range"],
      input[type="color"],
      input[type="file"],
      input[type="text"] {
        font-family: inherit;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.92);
      }
      select,
      input[type="text"] {
        width: 100%;
        padding: 10px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.25);
        outline: none;
        box-shadow: 0 0 0 0 rgba(120, 72, 255, 0.0);
      }
      select:focus,
      input[type="text"]:focus {
        border-color: rgba(0, 255, 210, 0.35);
        box-shadow: 0 0 0 3px rgba(0, 255, 210, 0.12);
      }
      input[type="range"] {
        width: 100%;
        accent-color: rgba(0, 255, 210, 0.85);
      }
      input[type="color"] {
        width: 46px;
        height: 38px;
        padding: 0;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.25);
        border-radius: 12px;
        overflow: hidden;
      }
      input[type="file"] {
        width: 100%;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px dashed rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.18);
      }

      .btnRow {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }
      button {
        cursor: pointer;
        padding: 10px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(0, 0, 0, 0.2));
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
        transition: transform 120ms ease, border-color 120ms ease, filter 120ms ease;
        user-select: none;
      }
      button:hover {
        transform: translateY(-1px);
        border-color: rgba(0, 255, 210, 0.22);
        filter: brightness(1.06);
      }
      button:active {
        transform: translateY(0px);
        filter: brightness(0.98);
      }
      button.primary {
        border-color: rgba(0, 255, 210, 0.25);
        background: linear-gradient(180deg, rgba(0, 255, 210, 0.14), rgba(0, 0, 0, 0.25));
        box-shadow: 0 14px 30px rgba(0, 255, 210, 0.08), 0 18px 50px rgba(0, 0, 0, 0.4);
      }
      button.danger {
        border-color: rgba(255, 76, 220, 0.25);
        background: linear-gradient(180deg, rgba(255, 76, 220, 0.14), rgba(0, 0, 0, 0.25));
      }
      button.ghost {
        background: rgba(0, 0, 0, 0.12);
        box-shadow: none;
      }
      button.small {
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 12px;
      }

      .toggles {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.2);
        cursor: pointer;
        user-select: none;
      }
      .toggle input {
        display: none;
      }
      .toggle i {
        width: 34px;
        height: 18px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.22) inset;
      }
      .toggle i::after {
        content: "";
        position: absolute;
        top: 1px;
        left: 1px;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.88);
        transition: transform 140ms ease, background 140ms ease;
      }
      .toggle input:checked + i {
        background: linear-gradient(90deg, rgba(0, 255, 210, 0.7), rgba(255, 76, 220, 0.6));
        border-color: rgba(0, 255, 210, 0.22);
        box-shadow: 0 0 18px rgba(0, 255, 210, 0.16);
      }
      .toggle input:checked + i::after {
        transform: translateX(16px);
        background: rgba(255, 255, 255, 0.95);
      }
      .toggle span {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.86);
      }

      .kbd {
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(255, 255, 255, 0.72);
        border: 1px solid rgba(255, 255, 255, 0.14);
        padding: 3px 7px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.2);
        white-space: nowrap;
      }

      .footerNote {
        grid-column: 1 / -1;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(0, 0, 0, 0.16);
        color: rgba(255, 255, 255, 0.7);
        display: flex;
        gap: 10px;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        pointer-events: none;
      }
      .overlay .gate {
        pointer-events: auto;
        width: min(620px, calc(100vw - 30px));
        border-radius: 26px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: linear-gradient(180deg, rgba(20, 14, 48, 0.75), rgba(12, 10, 28, 0.52));
        box-shadow: var(--shadow), var(--glow);
        backdrop-filter: blur(16px) saturate(1.2);
        -webkit-backdrop-filter: blur(16px) saturate(1.2);
        padding: 16px;
      }
      .gateHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
        margin-bottom: 12px;
      }
      .gateHeader h2 {
        margin: 0;
        font-size: 16px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }
      .gateHeader p {
        margin: 3px 0 0 0;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.35;
      }
      .gateHeader .burst {
        width: 44px;
        height: 44px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: radial-gradient(circle at 30% 35%, rgba(0, 255, 210, 0.9), transparent 55%),
          radial-gradient(circle at 70% 30%, rgba(255, 76, 220, 0.86), transparent 55%),
          radial-gradient(circle at 55% 78%, rgba(255, 224, 0, 0.72), transparent 58%),
          rgba(0, 0, 0, 0.18);
        box-shadow: 0 0 32px rgba(0, 255, 210, 0.12), 0 0 38px rgba(255, 76, 220, 0.1);
      }
      .gateActions {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 12px;
      }
      .hintRow {
        margin-top: 10px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        color: rgba(255, 255, 255, 0.7);
        font-size: 12px;
      }
      .hintRow .kbd {
        opacity: 0.95;
      }

      .minBtn {
        width: 40px;
        height: 36px;
        border-radius: 12px;
        display: grid;
        place-items: center;
      }
      .hamburger {
        width: 16px;
        height: 12px;
        display: grid;
        gap: 3px;
      }
      .hamburger i {
        height: 2px;
        border-radius: 2px;
        background: rgba(255, 255, 255, 0.82);
        box-shadow: 0 0 14px rgba(0, 255, 210, 0.12);
      }

      .panel.collapsed {
        width: 56px;
        height: 52px;
        border-radius: 18px;
        overflow: hidden;
      }
      .panel.collapsed .grid,
      .panel.collapsed .panelHeader .title,
      .panel.collapsed .panelHeader .right .notWhenCollapsed {
        display: none !important;
      }

      .panelHeader .right .minBtn {
        margin-left: 4px;
      }

      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
        .panelHeader .title span {
          display: none;
        }
        .statusPills .meter {
          width: 90px;
        }
      }
      @media (max-width: 540px) {
        .topbar {
          left: 10px;
          right: 10px;
          top: 10px;
        }
        .panel {
          left: 10px;
          right: 10px;
          bottom: 10px;
          width: auto;
        }
        .btnRow {
          grid-template-columns: 1fr 1fr;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          scroll-behavior: auto !important;
        }
        button,
        .toggle i::after,
        .meter > i {
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas id="stage" aria-label="Virtual light show canvas"></canvas>
      <div class="grain" aria-hidden="true"></div>

      <div class="topbar">
        <div class="brand" title="Click the stage to launch bursts • Drag to paint • Scroll to zoom intensity">
          <div class="logo" aria-hidden="true"></div>
          <div style="min-width: 0">
            <h1>Festival Lights Show</h1>
            <span class="sub">Color • Patterns • Music sync • Click to burst</span>
          </div>
        </div>

        <div class="statusPills">
          <div class="pill" title="Audio state & beat">
            <span class="dot" id="audioDot" aria-hidden="true"></span>
            <span id="audioLabel">Audio: Off</span>
            <span class="meter" aria-hidden="true"><i id="energyBar"></i></span>
          </div>
          <div class="pill" title="Tempo & frame time">
            <span class="badge" id="bpmBadge">BPM 124</span>
            <span class="badge" id="fpsBadge">60 FPS</span>
          </div>
        </div>
      </div>

      <div class="panel" id="panel">
        <div class="panelHeader">
          <div class="title">
            <b>Control Deck</b>
            <span id="sceneSubtitle">Neon Parade • synced glow</span>
          </div>
          <div class="right">
            <button class="small ghost notWhenCollapsed" id="btnHelp" title="Keyboard shortcuts">
              Shortcuts
            </button>
            <button class="minBtn ghost" id="btnCollapse" title="Collapse panel">
              <span class="hamburger" aria-hidden="true"><i></i><i></i><i></i></span>
            </button>
          </div>
        </div>

        <div class="grid" id="grid">
          <section class="card">
            <h3>
              Show
              <span class="badge" id="presetBadge">Preset</span>
            </h3>
            <label>
              Preset
              <select id="preset">
                <option value="neonParade">Neon Parade</option>
                <option value="sunsetPulse">Sunset Pulse</option>
                <option value="laserGrid">Laser Grid</option>
                <option value="cosmicBloom">Cosmic Bloom</option>
                <option value="iceAurora">Ice Aurora</option>
                <option value="emberCarnival">Ember Carnival</option>
              </select>
            </label>
            <label>
              Pattern
              <select id="pattern">
                <option value="aurora">Aurora Flow</option>
                <option value="rainbowWave">Rainbow Wave</option>
                <option value="chase">Chase Lines</option>
                <option value="spiral">Spiral Vortex</option>
                <option value="sparkle">Sparkle Field</option>
                <option value="fire">Ember Rise</option>
                <option value="strobe">Strobe</option>
              </select>
            </label>
            <div class="btnRow">
              <button class="primary" id="btnRandom">Randomize</button>
              <button class="danger" id="btnBlackout">Blackout</button>
              <button id="btnBurst">Burst</button>
            </div>
            <div class="toggles">
              <label class="toggle" title="Sync motion & brightness to audio energy">
                <input type="checkbox" id="sync" checked />
                <i aria-hidden="true"></i>
                <span>Music Sync</span>
              </label>
              <label class="toggle" title="More glow and bloom (GPU heavier)">
                <input type="checkbox" id="bloom" checked />
                <i aria-hidden="true"></i>
                <span>Bloom</span>
              </label>
              <label class="toggle" title="Paint bursts by dragging on the stage">
                <input type="checkbox" id="paint" checked />
                <i aria-hidden="true"></i>
                <span>Paint</span>
              </label>
            </div>
          </section>

          <section class="card">
            <h3>
              Color
              <span class="badge" id="colorModeBadge">Gradient</span>
            </h3>
            <label>
              Color Mode
              <select id="colorMode">
                <option value="gradient">Gradient (2 colors)</option>
                <option value="palette">Palette (3 colors)</option>
                <option value="single">Single + Rainbow Drift</option>
              </select>
            </label>
            <div class="row" style="margin-top: 10px">
              <label style="margin: 0">
                A
                <div class="row" style="gap: 8px">
                  <input type="color" id="cA" value="#00ffe0" />
                  <input type="text" id="cATxt" value="#00FFE0" spellcheck="false" />
                </div>
              </label>
              <label style="margin: 0">
                B
                <div class="row" style="gap: 8px">
                  <input type="color" id="cB" value="#ff4cdc" />
                  <input type="text" id="cBTxt" value="#FF4CDC" spellcheck="false" />
                </div>
              </label>
            </div>
            <label>
              C (palette)
              <div class="row" style="gap: 8px">
                <input type="color" id="cC" value="#ffe000" />
                <input type="text" id="cCTxt" value="#FFE000" spellcheck="false" />
              </div>
            </label>
            <label>
              Hue Drift
              <input id="hueDrift" type="range" min="0" max="1" step="0.001" value="0.38" />
            </label>
            <label>
              Saturation
              <input id="sat" type="range" min="0" max="1" step="0.001" value="0.92" />
            </label>
          </section>

          <section class="card">
            <h3>
              Motion
              <span class="badge" id="speedBadge">Speed</span>
            </h3>
            <label>
              Speed
              <input id="speed" type="range" min="0" max="2" step="0.001" value="1.0" />
            </label>
            <label>
              Intensity
              <input id="intensity" type="range" min="0" max="2" step="0.001" value="1.0" />
            </label>
            <label>
              Detail
              <input id="detail" type="range" min="0" max="1" step="0.001" value="0.58" />
            </label>
            <label>
              Trails
              <input id="trails" type="range" min="0" max="1" step="0.001" value="0.72" />
            </label>
            <label>
              Zoom
              <input id="zoom" type="range" min="0.6" max="2.2" step="0.001" value="1.15" />
            </label>
          </section>

          <section class="card">
            <h3>
              Audio
              <span class="badge" id="audioModeBadge">Synth</span>
            </h3>
            <label>
              Source
              <select id="audioMode">
                <option value="synth">Built-in Synth</option>
                <option value="file">Audio File</option>
              </select>
            </label>
            <label id="fileRow" style="display: none">
              Load audio
              <input type="file" id="audioFile" accept="audio/*" />
            </label>
            <div class="btnRow">
              <button class="primary" id="btnPlay">Play</button>
              <button id="btnTap">Tap Tempo</button>
              <button id="btnStop">Stop</button>
            </div>
            <label>
              Volume
              <input id="volume" type="range" min="0" max="1" step="0.001" value="0.78" />
            </label>
            <label>
              Tempo (BPM)
              <input id="tempo" type="range" min="60" max="180" step="1" value="124" />
            </label>
            <label>
              Beat Sensitivity
              <input id="sensitivity" type="range" min="0" max="1" step="0.001" value="0.34" />
            </label>
          </section>

          <div class="footerNote">
            <div>
              <span class="kbd">Space</span> play/pause · <span class="kbd">R</span> random ·
              <span class="kbd">B</span> blackout · <span class="kbd">C</span> collapse
            </div>
            <div style="font-family: var(--mono); opacity: 0.85" id="hintLine">Click stage: burst</div>
          </div>
        </div>
      </div>

      <div class="overlay" id="overlay">
        <div class="gate">
          <div class="gateHeader">
            <div>
              <h2>Start the Show</h2>
              <p>
                Tap to enable audio and sync the lights. Use built-in synth or load a song. Click the stage to launch
                bursts.
              </p>
            </div>
            <div class="burst" aria-hidden="true"></div>
          </div>
          <div class="gateActions">
            <button class="primary" id="btnStart">Enable Audio + Play</button>
            <button id="btnNoAudio">Visuals Only</button>
          </div>
          <div class="hintRow">
            <span>Tip: Drag to paint bursts (toggle “Paint”). Scroll adjusts intensity.</span>
            <span><span class="kbd">Space</span> · <span class="kbd">R</span> · <span class="kbd">B</span></span>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        const clamp01 = (v) => Math.max(0, Math.min(1, v));
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const smoothstep = (a, b, t) => {
          const x = clamp01((t - a) / (b - a));
          return x * x * (3 - 2 * x);
        };
        const fract = (x) => x - Math.floor(x);
        const TAU = Math.PI * 2;

        function nowSec() {
          return performance.now() / 1000;
        }

        function hexToRgb01(hex) {
          const m = /^#?([0-9a-f]{6})$/i.exec(String(hex).trim());
          if (!m) return { r: 1, g: 1, b: 1 };
          const int = Number.parseInt(m[1], 16);
          return { r: ((int >> 16) & 255) / 255, g: ((int >> 8) & 255) / 255, b: (int & 255) / 255 };
        }

        function rgb01ToHex({ r, g, b }) {
          const to = (x) => Math.round(clamp01(x) * 255).toString(16).padStart(2, "0");
          return `#${to(r)}${to(g)}${to(b)}`.toUpperCase();
        }

        function hsvToRgb01(h, s, v) {
          h = ((h % 1) + 1) % 1;
          s = clamp01(s);
          v = clamp01(v);
          const i = Math.floor(h * 6);
          const f = h * 6 - i;
          const p = v * (1 - s);
          const q = v * (1 - f * s);
          const t = v * (1 - (1 - f) * s);
          switch (i % 6) {
            case 0:
              return { r: v, g: t, b: p };
            case 1:
              return { r: q, g: v, b: p };
            case 2:
              return { r: p, g: v, b: t };
            case 3:
              return { r: p, g: q, b: v };
            case 4:
              return { r: t, g: p, b: v };
            case 5:
              return { r: v, g: p, b: q };
          }
        }

        // Compact hash noise for smooth patterns (no deps)
        function hash2(x, y) {
          const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123;
          return fract(s);
        }
        function noise2(x, y) {
          const ix = Math.floor(x);
          const iy = Math.floor(y);
          const fx = x - ix;
          const fy = y - iy;
          const a = hash2(ix, iy);
          const b = hash2(ix + 1, iy);
          const c = hash2(ix, iy + 1);
          const d = hash2(ix + 1, iy + 1);
          const ux = fx * fx * (3 - 2 * fx);
          const uy = fy * fy * (3 - 2 * fy);
          return lerp(lerp(a, b, ux), lerp(c, d, ux), uy);
        }
        function fbm2(x, y) {
          let v = 0;
          let a = 0.5;
          let f = 1.0;
          for (let i = 0; i < 5; i++) {
            v += a * noise2(x * f, y * f);
            f *= 2.0;
            a *= 0.5;
          }
          return v;
        }

        function easeOutExpo(x) {
          return x >= 1 ? 1 : 1 - Math.pow(2, -10 * x);
        }

        const $ = (sel) => document.querySelector(sel);
        const els = {
          stage: $("#stage"),
          panel: $("#panel"),
          grid: $("#grid"),
          overlay: $("#overlay"),
          audioDot: $("#audioDot"),
          audioLabel: $("#audioLabel"),
          energyBar: $("#energyBar"),
          bpmBadge: $("#bpmBadge"),
          fpsBadge: $("#fpsBadge"),
          sceneSubtitle: $("#sceneSubtitle"),
          hintLine: $("#hintLine"),

          preset: $("#preset"),
          pattern: $("#pattern"),
          colorMode: $("#colorMode"),
          cA: $("#cA"),
          cB: $("#cB"),
          cC: $("#cC"),
          cATxt: $("#cATxt"),
          cBTxt: $("#cBTxt"),
          cCTxt: $("#cCTxt"),
          hueDrift: $("#hueDrift"),
          sat: $("#sat"),
          speed: $("#speed"),
          intensity: $("#intensity"),
          detail: $("#detail"),
          trails: $("#trails"),
          zoom: $("#zoom"),

          sync: $("#sync"),
          bloom: $("#bloom"),
          paint: $("#paint"),

          audioMode: $("#audioMode"),
          audioFile: $("#audioFile"),
          fileRow: $("#fileRow"),
          volume: $("#volume"),
          tempo: $("#tempo"),
          sensitivity: $("#sensitivity"),

          btnStart: $("#btnStart"),
          btnNoAudio: $("#btnNoAudio"),
          btnPlay: $("#btnPlay"),
          btnStop: $("#btnStop"),
          btnTap: $("#btnTap"),
          btnRandom: $("#btnRandom"),
          btnBlackout: $("#btnBlackout"),
          btnBurst: $("#btnBurst"),
          btnCollapse: $("#btnCollapse"),
          btnHelp: $("#btnHelp"),
          presetBadge: $("#presetBadge"),
          colorModeBadge: $("#colorModeBadge"),
          speedBadge: $("#speedBadge"),
          audioModeBadge: $("#audioModeBadge"),
        };

        const STORAGE_KEY = "festivalLightsShow.v1";

        const PRESETS = {
          neonParade: {
            label: "Neon Parade",
            subtitle: "Neon Parade • synced glow",
            pattern: "aurora",
            colorMode: "gradient",
            cA: "#00FFE0",
            cB: "#FF4CDC",
            cC: "#FFE000",
            hueDrift: 0.38,
            sat: 0.92,
            speed: 1.02,
            intensity: 1.0,
            detail: 0.58,
            trails: 0.72,
            zoom: 1.15,
            sync: true,
            bloom: true,
          },
          sunsetPulse: {
            label: "Sunset Pulse",
            subtitle: "Sunset Pulse • warm waves",
            pattern: "rainbowWave",
            colorMode: "palette",
            cA: "#FF5A2E",
            cB: "#FFCA00",
            cC: "#8B5CFF",
            hueDrift: 0.24,
            sat: 0.9,
            speed: 0.86,
            intensity: 1.2,
            detail: 0.54,
            trails: 0.78,
            zoom: 1.02,
            sync: true,
            bloom: true,
          },
          laserGrid: {
            label: "Laser Grid",
            subtitle: "Laser Grid • sharp chase",
            pattern: "chase",
            colorMode: "single",
            cA: "#00FF7A",
            cB: "#00FF7A",
            cC: "#00FF7A",
            hueDrift: 0.64,
            sat: 0.98,
            speed: 1.34,
            intensity: 1.16,
            detail: 0.7,
            trails: 0.62,
            zoom: 1.45,
            sync: true,
            bloom: true,
          },
          cosmicBloom: {
            label: "Cosmic Bloom",
            subtitle: "Cosmic Bloom • bursts & vortex",
            pattern: "spiral",
            colorMode: "gradient",
            cA: "#7A4CFF",
            cB: "#00E6FF",
            cC: "#FF4CDC",
            hueDrift: 0.44,
            sat: 0.92,
            speed: 1.06,
            intensity: 1.08,
            detail: 0.62,
            trails: 0.84,
            zoom: 1.18,
            sync: true,
            bloom: true,
          },
          iceAurora: {
            label: "Ice Aurora",
            subtitle: "Ice Aurora • chilled shimmer",
            pattern: "aurora",
            colorMode: "palette",
            cA: "#00E6FF",
            cB: "#9BFFFA",
            cC: "#5A40FF",
            hueDrift: 0.18,
            sat: 0.78,
            speed: 0.74,
            intensity: 0.98,
            detail: 0.68,
            trails: 0.88,
            zoom: 1.28,
            sync: true,
            bloom: true,
          },
          emberCarnival: {
            label: "Ember Carnival",
            subtitle: "Ember Carnival • rising sparks",
            pattern: "fire",
            colorMode: "gradient",
            cA: "#FFB200",
            cB: "#FF2E97",
            cC: "#FF5A2E",
            hueDrift: 0.22,
            sat: 0.92,
            speed: 1.1,
            intensity: 1.3,
            detail: 0.6,
            trails: 0.76,
            zoom: 1.06,
            sync: true,
            bloom: true,
          },
        };

        const PATTERNS = {
          aurora: (x, y, t, a, p) => {
            const z = p.zoom;
            const d = p.detail;
            const flow = fbm2(x * 2.2 * z + t * 0.18, y * 1.6 * z - t * 0.12);
            const bands = Math.sin((y * 2.4 * z + flow * 2.2 + t * (0.9 + a.mid * 1.7)) * TAU);
            const rip = fbm2(x * 3.2 * z - t * 0.22, y * 2.6 * z + t * 0.16);
            const v = smoothstep(-0.6, 0.95, bands) * (0.65 + 0.35 * rip);
            const haze = fbm2(x * 1.2 * z + t * 0.08, y * 1.2 * z + t * 0.05);
            const lift = 0.4 + 0.6 * Math.pow(haze, 1.25);
            const w = (0.6 + 0.4 * a.energy) * (0.8 + 0.2 * d);
            return { v: clamp01(v * lift * w), h: flow * 0.22 + 0.12 * rip };
          },
          rainbowWave: (x, y, t, a, p) => {
            const z = p.zoom;
            const d = p.detail;
            const w1 = Math.sin((x * 1.4 * z + t * (0.9 + a.bass * 1.8)) * TAU);
            const w2 = Math.sin((y * 1.2 * z - t * (0.72 + a.mid * 1.4)) * TAU);
            const w3 = Math.sin(((x + y) * 1.0 * z + t * 0.35) * TAU);
            const v = 0.5 + 0.5 * (0.55 * w1 + 0.35 * w2 + 0.2 * w3);
            const v2 = Math.pow(clamp01(v), 0.7 + 0.6 * (1 - d));
            const h = 0.25 * w1 + 0.18 * w2 + 0.12 * w3 + 0.12 * a.treble;
            return { v: clamp01(v2 * (0.9 + 0.35 * a.energy)), h };
          },
          chase: (x, y, t, a, p) => {
            const z = p.zoom;
            const d = p.detail;
            const ang = Math.sin(t * 0.18) * 0.7 + 0.3;
            const u = x * Math.cos(ang) + y * Math.sin(ang);
            const v = -x * Math.sin(ang) + y * Math.cos(ang);
            const lanes = 10 + Math.floor(18 * d);
            const line = Math.abs(fract(u * lanes + t * (1.2 + a.bass * 2.4)) - 0.5) * 2;
            const beam = Math.pow(1 - line, 6.0);
            const gate = 0.65 + 0.35 * Math.sin((v * 2.0 * z + t * 0.6) * TAU);
            const sparkle = Math.pow(noise2(u * 18 * z + t * 2.2, v * 18 * z - t * 1.7), 8);
            const vv = clamp01(beam * (0.8 + 0.45 * a.energy) * gate + sparkle * (0.3 + 0.8 * a.treble));
            return { v: vv, h: u * 0.12 + 0.14 * a.mid };
          },
          spiral: (x, y, t, a, p) => {
            const z = p.zoom;
            const d = p.detail;
            const r = Math.hypot(x, y) + 1e-6;
            const ang = Math.atan2(y, x);
            const swirl = ang / TAU + r * (1.4 + 2.4 * d) - t * (0.6 + a.bass * 1.8);
            const rings = Math.sin((r * (4.0 + 6.0 * z) - t * (1.1 + a.mid * 1.2)) * TAU);
            const filament = Math.sin((swirl * 3.5 + rings * 0.25) * TAU);
            const core = Math.exp(-r * (1.8 + 1.2 * d));
            const v = clamp01(0.6 * (0.5 + 0.5 * filament) + 0.4 * core) * (0.85 + 0.35 * a.energy);
            return { v, h: swirl * 0.22 + 0.12 * rings + 0.18 * a.treble };
          },
          sparkle: (x, y, t, a, p) => {
            const z = p.zoom;
            const d = p.detail;
            const n = noise2(x * 22 * z + t * (0.8 + a.treble * 2.6), y * 18 * z - t * (0.65 + a.mid * 1.6));
            const g = noise2(x * 3 * z - t * 0.16, y * 3 * z + t * 0.12);
            const sparks = Math.pow(n, 12 - 6 * d);
            const halo = Math.pow(g, 2.5) * 0.35;
            const v = clamp01(sparks * (0.45 + 1.2 * a.treble) + halo * (0.7 + 0.25 * a.energy));
            return { v, h: (x - y) * 0.08 + 0.2 * a.bass };
          },
          fire: (x, y, t, a, p) => {
            const z = p.zoom;
            const d = p.detail;
            const yy = y * 1.2 + 0.6;
            const rise = t * (0.28 + a.bass * 0.65) * (0.7 + 0.6 * p.speed);
            const n = fbm2(x * (3.2 + 2.8 * d) * z + t * 0.22, (yy * 3.0) * z - rise);
            const flames = Math.pow(clamp01(1 - yy + n * 0.9), 2.2);
            const embers = Math.pow(noise2(x * 16 * z + t * 1.4, yy * 18 * z - t * 2.0), 9) * (1 - yy);
            const v = clamp01((flames * (0.8 + 0.4 * a.energy) + embers * (0.35 + 0.9 * a.treble)) * 1.1);
            return { v, h: -0.06 + 0.08 * n + 0.12 * a.mid };
          },
          strobe: (x, y, t, a, p) => {
            const rate = 7 + 16 * p.speed + 10 * a.bass;
            const k = 0.5 + 0.5 * Math.sin(t * rate * TAU);
            const flicker = noise2(x * 8 + t * 20, y * 8 - t * 18);
            const v = clamp01(Math.pow(k, 12) * (0.8 + 0.2 * flicker) * (0.7 + 0.6 * a.energy));
            return { v, h: 0.16 * Math.sin((x * 2 + y * 3 + t * 0.2) * TAU) };
          },
        };

        class RingBuffer {
          constructor(size) {
            this.buf = new Float32Array(size);
            this.i = 0;
            this.full = false;
          }
          push(v) {
            this.buf[this.i] = v;
            this.i = (this.i + 1) % this.buf.length;
            if (this.i === 0) this.full = true;
          }
          avg() {
            const n = this.full ? this.buf.length : this.i;
            if (n <= 0) return 0;
            let s = 0;
            for (let k = 0; k < n; k++) s += this.buf[k];
            return s / n;
          }
        }

        class AudioEngine {
          constructor() {
            this.ctx = null;
            this.master = null;
            this.analyser = null;
            this.freq = null;
            this.mode = "synth";
            this.mediaEl = null;
            this.mediaSrc = null;

            this.isPlaying = false;
            this.bpm = 124;
            this._nextNoteTime = 0;
            this._step = 0;
            this._timer = null;
            this._tapTimes = [];

            this.metrics = {
              energy: 0,
              bass: 0,
              mid: 0,
              treble: 0,
              beat: 0,
              beatHold: 0,
              beatCount: 0,
            };
            this._energyHist = new RingBuffer(60);
            this._lastBeatT = 0;
          }

          ensure() {
            if (this.ctx) return;
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (!AudioCtx) throw new Error("Web Audio not supported.");
            this.ctx = new AudioCtx({ latencyHint: "interactive" });
            this.master = this.ctx.createGain();
            this.master.gain.value = 0.78;
            this.analyser = this.ctx.createAnalyser();
            this.analyser.fftSize = 2048;
            this.analyser.smoothingTimeConstant = 0.72;
            this.freq = new Uint8Array(this.analyser.frequencyBinCount);
            this.master.connect(this.analyser);
            this.analyser.connect(this.ctx.destination);
          }

          setVolume(v) {
            if (!this.master) return;
            const t = this.ctx.currentTime;
            this.master.gain.cancelScheduledValues(t);
            this.master.gain.setTargetAtTime(clamp(v, 0, 1.2), t, 0.03);
          }

          setBpm(bpm) {
            this.bpm = clamp(Math.round(bpm), 40, 220);
          }

          setMode(mode) {
            this.mode = mode;
          }

          async resume() {
            this.ensure();
            if (this.ctx.state !== "running") await this.ctx.resume();
          }

          stop() {
            this.isPlaying = false;
            if (this._timer) {
              clearInterval(this._timer);
              this._timer = null;
            }
            if (this.mediaEl) {
              this.mediaEl.pause();
              this.mediaEl.currentTime = 0;
            }
          }

          async play() {
            await this.resume();
            if (this.mode === "file") {
              if (!this.mediaEl) throw new Error("No audio file loaded.");
              this.isPlaying = true;
              await this.mediaEl.play();
              return;
            }
            this.isPlaying = true;
            this._step = 0;
            this._nextNoteTime = this.ctx.currentTime + 0.06;
            if (this._timer) clearInterval(this._timer);
            this._timer = setInterval(() => this._scheduler(), 25);
          }

          async toggle() {
            if (this.isPlaying) {
              this.stop();
              return false;
            }
            await this.play();
            return true;
          }

          async loadFile(file) {
            await this.resume();
            if (!file) return;
            if (this.mediaEl) {
              try {
                this.mediaEl.pause();
              } catch {}
            }
            const url = URL.createObjectURL(file);
            const el = new Audio();
            el.src = url;
            el.loop = true;
            el.preload = "auto";
            el.crossOrigin = "anonymous";
            el.addEventListener(
              "ended",
              () => {
                try {
                  el.currentTime = 0;
                  el.play();
                } catch {}
              },
              { passive: true }
            );
            this.mediaEl = el;
            if (this.mediaSrc) {
              try {
                this.mediaSrc.disconnect();
              } catch {}
            }
            this.mediaSrc = this.ctx.createMediaElementSource(el);
            this.mediaSrc.connect(this.master);
          }

          tapTempo() {
            const t = performance.now();
            this._tapTimes.push(t);
            while (this._tapTimes.length > 7) this._tapTimes.shift();
            if (this._tapTimes.length < 3) return null;
            const diffs = [];
            for (let i = 1; i < this._tapTimes.length; i++) diffs.push(this._tapTimes[i] - this._tapTimes[i - 1]);
            diffs.sort((a, b) => a - b);
            const mid = diffs[Math.floor(diffs.length / 2)] || diffs[0];
            const bpm = clamp(60000 / mid, 60, 180);
            this.setBpm(bpm);
            return this.bpm;
          }

          _scheduler() {
            const lookahead = 0.12;
            while (this._nextNoteTime < this.ctx.currentTime + lookahead) {
              this._scheduleStep(this._step, this._nextNoteTime);
              const spb = 60 / this.bpm;
              const stepDur = (spb / 4) * 1; // 16th notes
              this._nextNoteTime += stepDur;
              this._step = (this._step + 1) % 16;
            }
          }

          _scheduleStep(step, t) {
            // 4-on-the-floor kick
            if (step % 4 === 0) this._kick(t, 0.9);
            // offbeat hat
            if (step % 2 === 1) this._hat(t, 0.26);
            // snare on 2 and 4
            if (step === 4 || step === 12) this._snare(t, 0.55);
            // bass sequence
            const bassNotes = [0, 0, -3, 0, 5, 0, 7, 0, 0, 0, -3, 0, 5, 0, 2, 0];
            const n = bassNotes[step];
            if (step % 2 === 0) this._bass(t, 55 * Math.pow(2, n / 12), 0.22);
            // lead sprinkles
            if (step === 7 || step === 15) this._pluck(t, 440 * Math.pow(2, (7 + (step === 15 ? 12 : 0)) / 12), 0.2);
          }

          _env(gain, t, a, d) {
            gain.gain.setValueAtTime(0.0001, t);
            gain.gain.exponentialRampToValueAtTime(a, t + 0.005);
            gain.gain.exponentialRampToValueAtTime(0.0001, t + d);
          }

          _kick(t, level) {
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.type = "sine";
            o.frequency.setValueAtTime(130, t);
            o.frequency.exponentialRampToValueAtTime(45, t + 0.08);
            this._env(g, t, 0.6 * level, 0.22);
            o.connect(g);
            g.connect(this.master);
            o.start(t);
            o.stop(t + 0.24);
          }

          _hat(t, level) {
            const bufferSize = Math.floor(this.ctx.sampleRate * 0.04);
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 0.2);
            const n = this.ctx.createBufferSource();
            n.buffer = buffer;
            const hp = this.ctx.createBiquadFilter();
            hp.type = "highpass";
            hp.frequency.value = 7000;
            const g = this.ctx.createGain();
            this._env(g, t, 0.22 * level, 0.06);
            n.connect(hp);
            hp.connect(g);
            g.connect(this.master);
            n.start(t);
            n.stop(t + 0.07);
          }

          _snare(t, level) {
            const bufferSize = Math.floor(this.ctx.sampleRate * 0.12);
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const n = this.ctx.createBufferSource();
            n.buffer = buffer;
            const bp = this.ctx.createBiquadFilter();
            bp.type = "bandpass";
            bp.frequency.value = 1800;
            bp.Q.value = 0.7;
            const g = this.ctx.createGain();
            this._env(g, t, 0.24 * level, 0.12);
            n.connect(bp);
            bp.connect(g);
            g.connect(this.master);
            n.start(t);
            n.stop(t + 0.14);
          }

          _bass(t, freq, level) {
            const o = this.ctx.createOscillator();
            const f = this.ctx.createBiquadFilter();
            const g = this.ctx.createGain();
            o.type = "sawtooth";
            o.frequency.setValueAtTime(freq, t);
            f.type = "lowpass";
            f.frequency.setValueAtTime(180, t);
            f.Q.value = 0.8;
            this._env(g, t, 0.18 * level, 0.24);
            o.connect(f);
            f.connect(g);
            g.connect(this.master);
            o.start(t);
            o.stop(t + 0.26);
          }

          _pluck(t, freq, level) {
            const o = this.ctx.createOscillator();
            const f = this.ctx.createBiquadFilter();
            const g = this.ctx.createGain();
            o.type = "triangle";
            o.frequency.setValueAtTime(freq, t);
            f.type = "bandpass";
            f.frequency.setValueAtTime(freq * 1.8, t);
            f.Q.value = 4.0;
            this._env(g, t, 0.18 * level, 0.18);
            o.connect(f);
            f.connect(g);
            g.connect(this.master);
            o.start(t);
            o.stop(t + 0.2);
          }

          sampleMetrics(sensitivity) {
            if (!this.analyser || !this.freq) return this.metrics;
            this.analyser.getByteFrequencyData(this.freq);
            const n = this.freq.length;
            if (n <= 0) return this.metrics;
            let bass = 0,
              mid = 0,
              treble = 0,
              all = 0;
            const bN = Math.floor(n * 0.12);
            const mN = Math.floor(n * 0.33);
            const tN = Math.floor(n * 0.7);
            for (let i = 0; i < n; i++) {
              const v = this.freq[i] / 255;
              all += v;
              if (i < bN) bass += v;
              else if (i < mN) mid += v;
              else if (i < tN) treble += v;
            }
            bass /= Math.max(1, bN);
            mid /= Math.max(1, mN - bN);
            treble /= Math.max(1, tN - mN);
            const energy = all / n;
            // Beat detection (energy flux vs moving average)
            this._energyHist.push(energy);
            const avg = this._energyHist.avg();
            const t = nowSec();
            const thr = avg * (1.12 + 0.85 * clamp01(sensitivity));
            let beat = 0;
            if (energy > thr && t - this._lastBeatT > 0.22) {
              beat = clamp01((energy - thr) * 2.4);
              this._lastBeatT = t;
              this.metrics.beatCount++;
            }
            this.metrics.energy = lerp(this.metrics.energy, clamp01(energy * 1.15), 0.18);
            this.metrics.bass = lerp(this.metrics.bass, clamp01(bass * 1.35), 0.15);
            this.metrics.mid = lerp(this.metrics.mid, clamp01(mid * 1.25), 0.12);
            this.metrics.treble = lerp(this.metrics.treble, clamp01(treble * 1.35), 0.12);
            this.metrics.beat = Math.max(beat, this.metrics.beat * 0.86 - 0.01);
            this.metrics.beatHold = Math.max(this.metrics.beatHold * 0.92 - 0.02, beat * 1.2);
            return this.metrics;
          }
        }

        class LightShow {
          constructor() {
            this.dpr = Math.min(2, window.devicePixelRatio || 1);
            this.canvas = els.stage;
            this.ctx = this.canvas.getContext("2d", { alpha: false, desynchronized: true });
            this.off = document.createElement("canvas");
            this.offCtx = this.off.getContext("2d", { willReadFrequently: true });
            this.offImg = null;
            this.offData = null;

            this.audio = new AudioEngine();
            this.state = this._defaultState();
            this._lastFrameT = performance.now();
            this._fpsSm = 60;
            this._frame = 0;
            this._collapsed = false;
            this._blackout = false;
            this._burstQueue = [];
            this._drag = { on: false, id: null, lastT: 0 };
            this._wakeLock = null;
            this._reducedMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
          }

          _defaultState() {
            return {
              preset: "neonParade",
              pattern: "aurora",
              colorMode: "gradient",
              colors: { A: hexToRgb01("#00FFE0"), B: hexToRgb01("#FF4CDC"), C: hexToRgb01("#FFE000") },
              hueDrift: 0.38,
              sat: 0.92,
              speed: 1.0,
              intensity: 1.0,
              detail: 0.58,
              trails: 0.72,
              zoom: 1.15,
              sync: true,
              bloom: true,
              paint: true,
              audioMode: "synth",
              volume: 0.78,
              tempo: 124,
              sensitivity: 0.34,
            };
          }

          loadState() {
            try {
              const raw = localStorage.getItem(STORAGE_KEY);
              if (!raw) return;
              const s = JSON.parse(raw);
              if (!s || typeof s !== "object") return;
              this.state = { ...this.state, ...s };
              if (s.colors && typeof s.colors === "object") {
                this.state.colors = { ...this.state.colors, ...s.colors };
              }
            } catch {}
          }

          saveState() {
            try {
              const s = {
                ...this.state,
                // Store colors as hex for stability
                colors: {
                  A: rgb01ToHex(this.state.colors.A),
                  B: rgb01ToHex(this.state.colors.B),
                  C: rgb01ToHex(this.state.colors.C),
                },
              };
              localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
            } catch {}
          }

          applyPreset(key) {
            const preset = PRESETS[key];
            if (!preset) return;
            this.state.preset = key;
            this.state.pattern = preset.pattern;
            this.state.colorMode = preset.colorMode;
            this.state.colors.A = hexToRgb01(preset.cA);
            this.state.colors.B = hexToRgb01(preset.cB);
            this.state.colors.C = hexToRgb01(preset.cC);
            this.state.hueDrift = preset.hueDrift;
            this.state.sat = preset.sat;
            this.state.speed = preset.speed;
            this.state.intensity = preset.intensity;
            this.state.detail = preset.detail;
            this.state.trails = preset.trails;
            this.state.zoom = preset.zoom;
            this.state.sync = preset.sync;
            this.state.bloom = preset.bloom;
            els.sceneSubtitle.textContent = preset.subtitle;
            els.presetBadge.textContent = preset.label;
            this._syncUIFromState();
            this.saveState();
          }

          _syncUIFromState() {
            const s = this.state;
            els.preset.value = s.preset;
            els.pattern.value = s.pattern;
            els.colorMode.value = s.colorMode;
            els.cA.value = rgb01ToHex(s.colors.A);
            els.cB.value = rgb01ToHex(s.colors.B);
            els.cC.value = rgb01ToHex(s.colors.C);
            els.cATxt.value = els.cA.value;
            els.cBTxt.value = els.cB.value;
            els.cCTxt.value = els.cC.value;
            els.hueDrift.value = String(s.hueDrift);
            els.sat.value = String(s.sat);
            els.speed.value = String(s.speed);
            els.intensity.value = String(s.intensity);
            els.detail.value = String(s.detail);
            els.trails.value = String(s.trails);
            els.zoom.value = String(s.zoom);
            els.sync.checked = !!s.sync;
            els.bloom.checked = !!s.bloom;
            els.paint.checked = !!s.paint;
            els.audioMode.value = s.audioMode;
            els.volume.value = String(s.volume);
            els.tempo.value = String(s.tempo);
            els.sensitivity.value = String(s.sensitivity);
            els.bpmBadge.textContent = `BPM ${Math.round(s.tempo)}`;
            els.colorModeBadge.textContent =
              s.colorMode === "gradient" ? "Gradient" : s.colorMode === "palette" ? "Palette" : "Single";
            els.audioModeBadge.textContent = s.audioMode === "file" ? "File" : "Synth";
            this._updateFileRow();
          }

          _updateFileRow() {
            els.fileRow.style.display = this.state.audioMode === "file" ? "grid" : "none";
          }

          attach() {
            this.loadState();
            // Restore colors if stored as hex strings
            for (const k of ["A", "B", "C"]) {
              const v = this.state.colors[k];
              if (typeof v === "string") this.state.colors[k] = hexToRgb01(v);
            }
            if (PRESETS[this.state.preset]) {
              // Re-apply preset structure but keep user overrides
              els.sceneSubtitle.textContent = PRESETS[this.state.preset].subtitle;
              els.presetBadge.textContent = PRESETS[this.state.preset].label;
            }
            this._syncUIFromState();
            this._wireUI();
            this._resize();
            window.addEventListener("resize", () => this._resize(), { passive: true });
            window.addEventListener("keydown", (e) => this._onKey(e), { passive: false });
            this._loop();
          }

          _wireUI() {
            const bindRange = (el, key, transform = (x) => x) => {
              el.addEventListener(
                "input",
                () => {
                  this.state[key] = transform(Number(el.value));
                  if (key === "tempo") {
                    this.audio.setBpm(this.state.tempo);
                    els.bpmBadge.textContent = `BPM ${Math.round(this.state.tempo)}`;
                  }
                  if (key === "volume") this.audio.setVolume(this.state.volume);
                  this._updateBadges();
                  this.saveState();
                },
                { passive: true }
              );
            };

            els.preset.addEventListener(
              "change",
              () => {
                this.applyPreset(els.preset.value);
              },
              { passive: true }
            );
            els.pattern.addEventListener(
              "change",
              () => {
                this.state.pattern = els.pattern.value;
                this._updateBadges();
                this.saveState();
              },
              { passive: true }
            );
            els.colorMode.addEventListener(
              "change",
              () => {
                this.state.colorMode = els.colorMode.value;
                this._syncUIFromState();
                this.saveState();
              },
              { passive: true }
            );

            const bindColor = (picker, txt, key) => {
              const apply = (val) => {
                const cleaned = String(val || "").trim();
                const m = /^#?([0-9a-f]{6})$/i.exec(cleaned);
                if (!m) return false;
                const hex = `#${m[1]}`.toUpperCase();
                picker.value = hex;
                txt.value = hex;
                this.state.colors[key] = hexToRgb01(hex);
                this.saveState();
                return true;
              };
              picker.addEventListener(
                "input",
                () => {
                  apply(picker.value);
                },
                { passive: true }
              );
              txt.addEventListener(
                "change",
                () => {
                  if (!apply(txt.value)) txt.value = picker.value;
                },
                { passive: true }
              );
              txt.addEventListener(
                "keydown",
                (e) => {
                  if (e.key === "Enter") {
                    e.preventDefault();
                    txt.blur();
                  }
                },
                { passive: false }
              );
            };
            bindColor(els.cA, els.cATxt, "A");
            bindColor(els.cB, els.cBTxt, "B");
            bindColor(els.cC, els.cCTxt, "C");

            bindRange(els.hueDrift, "hueDrift", (x) => clamp01(x));
            bindRange(els.sat, "sat", (x) => clamp01(x));
            bindRange(els.speed, "speed", (x) => clamp(x, 0, 2));
            bindRange(els.intensity, "intensity", (x) => clamp(x, 0, 2));
            bindRange(els.detail, "detail", (x) => clamp01(x));
            bindRange(els.trails, "trails", (x) => clamp01(x));
            bindRange(els.zoom, "zoom", (x) => clamp(x, 0.6, 2.2));

            els.sync.addEventListener(
              "change",
              () => {
                this.state.sync = els.sync.checked;
                this.saveState();
              },
              { passive: true }
            );
            els.bloom.addEventListener(
              "change",
              () => {
                this.state.bloom = els.bloom.checked;
                this.saveState();
              },
              { passive: true }
            );
            els.paint.addEventListener(
              "change",
              () => {
                this.state.paint = els.paint.checked;
                this.saveState();
              },
              { passive: true }
            );

            els.audioMode.addEventListener(
              "change",
              async () => {
                this.state.audioMode = els.audioMode.value;
                this.audio.setMode(this.state.audioMode);
                this._updateFileRow();
                els.audioModeBadge.textContent = this.state.audioMode === "file" ? "File" : "Synth";
                this.saveState();
                // If switching modes while playing, restart
                if (this.audio.isPlaying) {
                  this.audio.stop();
                  await this._tryPlay();
                }
              },
              { passive: true }
            );
            els.audioFile.addEventListener(
              "change",
              async () => {
                const file = els.audioFile.files && els.audioFile.files[0];
                if (!file) return;
                try {
                  await this.audio.loadFile(file);
                  this._flashHint("Loaded audio file ✓");
                  if (this.state.audioMode !== "file") {
                    this.state.audioMode = "file";
                    els.audioMode.value = "file";
                    this.audio.setMode("file");
                    this._updateFileRow();
                    els.audioModeBadge.textContent = "File";
                  }
                  this.saveState();
                } catch (err) {
                  this._flashHint("Could not load audio");
                  console.warn(err);
                }
              },
              { passive: true }
            );

            bindRange(els.volume, "volume", (x) => clamp(x, 0, 1.2));
            bindRange(els.tempo, "tempo", (x) => clamp(Math.round(x), 60, 180));
            bindRange(els.sensitivity, "sensitivity", (x) => clamp01(x));

            els.btnStart.addEventListener("click", async () => {
              await this._unlockAudio(true);
            });
            els.btnNoAudio.addEventListener("click", async () => {
              await this._unlockAudio(false);
            });
            els.btnPlay.addEventListener("click", async () => {
              await this._unlockAudio(false);
              await this._tryToggle();
            });
            els.btnStop.addEventListener("click", () => {
              this.audio.stop();
              this._setAudioUI(false);
            });
            els.btnTap.addEventListener("click", () => {
              const bpm = this.audio.tapTempo();
              if (bpm) {
                this.state.tempo = bpm;
                els.tempo.value = String(bpm);
                els.bpmBadge.textContent = `BPM ${bpm}`;
                this.saveState();
                this._flashHint(`Tempo: ${bpm} BPM`);
              } else {
                this._flashHint("Tap 3+ times…");
              }
            });
            els.btnRandom.addEventListener("click", () => this.randomize());
            els.btnBlackout.addEventListener("click", () => this.blackout());
            els.btnBurst.addEventListener("click", () => this.addBurst(0.5, 0.5, 1.0, true));
            els.btnCollapse.addEventListener("click", () => this.togglePanel());
            els.btnHelp.addEventListener("click", () => this.showHelp());

            // Canvas interactions
            const getPos = (e) => {
              const rect = this.canvas.getBoundingClientRect();
              const x = (e.clientX - rect.left) / rect.width;
              const y = (e.clientY - rect.top) / rect.height;
              return { x: clamp01(x), y: clamp01(y) };
            };

            this.canvas.addEventListener(
              "pointerdown",
              (e) => {
                this.canvas.setPointerCapture(e.pointerId);
                const p = getPos(e);
                this._drag.on = true;
                this._drag.id = e.pointerId;
                this._drag.lastT = performance.now();
                this.addBurst(p.x, p.y, 1.0, true);
              },
              { passive: true }
            );
            this.canvas.addEventListener(
              "pointermove",
              (e) => {
                if (!this._drag.on || this._drag.id !== e.pointerId) return;
                if (!this.state.paint) return;
                const t = performance.now();
                if (t - this._drag.lastT < 36) return;
                this._drag.lastT = t;
                const p = getPos(e);
                this.addBurst(p.x, p.y, 0.45, false);
              },
              { passive: true }
            );
            this.canvas.addEventListener(
              "pointerup",
              (e) => {
                if (this._drag.id === e.pointerId) {
                  this._drag.on = false;
                  this._drag.id = null;
                }
              },
              { passive: true }
            );
            this.canvas.addEventListener(
              "wheel",
              (e) => {
                e.preventDefault();
                const delta = Math.sign(e.deltaY);
                const next = clamp(this.state.intensity + (delta > 0 ? -0.06 : 0.06), 0, 2);
                this.state.intensity = next;
                els.intensity.value = String(next);
                this.saveState();
              },
              { passive: false }
            );
          }

          _updateBadges() {
            els.colorModeBadge.textContent =
              this.state.colorMode === "gradient" ? "Gradient" : this.state.colorMode === "palette" ? "Palette" : "Single";
            els.speedBadge.textContent = `Speed ${(this.state.speed * 100).toFixed(0)}%`;
            els.audioModeBadge.textContent = this.state.audioMode === "file" ? "File" : "Synth";
          }

          togglePanel() {
            this._collapsed = !this._collapsed;
            els.panel.classList.toggle("collapsed", this._collapsed);
            this._flashHint(this._collapsed ? "Panel collapsed (C)" : "Panel expanded (C)");
          }

          showHelp() {
            const msg =
              "Shortcuts:\n" +
              "Space: play/pause\n" +
              "R: randomize scene\n" +
              "B: blackout toggle\n" +
              "C: collapse panel\n" +
              "Click: burst • Drag: paint (if enabled)\n" +
              "Scroll: intensity";
            alert(msg);
          }

          blackout() {
            this._blackout = !this._blackout;
            this._flashHint(this._blackout ? "Blackout ON" : "Blackout OFF");
          }

          randomize() {
            const patterns = Object.keys(PATTERNS);
            this.state.pattern = patterns[Math.floor(Math.random() * patterns.length)];
            els.pattern.value = this.state.pattern;
            const modes = ["gradient", "palette", "single"];
            this.state.colorMode = modes[Math.floor(Math.random() * modes.length)];
            els.colorMode.value = this.state.colorMode;
            const randHue = () => Math.random();
            const randCol = () => hsvToRgb01(randHue(), 0.95, 1.0);
            this.state.colors.A = randCol();
            this.state.colors.B = randCol();
            this.state.colors.C = randCol();
            this.state.hueDrift = clamp01(0.15 + Math.random() * 0.65);
            this.state.sat = clamp01(0.75 + Math.random() * 0.25);
            this.state.speed = clamp(0.65 + Math.random() * 1.25, 0, 2);
            this.state.intensity = clamp(0.85 + Math.random() * 1.15, 0, 2);
            this.state.detail = clamp01(0.35 + Math.random() * 0.55);
            this.state.trails = clamp01(0.55 + Math.random() * 0.42);
            this.state.zoom = clamp(0.85 + Math.random() * 1.25, 0.6, 2.2);
            this.state.bloom = Math.random() > 0.2;
            this.state.sync = Math.random() > 0.1;
            this._syncUIFromState();
            this._flashHint("Randomized ✨");
            this.saveState();
          }

          async _unlockAudio(play) {
            try {
              await this.audio.resume();
              this.audio.setBpm(this.state.tempo);
              this.audio.setVolume(this.state.volume);
              this.audio.setMode(this.state.audioMode);
              els.overlay.style.display = "none";
              if (play) await this._tryPlay();
              this._acquireWakeLock();
            } catch (err) {
              els.overlay.style.display = "none";
              this._flashHint("Audio unavailable (visuals only)");
              console.warn(err);
            }
          }

          async _acquireWakeLock() {
            try {
              if (!("wakeLock" in navigator)) return;
              this._wakeLock = await navigator.wakeLock.request("screen");
            } catch {}
          }

          async _tryPlay() {
            try {
              await this.audio.play();
              this._setAudioUI(true);
            } catch (err) {
              this._flashHint(err?.message || "Could not play audio");
              this._setAudioUI(false);
              console.warn(err);
            }
          }

          async _tryToggle() {
            try {
              const on = await this.audio.toggle();
              this._setAudioUI(on);
            } catch (err) {
              this._flashHint(err?.message || "Audio error");
              this._setAudioUI(false);
              console.warn(err);
            }
          }

          _setAudioUI(on) {
            els.audioDot.classList.toggle("live", !!on);
            els.audioLabel.textContent = on ? `Audio: ${this.state.audioMode === "file" ? "File" : "Synth"}` : "Audio: Off";
            els.btnPlay.textContent = on ? "Pause" : "Play";
          }

          _resize() {
            const w = Math.floor(window.innerWidth * this.dpr);
            const h = Math.floor(window.innerHeight * this.dpr);
            this.canvas.width = w;
            this.canvas.height = h;
            // Shader-like low-res buffer
            const base = Math.min(520, Math.max(240, Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.62)));
            const offW = Math.floor(base * (window.innerWidth / Math.max(1, window.innerHeight)));
            const offH = base;
            this.off.width = Math.floor(offW);
            this.off.height = Math.floor(offH);
            this.offImg = this.offCtx.createImageData(this.off.width, this.off.height);
            this.offData = this.offImg.data;
          }

          addBurst(nx, ny, strength = 1, big = false) {
            const x = clamp01(nx);
            const y = clamp01(ny);
            const s = clamp(strength, 0, 2);
            const t = nowSec();
            const hue = Math.random();
            this._burstQueue.push({
              x,
              y,
              t,
              s: s * (big ? 1.1 : 0.75),
              hue,
              dur: big ? 1.35 : 0.9,
            });
            while (this._burstQueue.length > 34) this._burstQueue.shift();
          }

          _flashHint(text) {
            els.hintLine.textContent = text;
            const id = Symbol("hint");
            this._hintId = id;
            setTimeout(() => {
              if (this._hintId !== id) return;
              els.hintLine.textContent = "Click stage: burst";
            }, 1600);
          }

          _onKey(e) {
            if (e.target && (e.target.tagName === "INPUT" || e.target.tagName === "SELECT" || e.target.isContentEditable)) {
              // Let user type in fields
            } else {
              if (e.code === "Space") {
                e.preventDefault();
                this._unlockAudio(false).then(() => this._tryToggle());
              } else if (e.key === "r" || e.key === "R") {
                this.randomize();
              } else if (e.key === "b" || e.key === "B") {
                this.blackout();
              } else if (e.key === "c" || e.key === "C") {
                this.togglePanel();
              } else if (e.key === "h" || e.key === "H" || e.key === "?") {
                this.showHelp();
              }
            }
          }

          _computePalette(hShift, mixT, a) {
            const s = this.state.sat;
            const mode = this.state.colorMode;
            const A = this.state.colors.A;
            const B = this.state.colors.B;
            const C = this.state.colors.C;

            const drift = this.state.hueDrift * (0.4 + 0.6 * a.energy);
            const t = fract(mixT + hShift * drift);

            if (mode === "single") {
              // Single base, but drift hue by pattern/time for festival vibe
              // Convert A to HSV-ish by sampling its approximate hue from RGB
              const baseHue = rgbToHue(A);
              const hue = fract(baseHue + t * 0.66);
              return hsvToRgb01(hue, s, 1);
            }

            if (mode === "palette") {
              const u = t * 3;
              const i = Math.floor(u);
              const f = smoothstep(0, 1, u - i);
              const c0 = i % 3 === 0 ? A : i % 3 === 1 ? B : C;
              const c1 = (i + 1) % 3 === 0 ? A : (i + 1) % 3 === 1 ? B : C;
              const out = {
                r: lerp(c0.r, c1.r, f),
                g: lerp(c0.g, c1.g, f),
                b: lerp(c0.b, c1.b, f),
              };
              return saturateRgb(out, s);
            }

            // gradient
            const out = { r: lerp(A.r, B.r, t), g: lerp(A.g, B.g, t), b: lerp(A.b, B.b, t) };
            return saturateRgb(out, s);
          }

          _loop() {
            const tick = () => {
              this._render();
              requestAnimationFrame(tick);
            };
            requestAnimationFrame(tick);
          }

          _render() {
            const tNow = performance.now();
            const dt = (tNow - this._lastFrameT) / 1000;
            this._lastFrameT = tNow;
            const fps = dt > 0 ? 1 / dt : 60;
            this._fpsSm = lerp(this._fpsSm, clamp(fps, 5, 240), 0.07);
            this._frame++;
            if (this._frame % 12 === 0) els.fpsBadge.textContent = `${Math.round(this._fpsSm)} FPS`;

            const s = this.state;
            const audio = this.audio.sampleMetrics(s.sensitivity);
            const energy = audio.energy;
            els.energyBar.style.width = `${Math.round(clamp01(energy) * 100)}%`;
            els.audioDot.classList.toggle("live", this.audio.isPlaying);
            els.audioLabel.textContent = this.audio.isPlaying ? `Audio: ${s.audioMode === "file" ? "File" : "Synth"}` : "Audio: Off";
            els.btnPlay.textContent = this.audio.isPlaying ? "Pause" : "Play";
            if (this._frame % 10 === 0) els.bpmBadge.textContent = `BPM ${Math.round(s.tempo)}`;

            // Add automatic bursts on strong beats
            if (s.sync && audio.beat > 0.2 && Math.random() < 0.8) {
              const x = 0.2 + Math.random() * 0.6;
              const y = 0.2 + Math.random() * 0.6;
              this.addBurst(x, y, 0.8 + audio.beat * 1.3, false);
            }

            const W = this.canvas.width;
            const H = this.canvas.height;
            const offW = this.off.width;
            const offH = this.off.height;
            const data = this.offData;
            const pattern = PATTERNS[s.pattern] || PATTERNS.aurora;

            const t = nowSec();
            const syncBoost = s.sync ? 1 + 0.55 * energy + 0.25 * audio.beatHold : 1;
            const speed = s.speed * syncBoost * (this._reducedMotion ? 0.8 : 1);
            const time = t * speed;

            // Trails / persistence: fade previous frame slightly on main canvas
            const ctx = this.ctx;
            const fade = this._blackout ? 1 : clamp(0.06 + (1 - s.trails) * 0.28, 0.04, 0.34);
            ctx.save();
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = `rgba(0,0,0,${fade})`;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();

            // Fill shader buffer
            const invW = 1 / offW;
            const invH = 1 / offH;

            const centerVignette = 0.9 + 0.15 * Math.sin(time * 0.2);
            const baseIntensity = this._blackout ? 0 : s.intensity * (0.75 + 0.75 * (s.sync ? energy : 0));
            const beatPunch = this._blackout ? 0 : 0.18 + 0.6 * audio.beatHold;

            // Precompute burst impacts
            const bursts = this._burstQueue;
            const burstNow = t;
            for (let i = bursts.length - 1; i >= 0; i--) {
              if (burstNow - bursts[i].t > bursts[i].dur) bursts.splice(i, 1);
            }

            // Render pixels
            let idx = 0;
            for (let py = 0; py < offH; py++) {
              const ny = (py + 0.5) * invH;
              const y = (ny - 0.5) * 2;
              for (let px = 0; px < offW; px++) {
                const nx = (px + 0.5) * invW;
                const x = (nx - 0.5) * 2 * (offW / offH);
                const r = Math.hypot(x, y);
                const vign = smoothstep(1.25, 0.2, r) * centerVignette;
                const pr = pattern(x, y, time, audio, s);
                let v = pr.v;
                let h = pr.h;

                // Add burst contributions
                if (bursts.length) {
                  let bv = 0;
                  let bh = 0;
                  for (let k = 0; k < bursts.length; k++) {
                    const b = bursts[k];
                    const bt = (burstNow - b.t) / b.dur;
                    const life = 1 - bt;
                    const ex = (b.x - nx) * 2;
                    const ey = (b.y - ny) * 2;
                    const dist = Math.hypot(ex, ey);
                    const wave = Math.sin((dist * 4.0 - bt * 6.0) * TAU);
                    const shell = Math.exp(-dist * (4.5 - 2.2 * life)) * (0.5 + 0.5 * wave);
                    const burst = shell * b.s * easeOutExpo(life);
                    bv += burst;
                    bh += (b.hue - 0.5) * burst;
                  }
                  v = clamp01(v + bv);
                  h += bh * 0.18;
                }

                // Tone-map
                const flare = 0.22 * (audio.treble + audio.mid) + 0.2 * audio.beatHold;
                const lum = clamp01(v * baseIntensity * vign);
                const pulse = 1 + beatPunch * (s.sync ? flare : 0.15);
                const outV = clamp01(1 - Math.exp(-lum * (1.9 + 1.6 * pulse)));

                const col = this._computePalette(h, (nx + ny) * 0.15 + time * 0.03, audio);
                const satLift = 0.92 + 0.18 * audio.treble;
                const rr = clamp01(col.r * outV * satLift);
                const gg = clamp01(col.g * outV * satLift);
                const bb = clamp01(col.b * outV * satLift);

                data[idx++] = Math.round(rr * 255);
                data[idx++] = Math.round(gg * 255);
                data[idx++] = Math.round(bb * 255);
                data[idx++] = 255;
              }
            }
            this.offCtx.putImageData(this.offImg, 0, 0);

            // Composite with bloom
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.globalCompositeOperation = "lighter";

            if (s.bloom && !this._reducedMotion) {
              ctx.filter = `blur(${Math.max(6, Math.min(26, 10 + 16 * energy))}px)`;
              ctx.globalAlpha = 0.55 + 0.22 * energy;
              ctx.drawImage(this.off, 0, 0, W, H);
              ctx.filter = `blur(${Math.max(3, Math.min(14, 5 + 10 * audio.mid))}px)`;
              ctx.globalAlpha = 0.65;
              ctx.drawImage(this.off, 0, 0, W, H);
            }

            ctx.filter = "none";
            ctx.globalAlpha = 0.95;
            ctx.drawImage(this.off, 0, 0, W, H);
            ctx.restore();

            // Minimal floor glow / stage
            this._drawStageGlow(audio);
          }

          _drawStageGlow(a) {
            const ctx = this.ctx;
            const W = this.canvas.width;
            const H = this.canvas.height;
            const t = nowSec();
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            ctx.globalAlpha = 0.4 + 0.25 * a.energy;
            const grd = ctx.createRadialGradient(W * 0.5, H * 0.86, 10, W * 0.5, H * 0.86, H * 0.75);
            grd.addColorStop(0, `rgba(0, 255, 210, ${0.12 + 0.12 * a.mid})`);
            grd.addColorStop(0.35, `rgba(255, 76, 220, ${0.09 + 0.09 * a.treble})`);
            grd.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = 0.12;
            ctx.globalCompositeOperation = "overlay";
            ctx.fillStyle = `rgba(255,255,255,${0.02 + 0.02 * Math.sin(t * 0.5)})`;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
          }
        }

        function saturateRgb(rgb, sat) {
          // Approx saturation by mixing with luminance
          const l = rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;
          const s = clamp01(sat);
          return { r: lerp(l, rgb.r, s), g: lerp(l, rgb.g, s), b: lerp(l, rgb.b, s) };
        }

        function rgbToHue({ r, g, b }) {
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const d = max - min;
          if (d < 1e-5) return 0;
          let h = 0;
          if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
          else if (max === g) h = (b - r) / d + 2;
          else h = (r - g) / d + 4;
          return (h / 6) % 1;
        }

        const app = new LightShow();
        app.attach();

        // Make the overlay visible until user gestures (browser autoplay policies)
        els.overlay.style.display = "grid";
      })();
    </script>
  </body>
</html>
