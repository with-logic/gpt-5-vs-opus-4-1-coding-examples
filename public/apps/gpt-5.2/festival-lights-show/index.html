<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark" />
  <meta name="theme-color" content="#0b0b14" />
  <title>Festival Lights Show</title>
  <style>
    :root{
      --bg0:#070711;
      --bg1:#0b0b18;
      --glass: rgba(255,255,255,.08);
      --glass2: rgba(255,255,255,.12);
      --stroke: rgba(255,255,255,.14);
      --stroke2: rgba(255,255,255,.2);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --faint: rgba(255,255,255,.5);
      --shadow: 0 18px 70px rgba(0,0,0,.55);
      --shadow2: 0 10px 30px rgba(0,0,0,.35);
      --r: 18px;
      --r2: 26px;
      --pad: 14px;
      --pad2: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --accent0:#7c3aed;
      --accent1:#22d3ee;
      --accent2:#fb7185;
      --accent3:#a3e635;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1400px 900px at 10% -10%, rgba(124,58,237,.35), transparent 55%),
        radial-gradient(900px 700px at 110% 10%, rgba(34,211,238,.28), transparent 55%),
        radial-gradient(900px 700px at 30% 120%, rgba(251,113,133,.24), transparent 50%),
        radial-gradient(900px 700px at 90% 110%, rgba(163,230,53,.18), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow:hidden;
    }
    .grain{
      position:fixed; inset:-30px;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='260' height='260'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='260' height='260' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      mix-blend-mode:overlay;
      opacity:.18;
      pointer-events:none;
      transform:rotate(2deg) scale(1.1);
    }
    .app{
      height:100%;
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:16px;
      padding:16px;
    }
    @media (max-width: 980px){
      body{overflow:auto}
      .app{
        height:auto;
        min-height:100%;
        grid-template-columns: 1fr;
      }
    }
    .panel{
      border-radius: var(--r2);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      overflow:hidden;
    }
    .panel .hd{
      padding:16px 16px 12px 16px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:
        radial-gradient(700px 300px at 12% 0%, rgba(124,58,237,.22), transparent 55%),
        radial-gradient(700px 300px at 86% 0%, rgba(34,211,238,.18), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .title{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      min-width:0;
    }
    .logo{
      width:38px; height:38px; border-radius: 12px;
      background: conic-gradient(from 210deg, #22d3ee, #7c3aed, #fb7185, #a3e635, #22d3ee);
      filter: drop-shadow(0 10px 24px rgba(0,0,0,.35));
      position:relative;
    }
    .logo:after{
      content:"";
      position:absolute; inset:3px;
      border-radius: 10px;
      background: radial-gradient(18px 18px at 30% 30%, rgba(255,255,255,.8), rgba(255,255,255,0) 70%),
                  linear-gradient(180deg, rgba(0,0,0,.05), rgba(0,0,0,.28));
      mix-blend-mode:overlay;
    }
    h1{
      font-size:16px;
      margin:0;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .sub{
      margin-top:2px;
      font-size:12px;
      color:var(--muted);
      letter-spacing:.25px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .row{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.86);
      font-size:12px;
      box-shadow: 0 10px 24px rgba(0,0,0,.22) inset;
      user-select:none;
    }
    .pill .dot{
      width:8px; height:8px; border-radius: 999px;
      background: #22d3ee;
      box-shadow: 0 0 0 2px rgba(34,211,238,.2), 0 0 20px rgba(34,211,238,.45);
    }
    .content{
      padding: 14px 16px 16px 16px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .section{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      border-radius: var(--r);
      overflow:hidden;
    }
    .section .sh{
      padding:10px 12px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid rgba(255,255,255,.1);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .section .sh b{font-size:12px; letter-spacing:.3px}
    .section .sh small{color:var(--muted); font-size:12px}
    .grid{
      padding:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .grid.one{grid-template-columns: 1fr}
    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:12px;
      color: var(--muted);
    }
    label .top{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
    }
    label .top span:last-child{
      font-family:var(--mono);
      font-size:11px;
      color: rgba(255,255,255,.78);
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      padding:2px 8px;
      border-radius:999px;
      white-space:nowrap;
    }
    input[type="range"]{
      width:100%;
      accent-color: #22d3ee;
    }
    input[type="color"]{
      width:100%;
      height:38px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.15);
      padding:0;
      overflow:hidden;
      cursor:pointer;
    }
    select, button, input[type="text"]{
      width:100%;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.2);
      color: rgba(255,255,255,.9);
      box-shadow: 0 10px 30px rgba(0,0,0,.22) inset;
      outline:none;
    }
    select:focus, button:focus, input[type="text"]:focus{border-color: rgba(34,211,238,.5)}
    button{
      cursor:pointer;
      user-select:none;
      transition: transform .08s ease, filter .15s ease, background .2s ease;
    }
    button:active{transform: translateY(1px) scale(.99)}
    .btn{
      background: linear-gradient(135deg, rgba(34,211,238,.16), rgba(124,58,237,.16));
    }
    .btn:hover{filter: brightness(1.06)}
    .btn.primary{
      background: linear-gradient(135deg, rgba(34,211,238,.22), rgba(124,58,237,.22));
      border-color: rgba(255,255,255,.2);
    }
    .btn.danger{
      background: linear-gradient(135deg, rgba(251,113,133,.18), rgba(124,58,237,.12));
    }
    .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .btnRow3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .toggle{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.2);
      box-shadow: 0 10px 30px rgba(0,0,0,.22) inset;
    }
    .toggle .name{font-size:12px; color: var(--muted)}
    .switch{
      position:relative; width:44px; height:26px;
      border-radius:999px;
      background: rgba(255,255,255,.1);
      border:1px solid rgba(255,255,255,.16);
      cursor:pointer;
    }
    .switch:after{
      content:"";
      position:absolute; top:3px; left:3px;
      width:20px; height:20px; border-radius:999px;
      background: rgba(255,255,255,.88);
      box-shadow: 0 10px 20px rgba(0,0,0,.28);
      transition: transform .18s ease, background .18s ease;
    }
    .switch[data-on="true"]{
      background: rgba(34,211,238,.22);
      border-color: rgba(34,211,238,.35);
      box-shadow: 0 0 0 2px rgba(34,211,238,.12) inset;
    }
    .switch[data-on="true"]:after{
      transform: translateX(18px);
      background: rgba(255,255,255,.96);
    }
    .small{
      font-size:12px;
      color: var(--muted);
      line-height:1.35;
    }
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      padding:2px 6px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
    }
    .stage{
      position:relative;
      border-radius: var(--r2);
      overflow:hidden;
      box-shadow: var(--shadow);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      min-height: 520px;
    }
    @media (max-width: 980px){
      .stage{min-height: 460px}
    }
    canvas{
      display:block;
      width:100%;
      height:100%;
    }
    .hud{
      position:absolute; inset:14px 14px auto 14px;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      pointer-events:none;
    }
    .hud .card{
      pointer-events:none;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    .hud .card b{font-size:12px}
    .hud .card .m{font-family:var(--mono); font-size:11px; color:rgba(255,255,255,.78); margin-top:4px}
    .hud .meter{
      display:flex; gap:8px; align-items:center;
      margin-top:8px;
    }
    .bar{
      width:140px; height:8px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
    }
    .bar > i{
      display:block;
      height:100%;
      width:40%;
      background: linear-gradient(90deg, rgba(34,211,238,.9), rgba(124,58,237,.9), rgba(251,113,133,.9));
      border-radius:999px;
      filter: drop-shadow(0 0 10px rgba(34,211,238,.35));
    }
    .toast{
      position:absolute; left:50%; bottom:16px;
      transform: translateX(-50%);
      padding:10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.34);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.9);
      font-size:12px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 16px 60px rgba(0,0,0,.5);
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
      max-width: min(780px, calc(100% - 28px));
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.on{
      opacity:1;
      transform: translateX(-50%) translateY(-2px);
    }
    .sr{
      position:absolute;
      width:1px; height:1px;
      padding:0; margin:-1px; overflow:hidden;
      clip: rect(0,0,0,0);
      border:0;
    }
    .file{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.2);
      box-shadow: 0 10px 30px rgba(0,0,0,.22) inset;
    }
    .file input[type="file"]{width:100%; color: rgba(255,255,255,.76)}
    .file input::file-selector-button{
      border:1px solid rgba(255,255,255,.16);
      border-radius: 12px;
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.9);
      padding:8px 10px;
      cursor:pointer;
      margin-right:10px;
    }
    .divider{
      height:1px;
      background: rgba(255,255,255,.1);
      margin: 2px 0;
    }
  </style>
</head>
<body>
  <div class="grain" aria-hidden="true"></div>
  <div class="app">
    <aside class="panel" id="controlsPanel">
      <div class="hd">
        <div class="title">
          <div class="brand">
            <div class="logo" aria-hidden="true"></div>
            <div style="min-width:0">
              <h1>Festival Lights Show</h1>
              <div class="sub">Color • Patterns • Music Sync</div>
            </div>
          </div>
          <div class="pill" title="Live engine status">
            <i class="dot" id="statusDot"></i>
            <span id="statusText">Ready</span>
          </div>
        </div>
      </div>
      <div class="content">
        <div class="section">
          <div class="sh">
            <b>Show Control</b>
            <small><span class="kbd">Space</span> play</small>
          </div>
          <div class="grid">
            <button class="btn primary" id="btnStart">Start Show</button>
            <button class="btn" id="btnPause">Pause</button>
            <button class="btn" id="btnFullscreen">Fullscreen</button>
            <button class="btn danger" id="btnBlackout">Blackout</button>
          </div>
          <div class="grid one" style="padding-top:0">
            <div class="small" style="padding: 0 12px 12px 12px">
              Tips: <span class="kbd">R</span> randomize • <span class="kbd">B</span> beat hit • <span class="kbd">F</span> fullscreen
            </div>
          </div>
        </div>

        <div class="section">
          <div class="sh">
            <b>Pattern</b>
            <small id="patternHint">Neon motion</small>
          </div>
          <div class="grid">
            <label>
              <div class="top"><span>Mode</span><span id="valPattern">Aurora</span></div>
              <select id="pattern">
                <option value="aurora" selected>Aurora</option>
                <option value="rainbowChase">Rainbow Chase</option>
                <option value="pulseGrid">Pulse Grid</option>
                <option value="spiral">Spiral</option>
                <option value="strobe">Strobe</option>
                <option value="sparkle">Sparkle</option>
                <option value="fireworks">Fireworks</option>
                <option value="wave">Wave</option>
                <option value="scanline">Scanline</option>
              </select>
            </label>
            <label>
              <div class="top"><span>Layout</span><span id="valLayout">Ring</span></div>
              <select id="layout">
                <option value="ring" selected>Ring</option>
                <option value="stage">Stage</option>
                <option value="grid">Grid</option>
                <option value="tunnel">Tunnel</option>
              </select>
            </label>
            <label>
              <div class="top"><span>Speed</span><span id="valSpeed">1.15×</span></div>
              <input id="speed" type="range" min="0.1" max="3" step="0.01" value="1.15" />
            </label>
            <label>
              <div class="top"><span>Energy</span><span id="valEnergy">0.80</span></div>
              <input id="energy" type="range" min="0" max="1.4" step="0.01" value="0.8" />
            </label>
            <label>
              <div class="top"><span>Glow</span><span id="valGlow">0.65</span></div>
              <input id="glow" type="range" min="0" max="1" step="0.01" value="0.65" />
            </label>
            <label>
              <div class="top"><span>Trails</span><span id="valTrails">0.20</span></div>
              <input id="trails" type="range" min="0" max="0.7" step="0.01" value="0.2" />
            </label>
            <label>
              <div class="top"><span>Lights</span><span id="valLights">240</span></div>
              <input id="lights" type="range" min="48" max="900" step="1" value="240" />
            </label>
            <label>
              <div class="top"><span>Bloom</span><span id="valBloom">0.55</span></div>
              <input id="bloom" type="range" min="0" max="1" step="0.01" value="0.55" />
            </label>
          </div>
          <div class="grid one" style="padding-top:0">
            <div class="btnRow3">
              <button class="btn" id="btnRandom">Randomize</button>
              <button class="btn" id="btnBeat">Beat Hit</button>
              <button class="btn" id="btnShare">Share</button>
            </div>
          </div>
        </div>

        <div class="section">
          <div class="sh">
            <b>Color</b>
            <small>Palette blend</small>
          </div>
          <div class="grid">
            <label>
              <div class="top"><span>Base</span><span id="valBase">#7C3AED</span></div>
              <input id="baseColor" type="color" value="#7c3aed" />
            </label>
            <label>
              <div class="top"><span>Accent</span><span id="valAccent">#22D3EE</span></div>
              <input id="accentColor" type="color" value="#22d3ee" />
            </label>
            <label>
              <div class="top"><span>Warm</span><span id="valWarm">#FB7185</span></div>
              <input id="warmColor" type="color" value="#fb7185" />
            </label>
            <label>
              <div class="top"><span>Lime</span><span id="valLime">#A3E635</span></div>
              <input id="limeColor" type="color" value="#a3e635" />
            </label>
          </div>
          <div class="grid one" style="padding-top:0">
            <label>
              <div class="top"><span>Hue Drift</span><span id="valHueDrift">0.22</span></div>
              <input id="hueDrift" type="range" min="0" max="1" step="0.01" value="0.22" />
            </label>
          </div>
        </div>

        <div class="section">
          <div class="sh">
            <b>Music Sync</b>
            <small id="syncState">Off</small>
          </div>
          <div class="grid one">
            <div class="toggle">
              <div>
                <div class="name">Sync to audio (bass + beat)</div>
                <div class="small">Use a demo synth, an audio file, or your mic (permission required).</div>
              </div>
              <div class="switch" id="syncToggle" data-on="false" role="switch" aria-checked="false" tabindex="0"></div>
            </div>
            <div class="file">
              <input id="audioFile" type="file" accept="audio/*" />
            </div>
          </div>
          <div class="grid">
            <label>
              <div class="top"><span>Sensitivity</span><span id="valSens">1.25×</span></div>
              <input id="sensitivity" type="range" min="0.6" max="2.2" step="0.01" value="1.25" />
            </label>
            <label>
              <div class="top"><span>Beat Flash</span><span id="valBeatFlash">0.55</span></div>
              <input id="beatFlash" type="range" min="0" max="1" step="0.01" value="0.55" />
            </label>
            <label>
              <div class="top"><span>Bass</span><span id="valBass">0.85</span></div>
              <input id="bassBoost" type="range" min="0" max="1.8" step="0.01" value="0.85" />
            </label>
            <label>
              <div class="top"><span>Treble</span><span id="valTreble">0.55</span></div>
              <input id="trebleBoost" type="range" min="0" max="1.8" step="0.01" value="0.55" />
            </label>
          </div>
          <div class="grid one" style="padding-top:0">
            <div class="btnRow">
              <button class="btn" id="btnDemo">Demo Track</button>
              <button class="btn" id="btnMic">Mic</button>
            </div>
          </div>
          <div class="grid one" style="padding-top:0">
            <audio id="audio" controls preload="none" style="width:100%; filter: saturate(1.25) contrast(1.05);"></audio>
          </div>
        </div>

        <div class="section">
          <div class="sh">
            <b>Performance</b>
            <small id="perfHint">Adaptive</small>
          </div>
          <div class="grid">
            <label>
              <div class="top"><span>Resolution</span><span id="valRes">1.00×</span></div>
              <input id="resolution" type="range" min="0.6" max="1.5" step="0.01" value="1.0" />
            </label>
            <label>
              <div class="top"><span>Vignette</span><span id="valVig">0.35</span></div>
              <input id="vignette" type="range" min="0" max="0.85" step="0.01" value="0.35" />
            </label>
          </div>
          <div class="grid one" style="padding-top:0">
            <div class="toggle">
              <div>
                <div class="name">Low power mode</div>
                <div class="small">Cuts glow + particles for smoother rendering.</div>
              </div>
              <div class="switch" id="lowPowerToggle" data-on="false" role="switch" aria-checked="false" tabindex="0"></div>
            </div>
          </div>
        </div>

        <div class="small">
          Privacy: audio processing stays on-device. If you enable mic, your browser asks for permission.
        </div>
      </div>
    </aside>

    <main class="stage panel" id="stage">
      <canvas id="c"></canvas>
      <div class="hud">
        <div class="card">
          <b id="hudPattern">Aurora</b>
          <div class="m" id="hudMeta">Ring • 240 lights</div>
          <div class="meter">
            <span class="small">Level</span>
            <div class="bar" aria-hidden="true"><i id="meterLevel"></i></div>
          </div>
        </div>
        <div class="card">
          <b>Shortcuts</b>
          <div class="m">
            <span class="kbd">Space</span> play/pause&nbsp;&nbsp;
            <span class="kbd">R</span> randomize&nbsp;&nbsp;
            <span class="kbd">B</span> beat
          </div>
        </div>
      </div>
      <div class="toast" id="toast" role="status" aria-live="polite"></div>
      <div class="sr" id="liveRegion" aria-live="polite"></div>
    </main>
  </div>

  <script>
    (() => {
      "use strict";

      const el = (id) => document.getElementById(id);
      const stage = el("stage");
      const canvas = el("c");
      const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });

      const ui = {
        btnStart: el("btnStart"),
        btnPause: el("btnPause"),
        btnFullscreen: el("btnFullscreen"),
        btnBlackout: el("btnBlackout"),
        btnRandom: el("btnRandom"),
        btnBeat: el("btnBeat"),
        btnShare: el("btnShare"),
        btnDemo: el("btnDemo"),
        btnMic: el("btnMic"),
        pattern: el("pattern"),
        layout: el("layout"),
        speed: el("speed"),
        energy: el("energy"),
        glow: el("glow"),
        trails: el("trails"),
        lights: el("lights"),
        bloom: el("bloom"),
        baseColor: el("baseColor"),
        accentColor: el("accentColor"),
        warmColor: el("warmColor"),
        limeColor: el("limeColor"),
        hueDrift: el("hueDrift"),
        sensitivity: el("sensitivity"),
        beatFlash: el("beatFlash"),
        bassBoost: el("bassBoost"),
        trebleBoost: el("trebleBoost"),
        resolution: el("resolution"),
        vignette: el("vignette"),
        syncToggle: el("syncToggle"),
        lowPowerToggle: el("lowPowerToggle"),
        audioFile: el("audioFile"),
        audio: el("audio"),
        statusDot: el("statusDot"),
        statusText: el("statusText"),
        syncState: el("syncState"),
        patternHint: el("patternHint"),
        hudPattern: el("hudPattern"),
        hudMeta: el("hudMeta"),
        meterLevel: el("meterLevel"),
        toast: el("toast"),
        liveRegion: el("liveRegion"),
      };

      const labels = [
        ["pattern", "valPattern", (v) => ({
          aurora:"Aurora", rainbowChase:"Rainbow Chase", pulseGrid:"Pulse Grid", spiral:"Spiral", strobe:"Strobe",
          sparkle:"Sparkle", fireworks:"Fireworks", wave:"Wave", scanline:"Scanline"
        })[v] || v],
        ["layout", "valLayout", (v) => v.charAt(0).toUpperCase() + v.slice(1)],
        ["speed", "valSpeed", (v) => `${(+v).toFixed(2)}×`],
        ["energy", "valEnergy", (v) => (+v).toFixed(2)],
        ["glow", "valGlow", (v) => (+v).toFixed(2)],
        ["trails", "valTrails", (v) => (+v).toFixed(2)],
        ["lights", "valLights", (v) => `${Math.round(+v)}`],
        ["bloom", "valBloom", (v) => (+v).toFixed(2)],
        ["baseColor", "valBase", (v) => v.toUpperCase()],
        ["accentColor", "valAccent", (v) => v.toUpperCase()],
        ["warmColor", "valWarm", (v) => v.toUpperCase()],
        ["limeColor", "valLime", (v) => v.toUpperCase()],
        ["hueDrift", "valHueDrift", (v) => (+v).toFixed(2)],
        ["sensitivity", "valSens", (v) => `${(+v).toFixed(2)}×`],
        ["beatFlash", "valBeatFlash", (v) => (+v).toFixed(2)],
        ["bassBoost", "valBass", (v) => (+v).toFixed(2)],
        ["trebleBoost", "valTreble", (v) => (+v).toFixed(2)],
        ["resolution", "valRes", (v) => `${(+v).toFixed(2)}×`],
        ["vignette", "valVig", (v) => (+v).toFixed(2)],
      ];

      function setLabel(id, value){
        const pair = labels.find(p => p[0] === id);
        if (!pair) return;
        const [, outId, fmt] = pair;
        const out = el(outId);
        if (out) out.textContent = fmt(value);
      }
      for (const [id] of labels){
        const node = ui[id];
        if (!node) continue;
        const on = () => setLabel(id, node.value);
        node.addEventListener("input", on);
        on();
      }

      const hints = {
        aurora:"Silky gradients, bass-driven glow",
        rainbowChase:"Classic festival chase, vivid hue sweep",
        pulseGrid:"Beat-pulse waves across a grid",
        spiral:"Helix rotation with shimmer",
        strobe:"Sharp hits and accents",
        sparkle:"Twinkles + glitter burst",
        fireworks:"Beat-triggered particles",
        wave:"Sine waves + color crossfade",
        scanline:"Laser scanner sweep",
      };

      function toast(msg){
        ui.toast.textContent = msg;
        ui.liveRegion.textContent = msg;
        ui.toast.classList.add("on");
        clearTimeout(toast._t);
        toast._t = setTimeout(() => ui.toast.classList.remove("on"), 1600);
      }

      function clamp01(x){ return Math.max(0, Math.min(1, x)); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function smoothstep(a,b,x){
        const t = clamp01((x-a)/(b-a));
        return t*t*(3 - 2*t);
      }
      function fract(x){ return x - Math.floor(x); }
      function hash11(x){
        const s = Math.sin(x * 127.1 + 311.7) * 43758.5453123;
        return fract(s);
      }
      function hash21(x,y){
        const s = Math.sin(x*127.1 + y*311.7 + 74.7) * 43758.5453123;
        return fract(s);
      }

      function hexToRgb(hex){
        const m = /^#?([0-9a-f]{6})$/i.exec(hex.trim());
        if (!m) return {r:255,g:255,b:255};
        const n = parseInt(m[1], 16);
        return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
      }
      function rgbToHsl({r,g,b}){
        r/=255; g/=255; b/=255;
        const max = Math.max(r,g,b), min = Math.min(r,g,b);
        const d = max - min;
        let h = 0;
        if (d !== 0){
          if (max === r) h = ((g - b) / d) % 6;
          else if (max === g) h = (b - r) / d + 2;
          else h = (r - g) / d + 4;
          h /= 6;
          if (h < 0) h += 1;
        }
        const l = (max + min) / 2;
        const s = d === 0 ? 0 : d / (1 - Math.abs(2*l - 1));
        return { h, s, l };
      }
      function hslToRgb(h,s,l){
        const hue2rgb = (p,q,t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        let r,g,b;
        if (s === 0){
          r=g=b=l;
        } else {
          const q = l < 0.5 ? l * (1+s) : l + s - l*s;
          const p = 2*l - q;
          r = hue2rgb(p,q,h + 1/3);
          g = hue2rgb(p,q,h);
          b = hue2rgb(p,q,h - 1/3);
        }
        return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
      }
      function mixRgb(a,b,t){
        return {
          r: Math.round(lerp(a.r,b.r,t)),
          g: Math.round(lerp(a.g,b.g,t)),
          b: Math.round(lerp(a.b,b.b,t)),
        };
      }
      function rgba({r,g,b}, a){
        return `rgba(${r},${g},${b},${a})`;
      }

      const state = {
        running: false,
        paused: false,
        startedAt: 0,
        t0: performance.now(),
        lastFrame: performance.now(),
        dt: 1/60,
        beatPulse: 0,
        beatHit: 0,
        blackout: false,
        layoutDirty: true,
        particles: [],
        pointer: { x: 0, y: 0 },
        ringWarp: 0,
        fps: 60,
        fpsS: 60,
        frameCount: 0,
        audio: {
          enabled: false,
          ctx: null,
          analyser: null,
          dataFreq: null,
          dataTime: null,
          source: null,
          micStream: null,
          demoNodes: null,
          level: 0,
          bass: 0,
          mid: 0,
          treble: 0,
          beat: 0,
          beatCooldown: 0,
          eHist: [],
          ePtr: 0,
          eAvg: 0,
        }
      };

      function getSettings(){
        return {
          pattern: ui.pattern.value,
          layout: ui.layout.value,
          speed: +ui.speed.value,
          energy: +ui.energy.value,
          glow: +ui.glow.value,
          trails: +ui.trails.value,
          lights: Math.round(+ui.lights.value),
          bloom: +ui.bloom.value,
          baseColor: ui.baseColor.value,
          accentColor: ui.accentColor.value,
          warmColor: ui.warmColor.value,
          limeColor: ui.limeColor.value,
          hueDrift: +ui.hueDrift.value,
          sensitivity: +ui.sensitivity.value,
          beatFlash: +ui.beatFlash.value,
          bassBoost: +ui.bassBoost.value,
          trebleBoost: +ui.trebleBoost.value,
          resolution: +ui.resolution.value,
          vignette: +ui.vignette.value,
          sync: ui.syncToggle.dataset.on === "true",
          lowPower: ui.lowPowerToggle.dataset.on === "true",
        };
      }

      function applySettings(s){
        const set = (node, value) => {
          if (!node) return;
          node.value = value;
          node.dispatchEvent(new Event("input", { bubbles: true }));
        };
        set(ui.pattern, s.pattern ?? ui.pattern.value);
        set(ui.layout, s.layout ?? ui.layout.value);
        set(ui.speed, s.speed ?? ui.speed.value);
        set(ui.energy, s.energy ?? ui.energy.value);
        set(ui.glow, s.glow ?? ui.glow.value);
        set(ui.trails, s.trails ?? ui.trails.value);
        set(ui.lights, s.lights ?? ui.lights.value);
        set(ui.bloom, s.bloom ?? ui.bloom.value);
        set(ui.baseColor, s.baseColor ?? ui.baseColor.value);
        set(ui.accentColor, s.accentColor ?? ui.accentColor.value);
        set(ui.warmColor, s.warmColor ?? ui.warmColor.value);
        set(ui.limeColor, s.limeColor ?? ui.limeColor.value);
        set(ui.hueDrift, s.hueDrift ?? ui.hueDrift.value);
        set(ui.sensitivity, s.sensitivity ?? ui.sensitivity.value);
        set(ui.beatFlash, s.beatFlash ?? ui.beatFlash.value);
        set(ui.bassBoost, s.bassBoost ?? ui.bassBoost.value);
        set(ui.trebleBoost, s.trebleBoost ?? ui.trebleBoost.value);
        set(ui.resolution, s.resolution ?? ui.resolution.value);
        set(ui.vignette, s.vignette ?? ui.vignette.value);
        if (typeof s.lowPower === "boolean") setSwitch(ui.lowPowerToggle, s.lowPower);
        if (typeof s.sync === "boolean") setSwitch(ui.syncToggle, s.sync);
        state.layoutDirty = true;
      }

      function encodeSettings(s){
        const json = JSON.stringify(s);
        const bytes = new TextEncoder().encode(json);
        let bin = "";
        for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
        return btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
      }
      function decodeSettings(h){
        try{
          const b64 = h.replace(/-/g,"+").replace(/_/g,"/");
          const pad = b64.length % 4 ? "=".repeat(4 - (b64.length % 4)) : "";
          const bin = atob(b64 + pad);
          const bytes = new Uint8Array(bin.length);
          for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
          const json = new TextDecoder().decode(bytes);
          const obj = JSON.parse(json);
          return obj && typeof obj === "object" ? obj : null;
        } catch {
          return null;
        }
      }

      function setSwitch(node, on){
        node.dataset.on = on ? "true" : "false";
        node.setAttribute("aria-checked", on ? "true" : "false");
      }
      function toggleSwitch(node){
        const on = node.dataset.on !== "true";
        setSwitch(node, on);
        return on;
      }
      for (const sw of [ui.syncToggle, ui.lowPowerToggle]){
        sw.addEventListener("click", () => {
          const on = toggleSwitch(sw);
          if (sw === ui.syncToggle) setSync(on);
          if (sw === ui.lowPowerToggle) toast(on ? "Low power mode on" : "Low power mode off");
        });
        sw.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") { e.preventDefault(); sw.click(); }
        });
      }

      function updateTopMeta(){
        const s = getSettings();
        ui.patternHint.textContent = hints[s.pattern] || "Neon motion";
        ui.hudPattern.textContent = (labels.find(x => x[0] === "pattern")[2])(s.pattern);
        ui.hudMeta.textContent = `${s.layout.charAt(0).toUpperCase()+s.layout.slice(1)} • ${s.lights} lights`;
        ui.syncState.textContent = s.sync ? (state.audio.enabled ? "On" : "On (needs audio)") : "Off";
      }
      ui.pattern.addEventListener("change", updateTopMeta);
      ui.layout.addEventListener("change", () => { state.layoutDirty = true; updateTopMeta(); });
      ui.lights.addEventListener("input", () => { state.layoutDirty = true; updateTopMeta(); });
      ui.syncToggle.addEventListener("click", updateTopMeta);
      updateTopMeta();

      function setStatus(mode, detail){
        ui.statusText.textContent = detail ? `${mode} • ${detail}` : mode;
        const color = mode === "Live" ? "#22d3ee" : mode === "Paused" ? "#fb7185" : "#a3e635";
        ui.statusDot.style.background = color;
        ui.statusDot.style.boxShadow = `0 0 0 2px ${color}33, 0 0 20px ${color}66`;
      }
      setStatus("Ready");

      // ----- Layout: positions in normalized space [-1..1] -----
      let lights = [];
      function rebuildLights(){
        const s = getSettings();
        const n = Math.max(24, Math.min(1200, s.lights|0));
        lights = new Array(n);
        for (let i=0;i<n;i++) lights[i] = { x:0, y:0, a:0, r:0, seed: hash11(i+1.234) };
        const layout = s.layout;
        if (layout === "ring"){
          for (let i=0;i<n;i++){
            const a = (i / n) * Math.PI * 2;
            const wob = (hash11(i*1.7) - 0.5) * 0.12;
            const rr = 0.74 + wob;
            lights[i].x = Math.cos(a) * rr;
            lights[i].y = Math.sin(a) * rr;
            lights[i].a = a;
            lights[i].r = rr;
          }
        } else if (layout === "grid"){
          const cols = Math.ceil(Math.sqrt(n * 1.25));
          const rows = Math.ceil(n / cols);
          let k=0;
          for (let y=0;y<rows;y++){
            for (let x=0;x<cols;x++){
              if (k >= n) break;
              const u = cols <= 1 ? 0.5 : x/(cols-1);
              const v = rows <= 1 ? 0.5 : y/(rows-1);
              const jx = (hash21(x,y) - 0.5) * 0.05;
              const jy = (hash21(y,x) - 0.5) * 0.05;
              lights[k].x = (u*2 - 1) * 0.9 + jx;
              lights[k].y = (v*2 - 1) * 0.9 + jy;
              lights[k].a = Math.atan2(lights[k].y, lights[k].x);
              lights[k].r = Math.hypot(lights[k].x, lights[k].y);
              k++;
            }
          }
        } else if (layout === "tunnel"){
          for (let i=0;i<n;i++){
            const ring = i / n;
            const a = ring * Math.PI * 7.5 + hash11(i*3.3)*0.7;
            const rr = 0.18 + Math.pow(ring, 0.72) * 0.86;
            lights[i].x = Math.cos(a) * rr;
            lights[i].y = Math.sin(a) * rr;
            lights[i].a = a;
            lights[i].r = rr;
          }
        } else { // stage
          // Pseudo stage rig: top truss + side towers + floor cans
          const top = Math.floor(n*0.38);
          const side = Math.floor(n*0.24);
          const floor = n - top - side*2;
          let k=0;
          for (let i=0;i<top;i++){
            const u = top <= 1 ? 0.5 : i/(top-1);
            lights[k].x = (u*2 - 1)*0.92 + (hash11(i*2.1)-0.5)*0.03;
            lights[k].y = -0.82 + (hash11(i*6.2)-0.5)*0.05;
            k++;
          }
          for (let i=0;i<side;i++){
            const v = side <= 1 ? 0.5 : i/(side-1);
            const y = (v*2 - 1)*0.78 + (hash11(i*8.1)-0.5)*0.04;
            lights[k].x = -0.92 + (hash11(i*1.2)-0.5)*0.04;
            lights[k].y = y;
            k++;
          }
          for (let i=0;i<side;i++){
            const v = side <= 1 ? 0.5 : i/(side-1);
            const y = (v*2 - 1)*0.78 + (hash11(i*9.1)-0.5)*0.04;
            lights[k].x = 0.92 + (hash11(i*2.2)-0.5)*0.04;
            lights[k].y = y;
            k++;
          }
          for (let i=0;i<floor;i++){
            const u = floor <= 1 ? 0.5 : i/(floor-1);
            lights[k].x = (u*2 - 1)*0.92 + (hash11(i*4.1)-0.5)*0.04;
            lights[k].y = 0.82 + (hash11(i*5.1)-0.5)*0.05;
            k++;
          }
          for (let i=0;i<n;i++){
            lights[i].a = Math.atan2(lights[i].y, lights[i].x);
            lights[i].r = Math.hypot(lights[i].x, lights[i].y);
          }
        }
        state.layoutDirty = false;
      }

      // ----- Audio / Music Sync -----
      function ensureAudio(){
        if (state.audio.ctx) return state.audio.ctx;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return null;
        const audioCtx = new AudioContext();
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.75;
        analyser.minDecibels = -85;
        analyser.maxDecibels = -10;
        const gain = audioCtx.createGain();
        gain.gain.value = 0.9;
        gain.connect(analyser);
        analyser.connect(audioCtx.destination);
        state.audio.ctx = audioCtx;
        state.audio.analyser = analyser;
        state.audio.dataFreq = new Uint8Array(analyser.frequencyBinCount);
        state.audio.dataTime = new Uint8Array(analyser.fftSize);
        state.audio.master = gain;

        // Beat history for energy-based beat detection
        state.audio.eHist = new Array(60).fill(0);
        state.audio.ePtr = 0;
        state.audio.eAvg = 0;

        return audioCtx;
      }

      function disconnectSource(){
        try { state.audio.source?.disconnect?.(); } catch {}
        state.audio.source = null;
      }
      function stopMic(){
        if (!state.audio.micStream) return;
        for (const tr of state.audio.micStream.getTracks()) tr.stop();
        state.audio.micStream = null;
      }
      function stopDemo(){
        const nodes = state.audio.demoNodes;
        if (!nodes) return;
        try {
          nodes.sched?.stop?.();
        } catch {}
        for (const n of nodes.toStop || []) { try{ n.stop(); } catch {} }
        for (const n of nodes.toDisc || []) { try{ n.disconnect(); } catch {} }
        state.audio.demoNodes = null;
      }

      async function useMediaElement(){
        const audioCtx = ensureAudio();
        if (!audioCtx) { toast("Audio not supported in this browser"); return; }
        stopDemo();
        stopMic();
        disconnectSource();
        try {
          const src = audioCtx.createMediaElementSource(ui.audio);
          src.connect(state.audio.master);
          state.audio.source = src;
          state.audio.enabled = true;
          updateTopMeta();
          toast("Audio file connected");
        } catch (e){
          // Some browsers restrict multiple MediaElementSource per element
          toast("Couldn't connect audio element (try reloading the page)");
        }
      }

      async function useMic(){
        const audioCtx = ensureAudio();
        if (!audioCtx) { toast("Audio not supported in this browser"); return; }
        stopDemo();
        disconnectSource();
        stopMic();
        try{
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          const src = audioCtx.createMediaStreamSource(stream);
          src.connect(state.audio.master);
          state.audio.source = src;
          state.audio.micStream = stream;
          state.audio.enabled = true;
          updateTopMeta();
          toast("Mic connected");
        } catch {
          toast("Mic permission denied");
        }
      }

      function startDemoTrack(){
        const audioCtx = ensureAudio();
        if (!audioCtx) { toast("Audio not supported in this browser"); return; }
        stopMic();
        disconnectSource();
        stopDemo();

        const master = state.audio.master;
        const toStop = [];
        const toDisc = [];

        // Gentle sidechain-like pump using a low-frequency envelope.
        const pump = audioCtx.createGain();
        pump.gain.value = 1.0;
        pump.connect(master);
        toDisc.push(pump);

        // Music bed: chord pad
        const padGain = audioCtx.createGain();
        padGain.gain.value = 0.12;
        padGain.connect(pump);
        toDisc.push(padGain);

        const padLP = audioCtx.createBiquadFilter();
        padLP.type = "lowpass";
        padLP.frequency.value = 1600;
        padLP.Q.value = 0.7;
        padLP.connect(padGain);
        toDisc.push(padLP);

        const padChords = [
          [0, 4, 7, 11],   // maj7
          [0, 3, 7, 10],   // min7
          [0, 5, 9, 12],   // sus2-ish
          [0, 4, 7, 10],   // dom7
        ];
        const base = 110; // A2-ish

        function osc(type, freq, gain){
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g);
          g.connect(padLP);
          o.start();
          toStop.push(o);
          toDisc.push(g);
          return { o, g };
        }

        const padOscs = [];
        for (let i=0;i<4;i++) padOscs.push(osc("sawtooth", base * (1 + i*0.01), 0.0001));
        // Lead pluck
        const leadGain = audioCtx.createGain();
        leadGain.gain.value = 0.22;
        leadGain.connect(pump);
        toDisc.push(leadGain);
        const leadBP = audioCtx.createBiquadFilter();
        leadBP.type = "bandpass";
        leadBP.frequency.value = 850;
        leadBP.Q.value = 0.8;
        leadBP.connect(leadGain);
        toDisc.push(leadBP);

        const leadDel = audioCtx.createDelay(1.0);
        leadDel.delayTime.value = 0.22;
        leadDel.connect(leadGain);
        toDisc.push(leadDel);
        const leadFb = audioCtx.createGain();
        leadFb.gain.value = 0.32;
        leadGain.connect(leadDel);
        leadDel.connect(leadFb);
        leadFb.connect(leadDel);
        toDisc.push(leadFb);

        const lead = audioCtx.createOscillator();
        lead.type = "triangle";
        lead.frequency.value = 440;
        const leadEG = audioCtx.createGain();
        leadEG.gain.value = 0.0001;
        lead.connect(leadEG);
        leadEG.connect(leadBP);
        lead.start();
        toStop.push(lead);
        toDisc.push(leadEG);

        // Drums: kick + hat
        const drumGain = audioCtx.createGain();
        drumGain.gain.value = 0.55;
        drumGain.connect(pump);
        toDisc.push(drumGain);

        function kick(t){
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = "sine";
          o.frequency.setValueAtTime(150, t);
          o.frequency.exponentialRampToValueAtTime(48, t + 0.12);
          g.gain.setValueAtTime(1.0, t);
          g.gain.exponentialRampToValueAtTime(0.0001, t + 0.14);
          o.connect(g);
          g.connect(drumGain);
          o.start(t);
          o.stop(t + 0.16);
        }
        function hat(t){
          const bufferSize = 2 * audioCtx.sampleRate;
          const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2 - 1) * Math.pow(1 - i/bufferSize, 3);
          const src = audioCtx.createBufferSource();
          src.buffer = buffer;
          const hp = audioCtx.createBiquadFilter();
          hp.type = "highpass";
          hp.frequency.value = 6500;
          const g = audioCtx.createGain();
          g.gain.setValueAtTime(0.24, t);
          g.gain.exponentialRampToValueAtTime(0.0001, t + 0.05);
          src.connect(hp); hp.connect(g); g.connect(drumGain);
          src.start(t);
          src.stop(t + 0.06);
        }

        // Scheduler
        const bpm = 124;
        const spb = 60 / bpm;
        let step = 0;
        let chord = 0;
        let nextTime = audioCtx.currentTime + 0.05;
        const scale = [0, 3, 5, 7, 10, 12]; // minor-ish pentatonic

        const sched = {
          stopped: false,
          stop(){ this.stopped = true; }
        };
        function tick(){
          if (sched.stopped) return;
          const now = audioCtx.currentTime;
          while (nextTime < now + 0.25){
            const beat = step % 4;
            if (beat === 0) kick(nextTime);
            if (beat === 2 && Math.random() < 0.35) kick(nextTime);
            if (Math.random() < 0.85) hat(nextTime);
            if (Math.random() < 0.6) hat(nextTime + spb*0.5);

            // Sidechain pump
            pump.gain.cancelScheduledValues(nextTime);
            pump.gain.setValueAtTime(1.0, nextTime);
            pump.gain.linearRampToValueAtTime(0.62, nextTime + 0.02);
            pump.gain.exponentialRampToValueAtTime(1.0, nextTime + 0.18);

            // Chord change every 2 bars
            if (step % 8 === 0){
              chord = (chord + 1) % padChords.length;
              const deg = padChords[chord];
              for (let i=0;i<padOscs.length;i++){
                const semi = deg[i] + (chord % 2 ? 12 : 0);
                const f = base * Math.pow(2, semi/12);
                padOscs[i].o.frequency.setTargetAtTime(f, nextTime, 0.02);
                padOscs[i].g.gain.setTargetAtTime(0.045, nextTime, 0.06);
              }
              padLP.frequency.setTargetAtTime(1400 + Math.random()*800, nextTime, 0.2);
            }

            // Lead pluck
            if (Math.random() < 0.78){
              const note = scale[(step + Math.floor(Math.random()*3)) % scale.length] + (Math.random()<0.45 ? 12 : 24);
              const f = 220 * Math.pow(2, note/12);
              lead.frequency.setTargetAtTime(f, nextTime, 0.01);
              leadEG.gain.cancelScheduledValues(nextTime);
              leadEG.gain.setValueAtTime(0.0001, nextTime);
              leadEG.gain.exponentialRampToValueAtTime(0.55, nextTime + 0.01);
              leadEG.gain.exponentialRampToValueAtTime(0.0001, nextTime + 0.12);
              leadBP.frequency.setTargetAtTime(700 + Math.random()*850, nextTime, 0.06);
            }

            step++;
            nextTime += spb * 0.5; // eighth notes
          }
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);

        state.audio.demoNodes = { toStop, toDisc, sched };
        state.audio.enabled = true;
        updateTopMeta();
        toast("Demo track: synthwave pulse");
      }

      function setSync(on){
        if (on){
          const audioCtx = ensureAudio();
          if (!audioCtx){ setSwitch(ui.syncToggle, false); updateTopMeta(); return; }
          if (audioCtx.state === "suspended") audioCtx.resume?.();
          toast("Music sync armed");
        } else {
          toast("Music sync off");
        }
        updateTopMeta();
      }

      function readAudio(){
        if (!state.audio.enabled || !state.audio.analyser) {
          state.audio.level *= 0.92;
          state.audio.bass *= 0.92;
          state.audio.mid *= 0.92;
          state.audio.treble *= 0.92;
          state.audio.beat *= 0.9;
          return;
        }
        const { analyser, dataFreq, dataTime } = state.audio;
        analyser.getByteFrequencyData(dataFreq);
        analyser.getByteTimeDomainData(dataTime);

        // RMS level
        let sum = 0;
        for (let i=0;i<dataTime.length;i++){
          const v = (dataTime[i] - 128) / 128;
          sum += v*v;
        }
        const rms = Math.sqrt(sum / dataTime.length);

        const n = dataFreq.length;
        const band = (a,b) => {
          const i0 = Math.max(0, Math.floor(a*n));
          const i1 = Math.min(n-1, Math.floor(b*n));
          let s = 0;
          for (let i=i0;i<=i1;i++) s += dataFreq[i];
          const denom = Math.max(1, i1 - i0 + 1);
          return (s/denom) / 255;
        };

        const bass = band(0.00, 0.10);
        const mid = band(0.10, 0.42);
        const treble = band(0.42, 1.00);

        // Smooth
        state.audio.level = lerp(state.audio.level, clamp01(rms * 1.8), 0.18);
        state.audio.bass = lerp(state.audio.bass, bass, 0.22);
        state.audio.mid = lerp(state.audio.mid, mid, 0.18);
        state.audio.treble = lerp(state.audio.treble, treble, 0.18);

        // Beat detection (bass energy vs rolling average)
        const s = getSettings();
        const energy = Math.pow(bass, 1.35);
        const hist = state.audio.eHist;
        const ptr = state.audio.ePtr;
        state.audio.eAvg += (energy - hist[ptr]) / hist.length;
        hist[ptr] = energy;
        state.audio.ePtr = (ptr + 1) % hist.length;

        const avg = Math.max(0.0001, state.audio.eAvg);
        const sens = s.sensitivity;
        state.audio.beatCooldown = Math.max(0, state.audio.beatCooldown - state.dt);
        const threshold = avg * sens;
        const isBeat = (energy > threshold) && (bass > 0.14) && state.audio.beatCooldown <= 0;
        if (isBeat){
          state.audio.beat = 1.0;
          state.audio.beatCooldown = 0.16;
          onBeat("audio");
        } else {
          state.audio.beat = Math.max(0, state.audio.beat - state.dt * 3.1);
        }
      }

      // ----- Rendering -----
      let w=0, h=0, dpr=1;
      function resize(){
        const rect = stage.getBoundingClientRect();
        const s = getSettings();
        dpr = Math.min(2.2, (window.devicePixelRatio || 1) * s.resolution);
        w = Math.max(320, Math.floor(rect.width * dpr));
        h = Math.max(240, Math.floor(rect.height * dpr));
        canvas.width = w;
        canvas.height = h;
        state.layoutDirty = true;
      }
      window.addEventListener("resize", resize, { passive: true });

      function palette(){
        const s = getSettings();
        const a = rgbToHsl(hexToRgb(s.baseColor));
        const b = rgbToHsl(hexToRgb(s.accentColor));
        const c = rgbToHsl(hexToRgb(s.warmColor));
        const d = rgbToHsl(hexToRgb(s.limeColor));
        // Convert to HSL then drift hue slightly for animation.
        return { a, b, c, d };
      }

      function pickColor(pal, t, x){
        // x in [0..1], blend across 4 points with gentle bias.
        const u = clamp01(x);
        const a = pal.a, b = pal.b, c = pal.c, d = pal.d;
        const drift = (+ui.hueDrift.value) * (0.18 + 0.82*state.audio.treble);
        const hh = (h) => fract(h + drift * Math.sin(t*0.17 + u*6.0));
        const s = lerp(0.70, 0.98, 0.5 + 0.5*Math.sin(t*0.19 + u*3.2));
        const l = lerp(0.48, 0.62, 0.5 + 0.5*Math.sin(t*0.13 + u*4.1));
        const seg = u * 3;
        let h0,h1;
        if (seg < 1){ h0=hh(a.h); h1=hh(b.h); }
        else if (seg < 2){ h0=hh(b.h); h1=hh(c.h); }
        else { h0=hh(c.h); h1=hh(d.h); }
        const tt = fract(seg);
        // shortest-arc hue blend
        let dh = h1 - h0;
        if (dh > 0.5) dh -= 1;
        if (dh < -0.5) dh += 1;
        const hMix = fract(h0 + dh * smoothstep(0,1,tt));
        return hslToRgb(hMix, Math.min(1, s), Math.min(1, l));
      }

      function drawVignette(strength){
        if (strength <= 0.001) return;
        const g = ctx.createRadialGradient(w*0.5, h*0.5, Math.min(w,h)*0.12, w*0.5, h*0.5, Math.max(w,h)*0.68);
        g.addColorStop(0, "rgba(0,0,0,0)");
        g.addColorStop(1, `rgba(0,0,0,${clamp01(strength)})`);
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);
      }

      function onBeat(source){
        state.beatHit = 1.0;
        state.beatPulse = 1.0;
        if (getSettings().pattern === "fireworks" && !getSettings().lowPower){
          spawnFireworks(1 + Math.floor(Math.random()*2), source);
        } else if (!getSettings().lowPower && Math.random() < 0.25){
          spawnFireworks(1, source);
        }
      }

      function spawnFireworks(count, source){
        const s = getSettings();
        for (let k=0;k<count;k++){
          const center = {
            x: (hash11(performance.now()*0.001 + k*11.1) * 1.6 - 0.8),
            y: (hash11(performance.now()*0.001 + k*19.7) * 0.9 - 0.55),
          };
          const burst = 42 + Math.floor(Math.random()*70);
          const power = (source === "audio" ? 1.0 : 0.75) * (0.7 + state.audio.level*0.7);
          const t = (performance.now() - state.t0) * 0.001;
          const pal = palette();
          const base = pickColor(pal, t, Math.random());
          for (let i=0;i<burst;i++){
            const a = (i/burst) * Math.PI*2 + (Math.random()-0.5)*0.2;
            const sp = (0.35 + Math.random()*0.9) * power;
            state.particles.push({
              x:center.x, y:center.y,
              vx: Math.cos(a) * sp,
              vy: Math.sin(a) * sp,
              life: 0.7 + Math.random()*0.8,
              age: 0,
              size: 0.7 + Math.random()*1.8,
              col: base,
              hueJ: (Math.random()-0.5)*0.12
            });
          }
        }
      }

      function drawLight(px, py, radius, color, intensity, glow){
        if (intensity <= 0.001) return;
        const a = clamp01(intensity);
        const g = ctx.createRadialGradient(px, py, 0, px, py, radius);
        const core = rgba(color, clamp01(a * (0.88 + glow*0.35)));
        const mid = rgba(color, clamp01(a * (0.28 + glow*0.42)));
        const out = rgba(color, 0);
        g.addColorStop(0, core);
        g.addColorStop(0.25, mid);
        g.addColorStop(1, out);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI*2);
        ctx.fill();
      }

      function patternAt(s, t, L, audio){
        const i = L.i, n = L.n;
        const a = L.a, r = L.r;
        const x = L.x, y = L.y;

        const speed = s.speed;
        const eng = s.energy;
        const bass = audio.bass * s.bassBoost;
        const treb = audio.treble * s.trebleBoost;
        const lvl = audio.level;
        const beat = audio.beat;
        const pulse = state.beatPulse;

        const tw = (hash11(i*13.7) - 0.5);
        const shimmer = 0.5 + 0.5*Math.sin(t*2.1*speed + i*0.14 + tw*1.7);

        let u = 0, v = 0, bright = 0, huePos = 0;
        switch (s.pattern){
          case "rainbowChase": {
            huePos = fract(i/n + t*0.18*speed + r*0.22);
            const chase = 0.5 + 0.5*Math.sin((i/n)*Math.PI*2*6 + t*3.3*speed);
            bright = (0.22 + 0.78*chase) * (0.55 + 0.45*lvl) * eng;
            bright *= 0.85 + 0.15*Math.pow(treb, 1.2);
            bright += beat * s.beatFlash * 0.35;
            break;
          }
          case "pulseGrid": {
            u = (x*0.5 + 0.5);
            v = (y*0.5 + 0.5);
            const wave = 0.5 + 0.5*Math.sin((u*7.0 + v*9.0)*Math.PI + t*3.0*speed);
            const rings = 0.5 + 0.5*Math.sin((r*9.5)*Math.PI - t*2.4*speed);
            huePos = fract(u*0.35 + v*0.45 + t*0.06*speed);
            bright = (0.12 + 0.88*wave*rings) * eng;
            bright *= 0.75 + 0.55*bass;
            bright += beat * s.beatFlash * 0.55;
            break;
          }
          case "spiral": {
            huePos = fract(a/(Math.PI*2) + t*0.1*speed + r*0.35);
            const sp = 0.5 + 0.5*Math.sin((a + r*9.0 - t*3.4*speed));
            bright = (0.18 + 0.82*Math.pow(sp, 1.4)) * eng;
            bright *= 0.65 + 0.7*(0.55*bass + 0.45*treb);
            bright += pulse * s.beatFlash * 0.35;
            break;
          }
          case "strobe": {
            huePos = fract(t*0.08 + i/n);
            const rate = 6.0 + 12.0*speed + 18.0*bass;
            const st = Math.sin(t*rate*Math.PI);
            bright = (st > 0.75 ? 1 : 0.06) * eng;
            bright *= 0.8 + 0.4*lvl;
            bright += beat * s.beatFlash * 0.75;
            break;
          }
          case "sparkle": {
            huePos = fract((i/n)*0.55 + t*0.09*speed + r*0.25);
            const sparkle = smoothstep(0.92, 1.0, hash11(Math.floor(t*10*speed) * 999 + i*7.1));
            const glit = smoothstep(0.7, 1.0, shimmer);
            bright = (0.08 + 0.55*glit + 1.1*sparkle*(0.4+0.6*treb)) * eng;
            bright *= 0.75 + 0.45*lvl;
            bright += beat * s.beatFlash * 0.5;
            break;
          }
          case "fireworks": {
            huePos = fract(i/n + t*0.05*speed);
            const base = 0.06 + 0.24*(0.5 + 0.5*Math.sin(t*1.6*speed + r*5.0));
            bright = base * eng * (0.85 + 0.65*lvl);
            bright += beat * s.beatFlash * 0.65;
            break;
          }
          case "wave": {
            huePos = fract(0.35*(x+1) + 0.25*(y+1) + t*0.05*speed);
            const wv = 0.5 + 0.5*Math.sin((x*5.2 + y*3.7)*Math.PI + t*3.1*speed);
            const wv2 = 0.5 + 0.5*Math.sin((x*2.1 - y*6.1)*Math.PI - t*2.1*speed);
            bright = (0.12 + 0.88*(0.55*wv + 0.45*wv2)) * eng;
            bright *= 0.7 + 0.65*(0.7*bass + 0.3*treb);
            bright += pulse * s.beatFlash * 0.3;
            break;
          }
          case "scanline": {
            huePos = fract(t*0.07*speed + 0.35*(x+1));
            const scan = smoothstep(0.0, 0.2, 1 - Math.abs((y*0.5+0.5) - fract(t*0.38*speed)));
            const scan2 = smoothstep(0.0, 0.18, 1 - Math.abs((x*0.5+0.5) - fract(t*0.28*speed + 0.2)));
            bright = (0.07 + 1.15*(0.75*scan + 0.25*scan2)) * eng;
            bright *= 0.65 + 0.8*lvl;
            bright += beat * s.beatFlash * 0.5;
            break;
          }
          default: { // aurora
            huePos = fract(0.12*(x+1) + 0.18*(y+1) + t*0.06*speed + r*0.18);
            const flow = 0.5 + 0.5*Math.sin((x*2.3 + y*2.0)*Math.PI + t*1.55*speed);
            const flow2 = 0.5 + 0.5*Math.sin((x*1.0 - y*2.8)*Math.PI - t*1.25*speed);
            const aur = 0.55*flow + 0.45*flow2;
            bright = (0.1 + 0.95*Math.pow(aur, 1.35)) * eng;
            bright *= 0.65 + 0.85*(0.75*bass + 0.25*treb);
            bright += beat * s.beatFlash * 0.5;
            break;
          }
        }
        bright = clamp01(bright);
        return { bright, huePos, shimmer: clamp01(shimmer), bass, treb, lvl };
      }

      function frame(now){
        requestAnimationFrame(frame);
        const s = getSettings();

        // Timing
        const dt = Math.min(0.05, Math.max(0.001, (now - state.lastFrame) / 1000));
        state.lastFrame = now;
        state.dt = dt;
        const t = (now - state.t0) / 1000;
        state.beatPulse = Math.max(0, state.beatPulse - dt * 2.4);
        state.beatHit = Math.max(0, state.beatHit - dt * 3.2);

        // fps estimate
        state.frameCount++;
        if (state.frameCount % 14 === 0){
          state.fpsS = lerp(state.fpsS, 1/dt, 0.12);
          state.fps = Math.round(state.fpsS);
        }

        if (state.layoutDirty) rebuildLights();
        if (w === 0 || h === 0) resize();

        // Audio
        readAudio();
        const sync = s.sync;
        const audioMod = sync ? state.audio : { level:0, bass:0, mid:0, treble:0, beat:0 };

        // Meter UI
        ui.meterLevel.style.width = `${Math.round(12 + 88*clamp01(audioMod.level))}%`;

        // Background wash + trails
        const trail = clamp01(s.trails);
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = `rgba(4,4,10,${Math.max(0.08, 0.28 + trail)})`;
        ctx.fillRect(0,0,w,h);

        const pal = palette();
        const center = {
          x: w*0.5 + state.pointer.x * w * 0.035,
          y: h*0.5 + state.pointer.y * h * 0.03
        };
        const scale = Math.min(w,h) * 0.42;

        // Stage glow wash
        const washInt = clamp01(0.25 + 0.9*s.energy*(0.35 + 0.65*audioMod.level));
        if (!s.lowPower){
          const wash = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, Math.max(w,h)*0.65);
          const c0 = pickColor(pal, t, fract(t*0.03));
          const c1 = pickColor(pal, t, fract(0.35 + t*0.04));
          wash.addColorStop(0, rgba(c0, 0.12*washInt));
          wash.addColorStop(0.6, rgba(c1, 0.06*washInt));
          wash.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = wash;
          ctx.fillRect(0,0,w,h);
        }

        if (state.blackout){
          drawVignette(0.55);
          return;
        }

        // Lights
        const n = lights.length;
        const glow = s.lowPower ? Math.min(0.35, s.glow*0.6) : s.glow;
        const bloom = s.lowPower ? Math.min(0.25, s.bloom*0.55) : s.bloom;

        ctx.globalCompositeOperation = "lighter";
        for (let i=0;i<n;i++){
          const L = lights[i];
          L.i = i; L.n = n;
          const p = patternAt(s, t, L, audioMod);

          const px = center.x + (L.x) * scale * (1 + 0.02*Math.sin(t*0.9 + L.seed*9));
          const py = center.y + (L.y) * scale * (1 + 0.02*Math.cos(t*0.8 + L.seed*12));
          const huePos = p.huePos;
          const col = pickColor(pal, t, huePos);
          const core = p.bright;
          const sizeBase = lerp(5.5, 11.5, 0.35 + 0.65*glow) * dpr;
          const size = sizeBase * (0.8 + 0.9*Math.pow(core, 0.55)) * (0.9 + 0.3*p.shimmer);
          const inten = clamp01(core * (0.65 + 0.55*s.energy) + (sync ? 0.15*p.bass : 0));

          drawLight(px, py, size * (1.35 + bloom*2.4), col, inten, glow);
        }

        // Particles
        if (!s.lowPower && state.particles.length){
          const g = 0.55; // gravity-ish
          for (let i=state.particles.length-1;i>=0;i--){
            const P = state.particles[i];
            P.age += dt;
            if (P.age >= P.life){ state.particles.splice(i,1); continue; }
            P.vx *= Math.pow(0.15, dt);
            P.vy = P.vy * Math.pow(0.2, dt) + g*dt*0.08;
            P.x += P.vx * dt * 1.8;
            P.y += P.vy * dt * 1.8;
            const a = 1 - (P.age / P.life);
            const tt = (now - state.t0)/1000;
            const hsl = rgbToHsl(P.col);
            const col = hslToRgb(fract(hsl.h + P.hueJ + 0.02*Math.sin(tt*0.7 + i*0.11)), Math.min(1, hsl.s*1.05), Math.min(0.72, hsl.l*0.98));
            const px = center.x + P.x*scale;
            const py = center.y + P.y*scale;
            drawLight(px, py, (6 + 22*bloom) * dpr * P.size, col, a*(0.55 + 0.75*audioMod.level), 0.85);
          }
        }

        // Subtle vignette + framing
        drawVignette(s.vignette);
      }

      function start(opts){
        const silent = !!(opts && opts.silent);
        const restarting = state.running;
        state.running = true;
        state.paused = false;
        state.blackout = false;
        ui.btnPause.textContent = "Pause";
        state.t0 = performance.now();
        state.lastFrame = state.t0;
        state.beatPulse = 0;
        state.beatHit = 0;
        state.particles.length = 0;
        resize();
        requestAnimationFrame(frame);
        setStatus("Live", "engine running");
        if (!silent) toast(restarting ? "Restarted" : "Show started");
      }

      function pauseToggle(force){
        if (!state.running) return;
        const paused = typeof force === "boolean" ? force : !state.paused;
        state.paused = paused;
        ui.btnPause.textContent = paused ? "Play" : "Pause";
        if (!paused){
          state.lastFrame = performance.now();
          requestAnimationFrame(frame);
          setStatus("Live", "running");
          toast("Play");
        } else {
          setStatus("Paused", "stopped");
          toast("Pause");
        }
      }

      // We keep a single RAF loop; pause is implemented by early-out in frame wrapper.
      const _frame = frame;
      function framePaused(now){
        if (state.paused){
          // gentle idle render to keep UI feeling alive
          const s = getSettings();
          ctx.globalCompositeOperation = "source-over";
          ctx.fillStyle = "rgba(4,4,10,0.26)";
          ctx.fillRect(0,0,w,h);
          drawVignette(s.vignette);
          requestAnimationFrame(framePaused);
          return;
        }
        _frame(now);
      }
      // redirect RAF target to pause-aware wrapper
      frame = framePaused;

      function blackoutToggle(){
        state.blackout = !state.blackout;
        toast(state.blackout ? "Blackout" : "Lights up");
      }

      function randomize(){
        const s = getSettings();
        const patterns = ["aurora","rainbowChase","pulseGrid","spiral","sparkle","fireworks","wave","scanline"];
        const layouts = ["ring","stage","grid","tunnel"];
        const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];
        const randHex = (a,b,c) => {
          const h = (a + Math.random()*b) % 360;
          const s = lerp(0.75, 1.0, Math.random());
          const l = lerp(0.45, 0.62, Math.random());
          const rgb = hslToRgb(h/360, s, l);
          return "#" + [rgb.r,rgb.g,rgb.b].map(v => v.toString(16).padStart(2,"0")).join("");
        };
        applySettings({
          pattern: pick(patterns),
          layout: pick(layouts),
          speed: clamp01(Math.random()*1.4) * 2.3 + 0.25,
          energy: lerp(0.6, 1.15, Math.random()),
          glow: lerp(0.4, 0.95, Math.random()),
          trails: lerp(0.08, 0.38, Math.random()),
          bloom: lerp(0.25, 0.85, Math.random()),
          hueDrift: lerp(0.05, 0.55, Math.random()),
          baseColor: randHex(260, 100),
          accentColor: randHex(185, 60),
          warmColor: randHex(330, 60),
          limeColor: randHex(95, 80),
          lights: Math.round(lerp(160, 520, Math.random())),
        });
        updateTopMeta();
        toast("Randomized look");
      }

      function share(){
        const s = getSettings();
        const code = encodeSettings(s);
        const url = new URL(location.href);
        url.hash = `show=${code}`;
        navigator.clipboard?.writeText?.(url.toString())
          .then(() => toast("Link copied"))
          .catch(() => {
            // Fallback: prompt
            const ok = prompt("Copy this link:", url.toString());
            if (ok !== null) toast("Link ready");
          });
      }

      function toggleFullscreen(){
        const fsEl = document.fullscreenElement;
        if (!fsEl){
          stage.requestFullscreen?.().catch(() => {});
        } else {
          document.exitFullscreen?.().catch(() => {});
        }
      }

      // ----- UI wires -----
      ui.btnStart.addEventListener("click", async () => {
        start();
        const s = getSettings();
        if (s.sync){
          const audioCtx = ensureAudio();
          if (audioCtx?.state === "suspended") await audioCtx.resume?.();
        }
      });
      ui.btnPause.addEventListener("click", () => pauseToggle());
      ui.btnBlackout.addEventListener("click", blackoutToggle);
      ui.btnRandom.addEventListener("click", randomize);
      ui.btnBeat.addEventListener("click", () => onBeat("manual"));
      ui.btnShare.addEventListener("click", share);
      ui.btnFullscreen.addEventListener("click", toggleFullscreen);
      stage.addEventListener("dblclick", (e) => { e.preventDefault(); toggleFullscreen(); });
      stage.addEventListener("click", () => onBeat("manual"));
      stage.addEventListener("pointermove", (e) => {
        const r = stage.getBoundingClientRect();
        const x = (e.clientX - r.left) / Math.max(1, r.width);
        const y = (e.clientY - r.top) / Math.max(1, r.height);
        state.pointer.x = clamp01(x) * 2 - 1;
        state.pointer.y = clamp01(y) * 2 - 1;
      }, { passive: true });
      stage.addEventListener("pointerleave", () => {
        state.pointer.x *= 0.2;
        state.pointer.y *= 0.2;
      }, { passive: true });

      ui.btnDemo.addEventListener("click", async () => {
        start();
        const audioCtx = ensureAudio();
        if (audioCtx?.state === "suspended") await audioCtx.resume?.();
        startDemoTrack();
        if (ui.syncToggle.dataset.on !== "true") setSwitch(ui.syncToggle, true);
        setSync(true);
        updateTopMeta();
      });
      ui.btnMic.addEventListener("click", async () => {
        start();
        const audioCtx = ensureAudio();
        if (audioCtx?.state === "suspended") await audioCtx.resume?.();
        await useMic();
        if (ui.syncToggle.dataset.on !== "true") setSwitch(ui.syncToggle, true);
        setSync(true);
        updateTopMeta();
      });

      ui.audioFile.addEventListener("change", async () => {
        const file = ui.audioFile.files && ui.audioFile.files[0];
        if (!file) return;
        stopDemo(); stopMic();
        if (ui.audio.dataset.objurl) URL.revokeObjectURL(ui.audio.dataset.objurl);
        ui.audio.dataset.objurl = URL.createObjectURL(file);
        ui.audio.src = ui.audio.dataset.objurl;
        ui.audio.crossOrigin = "anonymous";
        ui.audio.play().catch(() => {});
        await useMediaElement();
        start();
        if (ui.syncToggle.dataset.on !== "true") setSwitch(ui.syncToggle, true);
        setSync(true);
        updateTopMeta();
      });

      ui.audio.addEventListener("play", async () => {
        const audioCtx = ensureAudio();
        if (audioCtx?.state === "suspended") await audioCtx.resume?.();
        if (!state.audio.source) await useMediaElement();
        state.audio.enabled = true;
        updateTopMeta();
      });
      ui.audio.addEventListener("pause", () => {
        state.audio.enabled = !!state.audio.source || !!state.audio.micStream || !!state.audio.demoNodes;
      });

      // Keyboard shortcuts
      window.addEventListener("keydown", (e) => {
        if (e.target && (e.target.tagName === "INPUT" || e.target.tagName === "SELECT" || e.target.tagName === "TEXTAREA")) return;
        if (e.key === " "){
          e.preventDefault();
          if (!state.running) { start(); return; }
          pauseToggle();
          return;
        }
        if (e.key.toLowerCase() === "r"){ randomize(); return; }
        if (e.key.toLowerCase() === "b"){ onBeat("manual"); return; }
        if (e.key.toLowerCase() === "f"){ toggleFullscreen(); return; }
        if (e.key.toLowerCase() === "x"){ blackoutToggle(); return; }
      }, { passive:false });

      // Apply URL share state if present
      const hash = location.hash || "";
      const m = /(?:^|[#&])show=([A-Za-z0-9_-]+)/.exec(hash);
      if (m){
        const s = decodeSettings(m[1]);
        if (s) {
          applySettings(s);
          toast("Loaded shared show");
        }
      }

      // Better initial sizing
      resize();
      requestAnimationFrame(() => {
        resize();
        rebuildLights();
        // Visuals can run without user interaction; audio remains gated by gestures.
        start({ silent: true });
      });

      // Keep status updated (paused/live)
      setInterval(() => {
        const s = getSettings();
        if (!state.running) setStatus("Ready");
        else if (state.paused) setStatus("Paused", `${state.fps} fps`);
        else setStatus("Live", `${state.fps} fps`);
        ui.syncState.textContent = s.sync ? (state.audio.enabled ? "On" : "On (no source)") : "Off";
        ui.btnStart.textContent = state.running ? "Restart" : "Start Show";
      }, 700);

    })();
  </script>
</body>
</html>
