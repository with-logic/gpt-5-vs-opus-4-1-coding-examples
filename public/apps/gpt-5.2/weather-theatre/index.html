<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark" />
    <title>Weather Theatre</title>
    <style>
      :root {
        --bg0: #070a12;
        --bg1: #0b1020;
        --panel: rgba(18, 23, 44, 0.54);
        --panel2: rgba(20, 24, 42, 0.32);
        --stroke: rgba(255, 255, 255, 0.12);
        --stroke2: rgba(255, 255, 255, 0.08);
        --txt: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.64);
        --dim: rgba(255, 255, 255, 0.44);
        --shadow: rgba(0, 0, 0, 0.5);
        --radius-xl: 24px;
        --radius-lg: 18px;
        --radius-md: 14px;
        --radius-sm: 12px;
        --blur: 16px;
        --hue: 32;
        --sat: 78%;
        --lit: 58%;
        --accent: hsl(var(--hue) var(--sat) var(--lit));
        --accent2: hsl(calc(var(--hue) + 32) 88% 60%);
        --accent3: hsl(calc(var(--hue) + 182) 92% 62%);
        --glow: rgba(255, 210, 140, 0.28);
        --glow2: rgba(140, 220, 255, 0.20);
        --glow3: rgba(255, 240, 210, 0.16);
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        font-family: var(--sans);
        color: var(--txt);
        overflow: hidden;
        background: radial-gradient(1200px 900px at 12% 18%, rgba(120, 160, 255, 0.14), transparent 52%),
          radial-gradient(900px 700px at 72% 36%, rgba(255, 170, 90, 0.12), transparent 55%),
          radial-gradient(1000px 900px at 52% 86%, rgba(80, 255, 210, 0.08), transparent 60%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
      }

      .appRoot {
        position: relative;
        width: 100%;
        height: 100%;
      }

      canvas#stage {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .ui {
        position: absolute;
        inset: 0;
        display: grid;
        grid-template-columns: 420px 1fr 420px;
        grid-template-rows: auto 1fr auto;
        gap: 18px;
        padding: 20px;
        pointer-events: none;
      }

      .brand {
        grid-column: 1 / -1;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
        pointer-events: none;
      }

      .brandLeft {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 0;
      }

      .mark {
        width: 40px;
        height: 40px;
        border-radius: 14px;
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.24), transparent 55%),
          linear-gradient(135deg, rgba(255, 175, 96, 0.34), rgba(120, 210, 255, 0.24));
        border: 1px solid rgba(255, 255, 255, 0.16);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(0, 0, 0, 0.2) inset;
      }

      .brand h1 {
        font-size: 15px;
        margin: 0;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        font-weight: 800;
        white-space: nowrap;
      }

      .brand p {
        margin: 0;
        font-size: 12.5px;
        color: var(--muted);
        letter-spacing: 0.02em;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .badgeRow {
        display: flex;
        align-items: center;
        gap: 10px;
        pointer-events: none;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .badge {
        font-family: var(--mono);
        font-size: 11px;
        padding: 7px 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.10);
        color: rgba(255, 255, 255, 0.78);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.18);
      }

      .panel {
        pointer-events: auto;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.03));
        border: 1px solid var(--stroke);
        border-radius: var(--radius-xl);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.35);
        overflow: hidden;
      }

      .panelInner {
        padding: 16px 16px 14px 16px;
      }

      .panelHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }

      .panelTitle {
        margin: 0;
        font-size: 12px;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.78);
      }

      .panelNote {
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.02em;
      }

      .leftPanel {
        grid-column: 1;
        grid-row: 2;
        align-self: stretch;
      }

      .rightPanel {
        grid-column: 3;
        grid-row: 2;
        align-self: stretch;
      }

      .subtitleBar {
        grid-column: 1 / -1;
        grid-row: 3;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .subtitleChip {
        pointer-events: auto;
        max-width: min(980px, calc(100vw - 40px));
        padding: 12px 14px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: radial-gradient(1200px 500px at 60% 0%, rgba(255, 255, 255, 0.08), transparent 60%),
          rgba(15, 18, 34, 0.42);
        box-shadow: 0 24px 70px rgba(0, 0, 0, 0.38);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .subtitleLead {
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(255, 255, 255, 0.62);
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .subtitleText {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.92);
        letter-spacing: 0.01em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: min(820px, calc(100vw - 190px));
      }

      .caret {
        width: 9px;
        height: 14px;
        background: rgba(255, 255, 255, 0.68);
        border-radius: 3px;
        margin-left: 4px;
        animation: blink 1s steps(2, end) infinite;
        box-shadow: 0 0 18px rgba(255, 255, 255, 0.18);
      }

      @keyframes blink {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0.08;
        }
      }

      .btnRow {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .btn {
        cursor: pointer;
        user-select: none;
        font-weight: 700;
        font-size: 12px;
        letter-spacing: 0.04em;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
        color: rgba(255, 255, 255, 0.90);
        box-shadow: 0 22px 50px rgba(0, 0, 0, 0.22);
        transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      }

      .btn:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 255, 255, 0.22);
      }

      .btn:active {
        transform: translateY(0px);
      }

      .btnPrimary {
        border-color: rgba(255, 255, 255, 0.18);
        background: radial-gradient(1000px 500px at 30% 10%, rgba(255, 255, 255, 0.16), transparent 55%),
          linear-gradient(135deg, rgba(255, 172, 92, 0.22), rgba(120, 210, 255, 0.16));
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 10px;
      }

      .togglePill {
        cursor: pointer;
        position: relative;
        width: 148px;
        height: 36px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.18);
        overflow: hidden;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.25);
      }

      .toggleKnob {
        position: absolute;
        top: 4px;
        left: 4px;
        width: 70px;
        height: 28px;
        border-radius: 999px;
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.24), transparent 55%),
          linear-gradient(180deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.06));
        border: 1px solid rgba(255, 255, 255, 0.12);
        transition: transform 220ms ease;
      }

      .togglePill[data-mode="night"] .toggleKnob {
        transform: translateX(70px);
      }

      .toggleLabels {
        position: absolute;
        inset: 0;
        display: grid;
        grid-template-columns: 1fr 1fr;
        align-items: center;
        text-align: center;
        font-size: 11px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.74);
        pointer-events: none;
        font-family: var(--mono);
      }

      .togglePill[data-mode="matinee"] .toggleLabels span:first-child,
      .togglePill[data-mode="night"] .toggleLabels span:last-child {
        color: rgba(255, 255, 255, 0.94);
      }

      .sliderStack {
        display: grid;
        gap: 12px;
      }

      .sliderCard {
        border-radius: var(--radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.03));
        padding: 12px 12px 10px 12px;
      }

      .sliderTop {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 8px;
      }

      .sliderName {
        font-weight: 800;
        letter-spacing: 0.04em;
        color: rgba(255, 255, 255, 0.92);
      }

      .sliderHint {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.60);
        font-family: var(--mono);
      }

      input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 28px;
        background: transparent;
        margin: 0;
      }

      input[type="range"]:focus {
        outline: none;
      }

      input[type="range"]::-webkit-slider-runnable-track {
        height: 10px;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0.10), rgba(255, 255, 255, 0.06));
        border: 1px solid rgba(255, 255, 255, 0.12);
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 22px;
        height: 22px;
        border-radius: 999px;
        margin-top: -7px;
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.28), transparent 55%),
          linear-gradient(180deg, rgba(255, 255, 255, 0.20), rgba(255, 255, 255, 0.08));
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35), 0 0 0 4px rgba(255, 255, 255, 0.06);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-track {
        height: 10px;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0.10), rgba(255, 255, 255, 0.06));
        border: 1px solid rgba(255, 255, 255, 0.12);
      }

      input[type="range"]::-moz-range-thumb {
        width: 22px;
        height: 22px;
        border-radius: 999px;
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.28), transparent 55%),
          linear-gradient(180deg, rgba(255, 255, 255, 0.20), rgba(255, 255, 255, 0.08));
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35), 0 0 0 4px rgba(255, 255, 255, 0.06);
        cursor: pointer;
      }

      .meter {
        margin-top: 8px;
        height: 10px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.18);
        border: 1px solid rgba(255, 255, 255, 0.10);
        overflow: hidden;
      }

      .meter > div {
        height: 100%;
        width: 50%;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
      }

      .sceneMix {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
        margin-top: 12px;
      }

      .mixPill {
        padding: 10px 10px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.14);
        display: grid;
        gap: 4px;
      }

      .mixName {
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(255, 255, 255, 0.72);
        letter-spacing: 0.10em;
        text-transform: uppercase;
      }

      .mixVal {
        font-size: 13px;
        font-weight: 900;
        letter-spacing: 0.02em;
      }

      .forecastGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .forecastHero {
        display: grid;
        gap: 8px;
        padding: 14px;
        border-radius: var(--radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: radial-gradient(900px 500px at 30% 10%, rgba(255, 255, 255, 0.10), transparent 60%),
          rgba(0, 0, 0, 0.16);
      }

      .forecastTitle {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
      }

      .place {
        font-weight: 900;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.88);
      }

      .timestamp {
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(255, 255, 255, 0.58);
      }

      .bigTemp {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .bigTemp .t {
        font-size: 46px;
        font-weight: 950;
        letter-spacing: -0.04em;
        line-height: 1;
      }

      .bigTemp .cond {
        display: grid;
        gap: 4px;
        justify-items: end;
        text-align: right;
      }

      .bigTemp .cond strong {
        font-size: 13px;
        letter-spacing: 0.04em;
      }

      .bigTemp .cond span {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.62);
      }

      .kvRow {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .kv {
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.10);
        background: rgba(255, 255, 255, 0.05);
        padding: 10px;
        display: grid;
        gap: 4px;
      }

      .kv label {
        font-family: var(--mono);
        font-size: 10px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.56);
      }

      .kv div {
        font-weight: 850;
        letter-spacing: 0.02em;
        color: rgba(255, 255, 255, 0.92);
      }

      .hours {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .hourCard {
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.10);
        background: rgba(0, 0, 0, 0.14);
        padding: 10px;
        display: grid;
        gap: 6px;
      }

      .hourCard .h {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(255, 255, 255, 0.66);
      }

      .hourCard .temp {
        font-weight: 900;
        font-size: 16px;
        letter-spacing: 0.01em;
      }

      .hourCard .mini {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.60);
      }

      .hint {
        margin-top: 12px;
        padding: 12px 12px;
        border-radius: 18px;
        border: 1px dashed rgba(255, 255, 255, 0.14);
        color: rgba(255, 255, 255, 0.64);
        font-size: 12px;
        line-height: 1.35;
      }

      .hint kbd {
        font-family: var(--mono);
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.20);
        color: rgba(255, 255, 255, 0.84);
      }

      .curtainWrap {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 20;
      }

      .curtainTop {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 74px;
        background: linear-gradient(180deg, rgba(110, 15, 34, 0.92), rgba(70, 12, 28, 0.52));
        border-bottom: 1px solid rgba(255, 255, 255, 0.10);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
        overflow: hidden;
      }

      .curtainTop::before {
        content: "";
        position: absolute;
        inset: -40px 0 0 0;
        background: radial-gradient(28px 18px at 10% 60%, rgba(255, 255, 255, 0.16), transparent 70%),
          radial-gradient(28px 18px at 30% 70%, rgba(255, 255, 255, 0.12), transparent 70%),
          radial-gradient(28px 18px at 50% 55%, rgba(255, 255, 255, 0.14), transparent 70%),
          radial-gradient(28px 18px at 70% 75%, rgba(255, 255, 255, 0.10), transparent 70%),
          radial-gradient(28px 18px at 90% 60%, rgba(255, 255, 255, 0.14), transparent 70%);
        opacity: 0.55;
      }

      .curtain {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 55vw;
        max-width: 760px;
        background: linear-gradient(90deg, rgba(75, 8, 22, 0.92), rgba(140, 16, 46, 0.86), rgba(70, 10, 26, 0.9));
        box-shadow: inset -24px 0 60px rgba(0, 0, 0, 0.55), 0 34px 100px rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.10);
        overflow: hidden;
      }

      .curtain::before {
        content: "";
        position: absolute;
        inset: 0;
        background: repeating-linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.06) 0px,
          rgba(255, 255, 255, 0.02) 10px,
          rgba(0, 0, 0, 0.08) 22px,
          rgba(255, 255, 255, 0.01) 32px
        );
        mix-blend-mode: overlay;
        opacity: 0.55;
      }

      .curtain::after {
        content: "";
        position: absolute;
        inset: -40px -20px -40px -20px;
        background: radial-gradient(300px 420px at 40% 20%, rgba(255, 255, 255, 0.16), transparent 60%),
          radial-gradient(260px 360px at 65% 55%, rgba(255, 255, 255, 0.10), transparent 62%);
        opacity: 0.5;
      }

      .curtain[data-side="left"] {
        left: 0;
        transform: translateX(0);
        border-right: none;
      }

      .curtain[data-side="right"] {
        right: 0;
        transform: translateX(0) scaleX(-1);
        border-left: none;
      }

      .curtainWrap[data-open="true"] .curtain[data-side="left"] {
        animation: openLeft 1200ms cubic-bezier(0.15, 0.9, 0.18, 1) forwards;
      }

      .curtainWrap[data-open="true"] .curtain[data-side="right"] {
        animation: openRight 1200ms cubic-bezier(0.15, 0.9, 0.18, 1) forwards;
      }

      @keyframes openLeft {
        from {
          transform: translateX(0);
        }
        to {
          transform: translateX(-105%);
        }
      }

      @keyframes openRight {
        from {
          transform: translateX(0) scaleX(-1);
        }
        to {
          transform: translateX(105%) scaleX(-1);
        }
      }

      .vignette {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 5;
        background: radial-gradient(1400px 800px at 50% 56%, transparent 55%, rgba(0, 0, 0, 0.44) 78%, rgba(0, 0, 0, 0.72)),
          radial-gradient(1200px 900px at 50% 0%, rgba(0, 0, 0, 0.40), transparent 55%);
      }

      .grain {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 6;
        opacity: 0.08;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
        mix-blend-mode: overlay;
      }

      .centerHint {
        grid-column: 2;
        grid-row: 2;
        align-self: end;
        justify-self: center;
        pointer-events: none;
        opacity: 0.72;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.62);
        letter-spacing: 0.02em;
        text-align: center;
        padding: 10px 12px;
        border-radius: 16px;
        background: rgba(0, 0, 0, 0.14);
        border: 1px solid rgba(255, 255, 255, 0.10);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      @media (max-width: 1100px) {
        .ui {
          grid-template-columns: 1fr;
          grid-template-rows: auto auto auto auto;
          gap: 14px;
        }
        .leftPanel {
          grid-column: 1;
          grid-row: 2;
        }
        .rightPanel {
          grid-column: 1;
          grid-row: 3;
        }
        .centerHint {
          display: none;
        }
        .subtitleText {
          max-width: calc(100vw - 170px);
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .curtainWrap[data-open="true"] .curtain[data-side="left"],
        .curtainWrap[data-open="true"] .curtain[data-side="right"] {
          animation-duration: 1ms;
        }
        .caret {
          animation: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React 18 UMD -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX (runtime compile) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
      }
      function lerp(a, b, t) {
        return a + (b - a) * t;
      }
      function smoothstep(t) {
        const x = clamp(t, 0, 1);
        return x * x * (3 - 2 * x);
      }
      function mulberry32(seed) {
        let t = seed >>> 0;
        return function () {
          t += 0x6d2b79f5;
          let r = Math.imul(t ^ (t >>> 15), 1 | t);
          r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
          return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
      }
      function fmtTime(date) {
        const hh = String(date.getHours()).padStart(2, "0");
        const mm = String(date.getMinutes()).padStart(2, "0");
        return `${hh}:${mm}`;
      }
      function degToCompass(deg) {
        const dirs = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
        const i = Math.round(((deg % 360) / 45)) % 8;
        return dirs[i];
      }
      function pickWeighted(rng, items) {
        const total = items.reduce((s, it) => s + it.w, 0);
        let t = rng() * total;
        for (const it of items) {
          t -= it.w;
          if (t <= 0) return it.v;
        }
        return items[items.length - 1].v;
      }

      function createMockForecast(seed = 1337) {
        const rng = mulberry32(seed);
        const now = new Date();
        const baseTemp = Math.round(9 + rng() * 12);
        const windKmh = Math.round(8 + rng() * 26);
        const windDir = Math.round(rng() * 359);
        const humidity = Math.round(42 + rng() * 48);
        const cloud = Math.round(20 + rng() * 75);
        const precipChance = Math.round(clamp((cloud * 0.65 + rng() * 40) - 12, 0, 100));
        const pressure = Math.round(995 + rng() * 30);
        const conditions = [
          { v: "Fine haze", w: 0.8 },
          { v: "Overcast", w: 1.1 },
          { v: "Soft drizzle", w: 1.0 },
          { v: "Restless gusts", w: 0.7 },
          { v: "Bright breaks", w: 0.8 },
          { v: "Whispering fog", w: 0.65 },
        ];
        const condition = pickWeighted(rng, conditions);
        const hours = [];
        for (let i = 1; i <= 6; i++) {
          const d = new Date(now.getTime() + i * 60 * 60 * 1000);
          const temp = Math.round(baseTemp + Math.sin((i / 6) * Math.PI) * 3 + (rng() - 0.5) * 2);
          const c = Math.round(clamp(cloud + (rng() - 0.5) * 18, 0, 100));
          const p = Math.round(clamp((precipChance + (rng() - 0.5) * 22) - i * 2, 0, 100));
          const w = Math.round(clamp(windKmh + (rng() - 0.5) * 10, 0, 70));
          hours.push({ t: fmtTime(d), temp, cloud: c, precip: p, wind: w });
        }
        return {
          place: "Port Orpheus",
          now: {
            time: fmtTime(now),
            temp: baseTemp,
            condition,
            windKmh,
            windDir,
            humidity,
            cloud,
            precipChance,
            pressure,
          },
          hours,
        };
      }

      function sceneFromMix({ cosy, eerie, heroic, isNight }, forecast) {
        const c = cosy / 100;
        const e = eerie / 100;
        const h = heroic / 100;
        const sum = Math.max(0.0001, c + e + h);
        const cw = c / sum;
        const ew = e / sum;
        const hw = h / sum;

        const temp = forecast.now.temp;
        const cloud = forecast.now.cloud;
        const precip = forecast.now.precipChance;
        const wind = forecast.now.windKmh;
        const windDir = forecast.now.windDir;
        const windComp = degToCompass(windDir);

        const timeWord = isNight ? "night" : "matinée";

        const palette = (() => {
          const warmHue = 28;
          const eerieHue = 205;
          const heroHue = 44;
          const hue = warmHue * cw + eerieHue * ew + heroHue * hw;
          const sat = 64 + 18 * hw + 12 * cw;
          const lit = (isNight ? 46 : 58) + 8 * cw + 6 * hw - 10 * ew;
          return { hue: Math.round(hue), sat: clamp(sat, 52, 92), lit: clamp(lit, 38, 70) };
        })();

        const set = (() => {
          const cosySets = [
            "lantern promenade",
            "café awning",
            "velvet parlour",
            "bookshop stoop",
            "rooftop conservatory",
          ];
          const eerieSets = ["fog cathedral", "twisted grove", "harbour phantoms", "gilded mausoleum", "quiet arcade"];
          const heroicSets = ["sunlit battlements", "stormfront cliffs", "festival banners", "skybridge ascent", "brass lookout"];
          const seed =
            Math.floor(cosy * 1000) ^
            (Math.floor(eerie * 10000) << 1) ^
            (Math.floor(heroic * 100000) << 2) ^
            (isNight ? 0x9e3779b9 : 0) ^
            ((forecast.now.windDir | 0) << 3) ^
            ((forecast.now.precipChance | 0) << 5);
          const rng = mulberry32(seed >>> 0);
          const pick = (arr) => arr[Math.floor(rng() * arr.length)];
          if (hw >= cw && hw >= ew) return pick(heroicSets);
          if (ew >= cw && ew >= hw) return pick(eerieSets);
          return pick(cosySets);
        })();

        const moodWords = (() => {
          const cosyWord = cw > 0.55 ? "cosy" : "gentle";
          const eerieWord = ew > 0.55 ? "eerie" : "hushed";
          const heroWord = hw > 0.55 ? "heroic" : "bold";
          const dominant = hw >= cw && hw >= ew ? heroWord : ew >= cw ? eerieWord : cosyWord;
          const secondary = hw >= ew && hw < cw ? heroWord : ew >= cw && ew < hw ? eerieWord : cosyWord;
          return { dominant, secondary };
        })();

        const precipitationWord =
          precip > 70 ? "a steady curtain of weather" : precip > 35 ? "a restless drizzle" : cloud > 70 ? "heavy clouds" : "clean air";

        const tempWord =
          temp <= 2
            ? "cold"
            : temp <= 8
              ? "brisk"
              : temp <= 14
                ? "cool"
                : temp <= 20
                  ? "mild"
                  : "warm";

        const lighting =
          isNight && ew > 0.35
            ? "moonlight and a wandering spotlight"
            : isNight
              ? "electric stage-lamps and star-glow"
              : cw > 0.35
                ? "honeyed light and soft shadow"
                : hw > 0.35
                  ? "high-key beams and crisp edges"
                  : "filtered skylight and mist";

        const subtitle = `A ${moodWords.dominant} ${timeWord}: ${precipitationWord} in a ${set} — ${tempWord}, ${wind} km/h from ${windComp}, ${forecast.now.humidity}% humidity.`;

        return { subtitle, palette, weights: { cw, ew, hw }, set };
      }

      function useTypewriter(text, opts = {}) {
        const { cps = 40, delayMs = 160 } = opts;
        const [shown, setShown] = useState("");
        const tokenRef = useRef(0);
        useEffect(() => {
          const token = ++tokenRef.current;
          setShown("");
          let i = 0;
          let intervalId = null;
          const start = setTimeout(() => {
            intervalId = setInterval(() => {
              if (tokenRef.current !== token) return;
              i++;
              setShown(text.slice(0, i));
              if (i >= text.length && intervalId) clearInterval(intervalId);
            }, Math.max(8, Math.round(1000 / cps)));
          }, delayMs);
          return () => {
            clearTimeout(start);
            if (intervalId) clearInterval(intervalId);
          };
        }, [text, cps, delayMs]);
        return shown;
      }

      function StageCanvas({ mix, isNight, forecast, onPerf }) {
        const canvasRef = useRef(null);
        const pointerRef = useRef({ x: 0, y: 0, active: false });
        const engineRef = useRef(null);
        const mixRef = useRef(mix);
        const nightRef = useRef(isNight);

        useEffect(() => {
          mixRef.current = mix;
        }, [mix]);

        useEffect(() => {
          nightRef.current = isNight;
        }, [isNight]);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });
          const engine = new StageEngine(ctx, canvas, forecast);
          engineRef.current = engine;

          let last = performance.now();
          let raf = 0;

          const resize = () => engine.resize();
          const onPointer = (ev) => {
            const rect = canvas.getBoundingClientRect();
            const px = (ev.clientX - rect.left) / rect.width;
            const py = (ev.clientY - rect.top) / rect.height;
            pointerRef.current = { x: px, y: py, active: true };
          };
          const onLeave = () => (pointerRef.current.active = false);

          window.addEventListener("resize", resize, { passive: true });
          window.addEventListener("pointermove", onPointer, { passive: true });
          window.addEventListener("pointerleave", onLeave, { passive: true });

          const loop = (now) => {
            const dt = Math.min(0.05, (now - last) / 1000);
            last = now;
            engine.step({
              dt,
              t: now / 1000,
              targetMix: mixRef.current,
              isNight: nightRef.current,
              pointer: pointerRef.current,
            });
            if (onPerf) onPerf(engine.lastPerfMs);
            raf = requestAnimationFrame(loop);
          };
          raf = requestAnimationFrame(loop);
          resize();

          return () => {
            cancelAnimationFrame(raf);
            window.removeEventListener("resize", resize);
            window.removeEventListener("pointermove", onPointer);
            window.removeEventListener("pointerleave", onLeave);
          };
        }, [forecast]);

        useEffect(() => {
          const engine = engineRef.current;
          if (!engine) return;
          engine.setForecast(forecast);
        }, [forecast]);

        return <canvas id="stage" ref={canvasRef} />;
      }

      class StageEngine {
        constructor(ctx, canvas, forecast) {
          this.ctx = ctx;
          this.canvas = canvas;
          this.forecast = forecast;
          this.dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1));
          this.w = 1;
          this.h = 1;
          this.mix = { cosy: 55, eerie: 18, heroic: 38 };
          this.mixSmooth = { cosy: 55, eerie: 18, heroic: 38 };
          this.isNight = false;
          this.pointer = { x: 0.5, y: 0.5, active: false };
          this.seed = 424242;
          this.rng = mulberry32(this.seed);
          this.layers = this.buildLayers();
          this.particles = this.buildParticles(520);
          this.lastPerfMs = 0;
        }

        setForecast(forecast) {
          this.forecast = forecast;
        }

        resize() {
          const rect = this.canvas.getBoundingClientRect();
          this.dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1));
          this.w = Math.max(1, Math.floor(rect.width * this.dpr));
          this.h = Math.max(1, Math.floor(rect.height * this.dpr));
          this.canvas.width = this.w;
          this.canvas.height = this.h;
        }

        buildLayers() {
          const rng = this.rng;
          const clouds = Array.from({ length: 24 }, () => ({
            x: rng(),
            y: rng() * 0.46,
            s: 0.5 + rng() * 1.1,
            a: 0.06 + rng() * 0.12,
            k: rng() * 10,
          }));

          const stars = Array.from({ length: 260 }, () => ({
            x: rng(),
            y: rng() * 0.55,
            r: 0.5 + rng() * 1.6,
            a: 0.12 + rng() * 0.35,
            tw: rng() * 2.5,
          }));

          const mountain = (() => {
            const pts = [];
            const count = 10;
            for (let i = 0; i <= count; i++) {
              const x = i / count;
              const y = 0.22 + (0.18 * (0.4 + rng())) * (Math.sin(i * 0.7 + rng() * 2) * 0.5 + 0.5);
              pts.push({ x, y });
            }
            return pts;
          })();

          const skyline = Array.from({ length: 42 }, () => ({
            x: rng(),
            w: 0.02 + rng() * 0.05,
            h: 0.12 + rng() * 0.22,
            lit: rng() < 0.42,
          })).sort((a, b) => a.x - b.x);

          const trees = Array.from({ length: 40 }, () => ({
            x: rng(),
            y: 0.66 + rng() * 0.12,
            s: 0.5 + rng() * 1.2,
            bend: -0.35 + rng() * 0.7,
          }));

          const banners = Array.from({ length: 16 }, () => ({
            x: rng(),
            y: 0.62 + rng() * 0.18,
            l: 0.08 + rng() * 0.12,
            w: 0.012 + rng() * 0.018,
          }));

          return { clouds, stars, mountain, skyline, trees, banners };
        }

        buildParticles(n) {
          const rng = mulberry32(7777);
          return Array.from({ length: n }, () => ({
            x: rng(),
            y: rng(),
            v: 0.15 + rng() * 0.85,
            s: 0.3 + rng() * 1.6,
            t: rng() * 10,
            kind: rng(),
          }));
        }

        weights() {
          const c = this.mixSmooth.cosy / 100;
          const e = this.mixSmooth.eerie / 100;
          const h = this.mixSmooth.heroic / 100;
          const sum = Math.max(0.0001, c + e + h);
          return { cw: c / sum, ew: e / sum, hw: h / sum };
        }

        step({ dt, t, targetMix, isNight, pointer }) {
          const perfStart = performance.now();
          this.isNight = isNight;
          this.pointer = pointer;
          const alpha = 1 - Math.pow(0.001, dt); // framerate independent smoothing
          this.mixSmooth.cosy = lerp(this.mixSmooth.cosy, targetMix.cosy, alpha);
          this.mixSmooth.eerie = lerp(this.mixSmooth.eerie, targetMix.eerie, alpha);
          this.mixSmooth.heroic = lerp(this.mixSmooth.heroic, targetMix.heroic, alpha);
          this.draw(t, dt);
          this.lastPerfMs = performance.now() - perfStart;
        }

        draw(t, dt) {
          const ctx = this.ctx;
          const w = this.w;
          const h = this.h;
          ctx.clearRect(0, 0, w, h);

          const { cw, ew, hw } = this.weights();
          const forecast = this.forecast?.now || { cloud: 55, precipChance: 35, windKmh: 14, windDir: 210, humidity: 55 };
          const cloud = forecast.cloud / 100;
          const precip = forecast.precipChance / 100;
          const wind = forecast.windKmh / 70;
          const windRad = ((forecast.windDir || 210) * Math.PI) / 180;
          const windVx = Math.cos(windRad) * wind;
          const windVy = Math.sin(windRad) * wind * 0.22;

          const px = this.pointer.active ? (this.pointer.x - 0.5) : Math.sin(t * 0.12) * 0.08;
          const py = this.pointer.active ? (this.pointer.y - 0.5) : Math.cos(t * 0.11) * 0.06;

          const hue = 28 * cw + 205 * ew + 44 * hw;
          const sat = 62 + 18 * hw + 12 * cw;
          const skyLit = (this.isNight ? 18 : 30) + 10 * cw + 8 * hw - 12 * ew;

          const skyGrad = ctx.createLinearGradient(0, 0, 0, h);
          skyGrad.addColorStop(0, `hsl(${hue} ${sat}% ${clamp(skyLit + 8, 10, 62)}%)`);
          skyGrad.addColorStop(0.45, `hsl(${hue + 6} ${sat - 6}% ${clamp(skyLit, 8, 56)}%)`);
          skyGrad.addColorStop(1, `hsl(${hue + 20} ${sat - 18}% ${clamp(skyLit - 8, 6, 44)}%)`);
          ctx.fillStyle = skyGrad;
          ctx.fillRect(0, 0, w, h);

          // Aurora / gradient bloom
          const bloom = ctx.createRadialGradient(w * 0.3, h * 0.12, 0, w * 0.3, h * 0.12, h * 0.9);
          bloom.addColorStop(0, `rgba(255,255,255,${0.08 * (cw + 0.6 * hw)})`);
          bloom.addColorStop(0.55, `rgba(140,220,255,${0.08 * (0.6 * hw + 0.6 * (1 - this.isNight))})`);
          bloom.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = bloom;
          ctx.fillRect(0, 0, w, h);

          // Stars (night + eerie)
          if (this.isNight) {
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            const starAlpha = clamp(0.10 + 0.55 * ew + 0.25 * (1 - cloud), 0, 0.85);
            for (const s of this.layers.stars) {
              const tw = 0.5 + 0.5 * Math.sin(t * (0.6 + s.tw) + s.x * 12.3);
              const a = starAlpha * s.a * tw;
              if (a <= 0.01) continue;
              const x = (s.x + px * 0.05) * w;
              const y = (s.y + py * 0.03) * h;
              ctx.fillStyle = `rgba(210,230,255,${a})`;
              ctx.beginPath();
              ctx.arc(x, y, s.r * this.dpr, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }

          // Distant haze
          ctx.save();
          ctx.globalCompositeOperation = "source-over";
          const haze = ctx.createLinearGradient(0, h * 0.05, 0, h * 0.72);
          haze.addColorStop(0, `rgba(255,255,255,${0.05 + 0.10 * ew})`);
          haze.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = haze;
          ctx.fillRect(0, 0, w, h);
          ctx.restore();

          // Clouds
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          const cloudStrength = clamp(0.25 + 0.60 * cloud, 0, 1);
          const cloudAlpha = (0.05 + 0.16 * cloudStrength) * (0.8 + 0.5 * cw) * (1 - 0.35 * ew);
          for (const c of this.layers.clouds) {
            const drift = (t * (0.015 + 0.03 * c.s) + c.k) % 1;
            const x = (c.x + drift + px * 0.06) * w;
            const y = (c.y + py * 0.05) * h;
            const r = (90 + 190 * c.s) * this.dpr;
            const g = ctx.createRadialGradient(x, y, 0, x, y, r);
            const a = cloudAlpha * c.a;
            g.addColorStop(0, `rgba(240,250,255,${a})`);
            g.addColorStop(0.55, `rgba(210,230,255,${a * 0.55})`);
            g.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

          // Mountains
          ctx.save();
          const mountY = h * 0.52;
          ctx.translate(px * -28 * this.dpr, py * -10 * this.dpr);
          ctx.beginPath();
          ctx.moveTo(0, h);
          for (const p of this.layers.mountain) {
            const x = p.x * w;
            const y = mountY - p.y * h;
            ctx.lineTo(x, y);
          }
          ctx.lineTo(w, h);
          ctx.closePath();
          const mGrad = ctx.createLinearGradient(0, h * 0.18, 0, h);
          mGrad.addColorStop(0, `rgba(20,26,50,${0.55 + 0.25 * ew})`);
          mGrad.addColorStop(0.65, `rgba(10,12,22,${0.75 + 0.10 * hw})`);
          mGrad.addColorStop(1, `rgba(0,0,0,0.88)`);
          ctx.fillStyle = mGrad;
          ctx.fill();
          ctx.restore();

          // Mid silhouettes: skyline vs trees
          const midBaseY = h * 0.70;
          ctx.save();
          ctx.translate(px * -46 * this.dpr, py * -18 * this.dpr);

          // Skyline (cosy/heroic)
          const skyAlpha = clamp(0.25 + 0.62 * (cw + hw) - 0.35 * ew, 0, 0.85);
          if (skyAlpha > 0.01) {
            ctx.save();
            ctx.globalAlpha = skyAlpha;
            ctx.fillStyle = `rgba(8,10,18,${0.86})`;
            for (const b of this.layers.skyline) {
              const x = b.x * w;
              const bw = b.w * w;
              const bh = b.h * h;
              ctx.fillRect(x, midBaseY - bh, bw, bh);
              if (this.isNight && b.lit && (cw + hw) > 0.25) {
                const ww = Math.max(1.2 * this.dpr, bw * 0.12);
                const rows = Math.floor(bh / (10 * this.dpr));
                const cols = Math.floor(bw / (10 * this.dpr));
                ctx.fillStyle = `rgba(255,220,160,${0.22 + 0.22 * cw + 0.18 * hw})`;
                for (let ry = 0; ry < rows; ry++) {
                  for (let cx = 0; cx < cols; cx++) {
                    if (((ry * 17 + cx * 13) % 7) < 2) continue;
                    ctx.fillRect(x + 4 * this.dpr + cx * ww, midBaseY - bh + 4 * this.dpr + ry * (9 * this.dpr), ww * 0.7, 2.2 * this.dpr);
                  }
                }
              }
              ctx.fillStyle = `rgba(8,10,18,${0.86})`;
            }
            ctx.restore();
          }

          // Trees (eerie)
          const treeAlpha = clamp(0.10 + 0.85 * ew + 0.15 * (1 - (cw + hw)), 0, 0.92);
          if (treeAlpha > 0.01) {
            ctx.save();
            ctx.globalAlpha = treeAlpha;
            ctx.strokeStyle = `rgba(0,0,0,0.85)`;
            ctx.lineWidth = 2.2 * this.dpr;
            for (const tr of this.layers.trees) {
              const x = tr.x * w;
              const y = tr.y * h;
              const len = (42 + 90 * tr.s) * this.dpr;
              const bend = tr.bend * (0.4 + 0.6 * wind) + Math.sin(t * 0.8 + tr.x * 9) * 0.08;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.quadraticCurveTo(x + bend * len, y - len * 0.6, x + bend * len * 0.2, y - len);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(x, y - len * 0.4);
              ctx.quadraticCurveTo(x - bend * len * 0.2, y - len * 0.55, x - bend * len * 0.35, y - len * 0.72);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(x, y - len * 0.55);
              ctx.quadraticCurveTo(x + bend * len * 0.25, y - len * 0.7, x + bend * len * 0.4, y - len * 0.85);
              ctx.stroke();
            }
            ctx.restore();
          }

          // Heroic banners (heroic)
          const bannerAlpha = clamp(0.05 + 0.70 * hw, 0, 0.8);
          if (bannerAlpha > 0.01) {
            ctx.save();
            ctx.globalAlpha = bannerAlpha;
            ctx.globalCompositeOperation = "screen";
            for (const bn of this.layers.banners) {
              const x = bn.x * w;
              const y = bn.y * h;
              const len = bn.l * h;
              const bw = bn.w * w;
              const sway = (Math.sin(t * 1.6 + bn.x * 10.4) * 0.6 + windVx * 1.4) * 12 * this.dpr;
              const g = ctx.createLinearGradient(x, y, x + bw * 2, y + len);
              g.addColorStop(0, `rgba(255,220,160,${0.18 + 0.22 * hw})`);
              g.addColorStop(1, `rgba(140,220,255,${0.08 + 0.18 * hw})`);
              ctx.fillStyle = g;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.quadraticCurveTo(x + sway, y + len * 0.3, x, y + len);
              ctx.lineTo(x + bw, y + len);
              ctx.quadraticCurveTo(x + bw + sway, y + len * 0.3, x + bw, y);
              ctx.closePath();
              ctx.fill();
            }
            ctx.restore();
          }

          ctx.restore();

          // Stage floor
          const floorY = h * 0.84;
          ctx.save();
          const floorGrad = ctx.createRadialGradient(w * 0.5, floorY, h * 0.08, w * 0.5, floorY, h * 0.62);
          floorGrad.addColorStop(0, `rgba(255,255,255,${0.10 + 0.16 * cw + 0.16 * hw})`);
          floorGrad.addColorStop(0.35, `rgba(120,210,255,${0.06 + 0.10 * hw})`);
          floorGrad.addColorStop(1, `rgba(0,0,0,${0.85})`);
          ctx.fillStyle = floorGrad;
          ctx.beginPath();
          ctx.ellipse(w * 0.5, floorY, w * 0.62, h * 0.22, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          // Fog layer (eerie)
          if (ew > 0.02) {
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            const fogAlpha = (0.12 + 0.22 * ew) * (0.7 + 0.6 * cloud);
            const fog = ctx.createLinearGradient(0, h * 0.46, 0, h);
            fog.addColorStop(0, `rgba(220,240,255,${fogAlpha * 0.25})`);
            fog.addColorStop(0.55, `rgba(190,220,255,${fogAlpha * 0.42})`);
            fog.addColorStop(1, `rgba(140,180,255,${fogAlpha * 0.12})`);
            ctx.fillStyle = fog;
            ctx.fillRect(0, h * 0.45, w, h * 0.55);
            ctx.restore();
          }

          // Spotlight sweeps
          this.drawSpotlights(t, { cw, ew, hw });

          // Precipitation / stage particles
          this.drawParticles(t, dt, { cw, ew, hw, precip, windVx, windVy });

          // A thin proscenium edge
          ctx.save();
          ctx.globalCompositeOperation = "source-over";
          ctx.strokeStyle = `rgba(255,255,255,${0.08})`;
          ctx.lineWidth = 1 * this.dpr;
          ctx.strokeRect(8 * this.dpr, 8 * this.dpr, w - 16 * this.dpr, h - 16 * this.dpr);
          ctx.restore();
        }

        drawSpotlights(t, { cw, ew, hw }) {
          const ctx = this.ctx;
          const w = this.w;
          const h = this.h;
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          const base = 0.10 + 0.22 * hw + 0.10 * cw - 0.06 * ew;
          const nightBoost = this.isNight ? 1.22 : 1.0;
          const intensity = clamp(base * nightBoost, 0.06, 0.46);

          const sweep = (phase, hueShift) => {
            const x = w * (0.5 + 0.38 * Math.sin(t * (0.26 + 0.08 * hw) + phase));
            const y = h * (0.52 + 0.06 * Math.cos(t * 0.34 + phase));
            const r = h * (0.62 + 0.12 * Math.sin(t * 0.18 + phase));
            const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
            const c0 = `hsla(${Math.round(38 + hueShift)} 95% 68% / ${intensity})`;
            const c1 = `hsla(${Math.round(200 + hueShift)} 92% 66% / ${intensity * 0.32})`;
            grad.addColorStop(0, c0);
            grad.addColorStop(0.35, c1);
            grad.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(x, y + h * 0.1, w * 0.52, h * 0.44, 0, 0, Math.PI * 2);
            ctx.fill();
          };

          sweep(0.7, -8 * ew + 12 * hw);
          sweep(2.2, 10 * ew - 8 * cw);
          ctx.restore();
        }

        drawParticles(t, dt, { cw, ew, hw, precip, windVx, windVy }) {
          const ctx = this.ctx;
          const w = this.w;
          const h = this.h;
          const dpr = this.dpr;
          const night = this.isNight ? 1 : 0;

          const rainAmt = clamp(precip * (0.35 + 0.65 * (1 - cw) + 0.25 * ew), 0, 1);
          const snowAmt = clamp(precip * (0.10 + 0.35 * cw) * (1 - 0.35 * hw), 0, 0.65);
          const emberAmt = clamp((0.15 + 0.85 * cw) * (1 - precip * 0.45) * (0.35 + 0.65 * night), 0, 0.8);
          const sparkAmt = clamp(0.12 + 0.75 * hw, 0, 0.95);
          const mistAmt = clamp(0.08 + 0.9 * ew, 0, 1);

          // Rain
          if (rainAmt > 0.03) {
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            ctx.lineWidth = 1.1 * dpr;
            ctx.strokeStyle = `rgba(160,210,255,${0.12 + 0.18 * rainAmt})`;
            for (let i = 0; i < this.particles.length; i++) {
              const p = this.particles[i];
              if (p.kind < 0.52) continue;
              const speed = (420 + 680 * p.v) * (0.25 + 0.75 * rainAmt) * dpr;
              p.y += (speed * dt) / h;
              p.x += (windVx * (0.22 + 0.6 * p.v) * dt);
              if (p.y > 1.05) {
                p.y = -0.02;
                p.x = (p.x + 0.5 + this.rng()) % 1;
              }
              if (p.x < -0.2) p.x += 1.2;
              if (p.x > 1.2) p.x -= 1.2;
              const x = p.x * w;
              const y = p.y * h;
              const len = (18 + 34 * p.s) * (0.5 + 0.7 * rainAmt) * dpr;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x + windVx * 80 * dpr, y + len);
              ctx.stroke();
            }
            ctx.restore();
          }

          // Snow
          if (snowAmt > 0.03) {
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            for (let i = 0; i < this.particles.length; i++) {
              const p = this.particles[i];
              if (p.kind > 0.52) continue;
              const drift = (windVx * 0.12 + Math.sin(t * 0.9 + p.t) * 0.05) * (0.4 + p.v);
              const fall = (0.06 + 0.18 * p.v) * (0.35 + 0.65 * snowAmt);
              p.y += fall * dt;
              p.x += drift * dt;
              if (p.y > 1.08) {
                p.y = -0.02;
                p.x = (p.x + this.rng()) % 1;
              }
              const x = p.x * w;
              const y = p.y * h;
              const r = (0.6 + 1.4 * p.s) * (0.65 + 0.55 * snowAmt) * dpr;
              const a = (0.06 + 0.14 * snowAmt) * (0.65 + 0.35 * cw);
              ctx.fillStyle = `rgba(245,250,255,${a})`;
              ctx.beginPath();
              ctx.arc(x, y, r, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }

          // Embers (cosy)
          if (emberAmt > 0.03) {
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            for (let i = 0; i < this.particles.length; i++) {
              const p = this.particles[i];
              if (p.kind < 0.15 || p.kind > 0.42) continue;
              const rise = (0.10 + 0.22 * p.v) * (0.25 + 0.75 * emberAmt);
              const drift = (Math.sin(t * 0.9 + p.t) * 0.08 + windVx * 0.04) * (0.3 + 0.8 * p.v);
              p.y -= rise * dt;
              p.x += drift * dt;
              if (p.y < -0.08) {
                p.y = 1.02;
                p.x = (p.x + this.rng()) % 1;
              }
              const x = p.x * w;
              const y = (0.66 + (p.y - 0.5) * 0.9) * h;
              const r = (0.7 + 2.2 * p.s) * dpr;
              const a = (0.05 + 0.20 * emberAmt) * (0.5 + 0.5 * Math.sin(t * 1.7 + p.t));
              ctx.fillStyle = `rgba(255,190,120,${a})`;
              ctx.beginPath();
              ctx.arc(x, y, r, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }

          // Sparks (heroic)
          if (sparkAmt > 0.03) {
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            for (let i = 0; i < this.particles.length; i++) {
              const p = this.particles[i];
              if (p.kind < 0.42 || p.kind > 0.52) continue;
              const sp = (0.18 + 0.55 * p.v) * (0.25 + 0.75 * sparkAmt);
              const dir = windVx * 0.12 + Math.cos(t * 0.7 + p.t) * 0.06;
              p.y -= sp * dt;
              p.x += dir * dt;
              if (p.y < -0.08) {
                p.y = 1.05;
                p.x = (p.x + this.rng()) % 1;
              }
              const x = p.x * w;
              const y = (0.74 + (p.y - 0.5) * 0.92) * h;
              const len = (8 + 22 * p.s) * dpr;
              const a = (0.06 + 0.22 * sparkAmt) * (0.35 + 0.65 * Math.sin(t * 2.2 + p.t) ** 2);
              ctx.strokeStyle = `rgba(255,240,210,${a})`;
              ctx.lineWidth = 1.2 * dpr;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x + dir * 90 * dpr, y - len);
              ctx.stroke();
            }
            ctx.restore();
          }

          // Mist motes (eerie)
          if (mistAmt > 0.03) {
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            for (let i = 0; i < this.particles.length; i++) {
              const p = this.particles[i];
              if (p.kind > 0.15) continue;
              const drift = (Math.sin(t * 0.35 + p.t) * 0.05 + windVx * 0.03) * (0.5 + 0.5 * p.v);
              p.x += drift * dt;
              p.y += (0.01 + 0.03 * p.v) * dt;
              if (p.x < -0.2) p.x += 1.2;
              if (p.x > 1.2) p.x -= 1.2;
              if (p.y > 1.1) {
                p.y = -0.05;
                p.x = this.rng();
              }
              const x = p.x * w;
              const y = (0.4 + p.y * 0.6) * h;
              const r = (10 + 26 * p.s) * (0.25 + 0.75 * mistAmt) * dpr;
              const a = (0.015 + 0.085 * mistAmt) * (0.4 + 0.6 * (Math.sin(t * 0.8 + p.t) * 0.5 + 0.5));
              const g = ctx.createRadialGradient(x, y, 0, x, y, r);
              g.addColorStop(0, `rgba(210,240,255,${a})`);
              g.addColorStop(1, "rgba(0,0,0,0)");
              ctx.fillStyle = g;
              ctx.beginPath();
              ctx.arc(x, y, r, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }
        }
      }

      function App() {
        const forecast = useMemo(() => createMockForecast(10831), []);

        const [mix, setMix] = useState({ cosy: 62, eerie: 22, heroic: 46 });
        const [isNight, setIsNight] = useState(false);
        const [curtainOpen, setCurtainOpen] = useState(false);
        const [perf, setPerf] = useState(0);

        const scene = useMemo(() => sceneFromMix({ ...mix, isNight }, forecast), [mix, isNight, forecast]);
        const subtitleShown = useTypewriter(scene.subtitle, { cps: 44, delayMs: 160 });

        useEffect(() => {
          const id = setTimeout(() => setCurtainOpen(true), 640);
          return () => clearTimeout(id);
        }, []);

        useEffect(() => {
          const onKey = (e) => {
            if (e.key === " ") {
              e.preventDefault();
              setIsNight((v) => !v);
            }
            if (e.key.toLowerCase() === "r") {
              setMix({ cosy: 62, eerie: 22, heroic: 46 });
              setCurtainOpen(false);
              setTimeout(() => setCurtainOpen(true), 40);
            }
            if (e.key.toLowerCase() === "c") {
              setCurtainOpen(false);
              setTimeout(() => setCurtainOpen(true), 40);
            }
          };
          window.addEventListener("keydown", onKey);
          return () => window.removeEventListener("keydown", onKey);
        }, []);

        useEffect(() => {
          const root = document.documentElement;
          root.style.setProperty("--hue", String(scene.palette.hue));
          root.style.setProperty("--sat", `${scene.palette.sat}%`);
          root.style.setProperty("--lit", `${scene.palette.lit}%`);
        }, [scene.palette.hue, scene.palette.sat, scene.palette.lit]);

        const setSlider = (key) => (e) => {
          const v = clamp(parseInt(e.target.value, 10) || 0, 0, 100);
          setMix((m) => ({ ...m, [key]: v }));
        };

        const normalizePercent = (v) => Math.round((v / (mix.cosy + mix.eerie + mix.heroic + 0.0001)) * 100);
        const cosyPct = normalizePercent(mix.cosy);
        const eeriePct = normalizePercent(mix.eerie);
        const heroicPct = 100 - cosyPct - eeriePct;

        const now = forecast.now;
        const windComp = degToCompass(now.windDir);

        return (
          <div className="appRoot" style={{}}>
            <StageCanvas mix={mix} isNight={isNight} forecast={forecast} onPerf={(ms) => setPerf(ms)} />
            <div className="vignette" />
            <div className="grain" />

            <div className="ui">
              <div className="brand">
                <div className="brandLeft">
                  <div className="mark" />
                  <div style={{ minWidth: 0 }}>
                    <h1>Weather Theatre</h1>
                    <p>Remix a single forecast into stagecraft: parallax sets, spotlight sweeps, and a curtain reveal.</p>
                  </div>
                </div>
                <div className="badgeRow">
                  <div className="badge">{isNight ? "Night lighting" : "Matinée lighting"}</div>
                  <div className="badge">Render {perf.toFixed(1)}ms</div>
                  <div className="badge">Forecast is mock</div>
                </div>
              </div>

              <div className="panel leftPanel">
                <div className="panelInner">
                  <div className="panelHeader">
                    <div>
                      <div className="panelTitle">Director’s Console</div>
                      <div className="panelNote">Blend moods; the same weather plays three ways.</div>
                    </div>
                    <div className="toggle">
                      <div
                        className="togglePill"
                        role="switch"
                        aria-checked={isNight}
                        tabIndex={0}
                        data-mode={isNight ? "night" : "matinee"}
                        onClick={() => setIsNight((v) => !v)}
                        onKeyDown={(e) => {
                          if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            setIsNight((v) => !v);
                          }
                        }}
                        title="Toggle Matinée / Night (Space)"
                      >
                        <div className="toggleKnob" />
                        <div className="toggleLabels">
                          <span>Matinée</span>
                          <span>Night</span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="sliderStack">
                    <div className="sliderCard">
                      <div className="sliderTop">
                        <div className="sliderName">Cosy</div>
                        <div className="sliderHint">{mix.cosy.toFixed(0)}/100</div>
                      </div>
                      <input type="range" min="0" max="100" value={mix.cosy} onChange={setSlider("cosy")} />
                      <div className="meter">
                        <div style={{ width: `${mix.cosy}%`, background: "linear-gradient(90deg, rgba(255,190,120,0.42), rgba(255,240,210,0.08))" }} />
                      </div>
                    </div>

                    <div className="sliderCard">
                      <div className="sliderTop">
                        <div className="sliderName">Eerie</div>
                        <div className="sliderHint">{mix.eerie.toFixed(0)}/100</div>
                      </div>
                      <input type="range" min="0" max="100" value={mix.eerie} onChange={setSlider("eerie")} />
                      <div className="meter">
                        <div style={{ width: `${mix.eerie}%`, background: "linear-gradient(90deg, rgba(140,220,255,0.38), rgba(255,255,255,0.06))" }} />
                      </div>
                    </div>

                    <div className="sliderCard">
                      <div className="sliderTop">
                        <div className="sliderName">Heroic</div>
                        <div className="sliderHint">{mix.heroic.toFixed(0)}/100</div>
                      </div>
                      <input type="range" min="0" max="100" value={mix.heroic} onChange={setSlider("heroic")} />
                      <div className="meter">
                        <div style={{ width: `${mix.heroic}%`, background: "linear-gradient(90deg, rgba(255,240,210,0.36), rgba(120,210,255,0.14))" }} />
                      </div>
                    </div>
                  </div>

                  <div className="sceneMix">
                    <div className="mixPill">
                      <div className="mixName">Cosy share</div>
                      <div className="mixVal" style={{ color: "rgba(255,210,150,0.92)" }}>
                        {cosyPct}%
                      </div>
                    </div>
                    <div className="mixPill">
                      <div className="mixName">Eerie share</div>
                      <div className="mixVal" style={{ color: "rgba(160,225,255,0.92)" }}>
                        {eeriePct}%
                      </div>
                    </div>
                    <div className="mixPill">
                      <div className="mixName">Heroic share</div>
                      <div className="mixVal" style={{ color: "rgba(255,245,220,0.92)" }}>
                        {heroicPct}%
                      </div>
                    </div>
                  </div>

                  <div style={{ marginTop: 12, display: "flex", alignItems: "center", justifyContent: "space-between", gap: 10 }}>
                    <div className="btnRow">
                      <button
                        className="btn btnPrimary"
                        onClick={() => {
                          setCurtainOpen(false);
                          setTimeout(() => setCurtainOpen(true), 40);
                        }}
                        title="Replay curtain reveal (C)"
                      >
                        Curtain
                      </button>
                      <button
                        className="btn"
                        onClick={() => {
                          setMix({ cosy: 62, eerie: 22, heroic: 46 });
                        }}
                        title="Reset sliders (R)"
                      >
                        Reset mix
                      </button>
                    </div>
                  </div>

                  <div className="hint">
                    Drag your pointer to tilt the stage. Toggle light with <kbd>Space</kbd>. Replay curtain with <kbd>C</kbd>. Reset mix with{" "}
                    <kbd>R</kbd>.
                  </div>
                </div>
              </div>

              <div className="centerHint">Parallax backdrops + spotlight sweeps render on the canvas stage.</div>

              <div className="panel rightPanel">
                <div className="panelInner">
                  <div className="panelHeader">
                    <div>
                      <div className="panelTitle">Mock Forecast</div>
                      <div className="panelNote">One script, three productions.</div>
                    </div>
                  </div>

                  <div className="forecastGrid">
                    <div className="forecastHero">
                      <div className="forecastTitle">
                        <div className="place">{forecast.place}</div>
                        <div className="timestamp">{now.time}</div>
                      </div>
                      <div className="bigTemp">
                        <div className="t">{now.temp}°</div>
                        <div className="cond">
                          <strong>{now.condition}</strong>
                          <span>
                            Wind {now.windKmh} km/h {windComp} · Cloud {now.cloud}% · Rain {now.precipChance}%
                          </span>
                        </div>
                      </div>
                      <div className="kvRow">
                        <div className="kv">
                          <label>Humidity</label>
                          <div>{now.humidity}%</div>
                        </div>
                        <div className="kv">
                          <label>Pressure</label>
                          <div>{now.pressure} hPa</div>
                        </div>
                      </div>
                    </div>

                    <div className="hours">
                      {forecast.hours.slice(0, 6).map((h, idx) => (
                        <div className="hourCard" key={idx}>
                          <div className="h">
                            <span>{h.t}</span>
                            <span>{h.wind} km/h</span>
                          </div>
                          <div className="temp">{h.temp}°</div>
                          <div className="mini">Cloud {h.cloud}% · Rain {h.precip}%</div>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>

              <div className="subtitleBar">
                <div className="subtitleChip" title="Scene subtitle (typewriter)">
                  <div className="subtitleLead">Scene</div>
                  <div className="subtitleText">
                    {subtitleShown}
                    <span className="caret" aria-hidden="true" />
                  </div>
                </div>
              </div>
            </div>

            <div className="curtainWrap" data-open={curtainOpen ? "true" : "false"}>
              <div className="curtainTop" />
              <div className="curtain" data-side="left" />
              <div className="curtain" data-side="right" />
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
