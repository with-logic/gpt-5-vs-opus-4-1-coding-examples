<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark light" />
    <title>Kinetic Typography Studio</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Space+Grotesk:wght@300..700&family=IBM+Plex+Mono:wght@300..700&display=swap");
      :root {
        --bg0: #070a12;
        --bg1: #0b1020;
        --panel: rgba(18, 22, 40, 0.7);
        --panel2: rgba(12, 14, 26, 0.75);
        --stroke: rgba(255, 255, 255, 0.09);
        --stroke2: rgba(255, 255, 255, 0.14);
        --text: rgba(245, 247, 255, 0.92);
        --muted: rgba(245, 247, 255, 0.62);
        --faint: rgba(245, 247, 255, 0.42);
        --accent: #7c5cff;
        --accent2: #29d3ff;
        --good: #2ee59d;
        --warn: #ffb020;
        --bad: #ff4d7d;
        --shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
        --shadow2: 0 10px 28px rgba(0, 0, 0, 0.48);
        --radius: 14px;
        --radius2: 10px;
        --mono: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --ui: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        --display: "Space Grotesk", Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: var(--ui);
        color: var(--text);
        background: radial-gradient(1200px 900px at 20% 12%, rgba(124, 92, 255, 0.22), transparent 55%),
          radial-gradient(900px 750px at 90% 20%, rgba(41, 211, 255, 0.16), transparent 50%),
          radial-gradient(1100px 900px at 60% 110%, rgba(46, 229, 157, 0.12), transparent 55%), linear-gradient(180deg, var(--bg0), var(--bg1));
        overflow: hidden;
      }

      .app {
        height: 100%;
        display: grid;
        grid-template-rows: 56px 1fr 220px;
        grid-template-columns: 360px 1fr 380px;
        grid-template-areas:
          "top top top"
          "left stage right"
          "timeline timeline timeline";
        gap: 12px;
        padding: 12px;
      }

      .topbar {
        grid-area: top;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(20, 24, 44, 0.72), rgba(10, 12, 22, 0.72));
        border-radius: var(--radius);
        box-shadow: var(--shadow2);
        backdrop-filter: blur(10px);
      }
      .brand {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 240px;
      }
      .logo {
        width: 32px;
        height: 32px;
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(124, 92, 255, 0.95), rgba(41, 211, 255, 0.85));
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.12) inset, 0 16px 36px rgba(124, 92, 255, 0.18);
        position: relative;
        overflow: hidden;
      }
      .logo:before {
        content: "";
        position: absolute;
        inset: -40%;
        background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.48), transparent 42%),
          radial-gradient(circle at 60% 70%, rgba(255, 255, 255, 0.22), transparent 50%);
        transform: rotate(18deg);
      }
      .brand h1 {
        margin: 0;
        font-family: var(--display);
        letter-spacing: 0.2px;
        font-size: 15px;
        line-height: 1.1;
      }
      .brand .sub {
        font-size: 12px;
        color: var(--muted);
        margin-top: 2px;
      }

      .toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1;
        justify-content: center;
      }
      .toolbar .group {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 7px 8px;
        background: rgba(0, 0, 0, 0.18);
        border: 1px solid var(--stroke);
        border-radius: 999px;
      }
      .rightbar {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 10px;
        min-width: 360px;
      }

      .panel {
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(22, 26, 48, 0.65), rgba(10, 12, 22, 0.68));
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        backdrop-filter: blur(12px);
        overflow: hidden;
      }
      .panel header {
        padding: 12px 12px 10px;
        border-bottom: 1px solid var(--stroke);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .panel header .title {
        display: flex;
        align-items: baseline;
        gap: 10px;
      }
      .panel header h2 {
        margin: 0;
        font-size: 12px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: rgba(245, 247, 255, 0.78);
      }
      .panel header .meta {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--faint);
      }
      .panel .content {
        padding: 12px;
        overflow: auto;
        height: calc(100% - 46px);
      }

      .left {
        grid-area: left;
        display: flex;
        flex-direction: column;
      }
      .right {
        grid-area: right;
        display: flex;
        flex-direction: column;
      }
      .stage {
        grid-area: stage;
        position: relative;
        overflow: hidden;
      }
      .stage .stageWrap {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 10px;
      }
      .stageCanvasShell {
        position: relative;
        border-radius: calc(var(--radius) + 2px);
        border: 1px solid var(--stroke);
        background: rgba(0, 0, 0, 0.25);
        box-shadow: 0 22px 70px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        touch-action: none;
      }
      #stageCanvas {
        display: block;
        background: transparent;
        image-rendering: auto;
      }
      .stageOverlays {
        pointer-events: none;
        position: absolute;
        inset: 0;
      }
      .safeArea {
        position: absolute;
        border: 1px dashed rgba(255, 255, 255, 0.22);
        border-radius: 12px;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.35) inset;
        opacity: 0.95;
      }
      .grid {
        position: absolute;
        inset: 0;
        opacity: 0.55;
        background-image: linear-gradient(to right, rgba(255, 255, 255, 0.06) 1px, transparent 1px),
          linear-gradient(to bottom, rgba(255, 255, 255, 0.06) 1px, transparent 1px);
        background-size: 40px 40px;
        mix-blend-mode: screen;
      }
      .centerCross {
        position: absolute;
        inset: 0;
        opacity: 0.9;
      }
      .centerCross:before,
      .centerCross:after {
        content: "";
        position: absolute;
        background: rgba(41, 211, 255, 0.17);
      }
      .centerCross:before {
        left: 50%;
        top: 0;
        width: 1px;
        height: 100%;
      }
      .centerCross:after {
        top: 50%;
        left: 0;
        height: 1px;
        width: 100%;
      }

      .timeline {
        grid-area: timeline;
        position: relative;
        overflow: hidden;
      }
      #timelineCanvas {
        width: 100%;
        height: 100%;
        display: block;
        background: linear-gradient(180deg, rgba(12, 14, 26, 0.72), rgba(5, 6, 12, 0.78));
      }
      .timelineHUD {
        position: absolute;
        top: 10px;
        right: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        pointer-events: none;
      }
      .pill {
        pointer-events: none;
        font-family: var(--mono);
        font-size: 11px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.13);
        background: rgba(0, 0, 0, 0.25);
        color: rgba(255, 255, 255, 0.82);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.34);
      }

      button,
      select,
      input,
      textarea {
        font: inherit;
        color: inherit;
      }
      button {
        cursor: pointer;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        padding: 8px 10px;
        transition: transform 0.08s ease, background 0.15s ease, border-color 0.15s ease;
        outline: none;
      }
      button:hover {
        background: rgba(255, 255, 255, 0.09);
        border-color: rgba(255, 255, 255, 0.2);
      }
      button:active {
        transform: translateY(1px);
      }
      button.primary {
        border-color: rgba(124, 92, 255, 0.65);
        background: linear-gradient(180deg, rgba(124, 92, 255, 0.95), rgba(124, 92, 255, 0.55));
        box-shadow: 0 14px 32px rgba(124, 92, 255, 0.25);
      }
      button.primary:hover {
        background: linear-gradient(180deg, rgba(124, 92, 255, 1), rgba(124, 92, 255, 0.62));
      }
      button.ghost {
        background: transparent;
      }
      button.icon {
        padding: 8px;
        border-radius: 999px;
        display: grid;
        place-items: center;
      }
      button.icon svg {
        width: 16px;
        height: 16px;
      }
      button:focus-visible,
      select:focus-visible,
      input:focus-visible,
      textarea:focus-visible {
        outline: 2px solid rgba(41, 211, 255, 0.65);
        outline-offset: 2px;
      }

      select,
      input[type="text"],
      input[type="number"],
      textarea {
        width: 100%;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.24);
        padding: 9px 10px;
        color: rgba(255, 255, 255, 0.9);
      }
      textarea {
        resize: vertical;
        min-height: 74px;
        line-height: 1.25;
      }
      input[type="range"] {
        width: 100%;
        accent-color: var(--accent);
      }
      input[type="color"] {
        width: 44px;
        height: 34px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.2);
        padding: 0;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 10px;
      }
      .row3 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
        margin-bottom: 10px;
      }
      .rowTight {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 10px;
        align-items: center;
        margin-bottom: 10px;
      }
      .field label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin: 0 0 6px 2px;
      }
      .field .hint {
        font-size: 11px;
        color: var(--faint);
        margin: 6px 2px 0;
      }
      .chipRow {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 10px;
      }
      .chip {
        border-radius: 999px;
        padding: 7px 10px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.22);
        font-size: 12px;
        color: rgba(255, 255, 255, 0.84);
      }
      .chip[aria-pressed="true"] {
        border-color: rgba(41, 211, 255, 0.52);
        background: rgba(41, 211, 255, 0.12);
      }
      .divider {
        height: 1px;
        background: rgba(255, 255, 255, 0.1);
        margin: 12px 0;
      }

      .tabs {
        display: flex;
        gap: 8px;
        padding: 8px;
        border: 1px solid var(--stroke);
        background: rgba(0, 0, 0, 0.18);
        border-radius: 16px;
        margin-bottom: 12px;
      }
      .tab {
        flex: 1;
        text-align: center;
        padding: 9px 10px;
        border-radius: 12px;
        font-size: 12px;
        border: 1px solid transparent;
        background: transparent;
        color: rgba(255, 255, 255, 0.84);
      }
      .tab[aria-selected="true"] {
        border-color: rgba(124, 92, 255, 0.55);
        background: rgba(124, 92, 255, 0.14);
      }
      .tabPanels > section {
        display: none;
      }
      .tabPanels > section[data-active="true"] {
        display: block;
      }

      .layerList {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 10px;
      }
      .layerItem {
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.22);
      }
      .layerItem[aria-selected="true"] {
        border-color: rgba(41, 211, 255, 0.55);
        background: rgba(41, 211, 255, 0.08);
      }
      .layerItem .name {
        flex: 1;
        min-width: 0;
      }
      .layerItem .name .top {
        display: flex;
        align-items: baseline;
        gap: 8px;
      }
      .layerItem .name .top strong {
        font-size: 13px;
        font-weight: 650;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .layerItem .name .bottom {
        font-size: 11px;
        color: var(--muted);
        font-family: var(--mono);
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .layerDot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: linear-gradient(135deg, rgba(124, 92, 255, 1), rgba(41, 211, 255, 0.9));
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
      }
      .miniBtns {
        display: flex;
        gap: 6px;
      }
      .miniBtns button {
        padding: 7px;
        border-radius: 12px;
      }

      .kbd {
        font-family: var(--mono);
        font-size: 11px;
        padding: 3px 7px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.25);
        color: rgba(255, 255, 255, 0.82);
      }

      dialog {
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: linear-gradient(180deg, rgba(22, 26, 48, 0.92), rgba(10, 12, 22, 0.92));
        border-radius: 18px;
        box-shadow: 0 28px 120px rgba(0, 0, 0, 0.6);
        color: rgba(255, 255, 255, 0.92);
        max-width: min(720px, calc(100vw - 28px));
      }
      dialog::backdrop {
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(8px);
      }
      .modalHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 14px 14px 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.12);
      }
      .modalHeader h3 {
        margin: 0;
        font-family: var(--display);
        font-size: 16px;
        letter-spacing: 0.2px;
      }
      .modalBody {
        padding: 14px;
      }
      .shortcutGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .shortcutItem {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.22);
      }
      .shortcutItem .keys {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 6px;
      }
      .shortcutItem .desc {
        color: var(--muted);
        font-size: 12px;
      }
      .note {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }
      .statusLine {
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(255, 255, 255, 0.72);
        margin-top: 8px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .toast {
        position: fixed;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.55);
        box-shadow: 0 20px 80px rgba(0, 0, 0, 0.52);
        color: rgba(255, 255, 255, 0.88);
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.15s ease, transform 0.15s ease;
        max-width: min(720px, calc(100vw - 20px));
      }
      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-4px);
      }

      @media (max-width: 1220px) {
        .app {
          grid-template-columns: 340px 1fr 360px;
        }
      }
      @media (max-width: 1080px) {
        body {
          overflow: auto;
        }
        .app {
          height: auto;
          min-height: 100%;
          grid-template-rows: 56px minmax(380px, 56vh) 220px;
          grid-template-columns: 1fr;
          grid-template-areas:
            "top"
            "stage"
            "timeline";
        }
        .left,
        .right {
          display: none;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          scroll-behavior: auto !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="app" role="application" aria-label="Kinetic Typography Studio">
      <div class="topbar panel" role="banner">
        <div class="brand" aria-label="App title">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1>Kinetic Typography Studio</h1>
            <div class="sub">Design • Animate • Export</div>
          </div>
        </div>

        <div class="toolbar" aria-label="Playback controls">
          <div class="group" role="group" aria-label="Transport">
            <button class="icon" id="btnPlay" aria-label="Play or pause" aria-keyshortcuts="Space">
              <svg viewBox="0 0 24 24" fill="none">
                <path id="playIcon" d="M10 8.5v7l6-3.5-6-3.5Z" fill="currentColor" opacity="0.92" />
                <path id="pauseIcon" d="M9 8h2v8H9V8Zm4 0h2v8h-2V8Z" fill="currentColor" opacity="0.92" style="display: none" />
              </svg>
            </button>
            <button class="icon" id="btnStop" aria-label="Stop and return to start">
              <svg viewBox="0 0 24 24" fill="none">
                <path d="M8 8h8v8H8V8Z" fill="currentColor" opacity="0.92" />
              </svg>
            </button>
            <button class="icon" id="btnLoop" aria-label="Toggle looping" aria-pressed="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M7 7h10v3l3-3-3-3v2H6a3 3 0 0 0-3 3v4h2V9a2 2 0 0 1 2-2Zm10 10H7v-3l-3 3 3 3v-2h11a3 3 0 0 0 3-3v-4h-2v4a2 2 0 0 1-2 2Z"
                  fill="currentColor"
                  opacity="0.92"
                />
              </svg>
            </button>
          </div>

          <div class="group" role="group" aria-label="Time and zoom">
            <span class="pill" id="timecode" aria-label="Current timecode">00:00.00</span>
            <label class="pill" style="display: flex; gap: 8px; align-items: center" aria-label="Timeline zoom">
              <span style="opacity: 0.85">Zoom</span>
              <input id="zoom" type="range" min="60" max="360" value="150" style="width: 140px" />
            </label>
          </div>

          <div class="group" role="group" aria-label="Snapping">
            <button class="chip" id="snapFrames" aria-label="Snap to frames" aria-pressed="true">Frames</button>
            <button class="chip" id="snapBeats" aria-label="Snap to beats" aria-pressed="true">Beats</button>
            <button class="chip" id="autoKey" aria-label="Auto keyframe on edits" aria-pressed="true">Auto‑Key</button>
          </div>
        </div>

        <div class="rightbar" aria-label="Project controls">
          <div class="group" role="group" aria-label="Project settings">
            <label class="pill" style="display: flex; align-items: center; gap: 8px" aria-label="Frames per second">
              <span style="opacity: 0.85">FPS</span>
              <input id="fps" type="number" min="1" max="240" step="1" value="30" style="width: 72px; padding: 6px 8px; border-radius: 10px" />
            </label>
            <label class="pill" style="display: flex; align-items: center; gap: 8px" aria-label="Duration seconds">
              <span style="opacity: 0.85">Dur</span>
              <input id="duration" type="number" min="0.1" max="120" step="0.1" value="6" style="width: 72px; padding: 6px 8px; border-radius: 10px" />
            </label>
          </div>
          <button class="primary" id="btnExport" aria-label="Export animation" aria-keyshortcuts="Control+E Meta+E">Export</button>
          <button class="ghost icon" id="btnHelp" aria-label="Keyboard shortcuts and help">
            <svg viewBox="0 0 24 24" fill="none">
              <path
                d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm0 15.3a1.1 1.1 0 1 1 0 2.2 1.1 1.1 0 0 1 0-2.2ZM12 6.3c1.86 0 3.3 1.06 3.3 2.8 0 1.27-.67 2-1.68 2.58-.9.52-1.22.84-1.22 1.62v.35h-1.9v-.5c0-1.3.64-2.02 1.6-2.58.88-.52 1.3-.88 1.3-1.52 0-.74-.62-1.22-1.4-1.22-.86 0-1.44.47-1.6 1.33l-1.85-.55C8.9 7.18 10.23 6.3 12 6.3Z"
                fill="currentColor"
                opacity="0.92"
              />
            </svg>
          </button>
        </div>
      </div>

      <aside class="left panel" aria-label="Design panels">
        <header>
          <div class="title">
            <h2>Layers</h2>
            <span class="meta" id="layerMeta">1 layer</span>
          </div>
          <div class="miniBtns" role="group" aria-label="Layer actions">
            <button class="icon" id="btnAddLayer" aria-label="Add text layer">
              <svg viewBox="0 0 24 24" fill="none">
                <path d="M11 5h2v14h-2V5Zm-6 6h14v2H5v-2Z" fill="currentColor" opacity="0.92" />
              </svg>
            </button>
            <button class="icon" id="btnDupLayer" aria-label="Duplicate selected layer">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M8 8h11v11H8V8Zm-3 8H4V5h11v1H5v10Z"
                  fill="currentColor"
                  opacity="0.92"
                />
              </svg>
            </button>
            <button class="icon" id="btnDelLayer" aria-label="Delete selected layer">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M9 3h6l1 2h4v2H4V5h4l1-2Zm1 6h2v9h-2V9Zm4 0h2v9h-2V9Z"
                  fill="currentColor"
                  opacity="0.92"
                />
              </svg>
            </button>
          </div>
        </header>
        <div class="content">
          <div class="layerList" id="layerList" aria-label="Layer list"></div>

          <div class="tabs" role="tablist" aria-label="Editor tabs">
            <button class="tab" role="tab" id="tabText" aria-selected="true" aria-controls="panelText">Text</button>
            <button class="tab" role="tab" id="tabStyle" aria-selected="false" aria-controls="panelStyle">Style</button>
            <button class="tab" role="tab" id="tabMotion" aria-selected="false" aria-controls="panelMotion">Motion</button>
            <button class="tab" role="tab" id="tabLayout" aria-selected="false" aria-controls="panelLayout">Layout</button>
            <button class="tab" role="tab" id="tabAudio" aria-selected="false" aria-controls="panelAudio">Audio</button>
          </div>

          <div class="tabPanels">
            <section id="panelText" role="tabpanel" aria-labelledby="tabText" data-active="true">
              <div class="field">
                <label for="layerName">Layer name</label>
                <input id="layerName" type="text" aria-label="Layer name" />
              </div>
              <div class="divider"></div>
              <div class="field">
                <label for="textInput">Text</label>
                <textarea id="textInput" aria-label="Layer text"></textarea>
                <div class="hint">Tip: use line breaks for multi-line kinetic layouts.</div>
              </div>

              <div class="row">
                <div class="field">
                  <label for="fontFamily">Font</label>
                  <select id="fontFamily" aria-label="Font family"></select>
                </div>
                <div class="field">
                  <label for="fontSize">Size</label>
                  <input id="fontSize" type="number" min="6" max="600" step="1" aria-label="Font size" />
                </div>
              </div>

              <div class="row3">
                <div class="field">
                  <label for="fontWeight">Weight</label>
                  <input id="fontWeight" type="number" min="100" max="900" step="50" aria-label="Font weight" />
                </div>
                <div class="field">
                  <label for="italicToggle">Italic</label>
                  <button class="chip" id="italicToggle" aria-label="Italic" aria-pressed="false" style="width: 100%">Italic</button>
                </div>
                <div class="field">
                  <label for="lineHeight">Line height</label>
                  <input id="lineHeight" type="number" min="0.7" max="3" step="0.05" aria-label="Line height" />
                </div>
              </div>

              <div class="field">
                <label>Alignment</label>
                <div class="chipRow" role="group" aria-label="Text alignment">
                  <button class="chip" id="alignLeft" aria-label="Align left" aria-pressed="false">Left</button>
                  <button class="chip" id="alignCenter" aria-label="Align center" aria-pressed="true">Center</button>
                  <button class="chip" id="alignRight" aria-label="Align right" aria-pressed="false">Right</button>
                </div>
              </div>
            </section>

            <section id="panelStyle" role="tabpanel" aria-labelledby="tabStyle">
              <div class="row">
                <div class="field">
                  <label for="fillMode">Fill</label>
                  <select id="fillMode" aria-label="Fill mode">
                    <option value="solid">Solid</option>
                    <option value="gradient">Gradient</option>
                  </select>
                </div>
                <div class="field">
                  <label for="bgColor">Background</label>
                  <input id="bgColor" type="color" aria-label="Background color" />
                </div>
              </div>

              <div class="row">
                <div class="field">
                  <label for="fillA">Color A</label>
                  <input id="fillA" type="color" aria-label="Fill color A" />
                </div>
                <div class="field">
                  <label for="fillB">Color B</label>
                  <input id="fillB" type="color" aria-label="Fill color B" />
                </div>
              </div>
              <div class="field">
                <label for="gradAngle">Gradient angle</label>
                <input id="gradAngle" type="range" min="0" max="360" value="30" aria-label="Gradient angle" />
              </div>

              <div class="divider"></div>
              <div class="row3">
                <div class="field">
                  <label for="strokeOn">Outline</label>
                  <button class="chip" id="strokeOn" aria-label="Toggle outline" aria-pressed="false" style="width: 100%">Outline</button>
                </div>
                <div class="field">
                  <label for="strokeWidth">Width</label>
                  <input id="strokeWidth" type="number" min="0" max="60" step="0.5" aria-label="Outline width" />
                </div>
                <div class="field">
                  <label for="strokeColor">Color</label>
                  <input id="strokeColor" type="color" aria-label="Outline color" />
                </div>
              </div>

              <div class="divider"></div>
              <div class="row3">
                <div class="field">
                  <label for="shadowOn">Shadow</label>
                  <button class="chip" id="shadowOn" aria-label="Toggle shadow" aria-pressed="true" style="width: 100%">Shadow</button>
                </div>
                <div class="field">
                  <label for="shadowBlur">Blur</label>
                  <input id="shadowBlur" type="number" min="0" max="120" step="1" aria-label="Shadow blur" />
                </div>
                <div class="field">
                  <label for="shadowColor">Color</label>
                  <input id="shadowColor" type="color" aria-label="Shadow color" />
                </div>
              </div>
              <div class="row">
                <div class="field">
                  <label for="shadowX">Offset X</label>
                  <input id="shadowX" type="number" min="-240" max="240" step="1" aria-label="Shadow offset X" />
                </div>
                <div class="field">
                  <label for="shadowY">Offset Y</label>
                  <input id="shadowY" type="number" min="-240" max="240" step="1" aria-label="Shadow offset Y" />
                </div>
              </div>

              <div class="divider"></div>
              <div class="rowTight">
                <button class="chip" id="bgImageBtn" aria-label="Load background image">Load image…</button>
                <div class="note" id="bgImageNote">No image loaded.</div>
                <input id="bgImageFile" type="file" accept="image/*" style="display: none" aria-label="Background image file" />
              </div>
            </section>

            <section id="panelMotion" role="tabpanel" aria-labelledby="tabMotion">
              <div class="row">
                <div class="field">
                  <label for="preset">Preset</label>
                  <select id="preset" aria-label="Animation preset">
                    <option value="none">None (keyframes only)</option>
                    <option value="typewriter">Typewriter</option>
                    <option value="fadeUp">Fade‑Up</option>
                    <option value="bounce">Bounce</option>
                    <option value="cascade">Cascade</option>
                    <option value="liquid">Liquid</option>
                    <option value="glitch">Glitch</option>
                  </select>
                </div>
                <div class="field">
                  <label for="presetApply">Quick start</label>
                  <button class="primary" id="presetApply" aria-label="Apply preset and generate keyframes" style="width: 100%">Apply</button>
                </div>
              </div>

              <div class="row3">
                <div class="field">
                  <label for="staggerUnit">Cascade</label>
                  <select id="staggerUnit" aria-label="Cascade unit">
                    <option value="letter">By letter</option>
                    <option value="word">By word</option>
                    <option value="line">By line</option>
                  </select>
                </div>
                <div class="field">
                  <label for="stagger">Stagger (ms)</label>
                  <input id="stagger" type="number" min="0" max="6000" step="10" aria-label="Stagger milliseconds" />
                </div>
                <div class="field">
                  <label for="animDur">Unit dur (ms)</label>
                  <input id="animDur" type="number" min="10" max="12000" step="10" aria-label="Per unit duration milliseconds" />
                </div>
              </div>

              <div class="row3">
                <div class="field">
                  <label for="amplitude">Amplitude</label>
                  <input id="amplitude" type="range" min="0" max="200" value="60" aria-label="Preset amplitude" />
                </div>
                <div class="field">
                  <label for="motionBlur">Motion blur</label>
                  <button class="chip" id="motionBlur" aria-label="Toggle motion blur" aria-pressed="false" style="width: 100%">Blur</button>
                </div>
                <div class="field">
                  <label for="seed">Seed</label>
                  <input id="seed" type="number" min="0" max="999999" step="1" aria-label="Effect seed" />
                </div>
              </div>

              <div class="divider"></div>
              <div class="field">
                <label>Keyframe at playhead</label>
                <div class="chipRow" role="group" aria-label="Add keyframe buttons">
                  <button class="chip" data-addkf="x" aria-label="Add keyframe for position X">Pos X</button>
                  <button class="chip" data-addkf="y" aria-label="Add keyframe for position Y">Pos Y</button>
                  <button class="chip" data-addkf="scale" aria-label="Add keyframe for scale">Scale</button>
                  <button class="chip" data-addkf="rot" aria-label="Add keyframe for rotation">Rot</button>
                  <button class="chip" data-addkf="opacity" aria-label="Add keyframe for opacity">Opacity</button>
                  <button class="chip" data-addkf="tracking" aria-label="Add keyframe for tracking">Tracking</button>
                  <button class="chip" data-addkf="letterOffset" aria-label="Add keyframe for letter offset">Letter</button>
                  <button class="chip" data-addkf="wordOffset" aria-label="Add keyframe for word offset">Word</button>
                </div>
                <div class="hint">Tip: double‑click a lane in the timeline to add a keyframe.</div>
              </div>

              <div class="divider"></div>
              <div class="field">
                <label>Easing</label>
                <div class="row">
                  <div class="field">
                    <label for="easePreset" style="margin-top: -14px">Preset</label>
                    <select id="easePreset" aria-label="Easing preset">
                      <option value="easeInOut">Ease In‑Out</option>
                      <option value="linear">Linear</option>
                      <option value="easeIn">Ease In</option>
                      <option value="easeOut">Ease Out</option>
                      <option value="bounce">Bounce</option>
                      <option value="elastic">Elastic</option>
                      <option value="steps">Steps (typewriter)</option>
                      <option value="bezier">Custom Bézier…</option>
                    </select>
                  </div>
                  <div class="field">
                    <label for="applyEase" style="margin-top: -14px">Keyframe</label>
                    <button id="applyEase" aria-label="Apply easing to selected keyframe" style="width: 100%">Apply easing</button>
                  </div>
                </div>
                <div class="row3" id="bezierRow" style="display: none">
                  <div class="field">
                    <label for="bz1x">P1x</label>
                    <input id="bz1x" type="number" step="0.01" min="0" max="1" aria-label="Bezier control point 1 x" />
                  </div>
                  <div class="field">
                    <label for="bz1y">P1y</label>
                    <input id="bz1y" type="number" step="0.01" min="-2" max="2" aria-label="Bezier control point 1 y" />
                  </div>
                  <div class="field">
                    <label for="bz2x">P2x</label>
                    <input id="bz2x" type="number" step="0.01" min="0" max="1" aria-label="Bezier control point 2 x" />
                  </div>
                  <div class="field">
                    <label for="bz2y">P2y</label>
                    <input id="bz2y" type="number" step="0.01" min="-2" max="2" aria-label="Bezier control point 2 y" />
                  </div>
                  <div class="field" style="grid-column: 1 / -1">
                    <div class="hint">Cubic Bézier format: (0,0) → (P1x,P1y) → (P2x,P2y) → (1,1)</div>
                  </div>
                </div>
              </div>
            </section>

            <section id="panelLayout" role="tabpanel" aria-labelledby="tabLayout">
              <div class="row">
                <div class="field">
                  <label for="aspect">Aspect</label>
                  <select id="aspect" aria-label="Aspect preset">
                    <option value="16:9">16:9</option>
                    <option value="9:16">9:16</option>
                    <option value="1:1">1:1</option>
                    <option value="4:5">4:5</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
                <div class="field">
                  <label for="resPreset">Resolution</label>
                  <select id="resPreset" aria-label="Resolution preset">
                    <option value="1920x1080">1920×1080</option>
                    <option value="1080x1920">1080×1920</option>
                    <option value="1080x1080">1080×1080</option>
                    <option value="2048x2048">2048×2048</option>
                    <option value="1280x720">1280×720</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
              </div>

              <div class="row3">
                <div class="field">
                  <label for="width">Width</label>
                  <input id="width" type="number" min="64" max="8192" step="1" aria-label="Canvas width" />
                </div>
                <div class="field">
                  <label for="height">Height</label>
                  <input id="height" type="number" min="64" max="8192" step="1" aria-label="Canvas height" />
                </div>
                <div class="field">
                  <label for="margin">Safe margin</label>
                  <input id="margin" type="range" min="0" max="0.25" step="0.005" aria-label="Safe area margin" />
                </div>
              </div>

              <div class="row3">
                <div class="field">
                  <label for="showGrid">Grid</label>
                  <button class="chip" id="showGrid" aria-label="Toggle grid" aria-pressed="true" style="width: 100%">Grid</button>
                </div>
                <div class="field">
                  <label for="showSafe">Safe area</label>
                  <button class="chip" id="showSafe" aria-label="Toggle safe area" aria-pressed="true" style="width: 100%">Safe</button>
                </div>
                <div class="field">
                  <label for="showCross">Center</label>
                  <button class="chip" id="showCross" aria-label="Toggle center crosshair" aria-pressed="false" style="width: 100%">Cross</button>
                </div>
              </div>

              <div class="divider"></div>
              <div class="note">
                Stage drag: move selected layer. <span class="kbd">Shift</span> drag constrains axis. Mouse wheel / trackpad zooms stage. Timeline: <span class="kbd">double‑click</span> to add keyframes.
              </div>
            </section>

            <section id="panelAudio" role="tabpanel" aria-labelledby="tabAudio">
              <div class="rowTight">
                <button class="chip" id="audioLoad" aria-label="Load audio file">Load audio…</button>
                <div class="note" id="audioNote">No audio loaded.</div>
                <input id="audioFile" type="file" accept="audio/*" style="display: none" aria-label="Audio file" />
              </div>

              <div class="row3">
                <div class="field">
                  <label for="audioSnap">Beat snap</label>
                  <button class="chip" id="audioSnap" aria-label="Snap keyframes to beats" aria-pressed="true" style="width: 100%">Snap</button>
                </div>
                <div class="field">
                  <label for="audioReactive">Reactive</label>
                  <button class="chip" id="audioReactive" aria-label="Enable audio-reactive mode" aria-pressed="false" style="width: 100%">Reactive</button>
                </div>
                <div class="field">
                  <label for="audioIntensity">Intensity</label>
                  <input id="audioIntensity" type="range" min="0" max="2" step="0.01" aria-label="Audio intensity" />
                </div>
              </div>

              <div class="row">
                <div class="field">
                  <label for="audioScaleAmt">Scale drive</label>
                  <input id="audioScaleAmt" type="range" min="0" max="1.2" step="0.01" aria-label="Audio scale amount" />
                </div>
                <div class="field">
                  <label for="audioRotAmt">Rotation drive</label>
                  <input id="audioRotAmt" type="range" min="0" max="2" step="0.01" aria-label="Audio rotation amount" />
                </div>
              </div>
              <div class="row">
                <div class="field">
                  <label for="audioTrackAmt">Tracking drive</label>
                  <input id="audioTrackAmt" type="range" min="0" max="80" step="0.5" aria-label="Audio tracking amount" />
                </div>
                <div class="field">
                  <label for="audioGlitchAmt">Glitch drive</label>
                  <input id="audioGlitchAmt" type="range" min="0" max="2" step="0.01" aria-label="Audio glitch amount" />
                </div>
              </div>
              <div class="note" id="audioStats">BPM: — • Beats: —</div>
            </section>
          </div>
        </div>
      </aside>

      <main class="stage panel" aria-label="Preview stage">
        <header>
          <div class="title">
            <h2>Stage</h2>
            <span class="meta" id="stageMeta">—</span>
          </div>
          <div class="miniBtns" role="group" aria-label="Stage actions">
            <button class="icon" id="btnFit" aria-label="Fit stage">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M8 3H3v5h2V5h3V3Zm13 0h-5v2h3v3h2V3ZM3 16v5h5v-2H5v-3H3Zm18 0h-2v3h-3v2h5v-5Z"
                  fill="currentColor"
                  opacity="0.92"
                />
              </svg>
            </button>
            <button class="icon" id="btnScreenshot" aria-label="Export current frame PNG">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M9 5h6l1 2h3a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h3l1-2Zm3 14a5 5 0 1 0 0-10 5 5 0 0 0 0 10Zm0-2.2a2.8 2.8 0 1 1 0-5.6 2.8 2.8 0 0 1 0 5.6Z"
                  fill="currentColor"
                  opacity="0.92"
                />
              </svg>
            </button>
          </div>
        </header>
        <div class="stageWrap">
          <div class="stageCanvasShell" id="stageShell" aria-label="Canvas preview" tabindex="0">
            <canvas id="stageCanvas" width="1920" height="1080" aria-label="Animation canvas"></canvas>
            <div class="stageOverlays" aria-hidden="true">
              <div class="grid" id="gridOverlay"></div>
              <div class="safeArea" id="safeOverlay"></div>
              <div class="centerCross" id="crossOverlay"></div>
            </div>
          </div>
        </div>
      </main>

      <aside class="right panel" aria-label="Inspector">
        <header>
          <div class="title">
            <h2>Inspector</h2>
            <span class="meta" id="inspectorMeta">No selection</span>
          </div>
          <div class="miniBtns" role="group" aria-label="Edit actions">
            <button class="icon" id="btnUndo" aria-label="Undo (Ctrl or Cmd Z)" aria-keyshortcuts="Control+Z Meta+Z">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M12 5a7 7 0 0 1 7 7h-2a5 5 0 0 0-8.54-3.54L11 11H4V4l2.72 2.72A7 7 0 0 1 12 5Z"
                  fill="currentColor"
                  opacity="0.92"
                />
              </svg>
            </button>
            <button class="icon" id="btnRedo" aria-label="Redo (Ctrl or Cmd Shift Z)" aria-keyshortcuts="Control+Shift+Z Meta+Shift+Z">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M12 5a7 7 0 0 0-7 7h2a5 5 0 0 1 8.54-3.54L13 11h7V4l-2.72 2.72A7 7 0 0 0 12 5Z"
                  fill="currentColor"
                  opacity="0.92"
                />
              </svg>
            </button>
            <button class="icon" id="btnReset" aria-label="Reset selected layer transforms">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M12 6V3L8 7l4 4V8a4 4 0 1 1-4 4H6a6 6 0 1 0 6-6Z"
                  fill="currentColor"
                  opacity="0.92"
                />
              </svg>
            </button>
          </div>
        </header>
        <div class="content">
          <div class="row">
            <div class="field">
              <label for="propX">Position X</label>
              <input id="propX" type="number" step="1" aria-label="Position X" />
            </div>
            <div class="field">
              <label for="propY">Position Y</label>
              <input id="propY" type="number" step="1" aria-label="Position Y" />
            </div>
          </div>
          <div class="row">
            <div class="field">
              <label for="propScale">Scale</label>
              <input id="propScale" type="number" step="0.01" min="0.01" aria-label="Scale" />
            </div>
            <div class="field">
              <label for="propRot">Rotation (deg)</label>
              <input id="propRot" type="number" step="0.1" aria-label="Rotation degrees" />
            </div>
          </div>
          <div class="row">
            <div class="field">
              <label for="propOpacity">Opacity</label>
              <input id="propOpacity" type="number" step="0.01" min="0" max="1" aria-label="Opacity" />
            </div>
            <div class="field">
              <label for="propTracking">Tracking (px)</label>
              <input id="propTracking" type="number" step="0.5" aria-label="Tracking" />
            </div>
          </div>
          <div class="row">
            <div class="field">
              <label for="propLetterOffset">Letter offset (px)</label>
              <input id="propLetterOffset" type="number" step="1" aria-label="Letter offset" />
            </div>
            <div class="field">
              <label for="propWordOffset">Word offset (px)</label>
              <input id="propWordOffset" type="number" step="1" aria-label="Word offset" />
            </div>
          </div>

          <div class="divider"></div>
          <div class="note">
            Selected keyframe: <span class="kbd">drag</span> in timeline • <span class="kbd">Delete</span> removes • <span class="kbd">K</span> adds at playhead.
          </div>
          <div class="statusLine" id="statusLine">Ready.</div>
        </div>
      </aside>

      <section class="timeline panel" aria-label="Timeline editor">
        <canvas id="timelineCanvas" aria-label="Timeline canvas"></canvas>
        <div class="timelineHUD" aria-hidden="true">
          <div class="pill" id="timelineHint">Double‑click: keyframe • Drag: move • Space: play</div>
        </div>
      </section>
    </div>

    <dialog id="exportDialog" aria-label="Export dialog">
      <div class="modalHeader">
        <h3>Export</h3>
        <button class="icon" id="btnCloseExport" aria-label="Close export dialog">
          <svg viewBox="0 0 24 24" fill="none">
            <path d="M7 7l10 10M17 7 7 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" opacity="0.92" />
          </svg>
        </button>
      </div>
      <div class="modalBody">
        <div class="row">
          <div class="field">
            <label for="exportFormat">Format</label>
            <select id="exportFormat" aria-label="Export format">
              <option value="webm">WebM video</option>
              <option value="gif">GIF</option>
              <option value="pngseq">PNG sequence (ZIP)</option>
              <option value="mp4">MP4 (experimental)</option>
            </select>
            <div class="hint">MP4 support depends on browser codecs; WebM is the most reliable.</div>
          </div>
          <div class="field">
            <label for="exportFps">Frame rate</label>
            <input id="exportFps" type="number" min="1" max="240" step="1" aria-label="Export frame rate" />
            <div class="hint">Tip: GIF works best at 12–20 fps.</div>
          </div>
        </div>
        <div class="row">
          <div class="field">
            <label for="exportW">Width</label>
            <input id="exportW" type="number" min="64" max="8192" step="1" aria-label="Export width" />
          </div>
          <div class="field">
            <label for="exportH">Height</label>
            <input id="exportH" type="number" min="64" max="8192" step="1" aria-label="Export height" />
          </div>
        </div>
        <div class="row">
          <div class="field">
            <label for="exportStart">Start (s)</label>
            <input id="exportStart" type="number" min="0" step="0.01" aria-label="Export start time" />
          </div>
          <div class="field">
            <label for="exportEnd">End (s)</label>
            <input id="exportEnd" type="number" min="0" step="0.01" aria-label="Export end time" />
          </div>
        </div>
        <div class="row3">
          <div class="field">
            <label for="exportQuality">Quality</label>
            <input id="exportQuality" type="range" min="0.1" max="1" step="0.01" aria-label="Export quality" />
          </div>
          <div class="field">
            <label for="exportOffline">Renderer</label>
            <select id="exportOffline" aria-label="Export renderer">
              <option value="offline">Offline render (best)</option>
              <option value="realtime">Realtime record</option>
            </select>
          </div>
          <div class="field">
            <label for="exportNoEffects">Reduced FX</label>
            <button class="chip" id="exportNoEffects" aria-label="Reduce heavy effects during export" aria-pressed="false" style="width: 100%">Reduce</button>
          </div>
        </div>
        <div class="divider"></div>
        <div class="row">
          <button class="primary" id="btnDoExport" aria-label="Start export" style="width: 100%">Render & Download</button>
        </div>
        <div class="statusLine" id="exportStatus">Ready.</div>
      </div>
    </dialog>

    <dialog id="helpDialog" aria-label="Help dialog">
      <div class="modalHeader">
        <h3>Shortcuts & Tips</h3>
        <button class="icon" id="btnCloseHelp" aria-label="Close help dialog">
          <svg viewBox="0 0 24 24" fill="none">
            <path d="M7 7l10 10M17 7 7 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" opacity="0.92" />
          </svg>
        </button>
      </div>
      <div class="modalBody">
        <div class="shortcutGrid" aria-label="Keyboard shortcuts list">
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">Space</span></div>
            <div class="desc">Play / pause</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">K</span></div>
            <div class="desc">Add keyframe (selected property)</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">Shift</span> <span class="kbd">K</span></div>
            <div class="desc">Add keyframes for all properties</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">Delete</span></div>
            <div class="desc">Delete selected keyframe</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">←</span> <span class="kbd">→</span></div>
            <div class="desc">Nudge selected keyframe by 1 frame</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">Shift</span> <span class="kbd">←</span> <span class="kbd">→</span></div>
            <div class="desc">Nudge by 10 frames</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">Ctrl/Cmd</span> <span class="kbd">Z</span></div>
            <div class="desc">Undo</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">Ctrl/Cmd</span> <span class="kbd">Shift</span> <span class="kbd">Z</span></div>
            <div class="desc">Redo</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">Ctrl/Cmd</span> <span class="kbd">E</span></div>
            <div class="desc">Export</div>
          </div>
          <div class="shortcutItem">
            <div class="keys"><span class="kbd">Home</span> <span class="kbd">End</span></div>
            <div class="desc">Jump to start / end</div>
          </div>
        </div>
        <div class="divider"></div>
        <div class="note">
          Audio: load a local track, then enable <span class="kbd">Reactive</span> for scale/rotation/tracking/glitch drive. Timeline snaps to beats and frames.
          <br />
          Export renders without UI chrome. If you have <span class="kbd">prefers‑reduced‑motion</span> enabled, heavy effects are softened.
        </div>
      </div>
    </dialog>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <script type="module">
      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const deg2rad = (d) => (d * Math.PI) / 180;
      const rad2deg = (r) => (r * 180) / Math.PI;
      const isMac = /Mac|iPhone|iPad|iPod/.test(navigator.platform);
      const modKey = isMac ? "⌘" : "Ctrl";

      const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;

      function uid(prefix = "id") {
        return `${prefix}_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
      }

      function formatTime(t) {
        const s = Math.max(0, t);
        const mm = Math.floor(s / 60);
        const ss = Math.floor(s % 60);
        const cs = Math.floor((s - Math.floor(s)) * 100);
        return `${String(mm).padStart(2, "0")}:${String(ss).padStart(2, "0")}.${String(cs).padStart(2, "0")}`;
      }

      function toast(msg, kind = "info", ms = 2100) {
        const el = $("#toast");
        if (!el) return;
        el.textContent = msg;
        el.style.borderColor =
          kind === "good" ? "rgba(46,229,157,0.45)" : kind === "bad" ? "rgba(255,77,125,0.55)" : "rgba(255,255,255,0.16)";
        el.classList.add("show");
        clearTimeout(toast._t);
        toast._t = setTimeout(() => el.classList.remove("show"), ms);
      }

      function deepClone(obj) {
        return typeof structuredClone === "function" ? structuredClone(obj) : JSON.parse(JSON.stringify(obj));
      }

      function seeded(seed) {
        let t = seed >>> 0;
        return () => {
          t += 0x6d2b79f5;
          let x = t;
          x = Math.imul(x ^ (x >>> 15), x | 1);
          x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
          return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
        };
      }

      // ---- EASING ----
      function cubicBezier(p1x, p1y, p2x, p2y) {
        // Based on bezier-easing (gre) approach.
        const NEWTON_ITERATIONS = 8;
        const NEWTON_MIN_SLOPE = 0.001;
        const SUBDIVISION_PRECISION = 1e-7;
        const SUBDIVISION_MAX_ITERATIONS = 12;
        const kSplineTableSize = 11;
        const kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

        const float32ArraySupported = typeof Float32Array === "function";
        const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

        function A(a1, a2) {
          return 1.0 - 3.0 * a2 + 3.0 * a1;
        }
        function B(a1, a2) {
          return 3.0 * a2 - 6.0 * a1;
        }
        function C(a1) {
          return 3.0 * a1;
        }
        function calcBezier(t, a1, a2) {
          return ((A(a1, a2) * t + B(a1, a2)) * t + C(a1)) * t;
        }
        function getSlope(t, a1, a2) {
          return 3.0 * A(a1, a2) * t * t + 2.0 * B(a1, a2) * t + C(a1);
        }
        function binarySubdivide(x, a, b) {
          let currentX, currentT, i = 0;
          do {
            currentT = a + (b - a) / 2.0;
            currentX = calcBezier(currentT, p1x, p2x) - x;
            if (currentX > 0.0) b = currentT;
            else a = currentT;
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
          return currentT;
        }
        function newtonRaphsonIterate(x, guessT) {
          for (let i = 0; i < NEWTON_ITERATIONS; ++i) {
            const slope = getSlope(guessT, p1x, p2x);
            if (slope === 0.0) return guessT;
            const currentX = calcBezier(guessT, p1x, p2x) - x;
            guessT -= currentX / slope;
          }
          return guessT;
        }
        function getTForX(x) {
          let intervalStart = 0.0;
          let currentSample = 1;
          const lastSample = kSplineTableSize - 1;

          for (; currentSample !== lastSample && sampleValues[currentSample] <= x; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;

          const dist = (x - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          let guessT = intervalStart + dist * kSampleStepSize;

          const initialSlope = getSlope(guessT, p1x, p2x);
          if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(x, guessT);
          if (initialSlope === 0.0) return guessT;
          return binarySubdivide(x, intervalStart, intervalStart + kSampleStepSize);
        }

        for (let i = 0; i < kSplineTableSize; ++i) sampleValues[i] = calcBezier(i * kSampleStepSize, p1x, p2x);

        return (x) => {
          if (p1x === p1y && p2x === p2y) return x;
          if (x <= 0) return 0;
          if (x >= 1) return 1;
          return calcBezier(getTForX(x), p1y, p2y);
        };
      }

      const EASE = {
        linear: (t) => t,
        easeIn: cubicBezier(0.42, 0.0, 1.0, 1.0),
        easeOut: cubicBezier(0.0, 0.0, 0.58, 1.0),
        easeInOut: cubicBezier(0.42, 0.0, 0.58, 1.0),
        bounce: (t) => {
          const n1 = 7.5625;
          const d1 = 2.75;
          if (t < 1 / d1) return n1 * t * t;
          if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
          if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
          return n1 * (t -= 2.625 / d1) * t + 0.984375;
        },
        elastic: (t) => {
          const c4 = (2 * Math.PI) / 3;
          if (t === 0) return 0;
          if (t === 1) return 1;
          return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        },
      };

      function easeFnFromKeyframe(kf) {
        if (!kf || !kf.ease) return EASE.easeInOut;
        const e = kf.ease;
        if (e.type === "preset") {
          if (e.name === "steps") {
            const steps = Math.max(1, Math.floor(e.steps ?? 10));
            return (t) => Math.floor(t * steps) / steps;
          }
          return EASE[e.name] || EASE.easeInOut;
        }
        if (e.type === "bezier") {
          const { p1x, p1y, p2x, p2y } = e;
          return cubicBezier(p1x, p1y, p2x, p2y);
        }
        return EASE.easeInOut;
      }

      // ---- MODEL ----
      const TRACKS = [
        { id: "x", label: "Pos X", unit: "px" },
        { id: "y", label: "Pos Y", unit: "px" },
        { id: "scale", label: "Scale", unit: "" },
        { id: "rot", label: "Rot", unit: "°" },
        { id: "opacity", label: "Opacity", unit: "" },
        { id: "tracking", label: "Tracking", unit: "px" },
        { id: "letterOffset", label: "Letter", unit: "px" },
        { id: "wordOffset", label: "Word", unit: "px" },
      ];

      function defaultKeyframes(v) {
        return [{ t: 0, v, ease: { type: "preset", name: "easeInOut" } }];
      }

      function makeLayer(name, text) {
        const id = uid("layer");
        return {
          id,
          name,
          text,
          style: {
            fontFamily: "Space Grotesk",
            fontSize: 128,
            fontWeight: 650,
            italic: false,
            align: "center",
            lineHeight: 1.05,
            fillMode: "gradient",
            fillA: "#ffffff",
            fillB: "#29d3ff",
            gradAngle: 25,
            strokeOn: false,
            strokeWidth: 8,
            strokeColor: "#0b1020",
            shadowOn: true,
            shadowColor: "#000000",
            shadowBlur: 30,
            shadowX: 0,
            shadowY: 18,
          },
          motion: {
            preset: "fadeUp",
            staggerUnit: "letter",
            staggerMs: 32,
            unitDurMs: 460,
            amplitude: prefersReducedMotion ? 35 : 70,
            motionBlur: false,
            seed: Math.floor(Math.random() * 900000),
          },
          tracks: {
            x: defaultKeyframes(0),
            y: defaultKeyframes(0),
            scale: defaultKeyframes(1),
            rot: defaultKeyframes(0),
            opacity: defaultKeyframes(1),
            tracking: defaultKeyframes(0),
            letterOffset: defaultKeyframes(0),
            wordOffset: defaultKeyframes(0),
          },
        };
      }

      const state = {
        project: {
          width: 1920,
          height: 1080,
          fps: 30,
          duration: 6,
          bg: { color: "#0b1020", imageDataUrl: null, imageBitmap: null },
          guides: { safe: true, grid: true, cross: false, margin: 0.08 },
        },
        ui: {
          time: 0,
          playing: false,
          loop: true,
          zoom: 150,
          scroll: 0,
          snapFrames: true,
          snapBeats: true,
          autoKey: true,
          stageFit: 1,
          stagePanX: 0,
          stagePanY: 0,
          stageZoom: 1,
          selectedLayerId: null,
          selectedKey: null, // { prop, index }
          selectedTrack: "x",
          dragging: null,
        },
        audio: {
          fileName: null,
          buffer: null,
          bpm: null,
          beats: [],
          bars: [],
          reactive: false,
          intensity: 0.85,
          map: { scale: 0.16, rot: 0.18, tracking: 10, glitch: 0.45 },
          rms: null, // { sampleRate, hopSec, values: Float32Array }
          ctx: null,
          gain: null,
          source: null,
          playing: false,
          startCtxTime: 0,
          offset: 0,
        },
        export: {
          reduceFx: false,
        },
        history: {
          undo: [],
          redo: [],
          max: 60,
          lock: false,
        },
        layers: [makeLayer("Headline", "KINETIC\nTYPE\nSTUDIO")],
      };
      state.ui.selectedLayerId = state.layers[0].id;

      // ---- HISTORY ----
      function snapshot(label = "") {
        if (state.history.lock) return;
        const snap = deepClone({
          project: state.project,
          layers: state.layers,
          ui: {
            selectedLayerId: state.ui.selectedLayerId,
            selectedKey: state.ui.selectedKey,
            selectedTrack: state.ui.selectedTrack,
          },
          audio: {
            bpm: state.audio.bpm,
            beats: state.audio.beats,
            bars: state.audio.bars,
            reactive: state.audio.reactive,
            intensity: state.audio.intensity,
            map: state.audio.map,
            fileName: state.audio.fileName,
          },
        });
        state.history.undo.push({ snap, label, at: Date.now() });
        if (state.history.undo.length > state.history.max) state.history.undo.shift();
        state.history.redo.length = 0;
      }
      function restoreSnap(snap) {
        state.history.lock = true;
        state.project = snap.project;
        state.layers = snap.layers;
        state.ui.selectedLayerId = snap.ui.selectedLayerId;
        state.ui.selectedKey = snap.ui.selectedKey;
        state.ui.selectedTrack = snap.ui.selectedTrack;
        state.audio.bpm = snap.audio.bpm;
        state.audio.beats = snap.audio.beats;
        state.audio.bars = snap.audio.bars || [];
        state.audio.reactive = snap.audio.reactive;
        state.audio.intensity = snap.audio.intensity;
        state.audio.map = snap.audio.map;
        state.audio.fileName = snap.audio.fileName;
        state.history.lock = false;
        updateAllUI();
        invalidateAll();
      }
      function undo() {
        const last = state.history.undo.pop();
        if (!last) return;
        state.history.redo.push({
          snap: deepClone({
            project: state.project,
            layers: state.layers,
            ui: { selectedLayerId: state.ui.selectedLayerId, selectedKey: state.ui.selectedKey, selectedTrack: state.ui.selectedTrack },
            audio: { bpm: state.audio.bpm, beats: state.audio.beats, bars: state.audio.bars, reactive: state.audio.reactive, intensity: state.audio.intensity, map: state.audio.map, fileName: state.audio.fileName },
          }),
          label: "redo",
        });
        restoreSnap(last.snap);
        toast("Undo", "info");
      }
      function redo() {
        const last = state.history.redo.pop();
        if (!last) return;
        snapshot("undo");
        restoreSnap(last.snap);
        toast("Redo", "info");
      }

      // ---- DOM WIRING ----
      const stageCanvas = $("#stageCanvas");
      const stageShell = $("#stageShell");
      const stageCtx = stageCanvas.getContext("2d", { alpha: true, desynchronized: true });
      const timelineCanvas = $("#timelineCanvas");
      const tlCtx = timelineCanvas.getContext("2d", { alpha: true, desynchronized: true });

      const exportDialog = $("#exportDialog");
      const helpDialog = $("#helpDialog");

      const FONT_OPTIONS = [
        { label: "Space Grotesk (web)", value: "Space Grotesk" },
        { label: "Inter (web)", value: "Inter" },
        { label: "IBM Plex Mono (web)", value: "IBM Plex Mono" },
        { label: "System UI", value: "system-ui" },
        { label: "SF Pro (macOS)", value: "-apple-system" },
        { label: "Segoe UI (Windows)", value: "Segoe UI" },
        { label: "Roboto", value: "Roboto" },
        { label: "Georgia", value: "Georgia" },
        { label: "Times", value: "Times New Roman" },
        { label: "Courier", value: "Courier New" },
        { label: "Impact", value: "Impact" },
      ];

      function layerById(id) {
        return state.layers.find((l) => l.id === id) || state.layers[0];
      }
      function selectedLayer() {
        return layerById(state.ui.selectedLayerId);
      }

      function keyframesFor(layer, prop) {
        return layer.tracks[prop] || (layer.tracks[prop] = defaultKeyframes(0));
      }

      function sortKeyframes(kfs) {
        kfs.sort((a, b) => a.t - b.t);
      }

      function getValueAt(layer, prop, t) {
        const kfs = keyframesFor(layer, prop);
        if (kfs.length === 0) return 0;
        sortKeyframes(kfs);
        if (t <= kfs[0].t) return kfs[0].v;
        if (t >= kfs[kfs.length - 1].t) return kfs[kfs.length - 1].v;
        for (let i = 0; i < kfs.length - 1; i++) {
          const a = kfs[i];
          const b = kfs[i + 1];
          if (t >= a.t && t <= b.t) {
            const u = (t - a.t) / Math.max(1e-6, b.t - a.t);
            const ease = easeFnFromKeyframe(a);
            const uu = ease(clamp(u, 0, 1));
            return lerp(a.v, b.v, uu);
          }
        }
        return kfs[kfs.length - 1].v;
      }

      function setKeyframe(layer, prop, t, v, keepEase = true) {
        const kfs = keyframesFor(layer, prop);
        const eps = 1 / Math.max(1, state.project.fps) / 2;
        let found = -1;
        for (let i = 0; i < kfs.length; i++) {
          if (Math.abs(kfs[i].t - t) <= eps) {
            found = i;
            break;
          }
        }
        if (found >= 0) {
          kfs[found].v = v;
          if (!keepEase) kfs[found].ease = { type: "preset", name: "easeInOut" };
          state.ui.selectedKey = { prop, index: found };
        } else {
          kfs.push({ t, v, ease: { type: "preset", name: "easeInOut" } });
          sortKeyframes(kfs);
          const idx = kfs.findIndex((x) => Math.abs(x.t - t) <= eps);
          state.ui.selectedKey = { prop, index: idx >= 0 ? idx : 0 };
        }
      }

      function deleteSelectedKeyframe() {
        const layer = selectedLayer();
        const sel = state.ui.selectedKey;
        if (!sel) return;
        const kfs = keyframesFor(layer, sel.prop);
        if (!kfs[sel.index]) return;
        if (kfs.length <= 1) {
          toast("Keep at least 1 keyframe per track.", "info");
          return;
        }
        snapshot("delete keyframe");
        kfs.splice(sel.index, 1);
        sortKeyframes(kfs);
        state.ui.selectedKey = null;
        invalidateTimeline();
      }

      // ---- UI INIT ----
      function initFonts() {
        const sel = $("#fontFamily");
        sel.innerHTML = "";
        for (const f of FONT_OPTIONS) {
          const opt = document.createElement("option");
          opt.value = f.value;
          opt.textContent = f.label;
          sel.appendChild(opt);
        }
      }

      function setTab(tabId) {
        const tabs = [
          ["tabText", "panelText"],
          ["tabStyle", "panelStyle"],
          ["tabMotion", "panelMotion"],
          ["tabLayout", "panelLayout"],
          ["tabAudio", "panelAudio"],
        ];
        for (const [tId, pId] of tabs) {
          const active = tId === tabId;
          $("#" + tId).setAttribute("aria-selected", String(active));
          $("#" + pId).dataset.active = String(active);
        }
      }
      for (const tab of ["tabText", "tabStyle", "tabMotion", "tabLayout", "tabAudio"]) {
        $("#" + tab).addEventListener("click", () => setTab(tab));
      }

      function updateLayerList() {
        const list = $("#layerList");
        list.innerHTML = "";
        for (const layer of state.layers) {
          const row = document.createElement("button");
          row.type = "button";
          row.className = "layerItem";
          row.setAttribute("aria-selected", String(layer.id === state.ui.selectedLayerId));
          row.setAttribute("aria-label", `Select layer ${layer.name}`);
          row.innerHTML = `
            <div class="layerDot" aria-hidden="true"></div>
            <div class="name">
              <div class="top">
                <strong>${escapeHtml(layer.name)}</strong>
              </div>
              <div class="bottom">${escapeHtml(layer.text.replaceAll("\n", " ↵ ").slice(0, 64))}</div>
            </div>
          `;
          row.addEventListener("click", () => {
            state.ui.selectedLayerId = layer.id;
            state.ui.selectedKey = null;
            updateAllUI();
            invalidateAll();
          });
          list.appendChild(row);
        }
        $("#layerMeta").textContent = `${state.layers.length} layer${state.layers.length === 1 ? "" : "s"}`;
      }

      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c]));
      }

      // ---- UI BINDINGS ----
      function bind() {
        $("#btnHelp").addEventListener("click", () => helpDialog.showModal());
        $("#btnCloseHelp").addEventListener("click", () => helpDialog.close());
        $("#btnExport").addEventListener("click", () => openExport());
        $("#btnCloseExport").addEventListener("click", () => exportDialog.close());

        $("#btnUndo").addEventListener("click", undo);
        $("#btnRedo").addEventListener("click", redo);
        $("#btnReset").addEventListener("click", () => {
          snapshot("reset transforms");
          const layer = selectedLayer();
          for (const t of ["x", "y", "scale", "rot", "opacity", "tracking", "letterOffset", "wordOffset"]) {
            const base = t === "scale" ? 1 : t === "opacity" ? 1 : 0;
            layer.tracks[t] = defaultKeyframes(base);
          }
          state.ui.selectedKey = null;
          invalidateAll();
          toast("Transforms reset.", "good");
        });

        $("#btnPlay").addEventListener("click", () => togglePlay());
        $("#btnStop").addEventListener("click", () => {
          stopPlayback();
          state.ui.time = 0;
          invalidateAll();
        });
        $("#btnLoop").addEventListener("click", () => {
          state.ui.loop = !state.ui.loop;
          $("#btnLoop").setAttribute("aria-pressed", String(state.ui.loop));
          toast(state.ui.loop ? "Loop: On" : "Loop: Off");
        });

        $("#zoom").addEventListener("input", (e) => {
          state.ui.zoom = Number(e.target.value);
          invalidateTimeline();
        });

        $("#snapFrames").addEventListener("click", () => {
          state.ui.snapFrames = !state.ui.snapFrames;
          $("#snapFrames").setAttribute("aria-pressed", String(state.ui.snapFrames));
          toast(state.ui.snapFrames ? "Snap to frames" : "Free timing");
        });
        $("#snapBeats").addEventListener("click", () => {
          state.ui.snapBeats = !state.ui.snapBeats;
          $("#snapBeats").setAttribute("aria-pressed", String(state.ui.snapBeats));
          toast(state.ui.snapBeats ? "Snap to beats" : "Beat snap off");
        });
        $("#autoKey").addEventListener("click", () => {
          state.ui.autoKey = !state.ui.autoKey;
          $("#autoKey").setAttribute("aria-pressed", String(state.ui.autoKey));
          toast(state.ui.autoKey ? "Auto-key on" : "Auto-key off");
        });

        $("#fps").addEventListener("change", (e) => {
          const v = clamp(Number(e.target.value || 30), 1, 240);
          snapshot("fps");
          state.project.fps = v;
          $("#fps").value = String(v);
          invalidateAll();
        });
        $("#duration").addEventListener("change", (e) => {
          const v = clamp(Number(e.target.value || 6), 0.1, 120);
          snapshot("duration");
          state.project.duration = v;
          $("#duration").value = String(v);
          state.ui.time = clamp(state.ui.time, 0, state.project.duration);
          invalidateTimeline();
        });

        $("#btnAddLayer").addEventListener("click", () => {
          snapshot("add layer");
          const l = makeLayer(`Layer ${state.layers.length + 1}`, "NEW TEXT");
          l.motion.preset = "typewriter";
          l.style.fontFamily = "Inter";
          l.style.fontSize = 120;
          l.style.fillB = "#7c5cff";
          l.style.gradAngle = 135;
          l.tracks.y[0].v = 80;
          state.layers.unshift(l);
          state.ui.selectedLayerId = l.id;
          updateAllUI();
          invalidateAll();
          toast("Layer added.", "good");
        });
        $("#btnDupLayer").addEventListener("click", () => {
          snapshot("duplicate layer");
          const src = selectedLayer();
          const dup = deepClone(src);
          dup.id = uid("layer");
          dup.name = src.name + " Copy";
          dup.tracks.x = deepClone(src.tracks.x);
          dup.tracks.y = deepClone(src.tracks.y);
          dup.tracks.y = dup.tracks.y.map((k) => ({ ...k, v: k.v + 60 }));
          state.layers.unshift(dup);
          state.ui.selectedLayerId = dup.id;
          updateAllUI();
          invalidateAll();
          toast("Layer duplicated.", "good");
        });
        $("#btnDelLayer").addEventListener("click", () => {
          if (state.layers.length <= 1) {
            toast("Keep at least one layer.", "info");
            return;
          }
          snapshot("delete layer");
          const idx = state.layers.findIndex((l) => l.id === state.ui.selectedLayerId);
          state.layers.splice(idx, 1);
          state.ui.selectedLayerId = state.layers[Math.max(0, idx - 1)].id;
          state.ui.selectedKey = null;
          updateAllUI();
          invalidateAll();
          toast("Layer deleted.", "good");
        });

        // Text panel
        $("#layerName").addEventListener("input", (e) => {
          selectedLayer().name = e.target.value || "Layer";
          updateLayerList();
        });
        $("#textInput").addEventListener("input", (e) => {
          snapshot("edit text");
          selectedLayer().text = e.target.value;
          invalidateStage();
          updateLayerList();
        });
        $("#fontFamily").addEventListener("change", (e) => {
          snapshot("font family");
          selectedLayer().style.fontFamily = e.target.value;
          invalidateStage();
        });
        $("#fontSize").addEventListener("change", (e) => {
          snapshot("font size");
          selectedLayer().style.fontSize = clamp(Number(e.target.value || 128), 6, 600);
          invalidateStage();
        });
        $("#fontWeight").addEventListener("change", (e) => {
          snapshot("font weight");
          selectedLayer().style.fontWeight = clamp(Number(e.target.value || 600), 100, 900);
          invalidateStage();
        });
        $("#italicToggle").addEventListener("click", () => {
          snapshot("italic");
          const layer = selectedLayer();
          layer.style.italic = !layer.style.italic;
          invalidateStage();
          updateAllUI();
        });
        $("#lineHeight").addEventListener("change", (e) => {
          snapshot("line height");
          selectedLayer().style.lineHeight = clamp(Number(e.target.value || 1.05), 0.7, 3);
          invalidateStage();
        });
        $("#alignLeft").addEventListener("click", () => setAlign("left"));
        $("#alignCenter").addEventListener("click", () => setAlign("center"));
        $("#alignRight").addEventListener("click", () => setAlign("right"));

        function setAlign(align) {
          snapshot("align");
          selectedLayer().style.align = align;
          updateAllUI();
          invalidateStage();
        }

        // Style panel
        $("#fillMode").addEventListener("change", (e) => {
          snapshot("fill mode");
          selectedLayer().style.fillMode = e.target.value;
          invalidateStage();
        });
        $("#bgColor").addEventListener("input", (e) => {
          snapshot("background color");
          state.project.bg.color = e.target.value;
          invalidateStage();
        });
        $("#fillA").addEventListener("input", (e) => {
          snapshot("fill A");
          selectedLayer().style.fillA = e.target.value;
          invalidateStage();
        });
        $("#fillB").addEventListener("input", (e) => {
          snapshot("fill B");
          selectedLayer().style.fillB = e.target.value;
          invalidateStage();
        });
        $("#gradAngle").addEventListener("input", (e) => {
          selectedLayer().style.gradAngle = Number(e.target.value);
          invalidateStage();
        });

        $("#strokeOn").addEventListener("click", () => {
          snapshot("stroke toggle");
          const l = selectedLayer();
          l.style.strokeOn = !l.style.strokeOn;
          updateAllUI();
          invalidateStage();
        });
        $("#strokeWidth").addEventListener("change", (e) => {
          snapshot("stroke width");
          selectedLayer().style.strokeWidth = clamp(Number(e.target.value || 0), 0, 60);
          invalidateStage();
        });
        $("#strokeColor").addEventListener("input", (e) => {
          snapshot("stroke color");
          selectedLayer().style.strokeColor = e.target.value;
          invalidateStage();
        });

        $("#shadowOn").addEventListener("click", () => {
          snapshot("shadow toggle");
          const l = selectedLayer();
          l.style.shadowOn = !l.style.shadowOn;
          updateAllUI();
          invalidateStage();
        });
        $("#shadowBlur").addEventListener("change", (e) => {
          snapshot("shadow blur");
          selectedLayer().style.shadowBlur = clamp(Number(e.target.value || 0), 0, 240);
          invalidateStage();
        });
        $("#shadowColor").addEventListener("input", (e) => {
          snapshot("shadow color");
          selectedLayer().style.shadowColor = e.target.value;
          invalidateStage();
        });
        $("#shadowX").addEventListener("change", (e) => {
          snapshot("shadow offset x");
          selectedLayer().style.shadowX = clamp(Number(e.target.value || 0), -240, 240);
          invalidateStage();
        });
        $("#shadowY").addEventListener("change", (e) => {
          snapshot("shadow offset y");
          selectedLayer().style.shadowY = clamp(Number(e.target.value || 0), -240, 240);
          invalidateStage();
        });

        $("#bgImageBtn").addEventListener("click", () => $("#bgImageFile").click());
        $("#bgImageFile").addEventListener("change", async (e) => {
          const file = e.target.files?.[0];
          if (!file) return;
          const url = await fileToDataURL(file);
          snapshot("background image");
          state.project.bg.imageDataUrl = url;
          state.project.bg.imageBitmap = await loadBitmap(url).catch(() => null);
          $("#bgImageNote").textContent = `Image: ${file.name}`;
          invalidateStage();
        });

        // Motion panel
        $("#preset").addEventListener("change", (e) => {
          snapshot("preset");
          selectedLayer().motion.preset = e.target.value;
          invalidateStage();
        });
        $("#presetApply").addEventListener("click", () => {
          snapshot("apply preset");
          applyPresetToSelected();
          invalidateAll();
          toast("Preset applied (keyframes generated).", "good");
        });
        $("#staggerUnit").addEventListener("change", (e) => {
          snapshot("stagger unit");
          selectedLayer().motion.staggerUnit = e.target.value;
          invalidateStage();
        });
        $("#stagger").addEventListener("change", (e) => {
          snapshot("stagger");
          selectedLayer().motion.staggerMs = clamp(Number(e.target.value || 0), 0, 6000);
          invalidateStage();
        });
        $("#animDur").addEventListener("change", (e) => {
          snapshot("unit duration");
          selectedLayer().motion.unitDurMs = clamp(Number(e.target.value || 500), 10, 12000);
          invalidateStage();
        });
        $("#amplitude").addEventListener("input", (e) => {
          selectedLayer().motion.amplitude = Number(e.target.value);
          invalidateStage();
        });
        $("#motionBlur").addEventListener("click", () => {
          snapshot("motion blur");
          const l = selectedLayer();
          l.motion.motionBlur = !l.motion.motionBlur;
          updateAllUI();
          invalidateStage();
        });
        $("#seed").addEventListener("change", (e) => {
          snapshot("seed");
          selectedLayer().motion.seed = clamp(Number(e.target.value || 0), 0, 999999);
          invalidateStage();
        });

        $("[data-addkf]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const prop = btn.dataset.addkf;
            addKeyAtPlayhead(prop);
          });
        });

        $("#easePreset").addEventListener("change", () => {
          const v = $("#easePreset").value;
          $("#bezierRow").style.display = v === "bezier" ? "" : "none";
        });
        $("#applyEase").addEventListener("click", () => applyEaseToSelected());

        // Layout panel
        $("#aspect").addEventListener("change", (e) => {
          const v = e.target.value;
          const [w, h] = aspectToWH(v, state.project.width, state.project.height);
          if (!w || !h) return;
          snapshot("aspect");
          setResolution(w, h);
          updateAllUI();
          toast(`Aspect set to ${v}.`, "good");
        });
        $("#resPreset").addEventListener("change", (e) => {
          const v = e.target.value;
          if (v === "custom") return;
          const [w, h] = v.split("x").map((n) => Number(n));
          snapshot("resolution preset");
          setResolution(w, h);
          updateAllUI();
          toast(`Resolution set to ${w}×${h}.`, "good");
        });
        $("#width").addEventListener("change", (e) => {
          snapshot("width");
          setResolution(clamp(Number(e.target.value || 1920), 64, 8192), state.project.height);
          updateAllUI();
        });
        $("#height").addEventListener("change", (e) => {
          snapshot("height");
          setResolution(state.project.width, clamp(Number(e.target.value || 1080), 64, 8192));
          updateAllUI();
        });
        $("#margin").addEventListener("input", (e) => {
          state.project.guides.margin = Number(e.target.value);
          layoutOverlays();
        });
        $("#showGrid").addEventListener("click", () => toggleGuide("grid"));
        $("#showSafe").addEventListener("click", () => toggleGuide("safe"));
        $("#showCross").addEventListener("click", () => toggleGuide("cross"));

        function toggleGuide(k) {
          state.project.guides[k] = !state.project.guides[k];
          updateAllUI();
          layoutOverlays();
        }

        $("#btnFit").addEventListener("click", () => fitStage());
        $("#btnScreenshot").addEventListener("click", () => downloadPNGCurrentFrame());

        // Audio panel
        $("#audioLoad").addEventListener("click", () => $("#audioFile").click());
        $("#audioFile").addEventListener("change", async (e) => {
          const f = e.target.files?.[0];
          if (!f) return;
          await loadAudioFile(f);
        });
        $("#audioSnap").addEventListener("click", () => {
          state.ui.snapBeats = !state.ui.snapBeats;
          $("#snapBeats").setAttribute("aria-pressed", String(state.ui.snapBeats));
          $("#audioSnap").setAttribute("aria-pressed", String(state.ui.snapBeats));
          toast(state.ui.snapBeats ? "Beat snapping on" : "Beat snapping off");
        });
        $("#audioReactive").addEventListener("click", () => {
          snapshot("audio reactive");
          state.audio.reactive = !state.audio.reactive;
          $("#audioReactive").setAttribute("aria-pressed", String(state.audio.reactive));
          invalidateStage();
        });
        $("#audioIntensity").addEventListener("input", (e) => {
          state.audio.intensity = Number(e.target.value);
          invalidateStage();
        });
        $("#audioScaleAmt").addEventListener("input", (e) => {
          state.audio.map.scale = Number(e.target.value);
          invalidateStage();
        });
        $("#audioRotAmt").addEventListener("input", (e) => {
          state.audio.map.rot = Number(e.target.value);
          invalidateStage();
        });
        $("#audioTrackAmt").addEventListener("input", (e) => {
          state.audio.map.tracking = Number(e.target.value);
          invalidateStage();
        });
        $("#audioGlitchAmt").addEventListener("input", (e) => {
          state.audio.map.glitch = Number(e.target.value);
          invalidateStage();
        });

        // Inspector
        bindInspector("propX", "x", 1);
        bindInspector("propY", "y", 1);
        bindInspector("propScale", "scale", 0.01);
        bindInspector("propRot", "rot", 0.1);
        bindInspector("propOpacity", "opacity", 0.01);
        bindInspector("propTracking", "tracking", 0.5);
        bindInspector("propLetterOffset", "letterOffset", 1);
        bindInspector("propWordOffset", "wordOffset", 1);

        function bindInspector(inputId, prop, step) {
          const el = $("#" + inputId);
          el.addEventListener("change", (e) => {
            const layer = selectedLayer();
            const t = state.ui.time;
            const raw = Number(e.target.value);
            if (!Number.isFinite(raw)) return;
            snapshot("inspector edit");
            if (state.ui.autoKey) {
              setKeyframe(layer, prop, snapTime(t), raw, true);
            } else {
              // Directly set first keyframe as base if no auto-key
              const kfs = keyframesFor(layer, prop);
              kfs[0].v = raw;
            }
            state.ui.selectedTrack = prop;
            invalidateAll();
          });
          el.addEventListener("input", () => invalidateStage());
          el.step = String(step);
        }

        // Export dialog
        $("#exportNoEffects").addEventListener("click", () => {
          state.export.reduceFx = !state.export.reduceFx;
          $("#exportNoEffects").setAttribute("aria-pressed", String(state.export.reduceFx));
        });
        $("#btnDoExport").addEventListener("click", () => doExport());

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
          const target = e.target;
          const typing = target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable);
          const ctrl = isMac ? e.metaKey : e.ctrlKey;
          if (ctrl && e.key.toLowerCase() === "e") {
            e.preventDefault();
            openExport();
            return;
          }
          if (ctrl && e.key.toLowerCase() === "z") {
            e.preventDefault();
            if (e.shiftKey) redo();
            else undo();
            return;
          }
          if (typing) return;
          if (e.key === " ") {
            e.preventDefault();
            togglePlay();
          } else if (e.key.toLowerCase() === "k") {
            e.preventDefault();
            if (e.shiftKey) {
              snapshot("add all keyframes");
              for (const tr of TRACKS) addKeyAtPlayhead(tr.id, true);
              toast("Keyframes added for all tracks.", "good");
            } else {
              addKeyAtPlayhead(state.ui.selectedTrack);
            }
          } else if (e.key === "Delete" || e.key === "Backspace") {
            e.preventDefault();
            deleteSelectedKeyframe();
          } else if (e.key === "Home") {
            state.ui.time = 0;
            invalidateAll();
          } else if (e.key === "End") {
            state.ui.time = state.project.duration;
            invalidateAll();
          } else if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
            if (!state.ui.selectedKey) return;
            e.preventDefault();
            const dir = e.key === "ArrowLeft" ? -1 : 1;
            nudgeSelectedKeyframe(dir * (e.shiftKey ? 10 : 1));
          }
        });
      }

      function aspectToWH(aspect, w, h) {
        if (aspect === "custom") return [w, h];
        const map = { "16:9": [16, 9], "9:16": [9, 16], "1:1": [1, 1], "4:5": [4, 5] };
        const a = map[aspect];
        if (!a) return [w, h];
        const ratio = a[0] / a[1];
        const ww = w;
        const hh = Math.round(ww / ratio);
        return [ww, hh];
      }

      function setResolution(w, h) {
        state.project.width = Math.round(w);
        state.project.height = Math.round(h);
        stageCanvas.width = state.project.width;
        stageCanvas.height = state.project.height;
        fitStage();
        layoutOverlays();
        invalidateAll();
      }

      function snapTime(t) {
        let tt = clamp(t, 0, state.project.duration);
        if (state.ui.snapFrames) {
          const f = state.project.fps;
          tt = Math.round(tt * f) / f;
        }
        if (state.ui.snapBeats && state.audio.beats?.length) {
          const beats = state.audio.beats;
          const idx = nearestIndex(beats, tt);
          const bt = beats[idx];
          if (Math.abs(bt - tt) < 0.06) tt = bt;
        }
        return tt;
      }

      function nearestIndex(arr, x) {
        let lo = 0;
        let hi = arr.length - 1;
        while (lo < hi) {
          const mid = (lo + hi) >> 1;
          if (arr[mid] < x) lo = mid + 1;
          else hi = mid;
        }
        const i = lo;
        if (i <= 0) return 0;
        if (i >= arr.length) return arr.length - 1;
        const a = arr[i - 1];
        const b = arr[i];
        return Math.abs(a - x) < Math.abs(b - x) ? i - 1 : i;
      }

      function addKeyAtPlayhead(prop, silent = false) {
        const layer = selectedLayer();
        const t = snapTime(state.ui.time);
        const v = getValueAt(layer, prop, t);
        if (!silent) snapshot("add keyframe");
        setKeyframe(layer, prop, t, v, true);
        state.ui.selectedTrack = prop;
        invalidateTimeline();
        if (!silent) toast(`Keyframe added: ${prop} @ ${formatTime(t)}`, "good");
      }

      function nudgeSelectedKeyframe(frames) {
        const layer = selectedLayer();
        const sel = state.ui.selectedKey;
        if (!sel) return;
        const kfs = keyframesFor(layer, sel.prop);
        const kf = kfs[sel.index];
        if (!kf) return;
        snapshot("nudge keyframe");
        const dt = frames / state.project.fps;
        kf.t = snapTime(kf.t + dt);
        sortKeyframes(kfs);
        // Refresh selection index
        const eps = 1 / state.project.fps / 2;
        const idx = kfs.findIndex((x) => Math.abs(x.t - kf.t) <= eps);
        state.ui.selectedKey.index = idx >= 0 ? idx : 0;
        state.ui.time = kf.t;
        invalidateTimeline();
      }

      function applyEaseToSelected() {
        const layer = selectedLayer();
        const sel = state.ui.selectedKey;
        if (!sel) {
          toast("Select a keyframe in the timeline first.", "info");
          return;
        }
        const kfs = keyframesFor(layer, sel.prop);
        const kf = kfs[sel.index];
        if (!kf) return;
        snapshot("apply easing");
        const preset = $("#easePreset").value;
        if (preset === "bezier") {
          const p1x = clamp(Number($("#bz1x").value || 0.33), 0, 1);
          const p1y = clamp(Number($("#bz1y").value || 0.0), -2, 2);
          const p2x = clamp(Number($("#bz2x").value || 0.67), 0, 1);
          const p2y = clamp(Number($("#bz2y").value || 1.0), -2, 2);
          kf.ease = { type: "bezier", p1x, p1y, p2x, p2y };
        } else if (preset === "steps") {
          kf.ease = { type: "preset", name: "steps", steps: 12 };
        } else {
          kf.ease = { type: "preset", name: preset };
        }
        invalidateTimeline();
        toast("Easing applied.", "good");
      }

      // ---- PRESETS / GENERATORS ----
      function applyPresetToSelected() {
        const layer = selectedLayer();
        const dur = state.project.duration;
        const preset = layer.motion.preset;
        const base = {
          x: 0,
          y: 0,
          scale: 1,
          rot: 0,
          opacity: 1,
          tracking: 0,
          letterOffset: 0,
          wordOffset: 0,
        };
        for (const t of TRACKS) layer.tracks[t.id] = defaultKeyframes(base[t.id]);
        state.ui.selectedKey = null;

        const k = (prop, time, value, easeName = "easeInOut") => {
          const kfs = keyframesFor(layer, prop);
          kfs.push({ t: time, v: value, ease: { type: "preset", name: easeName } });
          sortKeyframes(kfs);
        };

        if (preset === "fadeUp") {
          layer.tracks.opacity = [{ t: 0, v: 0, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(0.8, dur * 0.25), v: 1, ease: { type: "preset", name: "easeOut" } }];
          layer.tracks.y = [{ t: 0, v: 90, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(0.9, dur * 0.25), v: 0, ease: { type: "preset", name: "easeOut" } }];
          layer.tracks.tracking = [{ t: 0, v: 12, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(1.2, dur * 0.35), v: 0, ease: { type: "preset", name: "easeOut" } }];
        } else if (preset === "typewriter") {
          layer.tracks.opacity = [{ t: 0, v: 1, ease: { type: "preset", name: "linear" } }];
          layer.tracks.tracking = [{ t: 0, v: 0, ease: { type: "preset", name: "linear" } }];
        } else if (preset === "bounce") {
          layer.tracks.opacity = [{ t: 0, v: 0, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(0.45, dur * 0.15), v: 1, ease: { type: "preset", name: "easeOut" } }];
          k("y", 0, 140, "easeOut");
          k("y", Math.min(0.6, dur * 0.18), -20, "bounce");
          k("y", Math.min(1.0, dur * 0.28), 0, "bounce");
          layer.tracks.scale = [{ t: 0, v: 0.95, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(0.6, dur * 0.2), v: 1.0, ease: { type: "preset", name: "bounce" } }];
        } else if (preset === "cascade") {
          layer.tracks.opacity = [{ t: 0, v: 1, ease: { type: "preset", name: "linear" } }];
          layer.tracks.y = [{ t: 0, v: 40, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(1.0, dur * 0.25), v: 0, ease: { type: "preset", name: "easeOut" } }];
        } else if (preset === "liquid") {
          layer.tracks.opacity = [{ t: 0, v: 0, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(0.8, dur * 0.2), v: 1, ease: { type: "preset", name: "easeOut" } }];
          layer.tracks.letterOffset = [{ t: 0, v: 0, ease: { type: "preset", name: "linear" } }, { t: Math.min(1.0, dur * 0.25), v: 16, ease: { type: "preset", name: "easeInOut" } }];
        } else if (preset === "glitch") {
          layer.tracks.opacity = [{ t: 0, v: 0, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(0.7, dur * 0.2), v: 1, ease: { type: "preset", name: "easeOut" } }];
          layer.tracks.rot = [{ t: 0, v: -2.5, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(0.9, dur * 0.22), v: 0, ease: { type: "preset", name: "elastic" } }];
          layer.tracks.tracking = [{ t: 0, v: 20, ease: { type: "preset", name: "easeOut" } }, { t: Math.min(1.2, dur * 0.3), v: 0, ease: { type: "preset", name: "easeOut" } }];
        } else if (preset === "none") {
          // keep defaults
        }
      }

      // ---- AUDIO ----
      async function ensureAudioContext() {
        if (state.audio.ctx) return state.audio.ctx;
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const gain = ctx.createGain();
        gain.gain.value = 0.9;
        gain.connect(ctx.destination);
        state.audio.ctx = ctx;
        state.audio.gain = gain;
        return ctx;
      }

      async function loadAudioFile(file) {
        toast("Loading audio…");
        $("#audioNote").textContent = `Loading: ${file.name}`;
        const buf = await file.arrayBuffer();
        const ctx = await ensureAudioContext();
        const audioBuffer = await ctx.decodeAudioData(buf.slice(0));
        snapshot("load audio");
        state.audio.buffer = audioBuffer;
        state.audio.fileName = file.name;
        $("#audioNote").textContent = `Audio: ${file.name}`;
        const analysis = analyzeAudio(audioBuffer);
        state.audio.bpm = analysis.bpm;
        state.audio.beats = analysis.beats;
        state.audio.bars = analysis.bars || [];
        state.audio.rms = analysis.rms;
        $("#audioStats").textContent = `BPM: ${analysis.bpm ? analysis.bpm.toFixed(1) : "—"} • Beats: ${analysis.beats.length || "—"}`;
        invalidateTimeline();
        toast("Audio analyzed. Beat snap ready.", "good");
      }

      function analyzeAudio(audioBuffer) {
        const sampleRate = audioBuffer.sampleRate;
        const ch0 = audioBuffer.getChannelData(0);
        const ch1 = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : null;
        const N = ch0.length;
        const mono = new Float32Array(N);
        for (let i = 0; i < N; i++) mono[i] = ch1 ? (ch0[i] + ch1[i]) * 0.5 : ch0[i];

        const win = 1024;
        const hop = 512;
        const values = new Float32Array(Math.ceil((N - win) / hop));
        for (let i = 0, o = 0; i + win < N && o < values.length; i += hop, o++) {
          let sum = 0;
          for (let j = 0; j < win; j++) {
            const v = mono[i + j];
            sum += v * v;
          }
          values[o] = Math.sqrt(sum / win);
        }

        // Smooth
        const smooth = new Float32Array(values.length);
        const radius = 8;
        for (let i = 0; i < values.length; i++) {
          let acc = 0;
          let cnt = 0;
          for (let k = -radius; k <= radius; k++) {
            const j = i + k;
            if (j < 0 || j >= values.length) continue;
            acc += values[j];
            cnt++;
          }
          smooth[i] = acc / Math.max(1, cnt);
        }

        // Peak picking
        const beats = [];
        let lastBeat = -1e9;
        const minGapSec = 0.22;
        for (let i = 2; i < smooth.length - 2; i++) {
          const v = smooth[i];
          if (v < smooth[i - 1] || v < smooth[i + 1]) continue;
          // adaptive threshold from local mean
          let local = 0;
          let n = 0;
          for (let k = -24; k <= 24; k++) {
            const j = i + k;
            if (j < 0 || j >= smooth.length) continue;
            local += smooth[j];
            n++;
          }
          const mean = local / Math.max(1, n);
          const thr = mean * 1.35;
          if (v > thr) {
            const t = (i * hop) / sampleRate;
            if (t - lastBeat >= minGapSec) {
              beats.push(t);
              lastBeat = t;
            }
          }
        }

        // BPM estimation via median interval (robust)
        let bpm = null;
        if (beats.length >= 6) {
          const intervals = [];
          for (let i = 1; i < beats.length; i++) {
            const d = beats[i] - beats[i - 1];
            if (d > 0.2 && d < 2.0) intervals.push(d);
          }
          if (intervals.length) {
            intervals.sort((a, b) => a - b);
            const med = intervals[Math.floor(intervals.length / 2)];
            bpm = 60 / med;
            // Normalize to common range (60-180)
            while (bpm < 60) bpm *= 2;
            while (bpm > 180) bpm /= 2;
          }
        }

        const bars = beats.filter((_, i) => i % 4 === 0);
        return { bpm, beats, bars, rms: { sampleRate, hopSec: hop / sampleRate, values: smooth } };
      }

      function rmsAtTime(t) {
        if (!state.audio.rms) return 0;
        const { hopSec, values } = state.audio.rms;
        const idx = clamp(Math.floor(t / hopSec), 0, values.length - 1);
        // Normalize roughly
        const v = values[idx];
        const norm = clamp(v * 2.2, 0, 1);
        return norm;
      }

      function playAudioFrom(offset) {
        if (!state.audio.buffer) return;
        ensureAudioContext().then((ctx) => {
          if (ctx.state === "suspended") ctx.resume();
          stopAudio();
          const src = ctx.createBufferSource();
          src.buffer = state.audio.buffer;
          src.connect(state.audio.gain);
          state.audio.source = src;
          state.audio.offset = offset;
          state.audio.startCtxTime = ctx.currentTime;
          try {
            src.start(0, offset);
          } catch {
            // ignore
          }
        });
      }
      function stopAudio() {
        try {
          state.audio.source?.stop();
        } catch {}
        state.audio.source = null;
      }

      // ---- RENDERING ----
      const layoutCache = new Map();
      function layerFontCSS(layer) {
        const st = layer.style;
        const ital = st.italic ? "italic" : "normal";
        const weight = st.fontWeight;
        const size = st.fontSize;
        const family = st.fontFamily.includes(" ") ? `"${st.fontFamily}"` : st.fontFamily;
        return `${ital} ${weight} ${size}px ${family}`;
      }
      function layoutKey(layer, tracking) {
        const st = layer.style;
        return [
          st.fontFamily,
          st.fontSize,
          st.fontWeight,
          st.italic ? 1 : 0,
          st.align,
          st.lineHeight,
          tracking.toFixed(2),
          layer.text,
        ].join("|");
      }

      function segmentGraphemes(str) {
        if (window.Intl?.Segmenter) {
          const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
          return Array.from(seg.segment(str), (s) => s.segment);
        }
        return Array.from(str);
      }

      function layoutText(layer, trackingPx) {
        const key = layoutKey(layer, trackingPx);
        const cached = layoutCache.get(key);
        if (cached) return cached;

        const ctx = stageCtx;
        ctx.save();
        ctx.font = layerFontCSS(layer);
        ctx.textBaseline = "alphabetic";
        ctx.textAlign = "left";

        const lines = (layer.text || "").split("\\n");
        const glyphs = [];
        let maxWidth = 0;
        let totalHeight = 0;

        const metricsProbe = ctx.measureText("Hg");
        const ascentDefault = metricsProbe.actualBoundingBoxAscent || layer.style.fontSize * 0.78;
        const descentDefault = metricsProbe.actualBoundingBoxDescent || layer.style.fontSize * 0.22;
        const lineH = layer.style.fontSize * layer.style.lineHeight;

        const lineInfos = [];
        let globalIndex = 0;
        let wordCounter = 0;
        for (let li = 0; li < lines.length; li++) {
          const line = lines[li];
          const words = line.split(/(\\s+)/).filter((w) => w.length > 0);
          let x = 0;
          let lineGlyphs = [];
          for (const w of words) {
            const isSpace = /^\\s+$/.test(w);
            if (isSpace) {
              const m = ctx.measureText(w);
              x += m.width;
              continue;
            }
            const g = segmentGraphemes(w);
            const wordIndex = wordCounter++;
            for (let gi = 0; gi < g.length; gi++) {
              const ch = g[gi];
              const m = ctx.measureText(ch);
              const ascent = m.actualBoundingBoxAscent || ascentDefault;
              const descent = m.actualBoundingBoxDescent || descentDefault;
              const wpx = m.width;
              const glyph = {
                ch,
                lineIndex: li,
                wordIndex,
                glyphIndex: globalIndex++,
                xLeft: x,
                width: wpx,
                ascent,
                descent,
              };
              lineGlyphs.push(glyph);
              x += wpx + trackingPx;
            }
            // add word gap (single space)
            const sp = ctx.measureText(" ").width;
            x += sp;
          }
          const lineWidth = lineGlyphs.length ? lineGlyphs[lineGlyphs.length - 1].xLeft + lineGlyphs[lineGlyphs.length - 1].width : 0;
          maxWidth = Math.max(maxWidth, lineWidth);
          lineInfos.push({ glyphs: lineGlyphs, width: lineWidth });
          totalHeight = (li + 1) * lineH;
        }

        const blockTop = -totalHeight / 2 + ascentDefault;
        for (let li = 0; li < lineInfos.length; li++) {
          const info = lineInfos[li];
          let baseX = -info.width / 2;
          if (layer.style.align === "left") baseX = -maxWidth / 2;
          if (layer.style.align === "right") baseX = maxWidth / 2 - info.width;
          const baselineY = blockTop + li * lineH;
          for (const g of info.glyphs) {
            const centerY = (g.descent - g.ascent) / 2;
            glyphs.push({
              ...g,
              x: baseX + g.xLeft + g.width / 2,
              baselineY,
              centerY,
            });
          }
        }

        // BBox in layer local coords
        let minX = Infinity,
          maxX2 = -Infinity,
          minY = Infinity,
          maxY = -Infinity;
        for (const g of glyphs) {
          minX = Math.min(minX, g.x - g.width / 2);
          maxX2 = Math.max(maxX2, g.x + g.width / 2);
          minY = Math.min(minY, g.baselineY - g.ascent);
          maxY = Math.max(maxY, g.baselineY + g.descent);
        }
        if (!glyphs.length) {
          minX = -10;
          maxX2 = 10;
          minY = -10;
          maxY = 10;
        }

        const out = { glyphs, bbox: { minX, maxX: maxX2, minY, maxY } };
        layoutCache.set(key, out);
        ctx.restore();
        return out;
      }

      function computeCascadeOrder(glyphs, unit) {
        if (unit === "letter") return glyphs.map((g, i) => ({ id: i, key: g.glyphIndex }));
        if (unit === "word") return glyphs.map((g, i) => ({ id: i, key: g.wordIndex }));
        if (unit === "line") return glyphs.map((g, i) => ({ id: i, key: g.lineIndex }));
        return glyphs.map((g, i) => ({ id: i, key: g.glyphIndex }));
      }

      function renderLayer(ctx, layer, t, opts) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        const cx = width / 2;
        const cy = height / 2;

        const x = getValueAt(layer, "x", t);
        const y = getValueAt(layer, "y", t);
        let scale = getValueAt(layer, "scale", t);
        let rot = deg2rad(getValueAt(layer, "rot", t));
        let opacity = clamp(getValueAt(layer, "opacity", t), 0, 1);
        let tracking = getValueAt(layer, "tracking", t);
        const letterOffset = getValueAt(layer, "letterOffset", t);
        const wordOffset = getValueAt(layer, "wordOffset", t);

        const audioV = state.audio.reactive ? Math.pow(rmsAtTime(t) * state.audio.intensity, 1.25) : 0;
        if (audioV > 0) {
          scale *= 1 + audioV * state.audio.map.scale;
          rot += audioV * state.audio.map.rot * 0.22;
          tracking += audioV * state.audio.map.tracking;
        }

        const st = layer.style;
        const motion = layer.motion;
        const reducedFx = opts.reduceFx || prefersReducedMotion;
        const rng = seeded((opts.seed ?? Math.floor(t * state.project.fps)) + (motion.seed || 0));

        const { glyphs, bbox } = layoutText(layer, tracking);
        const cascade = computeCascadeOrder(glyphs, motion.staggerUnit);
        const uniqueCount = new Set(cascade.map((c) => c.key)).size || 1;
        const unitDur = motion.unitDurMs / 1000;
        const stagger = motion.staggerMs / 1000;
        const amp = motion.amplitude * (reducedFx ? 0.65 : 1);

        ctx.save();
        ctx.translate(cx + x, cy + y);
        ctx.rotate(rot);
        ctx.scale(scale, scale);

        // Fill style
        ctx.font = layerFontCSS(layer);
        ctx.textAlign = "left";
        ctx.textBaseline = "alphabetic";
        let fillStyle = st.fillA;
        if (st.fillMode === "gradient") {
          const ang = deg2rad(st.gradAngle);
          const dx = Math.cos(ang);
          const dy = Math.sin(ang);
          const len = Math.max(60, Math.hypot(bbox.maxX - bbox.minX, bbox.maxY - bbox.minY));
          const mx = (bbox.minX + bbox.maxX) / 2;
          const my = (bbox.minY + bbox.maxY) / 2;
          const g = ctx.createLinearGradient(mx - dx * len * 0.5, my - dy * len * 0.5, mx + dx * len * 0.5, my + dy * len * 0.5);
          g.addColorStop(0, st.fillA);
          g.addColorStop(1, st.fillB);
          fillStyle = g;
        }

        // Shadow
        if (st.shadowOn && !reducedFx) {
          ctx.shadowColor = st.shadowColor;
          ctx.shadowBlur = st.shadowBlur;
          ctx.shadowOffsetX = st.shadowX;
          ctx.shadowOffsetY = st.shadowY;
        } else {
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }

        // Glitch parameters
        const glitchDrive = (motion.preset === "glitch" ? 1 : 0) + (audioV > 0 ? audioV * state.audio.map.glitch : 0);
        const glitch = !reducedFx && glitchDrive > 0.02;
        const glitchProb = clamp(0.06 + glitchDrive * 0.18, 0, 0.36);

        const nowFrame = Math.round(t * state.project.fps);
        const glitchGate = glitch && ((nowFrame + (motion.seed || 0)) % 12 === 0 || rng() < glitchProb);
        const rgbSplit = glitchGate ? clamp(2 + glitchDrive * 10, 0, 16) : 0;

        const baseAlpha = opacity;
        const preset = motion.preset;
        const orderKeys = Array.from(new Set(cascade.map((c) => c.key))).sort((a, b) => a - b);
        const keyToIndex = new Map(orderKeys.map((k, i) => [k, i]));

        function unitIndexForGlyph(i) {
          const k = cascade[i]?.key ?? i;
          return keyToIndex.get(k) ?? 0;
        }

        // Render glyphs
        for (let i = 0; i < glyphs.length; i++) {
          const g = glyphs[i];
          const ui = unitIndexForGlyph(i);
          const offset = ui * stagger;
          const local = clamp((t - offset) / Math.max(1e-6, unitDur), 0, 1);
          let a = baseAlpha;
          let ox = 0,
            oy = 0,
            s = 1,
            r = 0;

          // Keyframed offsets (per-group)
          const letterJitter = letterOffset ? (i % 2 === 0 ? 1 : -1) * letterOffset : 0;
          const wordJitter = wordOffset ? ((ui % 2 === 0 ? 1 : -1) * wordOffset) : 0;

          if (preset === "typewriter") {
            const reveal = clamp((t - ui * stagger) / Math.max(1e-6, unitDur), 0, 1);
            a *= reveal < 1 ? (reveal < 0.02 ? 0 : 1) : 1;
            // subtle caret-like flicker on current unit
            if (!reducedFx) {
              const caretOn = Math.abs(reveal - 0.5) < 0.18 && (Math.floor(t * 12) % 2 === 0);
              if (caretOn) a *= 0.86;
            }
          } else if (preset === "fadeUp") {
            const e = EASE.easeOut(local);
            a *= e;
            oy += (1 - e) * (amp * 0.9);
            ox += letterJitter * (1 - e) * 0.7;
          } else if (preset === "bounce") {
            const e = EASE.bounce(local);
            a *= clamp(local * 1.6, 0, 1);
            oy += (1 - e) * amp;
            s *= 0.96 + 0.07 * e;
          } else if (preset === "cascade") {
            const e = EASE.easeOut(local);
            a *= e;
            oy += (1 - e) * (amp * 0.8);
            ox += (Math.sin((ui + i) * 0.8) * 0.5) * (1 - e) * (amp * 0.12);
          } else if (preset === "liquid") {
            const w = Math.sin(t * 3.2 + ui * 0.55) * amp * 0.18;
            const w2 = Math.cos(t * 2.1 + i * 0.33) * amp * 0.12;
            oy += w + letterJitter * 0.25;
            ox += w2 + wordJitter * 0.15;
            r += Math.sin(t * 2.4 + ui * 0.6) * 0.08 * (reducedFx ? 0.6 : 1);
            s *= 1 + Math.sin(t * 3.1 + i * 0.45) * 0.02;
          } else if (preset === "glitch") {
            a *= 1;
            if (glitchGate) {
              ox += (rng() - 0.5) * (amp * 0.9) * (0.4 + glitchDrive);
              oy += (rng() - 0.5) * (amp * 0.25) * (0.4 + glitchDrive);
              r += (rng() - 0.5) * 0.08 * (0.4 + glitchDrive);
              s *= 1 + (rng() - 0.5) * 0.06 * (0.4 + glitchDrive);
              a *= 0.92;
            } else if (!reducedFx && rng() < 0.04) {
              a *= 0.75;
            }
          } else {
            // none
          }

          // Generic offsets
          if (letterOffset) oy += letterJitter * 0.35;
          if (wordOffset) ox += wordJitter * 0.25;

          // Audio micro-bounce for readability
          if (audioV > 0.01) {
            oy += -audioV * 10 * Math.sin(t * 9.5 + ui * 0.7);
          }

          // Skip drawing if transparent
          if (a <= 0.001) continue;

          const drawGlyph = (dx, colorOverride = null, alphaMul = 1) => {
            ctx.save();
            ctx.globalAlpha = a * alphaMul;
            ctx.translate(g.x + ox + dx, g.baselineY + oy + g.centerY);
            ctx.rotate(r);
            ctx.scale(s, s);
            ctx.translate(-g.width / 2, -g.centerY);
            ctx.fillStyle = colorOverride || fillStyle;
            if (st.strokeOn) {
              ctx.lineJoin = "round";
              ctx.miterLimit = 2;
              ctx.lineWidth = st.strokeWidth;
              ctx.strokeStyle = st.strokeColor;
              ctx.strokeText(g.ch, 0, 0);
            }
            ctx.fillText(g.ch, 0, 0);
            ctx.restore();
          };

          if (rgbSplit > 0) {
            // RGB split: 3 passes.
            drawGlyph(-rgbSplit, "rgba(41,211,255,0.9)", 0.72);
            drawGlyph(rgbSplit, "rgba(255,77,125,0.82)", 0.66);
            drawGlyph(0, null, 0.96);
          } else {
            drawGlyph(0);
          }
        }

        // Scanline overlay for glitch (within layer bounds)
        if (glitchGate) {
          const lines = reducedFx ? 2 : 4;
          ctx.save();
          ctx.globalAlpha = 0.14 + clamp(glitchDrive, 0, 1) * 0.18;
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          for (let i = 0; i < lines; i++) {
            const y = lerp(bbox.minY, bbox.maxY, rng());
            ctx.fillRect(bbox.minX, y, bbox.maxX - bbox.minX, 2);
          }
          ctx.restore();
        }

        ctx.restore();
      }

      function renderFrame(ctx, t, opts = {}) {
        const w = ctx.canvas.width;
        const h = ctx.canvas.height;

        // Background
        ctx.save();
        ctx.globalCompositeOperation = "source-over";
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = state.project.bg.color;
        ctx.fillRect(0, 0, w, h);
        if (state.project.bg.imageBitmap) {
          const img = state.project.bg.imageBitmap;
          const scale = Math.max(w / img.width, h / img.height);
          const dw = img.width * scale;
          const dh = img.height * scale;
          const dx = (w - dw) / 2;
          const dy = (h - dh) / 2;
          ctx.globalAlpha = 1;
          ctx.drawImage(img, dx, dy, dw, dh);
          // subtle darken for contrast
          ctx.fillStyle = "rgba(0,0,0,0.28)";
          ctx.fillRect(0, 0, w, h);
        }
        ctx.restore();

        // Layers (top-down)
        for (let i = state.layers.length - 1; i >= 0; i--) {
          const layer = state.layers[i];
          renderLayer(ctx, layer, t, opts);
        }
      }

      // ---- STAGE VIEWPORT ----
      function fitStage() {
        const wrap = stageShell.getBoundingClientRect();
        const pad = 14;
        const availW = wrap.width - pad * 2;
        const availH = wrap.height - pad * 2;
        const s = Math.min(availW / state.project.width, availH / state.project.height);
        state.ui.stageFit = s;
        state.ui.stageZoom = 1;
        state.ui.stagePanX = 0;
        state.ui.stagePanY = 0;
        layoutStageShell();
        invalidateStage();
        toast("Stage fit.", "good");
      }

      function layoutStageShell() {
        const s = state.ui.stageFit * state.ui.stageZoom;
        stageCanvas.style.width = `${Math.round(state.project.width * s)}px`;
        stageCanvas.style.height = `${Math.round(state.project.height * s)}px`;
        stageShell.style.transform = `translate(${state.ui.stagePanX}px, ${state.ui.stagePanY}px)`;
        $("#stageMeta").textContent = `${state.project.width}×${state.project.height} @ ${state.project.fps}fps`;
      }

      function layoutOverlays() {
        const s = state.ui.stageFit * state.ui.stageZoom;
        const w = Math.round(state.project.width * s);
        const h = Math.round(state.project.height * s);
        $("#gridOverlay").style.display = state.project.guides.grid ? "" : "none";
        $("#safeOverlay").style.display = state.project.guides.safe ? "" : "none";
        $("#crossOverlay").style.display = state.project.guides.cross ? "" : "none";
        $("#gridOverlay").style.width = w + "px";
        $("#gridOverlay").style.height = h + "px";
        const m = state.project.guides.margin;
        const safe = $("#safeOverlay");
        safe.style.left = `${Math.round(w * m)}px`;
        safe.style.top = `${Math.round(h * m)}px`;
        safe.style.width = `${Math.round(w * (1 - 2 * m))}px`;
        safe.style.height = `${Math.round(h * (1 - 2 * m))}px`;
      }

      // ---- TIMELINE ----
      const TL = {
        dpr: Math.max(1, Math.min(2.5, window.devicePixelRatio || 1)),
        headerH: 26,
        rowH: 24,
        labelW: 118,
        padR: 10,
      };

      function layoutTimelineCanvas() {
        const rect = timelineCanvas.getBoundingClientRect();
        const dpr = TL.dpr;
        timelineCanvas.width = Math.max(1, Math.floor(rect.width * dpr));
        timelineCanvas.height = Math.max(1, Math.floor(rect.height * dpr));
        tlCtx.setTransform(1, 0, 0, 1, 0, 0);
        tlCtx.scale(dpr, dpr);
        invalidateTimeline();
      }

      function timeToX(t) {
        return TL.labelW + (t - state.ui.scroll) * state.ui.zoom;
      }
      function xToTime(x) {
        return (x - TL.labelW) / state.ui.zoom + state.ui.scroll;
      }

      function drawTimeline() {
        const ctx = tlCtx;
        const rect = timelineCanvas.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;
        ctx.clearRect(0, 0, w, h);

        // Background
        ctx.fillStyle = "rgba(0,0,0,0.12)";
        ctx.fillRect(0, 0, w, h);

        // Header
        ctx.fillStyle = "rgba(255,255,255,0.05)";
        ctx.fillRect(0, 0, w, TL.headerH);
        ctx.strokeStyle = "rgba(255,255,255,0.09)";
        ctx.beginPath();
        ctx.moveTo(0, TL.headerH + 0.5);
        ctx.lineTo(w, TL.headerH + 0.5);
        ctx.stroke();

        // Label column
        ctx.fillStyle = "rgba(0,0,0,0.18)";
        ctx.fillRect(0, 0, TL.labelW, h);
        ctx.strokeStyle = "rgba(255,255,255,0.09)";
        ctx.beginPath();
        ctx.moveTo(TL.labelW + 0.5, 0);
        ctx.lineTo(TL.labelW + 0.5, h);
        ctx.stroke();

        // Time grid + ruler
        const dur = state.project.duration;
        const pxPerSec = state.ui.zoom;
        const major = pxPerSec > 200 ? 0.25 : pxPerSec > 120 ? 0.5 : 1;
        const minor = major / 5;

        const start = Math.max(0, state.ui.scroll);
        const end = Math.min(dur, state.ui.scroll + (w - TL.labelW) / pxPerSec);

        // Bars / beats
        if (state.audio.bars?.length) {
          ctx.save();
          ctx.strokeStyle = "rgba(46,229,157,0.25)";
          ctx.lineWidth = 1.5;
          for (const bt of state.audio.bars) {
            if (bt < start || bt > end) continue;
            const x = timeToX(bt);
            ctx.beginPath();
            ctx.moveTo(x, TL.headerH);
            ctx.lineTo(x, h);
            ctx.stroke();
          }
          ctx.restore();
        }
        if (state.audio.beats?.length) {
          ctx.save();
          ctx.strokeStyle = "rgba(46,229,157,0.14)";
          ctx.lineWidth = 1;
          for (const bt of state.audio.beats) {
            if (bt < start || bt > end) continue;
            const x = timeToX(bt);
            ctx.beginPath();
            ctx.moveTo(x, TL.headerH);
            ctx.lineTo(x, h);
            ctx.stroke();
          }
          ctx.restore();
        }

        // Minor grid lines
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.06)";
        ctx.lineWidth = 1;
        const firstMinor = Math.floor(start / minor) * minor;
        for (let t = firstMinor; t <= end + minor; t += minor) {
          const x = timeToX(t);
          ctx.beginPath();
          ctx.moveTo(x, TL.headerH);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
        ctx.restore();

        // Major grid lines + labels
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.fillStyle = "rgba(255,255,255,0.72)";
        ctx.font = `11px ${getComputedStyle(document.documentElement).getPropertyValue("--mono")}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const firstMajor = Math.floor(start / major) * major;
        for (let t = firstMajor; t <= end + major; t += major) {
          const x = timeToX(t);
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
          if (Math.abs((t / major) % 2) < 1e-6 || major >= 1) {
            ctx.fillText(formatTime(t), x, TL.headerH / 2);
          }
        }
        ctx.restore();

        // Rows
        const layer = selectedLayer();
        ctx.save();
        ctx.font = `12px ${getComputedStyle(document.documentElement).fontFamily}`;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        for (let i = 0; i < TRACKS.length; i++) {
          const y = TL.headerH + i * TL.rowH;
          // Row fill
          ctx.fillStyle = i % 2 === 0 ? "rgba(255,255,255,0.03)" : "rgba(0,0,0,0.12)";
          ctx.fillRect(0, y, w, TL.rowH);
          // Label
          const tr = TRACKS[i];
          const active = state.ui.selectedTrack === tr.id;
          ctx.fillStyle = active ? "rgba(41,211,255,0.92)" : "rgba(255,255,255,0.78)";
          ctx.fillText(tr.label, 12, y + TL.rowH / 2);
          // Mini add key button icon
          ctx.save();
          ctx.globalAlpha = active ? 0.95 : 0.55;
          ctx.strokeStyle = active ? "rgba(41,211,255,0.7)" : "rgba(255,255,255,0.25)";
          ctx.beginPath();
          const cx = TL.labelW - 18;
          const cy = y + TL.rowH / 2;
          ctx.arc(cx, cy, 7, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - 3.5, cy);
          ctx.lineTo(cx + 3.5, cy);
          ctx.moveTo(cx, cy - 3.5);
          ctx.lineTo(cx, cy + 3.5);
          ctx.stroke();
          ctx.restore();

          // Keyframes
          const kfs = keyframesFor(layer, tr.id);
          sortKeyframes(kfs);
          for (let ki = 0; ki < kfs.length; ki++) {
            const kf = kfs[ki];
            const x = timeToX(kf.t);
            const cy2 = y + TL.rowH / 2;
            const sel = state.ui.selectedKey && state.ui.selectedKey.prop === tr.id && state.ui.selectedKey.index === ki;
            drawDiamond(ctx, x, cy2, sel ? 7 : 6, sel ? "rgba(41,211,255,0.95)" : "rgba(255,255,255,0.72)", sel ? "rgba(0,0,0,0.55)" : "rgba(0,0,0,0.35)");
          }
        }
        ctx.restore();

        // Playhead
        const phx = timeToX(state.ui.time);
        ctx.save();
        ctx.strokeStyle = "rgba(124,92,255,0.92)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(phx, 0);
        ctx.lineTo(phx, h);
        ctx.stroke();
        // Top handle
        ctx.fillStyle = "rgba(124,92,255,0.92)";
        ctx.beginPath();
        ctx.moveTo(phx - 7, 0);
        ctx.lineTo(phx + 7, 0);
        ctx.lineTo(phx, 12);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawDiamond(ctx, x, y, r, fill, shadow) {
        ctx.save();
        ctx.fillStyle = fill;
        ctx.shadowColor = shadow;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(x, y - r);
        ctx.lineTo(x + r, y);
        ctx.lineTo(x, y + r);
        ctx.lineTo(x - r, y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function timelineHitTest(px, py) {
        const rect = timelineCanvas.getBoundingClientRect();
        const x = px - rect.left;
        const y = py - rect.top;
        const laneIndex = Math.floor((y - TL.headerH) / TL.rowH);
        if (laneIndex < 0) return { kind: "ruler", x, y };
        if (laneIndex >= TRACKS.length) return { kind: "empty", x, y };
        const tr = TRACKS[laneIndex];
        // Add button in label column
        const addCx = TL.labelW - 18;
        const addCy = TL.headerH + laneIndex * TL.rowH + TL.rowH / 2;
        if (Math.hypot(x - addCx, y - addCy) < 10) return { kind: "add", prop: tr.id, laneIndex, x, y };

        const layer = selectedLayer();
        const kfs = keyframesFor(layer, tr.id);
        sortKeyframes(kfs);
        for (let i = 0; i < kfs.length; i++) {
          const kf = kfs[i];
          const kx = timeToX(kf.t);
          const ky = TL.headerH + laneIndex * TL.rowH + TL.rowH / 2;
          if (Math.abs(x - kx) < 9 && Math.abs(y - ky) < 9) return { kind: "key", prop: tr.id, index: i, x, y };
        }
        if (x < TL.labelW) return { kind: "selectTrack", prop: tr.id, laneIndex, x, y };
        return { kind: "lane", prop: tr.id, laneIndex, time: xToTime(x), x, y };
      }

      function initTimelineInteraction() {
        let lastTap = { t: 0, x: 0, y: 0 };
        let scrubRestartAt = 0;
        timelineCanvas.addEventListener("pointerdown", (e) => {
          timelineCanvas.setPointerCapture(e.pointerId);
          const hit = timelineHitTest(e.clientX, e.clientY);
          state.ui.dragging = null;
          if (hit.kind === "add") {
            addKeyAtPlayhead(hit.prop);
            return;
          }
          if (hit.kind === "selectTrack") {
            state.ui.selectedTrack = hit.prop;
            state.ui.selectedKey = null;
            updateAllUI();
            invalidateTimeline();
            return;
          }
          if (hit.kind === "key") {
            state.ui.selectedTrack = hit.prop;
            state.ui.selectedKey = { prop: hit.prop, index: hit.index };
            state.ui.dragging = { kind: "key", prop: hit.prop, index: hit.index, startX: hit.x, startT: state.ui.time, startKfT: keyframesFor(selectedLayer(), hit.prop)[hit.index].t };
            updateAllUI();
            invalidateTimeline();
            return;
          }
          // Drag playhead
          const t = snapTime(xToTime(hit.x));
          state.ui.time = t;
          state.ui.selectedTrack = hit.kind === "lane" ? hit.prop : state.ui.selectedTrack;
          state.ui.dragging = { kind: "playhead" };
          invalidateAll();

          // Double-tap/double-click to add keyframe
          const now = performance.now();
          if (now - lastTap.t < 320 && Math.hypot(hit.x - lastTap.x, hit.y - lastTap.y) < 16 && hit.kind === "lane") {
            snapshot("double click add keyframe");
            const layer = selectedLayer();
            const tt = snapTime(xToTime(hit.x));
            const v = getValueAt(layer, hit.prop, tt);
            setKeyframe(layer, hit.prop, tt, v, true);
            state.ui.selectedTrack = hit.prop;
            invalidateTimeline();
            toast(`Keyframe: ${hit.prop} @ ${formatTime(tt)}`, "good");
          }
          lastTap = { t: now, x: hit.x, y: hit.y };
        });

        timelineCanvas.addEventListener("pointermove", (e) => {
          if (!state.ui.dragging) return;
          const hit = timelineHitTest(e.clientX, e.clientY);
          if (state.ui.dragging.kind === "playhead") {
            state.ui.time = snapTime(xToTime(hit.x));
            if (state.ui.playing && state.audio.buffer) {
              const now = performance.now();
              if (now - scrubRestartAt > 85) {
                scrubRestartAt = now;
                playAudioFrom(state.ui.time);
              }
            }
            invalidateAll();
          } else if (state.ui.dragging.kind === "key") {
            const d = state.ui.dragging;
            const layer = selectedLayer();
            const kfs = keyframesFor(layer, d.prop);
            const kf = kfs[d.index];
            if (!kf) return;
            const newT = snapTime(xToTime(hit.x));
            kf.t = newT;
            sortKeyframes(kfs);
            // update selection index after sort
            const eps = 1 / state.project.fps / 2;
            const idx = kfs.findIndex((x) => Math.abs(x.t - newT) <= eps);
            state.ui.selectedKey = { prop: d.prop, index: idx >= 0 ? idx : 0 };
            state.ui.time = newT;
            if (state.ui.playing && state.audio.buffer) {
              const now = performance.now();
              if (now - scrubRestartAt > 85) {
                scrubRestartAt = now;
                playAudioFrom(state.ui.time);
              }
            }
            invalidateAll();
          }
        });

        timelineCanvas.addEventListener("pointerup", () => {
          if (state.ui.dragging?.kind === "key") snapshot("drag keyframe");
          state.ui.dragging = null;
        });

        // Scroll wheel to pan/zoom timeline
        timelineCanvas.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const rect = timelineCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const tAtCursor = xToTime(x);
            if (e.ctrlKey || e.metaKey) {
              // zoom
              const z = state.ui.zoom;
              const next = clamp(z * (e.deltaY > 0 ? 0.92 : 1.08), 60, 420);
              state.ui.zoom = next;
              $("#zoom").value = String(Math.round(next));
              // Keep time under cursor stable
              state.ui.scroll = clamp(tAtCursor - (x - TL.labelW) / state.ui.zoom, 0, Math.max(0, state.project.duration - (rect.width - TL.labelW) / state.ui.zoom));
              invalidateTimeline();
            } else {
              const dx = e.deltaX || (e.shiftKey ? e.deltaY : 0);
              const dy = e.deltaY;
              const panSec = (dx + dy) / state.ui.zoom;
              const maxScroll = Math.max(0, state.project.duration - (rect.width - TL.labelW) / state.ui.zoom);
              state.ui.scroll = clamp(state.ui.scroll + panSec, 0, maxScroll);
              invalidateTimeline();
            }
          },
          { passive: false }
        );
      }

      // ---- STAGE INTERACTION ----
      function initStageInteraction() {
        let drag = null;
        stageShell.addEventListener("pointerdown", (e) => {
          stageShell.setPointerCapture(e.pointerId);
          const rect = stageCanvas.getBoundingClientRect();
          const layer = selectedLayer();
          const start = { x: e.clientX, y: e.clientY };
          const t = state.ui.time;
          const lx = getValueAt(layer, "x", t);
          const ly = getValueAt(layer, "y", t);
          drag = { kind: "layerMove", start, lx, ly, shift: e.shiftKey };
        });
        stageShell.addEventListener("pointermove", (e) => {
          if (!drag) return;
          const layer = selectedLayer();
          const s = state.ui.stageFit * state.ui.stageZoom;
          const dx = (e.clientX - drag.start.x) / s;
          const dy = (e.clientY - drag.start.y) / s;
          const t = snapTime(state.ui.time);
          let nx = drag.lx + dx;
          let ny = drag.ly + dy;
          if (e.shiftKey) {
            if (Math.abs(dx) > Math.abs(dy)) ny = drag.ly;
            else nx = drag.lx;
          }
          if (state.ui.autoKey) {
            setKeyframe(layer, "x", t, Math.round(nx), true);
            setKeyframe(layer, "y", t, Math.round(ny), true);
          } else {
            layer.tracks.x[0].v = Math.round(nx);
            layer.tracks.y[0].v = Math.round(ny);
          }
          state.ui.selectedTrack = "x";
          invalidateAll();
        });
        stageShell.addEventListener("pointerup", () => {
          if (drag) snapshot("stage drag");
          drag = null;
        });

        stageShell.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const zoomBy = e.deltaY > 0 ? 0.94 : 1.06;
            const next = clamp(state.ui.stageZoom * zoomBy, 0.4, 3.2);
            state.ui.stageZoom = next;
            layoutStageShell();
            layoutOverlays();
          },
          { passive: false }
        );
      }

      // ---- PLAYBACK LOOP ----
      let raf = 0;
      let playStartMs = 0;
      let playOffset = 0;
      function togglePlay() {
        if (state.ui.playing) pausePlayback();
        else startPlayback();
      }
      function startPlayback() {
        if (state.ui.playing) return;
        state.ui.playing = true;
        $("#playIcon").style.display = "none";
        $("#pauseIcon").style.display = "";
        playStartMs = performance.now();
        playOffset = state.ui.time;
        if (state.audio.buffer) playAudioFrom(playOffset);
        tick();
      }
      function pausePlayback() {
        if (!state.ui.playing) return;
        state.ui.playing = false;
        $("#playIcon").style.display = "";
        $("#pauseIcon").style.display = "none";
        if (state.audio.ctx && state.audio.source) {
          const ctx = state.audio.ctx;
          const t = state.audio.offset + (ctx.currentTime - state.audio.startCtxTime);
          state.ui.time = clamp(t, 0, state.project.duration);
          stopAudio();
        } else {
          const t = playOffset + (performance.now() - playStartMs) / 1000;
          state.ui.time = clamp(t, 0, state.project.duration);
        }
        invalidateAll();
      }
      function stopPlayback() {
        pausePlayback();
        stopAudio();
      }

      function tick() {
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(tick);
        if (state.ui.playing) {
          let t;
          if (state.audio.ctx && state.audio.source) {
            t = state.audio.offset + (state.audio.ctx.currentTime - state.audio.startCtxTime);
          } else {
            t = playOffset + (performance.now() - playStartMs) / 1000;
          }
          if (t >= state.project.duration) {
            if (state.ui.loop) {
              t = t % state.project.duration;
              playOffset = t;
              playStartMs = performance.now();
              if (state.audio.buffer) playAudioFrom(t);
            } else {
              t = state.project.duration;
              pausePlayback();
            }
          }
          state.ui.time = clamp(t, 0, state.project.duration);
          invalidateAll();
        }
        renderIfNeeded();
      }

      // ---- INVALIDATION ----
      let dirtyStage = true;
      let dirtyTimeline = true;
      function invalidateStage() {
        dirtyStage = true;
      }
      function invalidateTimeline() {
        dirtyTimeline = true;
      }
      function invalidateAll() {
        invalidateStage();
        invalidateTimeline();
        updateTimeUI();
        updateInspectorUI();
      }
      function renderIfNeeded() {
        if (dirtyStage) {
          dirtyStage = false;
          const layer = selectedLayer();
          const blur = layer.motion.motionBlur && !prefersReducedMotion;
          const samples = blur ? 5 : 1;
          if (samples === 1) {
            renderFrame(stageCtx, state.ui.time, { seed: Math.round(state.ui.time * state.project.fps), reduceFx: false });
          } else {
            const fps = state.project.fps;
            const shutter = 0.6 / fps;
            stageCtx.save();
            stageCtx.globalCompositeOperation = "source-over";
            stageCtx.clearRect(0, 0, stageCanvas.width, stageCanvas.height);
            for (let i = 0; i < samples; i++) {
              const u = (i / (samples - 1) - 0.5) * 2;
              const tt = state.ui.time + u * shutter;
              stageCtx.globalAlpha = 1 / samples;
              renderFrame(stageCtx, tt, { seed: Math.round(tt * fps) + i * 31, reduceFx: false });
            }
            stageCtx.restore();
          }
          updateTimeUI();
        }
        if (dirtyTimeline) {
          dirtyTimeline = false;
          drawTimeline();
        }
      }

      function updateTimeUI() {
        $("#timecode").textContent = `${formatTime(state.ui.time)} / ${formatTime(state.project.duration)}`;
      }

      function updateAllUI() {
        updateLayerList();
        const layer = selectedLayer();
        $("#layerName").value = layer.name;
        $("#textInput").value = layer.text;
        $("#fontFamily").value = layer.style.fontFamily;
        $("#fontSize").value = String(layer.style.fontSize);
        $("#fontWeight").value = String(layer.style.fontWeight);
        $("#italicToggle").setAttribute("aria-pressed", String(layer.style.italic));
        $("#lineHeight").value = String(layer.style.lineHeight);
        $("#alignLeft").setAttribute("aria-pressed", String(layer.style.align === "left"));
        $("#alignCenter").setAttribute("aria-pressed", String(layer.style.align === "center"));
        $("#alignRight").setAttribute("aria-pressed", String(layer.style.align === "right"));

        $("#fillMode").value = layer.style.fillMode;
        $("#bgColor").value = state.project.bg.color;
        $("#fillA").value = layer.style.fillA;
        $("#fillB").value = layer.style.fillB;
        $("#gradAngle").value = String(layer.style.gradAngle);

        $("#strokeOn").setAttribute("aria-pressed", String(layer.style.strokeOn));
        $("#strokeWidth").value = String(layer.style.strokeWidth);
        $("#strokeColor").value = layer.style.strokeColor;
        $("#shadowOn").setAttribute("aria-pressed", String(layer.style.shadowOn));
        $("#shadowBlur").value = String(layer.style.shadowBlur);
        $("#shadowColor").value = layer.style.shadowColor;
        $("#shadowX").value = String(layer.style.shadowX);
        $("#shadowY").value = String(layer.style.shadowY);

        $("#preset").value = layer.motion.preset;
        $("#staggerUnit").value = layer.motion.staggerUnit;
        $("#stagger").value = String(layer.motion.staggerMs);
        $("#animDur").value = String(layer.motion.unitDurMs);
        $("#amplitude").value = String(layer.motion.amplitude);
        $("#motionBlur").setAttribute("aria-pressed", String(layer.motion.motionBlur));
        $("#seed").value = String(layer.motion.seed);

        $("#fps").value = String(state.project.fps);
        $("#duration").value = String(state.project.duration);

        $("#width").value = String(state.project.width);
        $("#height").value = String(state.project.height);
        $("#margin").value = String(state.project.guides.margin);
        $("#showGrid").setAttribute("aria-pressed", String(state.project.guides.grid));
        $("#showSafe").setAttribute("aria-pressed", String(state.project.guides.safe));
        $("#showCross").setAttribute("aria-pressed", String(state.project.guides.cross));

        $("#snapFrames").setAttribute("aria-pressed", String(state.ui.snapFrames));
        $("#snapBeats").setAttribute("aria-pressed", String(state.ui.snapBeats));
        $("#audioSnap").setAttribute("aria-pressed", String(state.ui.snapBeats));
        $("#autoKey").setAttribute("aria-pressed", String(state.ui.autoKey));
        $("#btnLoop").setAttribute("aria-pressed", String(state.ui.loop));

        $("#audioReactive").setAttribute("aria-pressed", String(state.audio.reactive));
        $("#audioIntensity").value = String(state.audio.intensity);
        $("#audioScaleAmt").value = String(state.audio.map.scale);
        $("#audioRotAmt").value = String(state.audio.map.rot);
        $("#audioTrackAmt").value = String(state.audio.map.tracking);
        $("#audioGlitchAmt").value = String(state.audio.map.glitch);
        $("#audioNote").textContent = state.audio.fileName ? `Audio: ${state.audio.fileName}` : "No audio loaded.";
        $("#audioStats").textContent = `BPM: ${state.audio.bpm ? state.audio.bpm.toFixed(1) : "—"} • Beats: ${state.audio.beats?.length || "—"}`;

        updateInspectorUI();
        layoutStageShell();
        layoutOverlays();
      }

      function updateInspectorUI() {
        const layer = selectedLayer();
        const t = state.ui.time;
        $("#propX").value = String(Math.round(getValueAt(layer, "x", t)));
        $("#propY").value = String(Math.round(getValueAt(layer, "y", t)));
        $("#propScale").value = String(+getValueAt(layer, "scale", t).toFixed(3));
        $("#propRot").value = String(+getValueAt(layer, "rot", t).toFixed(2));
        $("#propOpacity").value = String(+getValueAt(layer, "opacity", t).toFixed(3));
        $("#propTracking").value = String(+getValueAt(layer, "tracking", t).toFixed(2));
        $("#propLetterOffset").value = String(+getValueAt(layer, "letterOffset", t).toFixed(2));
        $("#propWordOffset").value = String(+getValueAt(layer, "wordOffset", t).toFixed(2));
        const sel = state.ui.selectedKey;
        $("#inspectorMeta").textContent = sel ? `Keyframe: ${sel.prop}` : `Track: ${state.ui.selectedTrack}`;
        const status = $("#statusLine");
        if (sel) {
          const kf = keyframesFor(layer, sel.prop)[sel.index];
          status.textContent = kf ? `Selected ${sel.prop} @ ${formatTime(kf.t)} • v=${formatVal(sel.prop, kf.v)}` : "Ready.";
        } else {
          status.textContent = "Ready.";
        }
      }

      function formatVal(prop, v) {
        if (prop === "scale") return v.toFixed(3);
        if (prop === "opacity") return v.toFixed(3);
        if (prop === "rot") return v.toFixed(2) + "°";
        return String(Math.round(v * 100) / 100);
      }

      // ---- EXPORT ----
      function openExport() {
        const dur = state.project.duration;
        $("#exportFormat").value = "webm";
        $("#exportFps").value = String(state.project.fps);
        $("#exportW").value = String(state.project.width);
        $("#exportH").value = String(state.project.height);
        $("#exportStart").value = "0";
        $("#exportEnd").value = String(dur);
        $("#exportQuality").value = "0.9";
        $("#exportOffline").value = "offline";
        $("#exportNoEffects").setAttribute("aria-pressed", String(state.export.reduceFx));
        $("#exportStatus").textContent = `Ready. Tips: ${modKey}+E opens this dialog • WebM is fastest.`;
        exportDialog.showModal();
      }

      async function doExport() {
        const format = $("#exportFormat").value;
        const fps = clamp(Number($("#exportFps").value || state.project.fps), 1, 240);
        const w = clamp(Number($("#exportW").value || state.project.width), 64, 8192);
        const h = clamp(Number($("#exportH").value || state.project.height), 64, 8192);
        const start = clamp(Number($("#exportStart").value || 0), 0, state.project.duration);
        const end = clamp(Number($("#exportEnd").value || state.project.duration), 0, state.project.duration);
        const quality = clamp(Number($("#exportQuality").value || 0.9), 0.1, 1);
        const renderer = $("#exportOffline").value;
        const reduceFx = $("#exportNoEffects").getAttribute("aria-pressed") === "true";

        if (end <= start + 1e-6) {
          toast("Export end must be after start.", "bad");
          return;
        }

        $("#exportStatus").textContent = "Preparing renderer…";
        await sleep(20);
        if (format === "pngseq") {
          await exportPngSequence({ fps, w, h, start, end, quality, reduceFx });
        } else if (format === "gif") {
          await exportGIF({ fps: clamp(fps, 1, 30), w, h, start, end, quality, reduceFx });
        } else if (format === "webm") {
          if (renderer === "offline") {
            const ok = await exportVideoWebCodecs({ container: "webm", fps, w, h, start, end, quality, reduceFx }).catch(() => false);
            if (!ok) await exportWebMRealtime({ fps, w, h, start, end, reduceFx });
          } else {
            await exportWebMRealtime({ fps, w, h, start, end, reduceFx });
          }
        } else if (format === "mp4") {
          if (renderer === "offline") {
            const ok = await exportVideoWebCodecs({ container: "mp4", fps, w, h, start, end, quality, reduceFx }).catch(() => false);
            if (!ok) await exportMP4Realtime({ fps, w, h, start, end, reduceFx });
          } else {
            await exportMP4Realtime({ fps, w, h, start, end, reduceFx });
          }
        }
      }

      async function exportPngSequence({ fps, w, h, start, end, quality, reduceFx }) {
        const frameCount = Math.ceil((end - start) * fps);
        $("#exportStatus").textContent = `Rendering ${frameCount} PNG frames…`;
        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d", { alpha: false });

        const files = [];
        for (let i = 0; i < frameCount; i++) {
          const t = start + i / fps;
          renderFrame(ctx, t, { seed: i, reduceFx });
          const blob = await canvasToBlob(canvas, "image/png", quality);
          const name = `frame_${String(i).padStart(5, "0")}.png`;
          files.push({ name, data: new Uint8Array(await blob.arrayBuffer()) });
          if (i % 10 === 0) {
            $("#exportStatus").textContent = `Rendering PNG… ${i + 1}/${frameCount}`;
            await sleep(0);
          }
        }

        $("#exportStatus").textContent = "Zipping…";
        const zip = await zipFiles(files);
        downloadBlob(zip, "kinetic_typography_frames.zip");
        $("#exportStatus").textContent = "Done.";
        toast("PNG sequence downloaded.", "good");
      }

      async function exportGIF({ fps, w, h, start, end, quality, reduceFx }) {
        const frameCount = Math.ceil((end - start) * fps);
        $("#exportStatus").textContent = `Rendering GIF (${frameCount} frames)…`;
        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d", { alpha: false });

        let gifenc;
        try {
          gifenc = await import("https://unpkg.com/gifenc@1.0.3/dist/gifenc.esm.js");
        } catch {
          toast("GIF encoder failed to load (CDN). Try WebM/PNG.", "bad");
          $("#exportStatus").textContent = "GIF encoder load failed.";
          return;
        }
        const { GIFEncoder, quantize, applyPalette } = gifenc;
        const enc = GIFEncoder();
        const delay = Math.round(1000 / fps);

        for (let i = 0; i < frameCount; i++) {
          const t = start + i / fps;
          renderFrame(ctx, t, { seed: i, reduceFx });
          const img = ctx.getImageData(0, 0, w, h);
          const palette = quantize(img.data, 256, { format: "rgba4444" });
          const index = applyPalette(img.data, palette, "rgba4444");
          enc.writeFrame(index, w, h, { palette, delay });
          if (i % 4 === 0) {
            $("#exportStatus").textContent = `GIF… ${i + 1}/${frameCount}`;
            await sleep(0);
          }
        }
        enc.finish();
        const bytes = enc.bytes();
        downloadBlob(new Blob([bytes], { type: "image/gif" }), "kinetic_typography.gif");
        $("#exportStatus").textContent = "Done.";
        toast("GIF downloaded.", "good");
      }

      async function exportWebMRealtime({ fps, w, h, start, end, reduceFx }) {
        $("#exportStatus").textContent = "Realtime record (WebM)…";
        const ok = MediaRecorder && HTMLCanvasElement.prototype.captureStream;
        if (!ok) {
          toast("MediaRecorder/captureStream not supported.", "bad");
          $("#exportStatus").textContent = "Not supported.";
          return;
        }
        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d", { alpha: false });
        const stream = canvas.captureStream(fps);
        const mime = pickMime(["video/webm;codecs=vp9", "video/webm;codecs=vp8", "video/webm"]);
        const rec = new MediaRecorder(stream, mime ? { mimeType: mime, videoBitsPerSecond: Math.round(6_000_000) } : undefined);
        const chunks = [];
        rec.ondataavailable = (e) => e.data && e.data.size && chunks.push(e.data);

        rec.start(200);
        const startWall = performance.now();
        const frameCount = Math.ceil((end - start) * fps);
        for (let i = 0; i < frameCount; i++) {
          const t = start + i / fps;
          renderFrame(ctx, t, { seed: i, reduceFx });
          // let recorder ingest frames
          await sleep(Math.max(0, 1000 / fps));
          if (i % 10 === 0) $("#exportStatus").textContent = `Recording WebM… ${i + 1}/${frameCount}`;
        }
        rec.stop();
        await new Promise((res) => (rec.onstop = res));
        const blob = new Blob(chunks, { type: mime || "video/webm" });
        downloadBlob(blob, "kinetic_typography.webm");
        $("#exportStatus").textContent = `Done. (${Math.round((performance.now() - startWall) / 1000)}s)`;
        toast("WebM downloaded.", "good");
      }

      async function exportMP4Realtime({ fps, w, h, start, end, reduceFx }) {
        $("#exportStatus").textContent = "Realtime record (MP4)…";
        const ok = MediaRecorder && HTMLCanvasElement.prototype.captureStream;
        if (!ok) {
          toast("MediaRecorder/captureStream not supported.", "bad");
          $("#exportStatus").textContent = "Not supported.";
          return;
        }
        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d", { alpha: false });
        const stream = canvas.captureStream(fps);
        const mime = pickMime(["video/mp4;codecs=avc1.42E01E", "video/mp4"]);
        if (!mime) {
          toast("MP4 MediaRecorder not supported here. Try offline MP4 or WebM.", "bad");
          $("#exportStatus").textContent = "MP4 MediaRecorder unavailable.";
          return;
        }
        const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: Math.round(8_000_000) });
        const chunks = [];
        rec.ondataavailable = (e) => e.data && e.data.size && chunks.push(e.data);
        rec.start(200);
        const frameCount = Math.ceil((end - start) * fps);
        for (let i = 0; i < frameCount; i++) {
          const t = start + i / fps;
          renderFrame(ctx, t, { seed: i, reduceFx });
          await sleep(Math.max(0, 1000 / fps));
          if (i % 10 === 0) $("#exportStatus").textContent = `Recording MP4… ${i + 1}/${frameCount}`;
        }
        rec.stop();
        await new Promise((res) => (rec.onstop = res));
        const blob = new Blob(chunks, { type: mime });
        downloadBlob(blob, "kinetic_typography.mp4");
        $("#exportStatus").textContent = "Done.";
        toast("MP4 downloaded.", "good");
      }

      function pickMime(mimes) {
        if (!window.MediaRecorder) return null;
        for (const m of mimes) {
          if (MediaRecorder.isTypeSupported?.(m)) return m;
        }
        return null;
      }

      async function exportVideoWebCodecs({ container, fps, w, h, start, end, quality, reduceFx }) {
        if (!("VideoEncoder" in window)) {
          $("#exportStatus").textContent = "WebCodecs not available; falling back…";
          return false;
        }
        $("#exportStatus").textContent = "Loading muxer…";
        let muxerMod = null;
        try {
          muxerMod = await import(container === "webm" ? "https://unpkg.com/webm-muxer@5.0.2/dist/webm-muxer.mjs" : "https://unpkg.com/mp4-muxer@5.0.2/dist/mp4-muxer.mjs");
        } catch {
          $("#exportStatus").textContent = "Muxer failed to load (CDN); falling back…";
          return false;
        }

        const { Muxer, ArrayBufferTarget } = muxerMod;
        const frameCount = Math.ceil((end - start) * fps);
        const target = new ArrayBufferTarget();

        let config;
        let muxer;
        let codec;
        if (container === "webm") {
          codec = "vp09.00.10.08";
          config = { codec, width: w, height: h, bitrate: Math.round(6_000_000 * quality), framerate: fps };
          muxer = new Muxer({
            target,
            video: { codec: "V_VP9", width: w, height: h, frameRate: fps },
            firstTimestampBehavior: "offset",
          });
        } else {
          // MP4 (H.264) support varies
          codec = "avc1.42E01E";
          config = { codec, width: w, height: h, bitrate: Math.round(8_000_000 * quality), framerate: fps };
          muxer = new Muxer({
            target,
            video: { codec: "avc", width: w, height: h, frameRate: fps },
            firstTimestampBehavior: "offset",
          });
        }

        const support = await VideoEncoder.isConfigSupported(config).catch(() => null);
        if (!support?.supported) {
          $("#exportStatus").textContent = `Codec not supported (${codec}); falling back…`;
          return false;
        }

        $("#exportStatus").textContent = `Offline encode (${container.toUpperCase()})…`;
        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d", { alpha: false });
        let encoded = 0;

        const encoder = new VideoEncoder({
          output: (chunk, meta) => {
            muxer.addVideoChunk(chunk, meta);
            encoded++;
          },
          error: (err) => {
            console.warn(err);
          },
        });
        encoder.configure(config);

        const frameDuration = 1_000_000 / fps;
        for (let i = 0; i < frameCount; i++) {
          const t = start + i / fps;
          renderFrame(ctx, t, { seed: i, reduceFx });
          const vf = new VideoFrame(canvas, { timestamp: Math.round(i * frameDuration) });
          encoder.encode(vf, { keyFrame: i % Math.round(fps) === 0 });
          vf.close();
          if (i % 10 === 0) {
            $("#exportStatus").textContent = `Offline encode… ${i + 1}/${frameCount}`;
            await sleep(0);
          }
        }
        await encoder.flush();
        encoder.close();
        muxer.finalize();

        const buffer = target.buffer;
        const blob = new Blob([buffer], { type: container === "webm" ? "video/webm" : "video/mp4" });
        downloadBlob(blob, `kinetic_typography.${container}`);
        $("#exportStatus").textContent = `Done. Encoded chunks: ${encoded}`;
        toast(`${container.toUpperCase()} downloaded.`, "good");
        return true;
      }

      // ---- UTIL ----
      function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
      }
      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 10_000);
      }
      function fileToDataURL(file) {
        return new Promise((res, rej) => {
          const fr = new FileReader();
          fr.onload = () => res(fr.result);
          fr.onerror = rej;
          fr.readAsDataURL(file);
        });
      }
      async function loadBitmap(dataUrl) {
        const img = new Image();
        img.decoding = "async";
        img.src = dataUrl;
        await img.decode();
        return await createImageBitmap(img);
      }
      function canvasToBlob(canvas, type, quality) {
        return new Promise((res) => canvas.toBlob((b) => res(b), type, quality));
      }

      async function zipFiles(files) {
        let fflate;
        try {
          fflate = await import("https://unpkg.com/fflate@0.8.2/esm/browser.js");
        } catch {
          // Basic fallback: single file download (first frame only)
          toast("ZIP library failed to load (CDN). Downloading first frame instead.", "bad");
          return new Blob([files[0].data], { type: "application/octet-stream" });
        }
        const { zipSync, strToU8 } = fflate;
        const data = {};
        for (const f of files) data[f.name] = f.data;
        const zipped = zipSync(data, { level: 6 });
        return new Blob([zipped], { type: "application/zip" });
      }

      async function downloadPNGCurrentFrame() {
        const canvas = document.createElement("canvas");
        canvas.width = state.project.width;
        canvas.height = state.project.height;
        const ctx = canvas.getContext("2d", { alpha: false });
        renderFrame(ctx, state.ui.time, { seed: Math.round(state.ui.time * state.project.fps), reduceFx: false });
        const blob = await canvasToBlob(canvas, "image/png", 0.95);
        downloadBlob(blob, `frame_${formatTime(state.ui.time).replaceAll(":", "-")}.png`);
        toast("PNG frame downloaded.", "good");
      }

      // ---- BOOT ----
      function init() {
        initFonts();
        bind();
        updateAllUI();
        layoutTimelineCanvas();
        fitStage();
        layoutOverlays();
        initTimelineInteraction();
        initStageInteraction();
        window.addEventListener("resize", () => {
          layoutTimelineCanvas();
          fitStage();
          layoutOverlays();
          invalidateAll();
        });

        // Seed defaults
        $("#bz1x").value = "0.33";
        $("#bz1y").value = "0.0";
        $("#bz2x").value = "0.67";
        $("#bz2y").value = "1.0";
        $("#exportQuality").value = "0.9";
        if (prefersReducedMotion) toast("Reduced motion: heavy effects softened.", "info", 2600);

        // First snapshot
        snapshot("init");
        tick();
        toast(`Ready. ${modKey}+E exports • Space plays.`, "good", 2800);
      }

      init();
    </script>
  </body>
</html>
