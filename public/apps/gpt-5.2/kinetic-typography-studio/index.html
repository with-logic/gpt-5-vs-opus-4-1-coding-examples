<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <title>Kinetic Typography Studio</title>
  <style>
    :root{
      --bg0:#070a13;
      --bg1:#0b1020;
      --bg2:#0f1834;
      --panel:#0c1226cc;
      --panel2:#0c1226f2;
      --stroke:#263154;
      --stroke2:#31406d;
      --text:#e8ecff;
      --muted:#aab4da;
      --faint:#7f8ab8;
      --brand:#7c5cff;
      --brand2:#4dd6ff;
      --warn:#ffcc66;
      --bad:#ff5c7a;
      --ok:#3ee98d;
      --shadow: 0 18px 50px rgba(0,0,0,.45);
      --radius: 14px;
      --radius-sm: 10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --focus: 0 0 0 3px rgba(124,92,255,.35), 0 0 0 1px rgba(124,92,255,.65) inset;
      --grid: rgba(124,92,255,.14);
      --grid2: rgba(77,214,255,.12);
      --safe: rgba(255,255,255,.09);
      --uiScale: 1;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg0:#f7f8ff;
        --bg1:#ffffff;
        --bg2:#f1f4ff;
        --panel:#ffffffcc;
        --panel2:#fffffff2;
        --stroke:#d6defa;
        --stroke2:#c9d2f5;
        --text:#11142a;
        --muted:#3a4168;
        --faint:#6a7297;
        --shadow: 0 18px 50px rgba(16,18,34,.15);
        --grid: rgba(124,92,255,.14);
        --grid2: rgba(77,214,255,.12);
        --safe: rgba(17,20,42,.08);
      }
    }
    @media (prefers-reduced-motion: reduce){
      :root{ --uiScale: 1; }
      .animPulse{ animation: none !important; }
      .glow{ filter: none !important; }
    }
    /* Optional web fonts (CDN); app works without them. */
    @import url("https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800;900&family=Montserrat:wght@200;300;400;500;600;700;800;900&family=Oswald:wght@200;300;400;500;600;700&family=Playfair+Display:ital,wght@0,400;0,700;0,900;1,400;1,700;1,900&display=swap");

    *{ box-sizing: border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(1200px 800px at 12% 10%, rgba(124,92,255,.23), transparent 55%),
                  radial-gradient(1200px 800px at 90% 30%, rgba(77,214,255,.14), transparent 52%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow:hidden;
    }
    a{ color: inherit; }
    button, input, select, textarea{
      font: inherit;
      color: inherit;
    }
    ::selection{ background: rgba(124,92,255,.35); }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
    }
    header{
      flex: 0 0 auto;
      display:flex;
      align-items:center;
      gap: 12px;
      padding: 10px 14px;
      border-bottom: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--panel2), var(--panel));
      backdrop-filter: blur(14px);
      box-shadow: 0 1px 0 rgba(0,0,0,.08);
    }
    .brand{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 240px;
    }
    .logo{
      width: 32px;
      height: 32px;
      border-radius: 10px;
      background:
        radial-gradient(18px 18px at 30% 30%, rgba(77,214,255,.95), rgba(77,214,255,.05) 60%),
        radial-gradient(20px 20px at 70% 65%, rgba(124,92,255,.95), rgba(124,92,255,.02) 62%),
        linear-gradient(135deg, rgba(255,255,255,.14), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.16);
      box-shadow: 0 18px 40px rgba(124,92,255,.18);
    }
    .brand h1{
      margin:0;
      font-size: 14px;
      line-height: 1.1;
      letter-spacing: .2px;
      font-weight: 750;
    }
    .brand .sub{
      display:block;
      margin-top: 2px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .2px;
    }
    .topbar{
      flex: 1 1 auto;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      min-width: 0;
    }
    .topbar .left, .topbar .right{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 6px 10px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.03);
      border-radius: 999px;
      box-shadow: 0 10px 26px rgba(0,0,0,.12);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .chip code{ font-family: var(--mono); font-size: 11px; color: var(--faint); }
    .btn{
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,.03);
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      box-shadow: 0 14px 36px rgba(0,0,0,.14);
      transition: transform .08s ease, border-color .15s ease, background .15s ease;
      user-select:none;
    }
    .btn:hover{ border-color: rgba(124,92,255,.55); background: rgba(124,92,255,.08); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      border-color: rgba(124,92,255,.8);
      background: linear-gradient(180deg, rgba(124,92,255,.22), rgba(124,92,255,.08));
    }
    .btn.danger:hover{ border-color: rgba(255,92,122,.55); background: rgba(255,92,122,.08); }
    .btn:focus-visible{ outline:none; box-shadow: var(--focus), 0 18px 40px rgba(0,0,0,.2); }
    .btn .k{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--faint);
      border: 1px solid var(--stroke);
      border-bottom-color: rgba(0,0,0,.25);
      padding: 2px 6px;
      border-radius: 8px;
      background: rgba(255,255,255,.03);
    }
    .btn.small{ padding: 6px 8px; border-radius: 10px; font-size: 12px; }
    .btn.icon{ width: 38px; height: 38px; padding: 0; }
    .btn.icon.small{ width: 32px; height: 32px; }

    .iconSvg{ width: 18px; height: 18px; opacity: .95; }
    .iconSvg.muted{ opacity: .75; }

    .workspace{
      flex: 1 1 auto;
      display:grid;
      grid-template-columns: 360px 1fr;
      min-height: 0;
    }
    aside{
      min-height: 0;
      border-right: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--panel2), var(--panel));
      backdrop-filter: blur(14px);
      box-shadow: inset -1px 0 0 rgba(0,0,0,.05);
      display:flex;
      flex-direction:column;
    }
    .panelScroll{
      overflow:auto;
      padding: 12px 12px 16px;
      min-height: 0;
    }
    .group{
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      background: rgba(255,255,255,.02);
      box-shadow: 0 20px 50px rgba(0,0,0,.14);
      overflow:hidden;
      margin-bottom: 12px;
    }
    .group summary{
      list-style:none;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      cursor:pointer;
      user-select:none;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border-bottom: 1px solid rgba(255,255,255,.02);
    }
    .group summary::-webkit-details-marker{ display:none; }
    .group summary .t{
      display:flex;
      flex-direction:column;
      gap: 2px;
      min-width: 0;
    }
    .group summary .t b{ font-size: 13px; letter-spacing:.2px; }
    .group summary .t span{ font-size: 12px; color: var(--muted); }
    .group .body{ padding: 12px; }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .row3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    label{
      display:flex;
      flex-direction:column;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    label .hint{ color: var(--faint); font-size: 11px; }
    input[type="text"], input[type="number"], select, textarea{
      width:100%;
      border-radius: 12px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,.03);
      padding: 9px 10px;
      outline:none;
      transition: box-shadow .15s ease, border-color .15s ease, background .15s ease;
    }
    textarea{
      resize: vertical;
      min-height: 84px;
      max-height: 220px;
      line-height: 1.3;
    }
    input[type="color"]{
      width: 100%;
      height: 40px;
      border-radius: 12px;
      border: 1px solid var(--stroke2);
      padding: 0;
      background: rgba(255,255,255,.03);
      cursor: pointer;
    }
    input[type="range"]{ width:100%; }
    input:focus, select:focus, textarea:focus{ box-shadow: var(--focus); border-color: rgba(124,92,255,.65); }
    .toggle{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.02);
      border-radius: 12px;
      margin-top: 8px;
    }
    .toggle b{ font-size: 12px; color: var(--text); }
    .toggle span{ font-size: 11px; color: var(--muted); }
    .switch{
      position: relative;
      width: 44px;
      height: 26px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid var(--stroke2);
      cursor: pointer;
      flex: 0 0 auto;
    }
    .switch i{
      position:absolute;
      top: 3px;
      left: 3px;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255,255,255,.92);
      box-shadow: 0 10px 20px rgba(0,0,0,.20);
      transition: transform .15s ease, background .15s ease;
    }
    .switch.on{
      background: rgba(124,92,255,.40);
      border-color: rgba(124,92,255,.65);
    }
    .switch.on i{
      transform: translateX(18px);
      background: rgba(255,255,255,.96);
    }
    .pillbar{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .pill{
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,.02);
      color: var(--muted);
      padding: 7px 9px;
      border-radius: 999px;
      cursor:pointer;
      font-size: 12px;
      user-select:none;
    }
    .pill[aria-pressed="true"]{
      border-color: rgba(124,92,255,.65);
      background: rgba(124,92,255,.14);
      color: var(--text);
    }
    .kv{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.02);
      margin-top: 8px;
    }
    .kv code{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--faint);
    }
    .kv .bad{ color: var(--bad); }
    .kv .ok{ color: var(--ok); }

    main{
      min-height: 0;
      display:flex;
      flex-direction:column;
    }
    .stageWrap{
      flex: 1 1 auto;
      min-height: 0;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      padding: 12px;
      gap: 12px;
    }
    .stage{
      flex: 1 1 auto;
      border-radius: var(--radius);
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.02);
      box-shadow: var(--shadow);
      position: relative;
      overflow:hidden;
      min-height: 0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .stage canvas{
      width: 100%;
      height: 100%;
      display:block;
      background: transparent;
      touch-action: none;
    }
    .hud{
      position:absolute;
      left: 12px;
      top: 12px;
      display:flex;
      gap: 8px;
      align-items:center;
      pointer-events:none;
    }
    .hud .badge{
      pointer-events:none;
      font-size: 12px;
      color: var(--muted);
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      backdrop-filter: blur(10px);
      padding: 6px 10px;
      border-radius: 999px;
      display:flex;
      gap: 8px;
      align-items:center;
      box-shadow: 0 18px 40px rgba(0,0,0,.18);
    }
    .hud .dot{
      width: 8px;
      height: 8px;
      border-radius: 99px;
      background: rgba(62,233,141,.9);
      box-shadow: 0 0 0 5px rgba(62,233,141,.10);
    }
    .hud .dot.off{
      background: rgba(255,92,122,.9);
      box-shadow: 0 0 0 5px rgba(255,92,122,.10);
    }
    .cornerHelp{
      position:absolute;
      right: 12px;
      top: 12px;
      display:flex;
      gap: 8px;
      align-items:center;
    }
    .cornerHelp .btn{ pointer-events:auto; }
    .toast{
      position:absolute;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 999px;
      box-shadow: 0 20px 50px rgba(0,0,0,.22);
      font-size: 12px;
      backdrop-filter: blur(12px);
      display:none;
      max-width: min(680px, 92vw);
    }
    .toast.show{ display:block; animation: toastIn .18s ease; }
    @keyframes toastIn{
      from{ transform: translateX(-50%) translateY(6px); opacity: 0; }
      to{ transform: translateX(-50%) translateY(0); opacity: 1; }
    }

    .timeline{
      flex: 0 0 auto;
      border-top: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      backdrop-filter: blur(14px);
      box-shadow: 0 -1px 0 rgba(0,0,0,.05);
      padding: 10px 12px 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-height: 180px;
    }
    .tlTop{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap:wrap;
    }
    .tlControls{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap:wrap;
    }
    .timeReadout{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.02);
      display:flex;
      gap: 10px;
      align-items:center;
      white-space:nowrap;
    }
    .timeReadout b{ color: var(--text); font-weight: 700; }
    .tlTrack{
      position: relative;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:
        linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01)),
        radial-gradient(900px 200px at 10% 20%, rgba(124,92,255,.12), transparent 60%),
        radial-gradient(900px 200px at 85% 60%, rgba(77,214,255,.10), transparent 55%);
      overflow:auto;
      min-height: 88px;
    }
    .tlCanvas{
      height: 88px;
      display:block;
      touch-action: none;
    }
    .tlLegend{
      display:flex;
      gap: 10px;
      align-items:center;
      font-size: 12px;
      color: var(--muted);
      flex-wrap:wrap;
    }
    .tlLegend .sw{ width: 10px; height: 10px; border-radius: 3px; background: rgba(124,92,255,.8); }
    .tlLegend .sw2{ width: 10px; height: 10px; border-radius: 3px; background: rgba(77,214,255,.8); }

    dialog{
      border: 1px solid var(--stroke2);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(20,28,56,.98), rgba(10,14,28,.98));
      color: var(--text);
      box-shadow: 0 40px 120px rgba(0,0,0,.55);
      width: min(980px, 96vw);
      max-height: min(88vh, 900px);
      padding: 0;
      overflow:hidden;
    }
    @media (prefers-color-scheme: light){
      dialog{
        background: linear-gradient(180deg, rgba(255,255,255,.98), rgba(245,247,255,.98));
      }
    }
    dialog::backdrop{
      background: rgba(0,0,0,.5);
      backdrop-filter: blur(8px);
    }
    .modalHead{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--stroke);
      background: rgba(255,255,255,.02);
    }
    .modalHead h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
    }
    .modalBody{
      padding: 14px;
      overflow:auto;
    }
    .modalGrid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 14px;
    }
    @media (max-width: 1020px){
      .workspace{ grid-template-columns: 1fr; }
      aside{ display:none; }
      .modalGrid{ grid-template-columns: 1fr; }
      .timeline{ min-height: 200px; }
    }
    .helpGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 820px){
      .helpGrid{ grid-template-columns: 1fr; }
    }
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,.03);
      padding: 2px 6px;
      border-radius: 8px;
      color: var(--text);
    }
    .note{
      border: 1px dashed rgba(124,92,255,.45);
      background: rgba(124,92,255,.10);
      padding: 10px 12px;
      border-radius: 14px;
      color: rgba(232,236,255,.92);
      font-size: 12px;
      line-height: 1.35;
    }
    .note b{ color: var(--text); }
    .statusLine{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
    }
    .progress{
      width: 220px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,.03);
      overflow:hidden;
    }
    .progress > i{
      display:block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(124,92,255,.9), rgba(77,214,255,.85));
    }

    .srOnly{
      position:absolute !important;
      width:1px !important;
      height:1px !important;
      padding:0 !important;
      margin:-1px !important;
      overflow:hidden !important;
      clip: rect(0,0,0,0) !important;
      white-space: nowrap !important;
      border:0 !important;
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="brand" aria-label="App title">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Kinetic Typography Studio</h1>
          <span class="sub">Design, preview, and export animated text sequences</span>
        </div>
      </div>
      <div class="topbar">
        <div class="left">
          <div class="chip" title="Keyboard shortcuts: press ?">
            <span aria-hidden="true">Shortcuts</span>
            <code>?</code>
            <span aria-hidden="true">•</span>
            <span aria-hidden="true">Export</span>
            <code>Ctrl/⌘ E</code>
          </div>
          <div class="chip" id="chipReduced" style="display:none">
            <span aria-hidden="true">Reduced motion</span>
            <code>prefers-reduced-motion</code>
          </div>
        </div>
        <div class="right">
          <button class="btn small" id="btnSidebar" aria-label="Toggle sidebar (mobile)"><svg class="iconSvg" viewBox="0 0 24 24" fill="none"><path d="M4 6h16M4 12h16M4 18h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg><span class="k">S</span></button>
          <button class="btn small" id="btnKeyframe" aria-label="Add keyframe at playhead"><svg class="iconSvg" viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M7.2 8.2 12 3.4l4.8 4.8L12 13z" fill="currentColor" opacity=".2"/></svg><span>Add keyframe</span><span class="k">K</span></button>
          <button class="btn primary small" id="btnExport" aria-label="Export animation"><svg class="iconSvg" viewBox="0 0 24 24" fill="none"><path d="M12 3v12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M8 11l4 4 4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M5 21h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg><span>Export</span><span class="k">Ctrl/⌘ E</span></button>
          <button class="btn icon small" id="btnHelp" aria-label="Help and shortcuts"><svg class="iconSvg" viewBox="0 0 24 24" fill="none"><path d="M12 18h.01" stroke="currentColor" stroke-width="3" stroke-linecap="round"/><path d="M9.6 9.2a2.6 2.6 0 1 1 3.9 2.2c-.9.5-1.5 1.2-1.5 2.6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 22c5.5 0 10-4.5 10-10S17.5 2 12 2 2 6.5 2 12s4.5 10 10 10Z" stroke="currentColor" stroke-width="2" opacity=".6"/></svg></button>
        </div>
      </div>
    </header>

    <div class="workspace">
      <aside id="sidebar" aria-label="Controls sidebar">
        <div class="panelScroll" id="panelScroll">

          <details class="group" open>
            <summary>
              <div class="t"><b>Text</b><span>Content, alignment, and layout</span></div>
              <span aria-hidden="true" style="color:var(--faint)">↵</span>
            </summary>
            <div class="body">
              <label>
                Text
                <textarea id="inText" aria-label="Text content">Kinetic
Typography</textarea>
                <span class="hint">Tip: use line breaks. Typewriter/cascade uses glyph or word order.</span>
              </label>
              <div class="row" style="margin-top:10px">
                <label>
                  Align
                  <select id="inAlign" aria-label="Text alignment">
                    <option value="center">Center</option>
                    <option value="left">Left</option>
                    <option value="right">Right</option>
                  </select>
                </label>
                <label>
                  Line height
                  <input id="inLineHeight" aria-label="Line height" type="number" min="0.8" max="2.5" step="0.05" value="1.05" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Box width (%)
                  <input id="inBoxW" aria-label="Text box width percent" type="number" min="20" max="100" step="1" value="86" />
                </label>
                <label>
                  Max lines
                  <input id="inMaxLines" aria-label="Max lines" type="number" min="1" max="20" step="1" value="10" />
                </label>
              </div>
            </div>
          </details>

          <details class="group" open>
            <summary>
              <div class="t"><b>Style</b><span>Font, fill, outline, shadows</span></div>
              <span aria-hidden="true" style="color:var(--faint)">Aa</span>
            </summary>
            <div class="body">
              <div class="row">
                <label>
                  Font
                  <select id="inFont" aria-label="Font family">
                    <option value="Inter, ui-sans-serif, system-ui">Inter</option>
                    <option value="Montserrat, ui-sans-serif, system-ui">Montserrat</option>
                    <option value="Oswald, ui-sans-serif, system-ui">Oswald</option>
                    <option value="Playfair Display, ui-serif, Georgia">Playfair Display</option>
                    <option value="system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial">System UI</option>
                    <option value="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas">Monospace</option>
                  </select>
                </label>
                <label>
                  Size (px)
                  <input id="inFontSize" aria-label="Font size" type="number" min="10" max="420" step="1" value="120" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Weight
                  <input id="inWeight" aria-label="Font weight" type="number" min="100" max="900" step="50" value="800" />
                </label>
                <label>
                  Italic
                  <select id="inItalic" aria-label="Italic">
                    <option value="normal">No</option>
                    <option value="italic">Yes</option>
                  </select>
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Fill color
                  <input id="inFill" aria-label="Fill color" type="color" value="#f2f5ff" />
                </label>
                <label>
                  Background
                  <input id="inBg" aria-label="Background color" type="color" value="#0b1020" />
                </label>
              </div>
              <div class="toggle" style="margin-top:10px" aria-label="Outline toggle">
                <div>
                  <b>Outline</b>
                  <span>Stroke around glyphs</span>
                </div>
                <div class="switch" id="swOutline" role="switch" tabindex="0" aria-checked="false" aria-label="Outline on or off"><i></i></div>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Outline width
                  <input id="inOutlineW" aria-label="Outline width" type="number" min="0" max="32" step="0.5" value="3" />
                </label>
                <label>
                  Outline color
                  <input id="inOutlineC" aria-label="Outline color" type="color" value="#090b12" />
                </label>
              </div>
              <div class="toggle" style="margin-top:10px" aria-label="Shadow toggle">
                <div>
                  <b>Shadow</b>
                  <span>Soft depth (export-safe)</span>
                </div>
                <div class="switch on" id="swShadow" role="switch" tabindex="0" aria-checked="true" aria-label="Shadow on or off"><i></i></div>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Shadow blur
                  <input id="inShadowBlur" aria-label="Shadow blur" type="number" min="0" max="80" step="1" value="18" />
                </label>
                <label>
                  Shadow opacity
                  <input id="inShadowA" aria-label="Shadow opacity" type="number" min="0" max="1" step="0.05" value="0.35" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Shadow X
                  <input id="inShadowX" aria-label="Shadow x offset" type="number" min="-120" max="120" step="1" value="0" />
                </label>
                <label>
                  Shadow Y
                  <input id="inShadowY" aria-label="Shadow y offset" type="number" min="-120" max="120" step="1" value="12" />
                </label>
              </div>
              <div class="toggle" style="margin-top:10px" aria-label="Gradient toggle">
                <div>
                  <b>Gradient fill</b>
                  <span>Two-stop linear gradient</span>
                </div>
                <div class="switch" id="swGrad" role="switch" tabindex="0" aria-checked="false" aria-label="Gradient on or off"><i></i></div>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Gradient A
                  <input id="inGradA" aria-label="Gradient color A" type="color" value="#7c5cff" />
                </label>
                <label>
                  Gradient B
                  <input id="inGradB" aria-label="Gradient color B" type="color" value="#4dd6ff" />
                </label>
              </div>
              <div class="toggle" style="margin-top:10px" aria-label="Motion blur toggle">
                <div>
                  <b>Motion blur</b>
                  <span>Preview + export (CPU-heavy)</span>
                </div>
                <div class="switch" id="swBlur" role="switch" tabindex="0" aria-checked="false" aria-label="Motion blur on or off"><i></i></div>
              </div>
            </div>
          </details>

          <details class="group" open>
            <summary>
              <div class="t"><b>Motion</b><span>Timeline values, easing, presets</span></div>
              <span aria-hidden="true" style="color:var(--faint)">⌁</span>
            </summary>
            <div class="body">
              <div class="row">
                <label>
                  Preset
                  <select id="inPreset" aria-label="Animation preset">
                    <option value="fade-up">Fade-up</option>
                    <option value="typewriter">Typewriter</option>
                    <option value="bounce">Bounce</option>
                    <option value="liquid">Liquid</option>
                    <option value="glitch">Glitch</option>
                    <option value="cascade">Cascade</option>
                  </select>
                </label>
                <label>
                  Stagger by
                  <select id="inStaggerMode" aria-label="Stagger grouping">
                    <option value="letter">Letter</option>
                    <option value="word">Word</option>
                    <option value="line">Line</option>
                  </select>
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Stagger (sec)
                  <input id="inStagger" aria-label="Stagger seconds" type="number" min="0" max="1.5" step="0.005" value="0.02" />
                </label>
                <label>
                  Local anim (sec)
                  <input id="inLocalDur" aria-label="Local animation duration seconds" type="number" min="0.1" max="3" step="0.05" value="0.7" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Tracking (px)
                  <input id="inTracking" aria-label="Tracking" type="number" min="-10" max="80" step="0.25" value="1.0" />
                </label>
                <label>
                  Opacity
                  <input id="inOpacity" aria-label="Opacity" type="number" min="0" max="1" step="0.01" value="1" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  X (%)
                  <input id="inPosX" aria-label="X percent" type="number" min="0" max="100" step="0.1" value="50" />
                </label>
                <label>
                  Y (%)
                  <input id="inPosY" aria-label="Y percent" type="number" min="0" max="100" step="0.1" value="50" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Scale
                  <input id="inScale" aria-label="Scale" type="number" min="0.05" max="6" step="0.01" value="1" />
                </label>
                <label>
                  Rotation (deg)
                  <input id="inRot" aria-label="Rotation degrees" type="number" min="-360" max="360" step="0.1" value="0" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Letter offset (px)
                  <input id="inLetterOffset" aria-label="Letter offset pixels" type="number" min="-200" max="200" step="1" value="28" />
                </label>
                <label>
                  Word offset (px)
                  <input id="inWordOffset" aria-label="Word offset pixels" type="number" min="-240" max="240" step="1" value="0" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Easing preset
                  <select id="inEasePreset" aria-label="Easing preset">
                    <option value="easeInOut">Ease in-out</option>
                    <option value="linear">Linear</option>
                    <option value="easeOut">Ease out</option>
                    <option value="easeIn">Ease in</option>
                    <option value="easeOutBack">Ease out-back</option>
                    <option value="easeOutElastic">Ease out-elastic</option>
                  </select>
                  <span class="hint">Applied from selected keyframe → next.</span>
                </label>
                <label>
                  Custom Bézier
                  <canvas id="easeCanvas" width="220" height="140" aria-label="Custom bezier editor" style="border-radius:14px;border:1px solid var(--stroke2);background:rgba(255,255,255,.02)"></canvas>
                </label>
              </div>
              <div class="pillbar" aria-label="Preset actions">
                <button class="pill" id="btnApplyPreset" aria-pressed="false">Rebuild keyframes from preset</button>
                <button class="pill" id="btnResetMotion" aria-pressed="false">Reset motion</button>
              </div>
              <div class="kv" aria-label="Keyframe selection status">
                <div><b style="color:var(--text)">Selected</b> <span style="color:var(--muted)">keyframe</span></div>
                <code id="kvSel">none</code>
              </div>
            </div>
          </details>

          <details class="group">
            <summary>
              <div class="t"><b>Audio</b><span>Beat detect, snapping, reactive</span></div>
              <span aria-hidden="true" style="color:var(--faint)">♪</span>
            </summary>
            <div class="body">
              <div class="note">
                <b>Audio-reactive</b> runs locally in your browser. Beat detection uses a lightweight energy/tempo estimator (good for many tracks; not perfect).
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Load audio (local)
                  <input id="inAudioFile" aria-label="Load audio file" type="file" accept="audio/*" />
                  <span class="hint">MP3/WAV/OGG depending on browser.</span>
                </label>
                <label>
                  Snap mode
                  <select id="inSnapMode" aria-label="Snap mode">
                    <option value="none">Off</option>
                    <option value="beat">Beats</option>
                    <option value="bar">Bars</option>
                  </select>
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Beats / bar
                  <input id="inBeatsPerBar" aria-label="Beats per bar" type="number" min="2" max="12" step="1" value="4" />
                </label>
                <label>
                  BPM (detected/override)
                  <input id="inBpm" aria-label="BPM" type="number" min="40" max="220" step="0.1" value="120" />
                </label>
              </div>
              <div class="pillbar" style="margin-top:10px">
                <button class="pill" id="btnDetect" aria-pressed="false">Detect beats</button>
                <button class="pill" id="btnSnapKeyframe" aria-pressed="false">Snap selected keyframe</button>
              </div>
              <div class="toggle" style="margin-top:10px" aria-label="Audio reactive toggle">
                <div>
                  <b>Audio-reactive</b>
                  <span>Drive motion + glow from audio energy</span>
                </div>
                <div class="switch" id="swAudioReactive" role="switch" tabindex="0" aria-checked="false" aria-label="Audio reactive on or off"><i></i></div>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  React: scale
                  <input id="inReactScale" aria-label="Audio reactive scale" type="number" min="0" max="1.5" step="0.01" value="0.18" />
                </label>
                <label>
                  React: glitch
                  <input id="inReactGlitch" aria-label="Audio reactive glitch" type="number" min="0" max="1.5" step="0.01" value="0.25" />
                </label>
              </div>
              <div class="kv" aria-label="Audio file status">
                <div><b style="color:var(--text)">Audio</b> <span style="color:var(--muted)">status</span></div>
                <code id="audStatus">no file</code>
              </div>
            </div>
          </details>

          <details class="group">
            <summary>
              <div class="t"><b>Layout</b><span>Aspect, guides, background image</span></div>
              <span aria-hidden="true" style="color:var(--faint)">▦</span>
            </summary>
            <div class="body">
              <div class="row">
                <label>
                  Aspect preset
                  <select id="inAspect" aria-label="Aspect preset">
                    <option value="16:9">16:9</option>
                    <option value="9:16">9:16</option>
                    <option value="1:1">1:1</option>
                    <option value="4:5">4:5</option>
                  </select>
                </label>
                <label>
                  Resolution
                  <select id="inRes" aria-label="Resolution preset">
                    <option value="1280x720">1280×720</option>
                    <option value="1920x1080">1920×1080</option>
                    <option value="1080x1920">1080×1920</option>
                    <option value="1080x1080">1080×1080</option>
                    <option value="custom">Custom…</option>
                  </select>
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Custom width
                  <input id="inW" aria-label="Custom width" type="number" min="240" max="4096" step="1" value="1280" />
                </label>
                <label>
                  Custom height
                  <input id="inH" aria-label="Custom height" type="number" min="240" max="4096" step="1" value="720" />
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Margins (%)
                  <input id="inMargins" aria-label="Margins percent" type="number" min="0" max="25" step="0.5" value="8" />
                </label>
                <label>
                  Grid density
                  <select id="inGrid" aria-label="Grid density">
                    <option value="8">8×8</option>
                    <option value="10">10×10</option>
                    <option value="12" selected>12×12</option>
                    <option value="16">16×16</option>
                  </select>
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Background image
                  <input id="inBgImg" aria-label="Background image file" type="file" accept="image/*" />
                </label>
                <label>
                  Image fit
                  <select id="inBgFit" aria-label="Background image fit">
                    <option value="cover">Cover</option>
                    <option value="contain">Contain</option>
                    <option value="stretch">Stretch</option>
                  </select>
                </label>
              </div>
              <div class="toggle" style="margin-top:10px" aria-label="Grid toggle">
                <div>
                  <b>Grid</b>
                  <span>Composition grid overlay</span>
                </div>
                <div class="switch on" id="swGrid" role="switch" tabindex="0" aria-checked="true" aria-label="Grid on or off"><i></i></div>
              </div>
              <div class="toggle" style="margin-top:10px" aria-label="Safe area toggle">
                <div>
                  <b>Safe area</b>
                  <span>Margins and center guides</span>
                </div>
                <div class="switch on" id="swSafe" role="switch" tabindex="0" aria-checked="true" aria-label="Safe area on or off"><i></i></div>
              </div>
            </div>
          </details>

          <details class="group">
            <summary>
              <div class="t"><b>Project</b><span>Duration, FPS, and tools</span></div>
              <span aria-hidden="true" style="color:var(--faint)">⚙</span>
            </summary>
            <div class="body">
              <div class="row">
                <label>
                  Duration (sec)
                  <input id="inDur" aria-label="Duration seconds" type="number" min="0.5" max="60" step="0.1" value="5" />
                </label>
                <label>
                  FPS
                  <input id="inFps" aria-label="Frames per second" type="number" min="12" max="60" step="1" value="30" />
                </label>
              </div>
              <div class="pillbar" style="margin-top:10px">
                <button class="pill" id="btnCenter" aria-pressed="false">Center text</button>
                <button class="pill" id="btnFit" aria-pressed="false">Fit to safe area</button>
                <button class="pill" id="btnClearAudio" aria-pressed="false">Clear audio</button>
              </div>
              <div class="kv" aria-label="Project statistics">
                <div><b style="color:var(--text)">Frames</b> <span style="color:var(--muted)">at fps</span></div>
                <code id="projFrames">150</code>
              </div>
            </div>
          </details>
        </div>
      </aside>

      <main aria-label="Preview and timeline">
        <div class="stageWrap">
          <div class="stage" id="stage" aria-label="Canvas preview">
            <canvas id="canvas" width="1280" height="720" aria-label="Animation preview canvas"></canvas>
            <div class="hud" aria-hidden="true">
              <div class="badge"><span class="dot" id="playDot"></span><span id="playLabel">Paused</span></div>
              <div class="badge"><span id="audioBadge">Audio: off</span></div>
              <div class="badge"><span id="presetBadge">Preset: fade-up</span></div>
            </div>
            <div class="cornerHelp" aria-hidden="false">
              <button class="btn icon small" id="btnPlay" aria-label="Play or pause (Space)"><svg class="iconSvg" id="icoPlay" viewBox="0 0 24 24" fill="none"><path d="M9 7v10l10-5-10-5Z" fill="currentColor"/></svg></button>
              <button class="btn icon small" id="btnStepBack" aria-label="Previous frame (Comma)"><svg class="iconSvg muted" viewBox="0 0 24 24" fill="none"><path d="M11 7v10M19 7l-6 5 6 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
              <button class="btn icon small" id="btnStepFwd" aria-label="Next frame (Period)"><svg class="iconSvg muted" viewBox="0 0 24 24" fill="none"><path d="M13 7v10M5 7l6 5-6 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
            </div>
            <div class="toast" id="toast" role="status" aria-live="polite"></div>
          </div>
        </div>

        <div class="timeline" aria-label="Timeline">
          <div class="tlTop">
            <div class="tlControls" aria-label="Timeline controls">
              <button class="btn icon" id="btnTlPlay" aria-label="Play or pause (Space)"><svg class="iconSvg" id="icoTlPlay" viewBox="0 0 24 24" fill="none"><path d="M9 7v10l10-5-10-5Z" fill="currentColor"/></svg></button>
              <button class="btn icon" id="btnTlStop" aria-label="Stop (Shift Space)"><svg class="iconSvg muted" viewBox="0 0 24 24" fill="none"><path d="M7 7h10v10H7z" fill="currentColor" opacity=".9"/></svg></button>
              <button class="btn" id="btnAddKF2" aria-label="Add keyframe (K)"><svg class="iconSvg" viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg><span>Add</span></button>
              <button class="btn danger" id="btnDelKF" aria-label="Delete selected keyframe (Delete)"><svg class="iconSvg" viewBox="0 0 24 24" fill="none"><path d="M6 7h12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M9 7V5h6v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M8 7l1 14h6l1-14" stroke="currentColor" stroke-width="2" stroke-linejoin="round" opacity=".8"/></svg><span>Delete</span></button>
              <div class="timeReadout" aria-label="Time readout"><span>t</span><b id="timeNow">0.00</b><span>/</span><span id="timeDur">5.00</span><span>sec</span><span aria-hidden="true">•</span><span>frame</span><b id="frameNow">0</b></div>
            </div>
            <div class="tlControls" aria-label="Timeline zoom and snapping">
              <div class="chip" aria-label="Zoom"><span aria-hidden="true">Zoom</span><code id="zoomRead">1.0×</code></div>
              <input id="inZoom" type="range" min="0.5" max="4" step="0.01" value="1" aria-label="Timeline zoom" />
              <div class="chip" aria-label="Snap"><span aria-hidden="true">Snap</span><code id="snapRead">beat</code></div>
            </div>
          </div>
          <div class="tlTrack" id="tlTrack" aria-label="Timeline track">
            <canvas class="tlCanvas" id="tlCanvas" width="1200" height="88" aria-label="Timeline canvas"></canvas>
          </div>
          <div class="tlLegend" aria-label="Timeline legend">
            <span class="sw" aria-hidden="true"></span> <span>Keyframes</span>
            <span class="sw2" aria-hidden="true"></span> <span>Beats</span>
            <span style="margin-left:auto;color:var(--faint)">Drag playhead • Drag keyframes • Hold <span class="kbd">Shift</span> to disable snapping</span>
          </div>
        </div>
      </main>
    </div>

    <dialog id="dlgHelp" aria-label="Help dialog">
      <div class="modalHead">
        <h2>Help & Shortcuts</h2>
        <button class="btn icon small" data-close aria-label="Close help"><svg class="iconSvg" viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg></button>
      </div>
      <div class="modalBody">
        <div class="helpGrid">
          <div class="group" style="margin:0">
            <div class="body">
              <div class="note">
                <b>Quick start</b>
                <div style="margin-top:8px;display:grid;gap:6px">
                  <div>1) Pick a preset (Motion)</div>
                  <div>2) Press <span class="kbd">K</span> to add keyframes as you scrub</div>
                  <div>3) (Optional) Load audio → Detect beats → Snap keyframes</div>
                  <div>4) Export to WebM/GIF/PNG/MP4</div>
                </div>
              </div>
              <div class="statusLine">
                <span><span class="kbd">Space</span> play/pause</span>
                <span><span class="kbd">Shift</span> + <span class="kbd">Space</span> stop</span>
                <span><span class="kbd">←</span>/<span class="kbd">→</span> nudge time</span>
                <span><span class="kbd">,</span>/<span class="kbd">.</span> prev/next frame</span>
              </div>
              <div class="statusLine">
                <span><span class="kbd">K</span> add keyframe</span>
                <span><span class="kbd">Delete</span> delete keyframe</span>
                <span><span class="kbd">Ctrl/⌘ E</span> export</span>
                <span><span class="kbd">S</span> sidebar (mobile)</span>
              </div>
            </div>
          </div>
          <div class="group" style="margin:0">
            <div class="body">
              <div class="note">
                <b>Tips</b>
                <ul style="margin:8px 0 0 16px; padding:0; color:rgba(232,236,255,.9); line-height:1.35; font-size:12px">
                  <li>Use <b>typewriter</b> + letter stagger for crisp reveals.</li>
                  <li><b>Glitch</b> is auto-reduced when <code>prefers-reduced-motion</code> is enabled.</li>
                  <li>Drag the canvas to <b>reposition</b> the text block.</li>
                  <li>Hold <b>Shift</b> while dragging keyframes to bypass snapping.</li>
                </ul>
              </div>
              <div class="note" style="margin-top:10px">
                <b>Accessibility</b>:
                Controls have labels and focus order; timeline is keyboard-nudgeable; effects respect reduced motion.
              </div>
            </div>
          </div>
        </div>
      </div>
    </dialog>

    <dialog id="dlgExport" aria-label="Export dialog">
      <div class="modalHead">
        <h2>Export</h2>
        <button class="btn icon small" data-close aria-label="Close export"><svg class="iconSvg" viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg></button>
      </div>
      <div class="modalBody">
        <div class="modalGrid">
          <div class="group" style="margin:0">
            <div class="body">
              <div class="row">
                <label>
                  Format
                  <select id="exFormat" aria-label="Export format">
                    <option value="webm">WebM (MediaRecorder)</option>
                    <option value="gif">GIF (gif.js)</option>
                    <option value="png">PNG sequence (.zip)</option>
                    <option value="mp4">MP4 (ffmpeg.wasm, experimental)</option>
                  </select>
                </label>
                <label>
                  Render
                  <select id="exRange" aria-label="Export range">
                    <option value="full">Full duration</option>
                    <option value="2s">First 2 seconds</option>
                    <option value="1s">First 1 second</option>
                  </select>
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  FPS
                  <input id="exFps" aria-label="Export fps" type="number" min="12" max="60" step="1" value="30" />
                </label>
                <label>
                  Scale
                  <select id="exScale" aria-label="Export resolution scale">
                    <option value="1">1×</option>
                    <option value="1.5">1.5×</option>
                    <option value="2">2×</option>
                  </select>
                  <span class="hint">Scales current project resolution.</span>
                </label>
              </div>
              <div class="row" style="margin-top:10px">
                <label>
                  Background
                  <select id="exBgMode" aria-label="Export background mode">
                    <option value="project">Use project background</option>
                    <option value="transparent">Transparent (where supported)</option>
                    <option value="black">Black</option>
                    <option value="white">White</option>
                  </select>
                </label>
                <label>
                  UI chrome
                  <select id="exChrome" aria-label="UI chrome">
                    <option value="none">Render canvas only</option>
                    <option value="watermark">Small watermark</option>
                  </select>
                </label>
              </div>
              <div class="pillbar" style="margin-top:10px">
                <button class="pill" id="btnStartExport" aria-pressed="false">Start export</button>
                <button class="pill" id="btnCancelExport" aria-pressed="false">Cancel</button>
              </div>
              <div class="statusLine">
                <div class="progress" aria-label="Export progress"><i id="exProg"></i></div>
                <div id="exStatus">Ready.</div>
              </div>
              <div class="note" style="margin-top:10px">
                <b>Note</b>: WebM export runs in real time (duration seconds). PNG/GIF/MP4 renders offline and may take longer. All processing stays local.
              </div>
            </div>
          </div>
          <div class="group" style="margin:0">
            <div class="body">
              <div class="note">
                <b>Export quality</b>
                <div style="margin-top:8px;display:grid;gap:8px">
                  <div>• Use higher resolution + motion blur for premium output.</div>
                  <div>• For glitch/liquid, consider enabling reduced motion if you need accessibility-friendly deliverables.</div>
                  <div>• MP4 requires loading ffmpeg.wasm (large download). WebM is fastest.</div>
                </div>
              </div>
              <div class="kv" style="margin-top:10px">
                <div><b style="color:var(--text)">Project</b> <span style="color:var(--muted)">render size</span></div>
                <code id="exProjInfo">1280×720 @ 30fps</code>
              </div>
              <div class="kv">
                <div><b style="color:var(--text)">Frames</b> <span style="color:var(--muted)">this export</span></div>
                <code id="exFrames">150</code>
              </div>
              <div class="kv">
                <div><b style="color:var(--text)">Tips</b></div>
                <code>Press Ctrl/⌘ E anytime</code>
              </div>
            </div>
          </div>
        </div>
      </div>
    </dialog>

    <div class="srOnly" aria-live="polite" id="srLive"></div>
  </div>

  <script>
    (() => {
      "use strict";

      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
      const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const invLerp = (a, b, v) => (v - a) / (b - a);
      const mod = (n, m) => ((n % m) + m) % m;
      const now = () => performance.now();
      const prefersReducedMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

      const EASE_PRESETS = {
        linear: { bezier: [0,0,1,1], label:"Linear" },
        easeInOut: { bezier: [0.42,0,0.58,1], label:"Ease in-out" },
        easeOut: { bezier: [0,0,0.2,1], label:"Ease out" },
        easeIn: { bezier: [0.4,0,1,1], label:"Ease in" },
        easeOutBack: { bezier: [0.12, 0.75, 0.19, 1.25], label:"Back" },
        easeOutElastic: { bezier: [0.1, 0.9, 0.2, 1.2], label:"Elastic-ish" },
      };

      function uid() {
        return Math.random().toString(16).slice(2) + "-" + Math.random().toString(16).slice(2);
      }

      function fmtTime(t) {
        return (Math.round(t * 100) / 100).toFixed(2);
      }

      function safeParseFloat(v, fallback) {
        const n = Number(v);
        return Number.isFinite(n) ? n : fallback;
      }

      function cssSwitch(el, on) {
        el.classList.toggle("on", !!on);
        el.setAttribute("aria-checked", on ? "true" : "false");
      }

      function toast(msg, ms=1600) {
        const t = $("#toast");
        t.textContent = msg;
        t.classList.add("show");
        $("#srLive").textContent = msg;
        clearTimeout(toast._tm);
        toast._tm = setTimeout(() => t.classList.remove("show"), ms);
      }

      function downloadBlob(blob, filename) {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(a.href), 8000);
      }

      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = src;
          s.async = true;
          s.onload = () => resolve();
          s.onerror = () => reject(new Error("Failed to load: " + src));
          document.head.appendChild(s);
        });
      }

      // Cubic Bezier (x,y) where x is time. Invert x via Newton-Raphson.
      function cubicBezier(p1x, p1y, p2x, p2y) {
        const cx = 3 * p1x;
        const bx = 3 * (p2x - p1x) - cx;
        const ax = 1 - cx - bx;
        const cy = 3 * p1y;
        const by = 3 * (p2y - p1y) - cy;
        const ay = 1 - cy - by;
        const sampleX = (t) => ((ax * t + bx) * t + cx) * t;
        const sampleY = (t) => ((ay * t + by) * t + cy) * t;
        const sampleDerivX = (t) => (3 * ax * t + 2 * bx) * t + cx;
        return (x) => {
          x = clamp(x, 0, 1);
          let t = x;
          for (let i = 0; i < 8; i++) {
            const x2 = sampleX(t) - x;
            const d = sampleDerivX(t);
            if (Math.abs(x2) < 1e-5) break;
            if (Math.abs(d) < 1e-6) break;
            t = t - x2 / d;
          }
          // Fallback bisection
          let t0 = 0, t1 = 1;
          if (!(t >= 0 && t <= 1)) t = x;
          for (let i = 0; i < 10; i++) {
            const x2 = sampleX(t);
            if (Math.abs(x2 - x) < 1e-5) break;
            if (x > x2) t0 = t; else t1 = t;
            t = (t0 + t1) / 2;
          }
          return clamp(sampleY(t), 0, 1);
        };
      }

      function easeFnFromKey(key) {
        const p = EASE_PRESETS[key] || EASE_PRESETS.easeInOut;
        const [x1,y1,x2,y2] = p.bezier;
        return cubicBezier(x1,y1,x2,y2);
      }

      function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }

      const project = {
        settings: {
          width: 1280,
          height: 720,
          aspect: "16:9",
          fps: 30,
          duration: 5,
          bgColor: "#0b1020",
          bgImage: null,
          bgFit: "cover",
          gridOn: true,
          safeOn: true,
          marginsPct: 8,
          gridN: 12,
        },
        text: {
          content: "Kinetic\nTypography",
          align: "center",
          lineHeight: 1.05,
          boxWPercent: 86,
          maxLines: 10,
          fontFamily: "Inter, ui-sans-serif, system-ui",
          fontSize: 120,
          fontWeight: 800,
          fontStyle: "normal",
          fill: "#f2f5ff",
          outlineOn: false,
          outlineW: 3,
          outlineC: "#090b12",
          shadowOn: true,
          shadowX: 0,
          shadowY: 12,
          shadowBlur: 18,
          shadowA: 0.35,
          gradOn: false,
          gradA: "#7c5cff",
          gradB: "#4dd6ff",
          motionBlur: false,
        },
        motion: {
          preset: "fade-up",
          staggerMode: "letter",
          stagger: 0.02,
          localDur: 0.7,
          // Base values (these also reflect the currently selected keyframe)
          base: {
            posX: 50,
            posY: 50,
            scale: 1,
            rot: 0,
            opacity: 1,
            tracking: 1.0,
            letterOffset: 28,
            wordOffset: 0,
          },
          easePreset: "easeInOut",
          customBezier: [0.42, 0, 0.58, 1],
        },
        audio: {
          fileName: "",
          url: "",
          enabled: false,
          snapMode: "beat",
          beatsPerBar: 4,
          bpm: 120,
          beatTimes: [],
          detected: false,
          reactiveOn: false,
          reactScale: 0.18,
          reactGlitch: 0.25,
        },
        keyframes: [],
        selection: { keyframeId: null },
      };

      // Keyframes store full values snapshot and easing from this keyframe to next.
      function ensureDefaultKeyframes() {
        if (project.keyframes.length) return;
        const t0 = {
          id: uid(),
          time: 0,
          values: {
            posX: 50, posY: 54,
            scale: 1,
            rot: 0,
            opacity: 0,
            tracking: 10,
            letterOffset: 40,
            wordOffset: 0,
          },
          ease: { mode: "preset", preset: "easeOut", bezier: deepClone(project.motion.customBezier) },
        };
        const t1 = {
          id: uid(),
          time: 1.2,
          values: {
            posX: 50, posY: 50,
            scale: 1,
            rot: 0,
            opacity: 1,
            tracking: 1.0,
            letterOffset: 0,
            wordOffset: 0,
          },
          ease: { mode: "preset", preset: "easeInOut", bezier: deepClone(project.motion.customBezier) },
        };
        const t2 = {
          id: uid(),
          time: Math.max(1.2, project.settings.duration - 0.2),
          values: deepClone(t1.values),
          ease: { mode: "preset", preset: "easeInOut", bezier: deepClone(project.motion.customBezier) },
        };
        project.keyframes = [t0, t1, t2].sort((a,b) => a.time - b.time);
        project.selection.keyframeId = t1.id;
      }

      function rebuildKeyframesFromPreset(preset) {
        const dur = project.settings.duration;
        const base = deepClone(project.motion.base);
        const k0 = { id: uid(), time: 0, values: deepClone(base), ease: { mode:"preset", preset:"easeOut", bezier: deepClone(project.motion.customBezier) } };
        const k1 = { id: uid(), time: clamp(dur * 0.22, 0.4, 1.8), values: deepClone(base), ease: { mode:"preset", preset:"easeInOut", bezier: deepClone(project.motion.customBezier) } };
        const k2 = { id: uid(), time: Math.max(k1.time, dur - 0.2), values: deepClone(base), ease: { mode:"preset", preset:"easeInOut", bezier: deepClone(project.motion.customBezier) } };

        if (preset === "fade-up") {
          k0.values.opacity = 0;
          k0.values.posY = clamp(base.posY + 6, 0, 100);
          k0.values.letterOffset = Math.max(18, base.letterOffset || 28);
          k0.values.tracking = Math.max(8, base.tracking || 1);
          k1.values.opacity = 1;
          k1.values.posY = base.posY;
          k1.values.tracking = base.tracking;
          k1.values.letterOffset = 0;
        } else if (preset === "typewriter") {
          k0.values.opacity = 1;
          k0.values.letterOffset = 0;
          k0.values.tracking = Math.max(1, base.tracking);
          k1.values.opacity = 1;
          k1.values.letterOffset = 0;
        } else if (preset === "bounce") {
          k0.values.opacity = 0;
          k0.values.scale = 0.92;
          k0.values.posY = clamp(base.posY + 4, 0, 100);
          k0.ease.preset = "easeOutBack";
          k1.values.opacity = 1;
          k1.values.scale = 1;
          k1.values.posY = base.posY;
          k1.ease.preset = "easeOutBack";
        } else if (preset === "liquid") {
          k0.values.opacity = 0;
          k0.values.tracking = Math.max(6, base.tracking);
          k0.values.letterOffset = Math.max(14, base.letterOffset);
          k1.values.opacity = 1;
          k1.values.tracking = base.tracking;
          k1.values.letterOffset = 0;
          k1.ease.preset = "easeInOut";
        } else if (preset === "glitch") {
          k0.values.opacity = 0;
          k0.values.tracking = Math.max(10, base.tracking);
          k0.values.rot = base.rot;
          k0.ease.preset = "easeOut";
          k1.values.opacity = 1;
          k1.values.tracking = base.tracking;
        } else if (preset === "cascade") {
          k0.values.opacity = 0;
          k0.values.letterOffset = 60;
          k0.values.tracking = Math.max(6, base.tracking);
          k1.values.opacity = 1;
          k1.values.letterOffset = 0;
          k1.values.tracking = base.tracking;
        }

        project.keyframes = [k0, k1, k2].sort((a,b) => a.time - b.time);
        project.selection.keyframeId = k1.id;
        toast("Keyframes rebuilt: " + preset);
      }

      function sortKeyframes() {
        project.keyframes.sort((a,b) => a.time - b.time);
      }

      function getSelectedKeyframe() {
        return project.keyframes.find(k => k.id === project.selection.keyframeId) || null;
      }

      function addKeyframe(atTime) {
        const t = clamp(atTime, 0, project.settings.duration);
        const v = deepClone(getValuesAtTime(t));
        const id = uid();
        project.keyframes.push({
          id,
          time: t,
          values: v,
          ease: { mode:"preset", preset: project.motion.easePreset, bezier: deepClone(project.motion.customBezier) },
        });
        sortKeyframes();
        project.selection.keyframeId = id;
        syncMotionInputsFromSelected();
        toast("Keyframe added at " + fmtTime(t) + "s");
      }

      function deleteSelectedKeyframe() {
        const k = getSelectedKeyframe();
        if (!k) return;
        if (project.keyframes.length <= 2) { toast("Keep at least 2 keyframes"); return; }
        const idx = project.keyframes.findIndex(x => x.id === k.id);
        project.keyframes.splice(idx, 1);
        project.selection.keyframeId = project.keyframes[Math.max(0, idx - 1)]?.id ?? project.keyframes[0].id;
        syncMotionInputsFromSelected();
        toast("Keyframe deleted");
      }

      function snapTime(t, mode, allowSnap) {
        if (!allowSnap) return t;
        if (!project.audio.beatTimes.length) return t;
        const beatsPerBar = Math.max(2, Math.floor(project.audio.beatsPerBar));
        const times = project.audio.beatTimes;
        const seek = (arr, target) => {
          let lo = 0, hi = arr.length - 1;
          while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (arr[mid] < target) lo = mid + 1; else hi = mid;
          }
          let i = lo;
          if (i > 0 && Math.abs(arr[i - 1] - target) < Math.abs(arr[i] - target)) i = i - 1;
          return arr[i];
        };
        if (mode === "beat") return seek(times, t);
        if (mode === "bar") {
          const bars = times.filter((_, i) => i % beatsPerBar === 0);
          if (!bars.length) return t;
          return seek(bars, t);
        }
        return t;
      }

      function applySnapToSelected() {
        const k = getSelectedKeyframe();
        if (!k) return;
        const allow = project.audio.snapMode !== "none";
        const snapped = snapTime(k.time, project.audio.snapMode, allow);
        k.time = clamp(snapped, 0, project.settings.duration);
        sortKeyframes();
        toast("Snapped keyframe to " + fmtTime(k.time) + "s");
      }

      function getValuesAtTime(t) {
        ensureDefaultKeyframes();
        sortKeyframes();
        const ks = project.keyframes;
        if (t <= ks[0].time) return deepClone(ks[0].values);
        if (t >= ks[ks.length - 1].time) return deepClone(ks[ks.length - 1].values);
        let i = 0;
        for (; i < ks.length - 1; i++) {
          if (t >= ks[i].time && t <= ks[i + 1].time) break;
        }
        const a = ks[i], b = ks[i + 1];
        const span = Math.max(1e-6, b.time - a.time);
        const raw = clamp((t - a.time) / span, 0, 1);
        let ease = easeFnFromKey(a.ease?.preset || "easeInOut");
        if (a.ease?.mode === "bezier" && Array.isArray(a.ease?.bezier)) {
          const [x1,y1,x2,y2] = a.ease.bezier;
          ease = cubicBezier(x1,y1,x2,y2);
        }
        const tt = ease(raw);
        const out = {};
        for (const k of Object.keys(a.values)) {
          const av = a.values[k];
          const bv = b.values[k] ?? av;
          out[k] = lerp(av, bv, tt);
        }
        return out;
      }

      // --- Rendering ---
      const canvas = $("#canvas");
      const ctx = canvas.getContext("2d");
      const tlCanvas = $("#tlCanvas");
      const tlCtx = tlCanvas.getContext("2d");

      const stage = $("#stage");
      const state = {
        playing: false,
        t: 0,
        lastTs: 0,
        drag: null,
        tl: { zoom: 1, drag: null, hoverKF: null, hoverPlayhead: false },
        layoutCache: { key: "", glyphs: [], lines: [], metrics: null },
        audio: {
          el: null,
          ctx: null,
          analyser: null,
          srcNode: null,
          data: null,
          energy: 0,
        },
        export: { cancel: false, busy: false },
      };

      function setCanvasSize(w, h) {
        canvas.width = w;
        canvas.height = h;
        $("#exProjInfo").textContent = `${w}×${h} @ ${project.settings.fps}fps`;
        renderOnce();
      }

      function stageToProjectPx(clientX, clientY) {
        const r = canvas.getBoundingClientRect();
        const x = (clientX - r.left) / Math.max(1, r.width) * canvas.width;
        const y = (clientY - r.top) / Math.max(1, r.height) * canvas.height;
        return { x, y };
      }

      function getTextLayoutKey(values) {
        const t = project.text;
        const s = project.settings;
        return [
          t.content, t.fontFamily, t.fontSize, t.fontWeight, t.fontStyle, t.align, t.lineHeight,
          Math.round(values.tracking * 100) / 100,
          t.boxWPercent, t.maxLines,
          s.width, s.height
        ].join("|");
      }

      function prepareTextLayout(values) {
        const key = getTextLayoutKey(values);
        if (state.layoutCache.key === key) return state.layoutCache;
        const t = project.text;
        const s = project.settings;
        const maxW = s.width * (t.boxWPercent / 100);

        ctx.save();
        ctx.font = `${t.fontStyle} ${t.fontWeight} ${t.fontSize}px ${t.fontFamily}`;
        ctx.textBaseline = "alphabetic";
        ctx.textAlign = "left";

        const raw = (t.content || "").replace(/\r/g, "");
        const manualLines = raw.split("\n");
        const wrapLines = [];
        for (const line of manualLines) {
          const words = line.split(/(\s+)/).filter(w => w.length > 0);
          let cur = "";
          for (const token of words) {
            const next = cur + token;
            const w = ctx.measureText(next).width + values.tracking * Math.max(0, next.replace(/\s/g,"").length - 1);
            if (w > maxW && cur.trim().length > 0 && token.trim().length > 0) {
              wrapLines.push(cur.trimEnd());
              cur = token.trimStart();
            } else {
              cur = next;
            }
          }
          wrapLines.push(cur);
        }
        const lines = wrapLines.slice(0, Math.max(1, Math.floor(t.maxLines || 10)));
        const fontSize = t.fontSize;
        const lineH = fontSize * t.lineHeight;

        const glyphs = [];
        let y = 0;
        let maxLineW = 0;
        const lineInfo = [];
        for (let li = 0; li < lines.length; li++) {
          const line = lines[li] ?? "";
          const chars = Array.from(line);
          // Measure with tracking.
          let lineW = 0;
          for (let i = 0; i < chars.length; i++) {
            const ch = chars[i];
            const w = ctx.measureText(ch).width;
            lineW += w;
            if (i !== chars.length - 1 && ch !== " " && chars[i+1] !== " ") lineW += values.tracking;
            if (i !== chars.length - 1 && ch === " " && chars[i+1] !== " ") lineW += values.tracking * 0.25;
          }
          maxLineW = Math.max(maxLineW, lineW);
          lineInfo.push({ text: line, width: lineW });
        }

        const totalH = lineInfo.length * lineH;
        const baseYTop = -totalH / 2 + lineH * 0.85;
        for (let li = 0; li < lineInfo.length; li++) {
          const line = lineInfo[li].text;
          const chars = Array.from(line);
          const wLine = lineInfo[li].width;
          let x0 = -wLine / 2;
          if (t.align === "left") x0 = -maxW / 2;
          if (t.align === "right") x0 = maxW / 2 - wLine;
          let x = x0;
          let wordIndex = -1;
          let inWord = false;
          for (let ci = 0; ci < chars.length; ci++) {
            const ch = chars[ci];
            if (ch.trim().length === 0) { inWord = false; }
            else if (!inWord) { inWord = true; wordIndex++; }
            const w = ctx.measureText(ch).width;
            glyphs.push({
              ch,
              line: li,
              char: ci,
              word: wordIndex,
              x,
              y: baseYTop + li * lineH,
              w,
            });
            x += w;
            if (ci !== chars.length - 1 && ch !== " " && chars[ci+1] !== " ") x += values.tracking;
            if (ci !== chars.length - 1 && ch === " " && chars[ci+1] !== " ") x += values.tracking * 0.25;
          }
        }
        ctx.restore();

        state.layoutCache = { key, glyphs, lines: lineInfo, metrics: { maxW, maxLineW, totalH, lineH } };
        return state.layoutCache;
      }

      function chooseFill(ctx2, w, h) {
        if (!project.text.gradOn) {
          ctx2.fillStyle = project.text.fill;
          return;
        }
        const g = ctx2.createLinearGradient(-w/2, -h/2, w/2, h/2);
        g.addColorStop(0, project.text.gradA);
        g.addColorStop(1, project.text.gradB);
        ctx2.fillStyle = g;
      }

      function drawBackground(ctx2, w, h, mode="project") {
        if (mode === "transparent") {
          ctx2.clearRect(0,0,w,h);
          return;
        }
        const c = mode === "black" ? "#000000" : mode === "white" ? "#ffffff" : project.settings.bgColor;
        ctx2.fillStyle = c;
        ctx2.fillRect(0,0,w,h);

        const img = project.settings.bgImage;
        if (!img || mode !== "project") return;
        const fit = project.settings.bgFit;
        const iw = img.naturalWidth || img.width;
        const ih = img.naturalHeight || img.height;
        if (!iw || !ih) return;
        if (fit === "stretch") {
          ctx2.drawImage(img, 0, 0, w, h);
          return;
        }
        const scale = fit === "contain" ? Math.min(w/iw, h/ih) : Math.max(w/iw, h/ih);
        const dw = iw * scale, dh = ih * scale;
        const dx = (w - dw)/2, dy = (h - dh)/2;
        ctx2.globalAlpha = 0.9;
        ctx2.drawImage(img, dx, dy, dw, dh);
        ctx2.globalAlpha = 1;
      }

      function drawGuides(ctx2, w, h) {
        const margins = clamp(project.settings.marginsPct / 100, 0, 0.35);
        const mx = w * margins, my = h * margins;
        if (project.settings.gridOn) {
          const n = Math.max(2, Math.floor(project.settings.gridN || 12));
          ctx2.save();
          ctx2.lineWidth = 1;
          ctx2.globalAlpha = 1;
          for (let i = 1; i < n; i++) {
            const x = (w - 2*mx) * i / n + mx;
            ctx2.strokeStyle = (i % 3 === 0) ? getComputedStyle(document.documentElement).getPropertyValue("--grid").trim() : getComputedStyle(document.documentElement).getPropertyValue("--grid2").trim();
            ctx2.beginPath(); ctx2.moveTo(x, my); ctx2.lineTo(x, h - my); ctx2.stroke();
          }
          for (let i = 1; i < n; i++) {
            const y = (h - 2*my) * i / n + my;
            ctx2.strokeStyle = (i % 3 === 0) ? getComputedStyle(document.documentElement).getPropertyValue("--grid").trim() : getComputedStyle(document.documentElement).getPropertyValue("--grid2").trim();
            ctx2.beginPath(); ctx2.moveTo(mx, y); ctx2.lineTo(w - mx, y); ctx2.stroke();
          }
          ctx2.restore();
        }
        if (project.settings.safeOn) {
          ctx2.save();
          ctx2.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--safe").trim();
          ctx2.lineWidth = 2;
          ctx2.setLineDash([8, 10]);
          ctx2.strokeRect(mx, my, w - 2*mx, h - 2*my);
          ctx2.setLineDash([]);
          ctx2.lineWidth = 1;
          ctx2.globalAlpha = 0.8;
          ctx2.beginPath(); ctx2.moveTo(w/2, my); ctx2.lineTo(w/2, h - my); ctx2.stroke();
          ctx2.beginPath(); ctx2.moveTo(mx, h/2); ctx2.lineTo(w - mx, h/2); ctx2.stroke();
          ctx2.restore();
        }
      }

      function glyphOrderIndex(g, layout) {
        const mode = project.motion.staggerMode;
        if (mode === "letter") return g.line * 10000 + g.char;
        if (mode === "word") return g.line * 10000 + Math.max(0, g.word) * 50 + g.char * 0.01;
        return g.line; // line
      }

      function localProgress(t, g, layout, baseDelay=0) {
        const st = Math.max(0, project.motion.stagger);
        const dur = Math.max(1e-4, project.motion.localDur);
        const idx = glyphOrderIndex(g, layout);
        const delay = baseDelay + idx * st;
        return clamp((t - delay) / dur, 0, 1);
      }

      function applyPresetEffects(preset, t, g, layout, vals, audioEnergy) {
        const p = localProgress(t, g, layout, 0);
        const e = easeFnFromKey(project.motion.easePreset)(p);
        const reduced = prefersReducedMotion;

        let alpha = 1;
        let ox = 0, oy = 0;
        let extraScale = 1;
        let extraRot = 0;
        let glitch = 0;
        let colorSplit = 0;

        const baseOff = vals.letterOffset || 0;
        const wordOff = vals.wordOffset || 0;
        const wordPhase = (Math.max(0, g.word) + 1) * 0.65;
        const charPhase = (g.char + 1) * 0.33;

        if (preset === "fade-up") {
          alpha = e;
          oy += lerp(baseOff, 0, e);
        } else if (preset === "typewriter") {
          // Reveal by hard step with a subtle ramp for anti-flicker.
          alpha = clamp(invLerp(0.02, 0.18, p), 0, 1);
          oy += lerp(8, 0, e) * 0.2;
        } else if (preset === "bounce") {
          alpha = e;
          const b = Math.sin(e * Math.PI) * (1 - e);
          oy += lerp(baseOff * 0.6, 0, e) + b * (18 + baseOff * 0.2);
          extraScale *= 1 + b * 0.06;
        } else if (preset === "liquid") {
          alpha = e;
          const w = reduced ? 0.6 : 1;
          const amp = (12 + Math.abs(baseOff) * 0.25) * w;
          const wave = Math.sin((t * 5.2) + charPhase + wordPhase) * amp;
          oy += lerp(baseOff * 0.35, 0, e) + wave * (0.55 + 0.45 * (1 - p));
          ox += Math.cos((t * 4.2) + charPhase) * (amp * 0.12);
        } else if (preset === "glitch") {
          alpha = e;
          const intensity = reduced ? 0.22 : 1;
          const reactive = project.audio.reactiveOn ? (audioEnergy * project.audio.reactGlitch) : 0;
          const sp = (Math.sin((t * 17.2) + charPhase * 1.9) * 0.5 + 0.5);
          glitch = intensity * (0.12 + 0.35 * sp + reactive);
          // Micro-jitter
          const j = (Math.sin((t * 43.0) + charPhase * 7.1) + Math.cos((t * 36.0) + wordPhase * 3.6)) * 0.5;
          ox += j * 8 * glitch;
          oy += (Math.cos((t * 37.0) + charPhase * 6.7)) * 5 * glitch;
          colorSplit = glitch;
        } else if (preset === "cascade") {
          alpha = e;
          oy += lerp(baseOff, 0, e);
          ox += Math.sin((t * 2.2) + wordPhase) * (wordOff * 0.15);
          // Gentle settle
          const settle = Math.sin(e * Math.PI) * (1 - e);
          oy += settle * 10;
        }

        // Word offset applies per word group as a bigger settle motion.
        if (wordOff !== 0 && g.word >= 0) {
          const wp = clamp((t - g.word * Math.max(0, project.motion.stagger) * 4) / Math.max(1e-4, project.motion.localDur * 1.1), 0, 1);
          const we = easeFnFromKey(project.motion.easePreset)(wp);
          oy += lerp(wordOff, 0, we) * 0.35;
        }

        // Audio-reactive scaling.
        if (project.audio.reactiveOn) {
          const r = clamp(audioEnergy, 0, 1);
          extraScale *= 1 + r * project.audio.reactScale;
        }

        return { alpha, ox, oy, extraScale, extraRot, glitch, colorSplit };
      }

      function drawText(ctx2, t, values, opts={}) {
        const w = ctx2.canvas.width, h = ctx2.canvas.height;
        const modeBg = opts.bgMode ?? "project";
        const showGuides = !!opts.guides;

        drawBackground(ctx2, w, h, modeBg);
        if (showGuides) drawGuides(ctx2, w, h);

        const layout = prepareTextLayout(values);
        const glyphs = layout.glyphs;

        const tx = (values.posX / 100) * w;
        const ty = (values.posY / 100) * h;

        const font = `${project.text.fontStyle} ${project.text.fontWeight} ${project.text.fontSize}px ${project.text.fontFamily}`;
        ctx2.save();
        ctx2.translate(tx, ty);
        ctx2.rotate((values.rot * Math.PI) / 180);
        ctx2.scale(values.scale, values.scale);
        ctx2.font = font;
        ctx2.textBaseline = "alphabetic";
        ctx2.textAlign = "left";
        ctx2.globalAlpha = 1;

        const baseOpacity = clamp(values.opacity, 0, 1);

        // Shadow
        if (project.text.shadowOn && !opts.disableShadow) {
          ctx2.shadowColor = `rgba(0,0,0,${clamp(project.text.shadowA,0,1)})`;
          ctx2.shadowBlur = Math.max(0, project.text.shadowBlur);
          ctx2.shadowOffsetX = project.text.shadowX;
          ctx2.shadowOffsetY = project.text.shadowY;
        } else {
          ctx2.shadowColor = "transparent";
          ctx2.shadowBlur = 0;
          ctx2.shadowOffsetX = 0;
          ctx2.shadowOffsetY = 0;
        }

        chooseFill(ctx2, w, h);

        // Audio energy for reactive effects.
        const audioEnergy = state.audio.energy || 0;

        const preset = project.motion.preset;
        for (let i = 0; i < glyphs.length; i++) {
          const g = glyphs[i];
          if (g.ch.length === 0) continue;
          const eff = applyPresetEffects(preset, t, g, layout, values, audioEnergy);
          const alpha = baseOpacity * eff.alpha;
          if (alpha <= 0.001) continue;

          const x = g.x + eff.ox;
          const y = g.y + eff.oy;

          ctx2.save();
          ctx2.globalAlpha = alpha;
          ctx2.translate(x, y);
          ctx2.scale(eff.extraScale, eff.extraScale);
          ctx2.rotate(eff.extraRot);

          // Glitch color split: draw slight offsets in brand colors.
          if (eff.colorSplit > 0.01 && !opts.disableGlitch) {
            const s = eff.colorSplit;
            ctx2.save();
            ctx2.shadowColor = "transparent";
            ctx2.shadowBlur = 0;
            ctx2.globalAlpha = alpha * 0.65;
            ctx2.fillStyle = "rgba(77,214,255,.85)";
            ctx2.fillText(g.ch, -1.5 * s, 0);
            ctx2.fillStyle = "rgba(124,92,255,.80)";
            ctx2.fillText(g.ch, 1.5 * s, 0);
            ctx2.restore();
            chooseFill(ctx2, w, h);
          }

          // Main fill
          ctx2.fillText(g.ch, 0, 0);

          // Outline
          if (project.text.outlineOn) {
            ctx2.lineWidth = project.text.outlineW;
            ctx2.strokeStyle = project.text.outlineC;
            ctx2.strokeText(g.ch, 0, 0);
          }
          ctx2.restore();
        }
        ctx2.restore();

        // Watermark if requested.
        if (opts.watermark) {
          ctx2.save();
          ctx2.globalAlpha = 0.65;
          ctx2.fillStyle = "rgba(255,255,255,.75)";
          ctx2.font = `600 14px ${project.text.fontFamily}`;
          ctx2.textAlign = "right";
          ctx2.textBaseline = "alphabetic";
          ctx2.fillText("Kinetic Typography Studio", w - 14, h - 14);
          ctx2.restore();
        }
      }

      function renderOnce() {
        const v = getValuesAtTime(state.t);
        // Update motion base to reflect current value if no keyframe selected? Keep selected separate.
        drawFrame(ctx, state.t, v, { guides: true });
        drawTimeline();
        updateHUD();
      }

      function drawFrame(ctx2, t, values, opts) {
        if (project.text.motionBlur && !prefersReducedMotion && (opts?.motionBlur !== false)) {
          const samples = 6;
          const span = 1 / Math.max(12, project.settings.fps);
          ctx2.save();
          ctx2.clearRect(0,0,ctx2.canvas.width, ctx2.canvas.height);
          for (let i = 0; i < samples; i++) {
            const tt = t - span * (1 - (i / (samples - 1)));
            const vv = getValuesAtTime(clamp(tt, 0, project.settings.duration));
            ctx2.globalAlpha = 1 / samples;
            drawText(ctx2, tt, vv, opts);
          }
          ctx2.restore();
          return;
        }
        drawText(ctx2, t, values, opts);
      }

      function updateHUD() {
        const playDot = $("#playDot");
        const playLabel = $("#playLabel");
        playLabel.textContent = state.playing ? "Playing" : "Paused";
        playDot.classList.toggle("off", !state.playing);
        $("#audioBadge").textContent = project.audio.fileName ? `Audio: ${project.audio.reactiveOn ? "reactive" : "loaded"}` : "Audio: off";
        $("#presetBadge").textContent = `Preset: ${project.motion.preset}`;
        $("#timeNow").textContent = fmtTime(state.t);
        $("#timeDur").textContent = fmtTime(project.settings.duration);
        const frame = Math.round(state.t * project.settings.fps);
        $("#frameNow").textContent = String(frame);
        $("#projFrames").textContent = String(Math.round(project.settings.duration * project.settings.fps));
      }

      function setPlaying(on) {
        if (state.playing === on) return;
        state.playing = on;
        const iconPath = on ? "M7 6h4v12H7zM13 6h4v12h-4z" : "M9 7v10l10-5-10-5Z";
        $("#icoPlay").innerHTML = `<path d="${iconPath}" fill="currentColor"></path>`;
        $("#icoTlPlay").innerHTML = `<path d="${iconPath}" fill="currentColor"></path>`;
        if (on) {
          state.lastTs = now();
          startAudioIfNeeded();
          requestAnimationFrame(tick);
        } else {
          pauseAudioIfNeeded();
        }
        updateHUD();
      }

      function stopPlayback() {
        setPlaying(false);
        seekTo(0, true);
      }

      function seekTo(t, fromUser=false) {
        state.t = clamp(t, 0, project.settings.duration);
        if (fromUser && state.audio.el && project.audio.fileName) {
          // Keep audio aligned when scrubbing (no auto-play)
          try { state.audio.el.currentTime = state.t; } catch {}
        }
        renderOnce();
      }

      function stepFrames(deltaFrames) {
        const dt = deltaFrames / Math.max(12, project.settings.fps);
        seekTo(state.t + dt, true);
      }

      function tick(ts) {
        if (!state.playing) return;
        const dt = (ts - state.lastTs) / 1000;
        state.lastTs = ts;
        const next = state.t + dt;
        if (next >= project.settings.duration) {
          seekTo(project.settings.duration, true);
          setPlaying(false);
          return;
        }
        state.t = next;
        // Sync audio currentTime to time when playing
        if (state.audio.el && project.audio.fileName) {
          const drift = Math.abs(state.audio.el.currentTime - state.t);
          if (drift > 0.08) {
            try { state.audio.el.currentTime = state.t; } catch {}
          }
        }
        updateAudioEnergy();
        renderOnce();
        requestAnimationFrame(tick);
      }

      // --- Timeline Drawing & Interaction ---
      function timelineScale() {
        return (state.tl.cssW / Math.max(0.001, project.settings.duration));
      }
      function timeToX(t) { return t * timelineScale(); }
      function xToTime(x) { return x / timelineScale(); }

      function resizeTimelineCanvas(keepPlayheadInView=true) {
        const track = $("#tlTrack");
        if (!track) return;
        const r = track.getBoundingClientRect();
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const cssH = Math.max(60, r.height);
        const cssBaseW = Math.max(600, r.width);
        const cssW = cssBaseW * state.tl.zoom;
        tlCanvas.style.width = cssW.toFixed(0) + "px";
        tlCanvas.style.height = cssH.toFixed(0) + "px";
        tlCanvas.width = Math.floor(cssW * dpr);
        tlCanvas.height = Math.floor(cssH * dpr);
        state.tl.dpr = dpr;
        state.tl.cssW = cssW;
        state.tl.cssH = cssH;
        if (keepPlayheadInView) {
          const pxCss = timeToX(state.t);
          const target = pxCss - cssBaseW * 0.45;
          track.scrollLeft = clamp(target, 0, Math.max(0, cssW - cssBaseW));
        }
        drawTimeline();
      }

      function drawTimeline() {
        const dpr = state.tl.dpr || 1;
        const w = state.tl.cssW || (tlCanvas.width / dpr);
        const h = state.tl.cssH || (tlCanvas.height / dpr);
        tlCtx.setTransform(1,0,0,1,0,0);
        tlCtx.clearRect(0,0,tlCanvas.width, tlCanvas.height);
        tlCtx.setTransform(dpr,0,0,dpr,0,0);

        // Background subtle grid
        tlCtx.save();
        tlCtx.globalAlpha = 0.9;
        const scale = timelineScale();
        const secPx = scale;
        const majorStep = secPx >= 220 ? 0.25 : secPx >= 120 ? 0.5 : 1;
        const minorStep = majorStep / 4;
        for (let t = 0; t <= project.settings.duration + 0.001; t += minorStep) {
          const x = timeToX(t);
          if (x < 0 || x > w) continue;
          const isMajor = Math.abs(mod(t, majorStep)) < 1e-6 || Math.abs(mod(t, majorStep) - majorStep) < 1e-6;
          tlCtx.strokeStyle = isMajor ? "rgba(255,255,255,.10)" : "rgba(255,255,255,.05)";
          tlCtx.beginPath();
          tlCtx.moveTo(x + 0.5, 0);
          tlCtx.lineTo(x + 0.5, h);
          tlCtx.stroke();
          if (isMajor) {
            tlCtx.fillStyle = "rgba(255,255,255,.45)";
            tlCtx.font = `11px ${getComputedStyle(document.documentElement).getPropertyValue("--mono").trim()}`;
            tlCtx.fillText(fmtTime(t), x + 6, 14);
          }
        }
        tlCtx.restore();

        // Beats
        if (project.audio.beatTimes.length) {
          tlCtx.save();
          for (let i = 0; i < project.audio.beatTimes.length; i++) {
            const bt = project.audio.beatTimes[i];
            if (bt < 0 || bt > project.settings.duration) continue;
            const x = timeToX(bt);
            if (x < 0 || x > w) continue;
            const bar = (i % Math.max(2, project.audio.beatsPerBar)) === 0;
            tlCtx.strokeStyle = bar ? "rgba(77,214,255,.35)" : "rgba(77,214,255,.18)";
            tlCtx.lineWidth = bar ? 2 : 1;
            tlCtx.beginPath();
            tlCtx.moveTo(x + 0.5, 22);
            tlCtx.lineTo(x + 0.5, h);
            tlCtx.stroke();
          }
          tlCtx.restore();
        }

        // Keyframes
        const ks = project.keyframes;
        const sel = project.selection.keyframeId;
        for (const kf of ks) {
          const x = timeToX(kf.time);
          const y = 52;
          const size = (kf.id === sel) ? 8 : 7;
          tlCtx.save();
          tlCtx.translate(x, y);
          tlCtx.rotate(Math.PI / 4);
          tlCtx.fillStyle = (kf.id === sel) ? "rgba(124,92,255,.95)" : "rgba(124,92,255,.75)";
          tlCtx.strokeStyle = (kf.id === sel) ? "rgba(255,255,255,.22)" : "rgba(0,0,0,.15)";
          tlCtx.lineWidth = 2;
          tlCtx.beginPath();
          tlCtx.rect(-size, -size, size*2, size*2);
          tlCtx.fill();
          tlCtx.stroke();
          tlCtx.restore();
        }

        // Playhead
        const px = timeToX(state.t);
        tlCtx.save();
        tlCtx.strokeStyle = "rgba(255,255,255,.55)";
        tlCtx.lineWidth = 2;
        tlCtx.beginPath();
        tlCtx.moveTo(px + 0.5, 0);
        tlCtx.lineTo(px + 0.5, h);
        tlCtx.stroke();
        tlCtx.fillStyle = "rgba(255,255,255,.75)";
        tlCtx.beginPath();
        tlCtx.moveTo(px, 0);
        tlCtx.lineTo(px - 6, 12);
        tlCtx.lineTo(px + 6, 12);
        tlCtx.closePath();
        tlCtx.fill();
        tlCtx.restore();
      }

      function timelineHitTest(clientX, clientY) {
        const r = tlCanvas.getBoundingClientRect();
        const x = (clientX - r.left);
        const y = (clientY - r.top);
        // Keyframes
        let best = null;
        let bestDist = 1e9;
        for (const kf of project.keyframes) {
          const kx = timeToX(kf.time);
          const dy = y - 52;
          const dx = x - kx;
          const d = Math.hypot(dx, dy);
          if (d < bestDist) { bestDist = d; best = kf; }
        }
        const onKF = best && bestDist < 12;
        // Playhead
        const px = timeToX(state.t);
        const onPH = Math.abs(x - px) < 10;
        return { x, y, onKF, kf: onKF ? best : null, onPH };
      }

      tlCanvas.addEventListener("pointerdown", (ev) => {
        tlCanvas.setPointerCapture(ev.pointerId);
        const hit = timelineHitTest(ev.clientX, ev.clientY);
        const bypassSnap = ev.shiftKey;
        if (hit.onKF && hit.kf) {
          project.selection.keyframeId = hit.kf.id;
          syncMotionInputsFromSelected();
          state.tl.drag = { kind: "kf", id: hit.kf.id, startX: hit.x, startTime: hit.kf.time, bypassSnap };
          renderOnce();
          return;
        }
        state.tl.drag = { kind: "playhead", bypassSnap };
        const tt = xToTime(hit.x);
        const snapped = snapTime(tt, project.audio.snapMode, project.audio.snapMode !== "none" && !bypassSnap);
        seekTo(snapped, true);
      });
      tlCanvas.addEventListener("pointermove", (ev) => {
        if (!state.tl.drag) return;
        const r = tlCanvas.getBoundingClientRect();
        const x = (ev.clientX - r.left);
        if (state.tl.drag.kind === "playhead") {
          const tt = xToTime(x);
          const snapped = snapTime(tt, project.audio.snapMode, project.audio.snapMode !== "none" && !state.tl.drag.bypassSnap);
          seekTo(snapped, true);
        } else if (state.tl.drag.kind === "kf") {
          const kf = project.keyframes.find(k => k.id === state.tl.drag.id);
          if (!kf) return;
          const tt = xToTime(x);
          const allow = project.audio.snapMode !== "none" && !state.tl.drag.bypassSnap;
          const snapped = snapTime(tt, project.audio.snapMode, allow);
          kf.time = clamp(snapped, 0, project.settings.duration);
          sortKeyframes();
          renderOnce();
        }
      });
      tlCanvas.addEventListener("pointerup", (ev) => {
        tlCanvas.releasePointerCapture(ev.pointerId);
        state.tl.drag = null;
      });
      tlCanvas.addEventListener("pointercancel", () => { state.tl.drag = null; });

      // --- Stage drag to reposition ---
      canvas.addEventListener("pointerdown", (ev) => {
        canvas.setPointerCapture(ev.pointerId);
        const pos = stageToProjectPx(ev.clientX, ev.clientY);
        state.drag = { id: ev.pointerId, kind: "move", start: pos, startVals: deepClone(getValuesAtTime(state.t)) };
      });
      canvas.addEventListener("pointermove", (ev) => {
        if (!state.drag || state.drag.id !== ev.pointerId) return;
        const cur = stageToProjectPx(ev.clientX, ev.clientY);
        const dx = cur.x - state.drag.start.x;
        const dy = cur.y - state.drag.start.y;
        const v = state.drag.startVals;
        const nx = clamp(((v.posX / 100) * canvas.width + dx) / canvas.width * 100, 0, 100);
        const ny = clamp(((v.posY / 100) * canvas.height + dy) / canvas.height * 100, 0, 100);
        // Apply to selected keyframe if exists, otherwise update base.
        const kf = getSelectedKeyframe();
        if (kf) {
          kf.values.posX = nx;
          kf.values.posY = ny;
          syncMotionInputsFromSelected(false);
        } else {
          project.motion.base.posX = nx;
          project.motion.base.posY = ny;
        }
        renderOnce();
      });
      canvas.addEventListener("pointerup", (ev) => {
        if (state.drag?.id === ev.pointerId) state.drag = null;
        try { canvas.releasePointerCapture(ev.pointerId); } catch {}
      });
      canvas.addEventListener("pointercancel", () => { state.drag = null; });

      // --- Easing editor ---
      const easeCanvas = $("#easeCanvas");
      const ectx = easeCanvas.getContext("2d");
      const easeState = { drag: null };

      function drawEaseEditor() {
        const w = easeCanvas.width, h = easeCanvas.height;
        ectx.clearRect(0,0,w,h);
        const pad = 14;
        const x0 = pad, y0 = h - pad;
        const x1 = w - pad, y1 = pad;

        // grid
        ectx.save();
        ectx.strokeStyle = "rgba(255,255,255,.06)";
        for (let i = 1; i < 4; i++) {
          const x = lerp(x0, x1, i/4);
          const y = lerp(y0, y1, i/4);
          ectx.beginPath(); ectx.moveTo(x, y0); ectx.lineTo(x, y1); ectx.stroke();
          ectx.beginPath(); ectx.moveTo(x0, y); ectx.lineTo(x1, y); ectx.stroke();
        }
        ectx.restore();

        // axes
        ectx.save();
        ectx.strokeStyle = "rgba(255,255,255,.14)";
        ectx.lineWidth = 2;
        ectx.beginPath(); ectx.moveTo(x0, y0); ectx.lineTo(x1, y0); ectx.stroke();
        ectx.beginPath(); ectx.moveTo(x0, y0); ectx.lineTo(x0, y1); ectx.stroke();
        ectx.restore();

        const kf = getSelectedKeyframe();
        const bez = (kf?.ease?.mode === "bezier" ? kf.ease.bezier : project.motion.customBezier) || [0.42,0,0.58,1];
        const [bx1, by1, bx2, by2] = bez;
        const p1 = { x: lerp(x0, x1, bx1), y: lerp(y0, y1, by1) };
        const p2 = { x: lerp(x0, x1, bx2), y: lerp(y0, y1, by2) };

        // curve
        ectx.save();
        ectx.strokeStyle = "rgba(124,92,255,.85)";
        ectx.lineWidth = 3;
        ectx.beginPath();
        ectx.moveTo(x0, y0);
        ectx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, x1, y1);
        ectx.stroke();
        ectx.restore();

        // handles
        const drawHandle = (p, label) => {
          ectx.save();
          ectx.strokeStyle = "rgba(255,255,255,.22)";
          ectx.fillStyle = "rgba(77,214,255,.85)";
          ectx.lineWidth = 2;
          ectx.beginPath();
          ectx.arc(p.x, p.y, 6.5, 0, Math.PI*2);
          ectx.fill();
          ectx.stroke();
          ectx.fillStyle = "rgba(255,255,255,.7)";
          ectx.font = "11px " + getComputedStyle(document.documentElement).getPropertyValue("--mono").trim();
          ectx.fillText(label, p.x + 9, p.y - 8);
          ectx.restore();
        };
        // link lines
        ectx.save();
        ectx.strokeStyle = "rgba(255,255,255,.12)";
        ectx.lineWidth = 2;
        ectx.beginPath(); ectx.moveTo(x0, y0); ectx.lineTo(p1.x, p1.y); ectx.stroke();
        ectx.beginPath(); ectx.moveTo(x1, y1); ectx.lineTo(p2.x, p2.y); ectx.stroke();
        ectx.restore();

        drawHandle(p1, "P1");
        drawHandle(p2, "P2");

        // text
        ectx.save();
        ectx.fillStyle = "rgba(255,255,255,.55)";
        ectx.font = "11px " + getComputedStyle(document.documentElement).getPropertyValue("--mono").trim();
        ectx.fillText("custom (bezier)", x0, y1 - 6);
        ectx.fillText(`${bx1.toFixed(2)},${by1.toFixed(2)}  ${bx2.toFixed(2)},${by2.toFixed(2)}`, x0, y0 + 16);
        ectx.restore();
      }

      function easeHitTest(px, py) {
        const pad = 14;
        const w = easeCanvas.width, h = easeCanvas.height;
        const x0 = pad, y0 = h - pad;
        const x1 = w - pad, y1 = pad;
        const kf = getSelectedKeyframe();
        const bez = (kf?.ease?.mode === "bezier" ? kf.ease.bezier : project.motion.customBezier) || [0.42,0,0.58,1];
        const [bx1, by1, bx2, by2] = bez;
        const p1 = { x: lerp(x0, x1, bx1), y: lerp(y0, y1, by1) };
        const p2 = { x: lerp(x0, x1, bx2), y: lerp(y0, y1, by2) };
        const d1 = Math.hypot(px - p1.x, py - p1.y);
        const d2 = Math.hypot(px - p2.x, py - p2.y);
        if (d1 < 12) return { which: 1, x0, y0, x1, y1, bez };
        if (d2 < 12) return { which: 2, x0, y0, x1, y1, bez };
        return null;
      }

      easeCanvas.addEventListener("pointerdown", (ev) => {
        easeCanvas.setPointerCapture(ev.pointerId);
        const r = easeCanvas.getBoundingClientRect();
        const x = (ev.clientX - r.left) / Math.max(1, r.width) * easeCanvas.width;
        const y = (ev.clientY - r.top) / Math.max(1, r.height) * easeCanvas.height;
        const hit = easeHitTest(x, y);
        if (!hit) return;
        easeState.drag = { id: ev.pointerId, ...hit };
        // Switch selected easing to custom bezier
        const kf = getSelectedKeyframe();
        if (kf) {
          kf.ease.mode = "bezier";
          kf.ease.bezier = deepClone(project.motion.customBezier);
          $("#inEasePreset").value = kf.ease.preset || project.motion.easePreset;
        }
        drawEaseEditor();
      });
      easeCanvas.addEventListener("pointermove", (ev) => {
        if (!easeState.drag || easeState.drag.id !== ev.pointerId) return;
        const r = easeCanvas.getBoundingClientRect();
        const px = (ev.clientX - r.left) / Math.max(1, r.width) * easeCanvas.width;
        const py = (ev.clientY - r.top) / Math.max(1, r.height) * easeCanvas.height;
        const { which, x0, y0, x1, y1 } = easeState.drag;
        const bx = clamp(invLerp(x0, x1, px), 0, 1);
        const by = clamp(invLerp(y0, y1, py), 0, 1);
        const kf = getSelectedKeyframe();
        if (kf) {
          if (!kf.ease) kf.ease = { mode:"bezier", preset: project.motion.easePreset, bezier: deepClone(project.motion.customBezier) };
          kf.ease.mode = "bezier";
          const b = (Array.isArray(kf.ease.bezier) ? kf.ease.bezier : deepClone(project.motion.customBezier));
          if (which === 1) { b[0] = bx; b[1] = by; }
          else { b[2] = bx; b[3] = by; }
          kf.ease.bezier = b;
          project.motion.customBezier = deepClone(b);
        } else {
          const b = deepClone(project.motion.customBezier);
          if (which === 1) { b[0] = bx; b[1] = by; }
          else { b[2] = bx; b[3] = by; }
          project.motion.customBezier = b;
        }
        drawEaseEditor();
        renderOnce();
      });
      easeCanvas.addEventListener("pointerup", (ev) => {
        if (easeState.drag?.id === ev.pointerId) easeState.drag = null;
        try { easeCanvas.releasePointerCapture(ev.pointerId); } catch {}
      });
      easeCanvas.addEventListener("pointercancel", () => { easeState.drag = null; });

      // --- Audio: load + analyse ---
      function initAudioGraphIfNeeded() {
        if (state.audio.ctx) return;
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) return;
        state.audio.ctx = new AudioCtx();
        state.audio.analyser = state.audio.ctx.createAnalyser();
        state.audio.analyser.fftSize = 2048;
        state.audio.data = new Uint8Array(state.audio.analyser.frequencyBinCount);
      }

      function attachAudioElement(url) {
        if (state.audio.el) {
          try { state.audio.el.pause(); } catch {}
        }
        const el = new Audio();
        el.src = url;
        el.preload = "auto";
        el.crossOrigin = "anonymous";
        el.addEventListener("ended", () => { setPlaying(false); });
        state.audio.el = el;
        initAudioGraphIfNeeded();
        if (state.audio.ctx && state.audio.analyser) {
          try {
            if (state.audio.srcNode) state.audio.srcNode.disconnect();
            state.audio.srcNode = state.audio.ctx.createMediaElementSource(el);
            state.audio.srcNode.connect(state.audio.analyser);
            state.audio.analyser.connect(state.audio.ctx.destination);
          } catch (e) {
            // Some browsers disallow multiple media element sources; ignore.
          }
        }
      }

      function startAudioIfNeeded() {
        if (!project.audio.fileName || !state.audio.el) return;
        try {
          if (state.audio.ctx && state.audio.ctx.state === "suspended") state.audio.ctx.resume();
        } catch {}
        try {
          if (Math.abs(state.audio.el.currentTime - state.t) > 0.08) state.audio.el.currentTime = state.t;
          state.audio.el.play().catch(() => {});
        } catch {}
      }
      function pauseAudioIfNeeded() {
        if (!state.audio.el) return;
        try { state.audio.el.pause(); } catch {}
      }

      function updateAudioEnergy() {
        if (!project.audio.reactiveOn || !state.audio.analyser || !state.audio.data) {
          state.audio.energy = 0;
          return;
        }
        state.audio.analyser.getByteFrequencyData(state.audio.data);
        let sum = 0;
        // Focus on low-mid band for beat energy.
        const n = state.audio.data.length;
        const lo = Math.floor(n * 0.02);
        const hi = Math.floor(n * 0.28);
        for (let i = lo; i < hi; i++) sum += state.audio.data[i];
        const avg = sum / Math.max(1, (hi - lo)) / 255;
        // Smooth
        state.audio.energy = lerp(state.audio.energy, clamp(avg * 1.6, 0, 1), 0.25);
      }

      async function detectBeatsFromArrayBuffer(buf) {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) throw new Error("Web Audio not supported");
        const ctx2 = new AudioCtx();
        const audioBuf = await ctx2.decodeAudioData(buf.slice(0));
        const sr = audioBuf.sampleRate;
        const ch0 = audioBuf.getChannelData(0);
        const len = ch0.length;
        // Envelope: RMS over windows
        const win = 1024;
        const hop = 512;
        const env = [];
        for (let i = 0; i + win < len; i += hop) {
          let s = 0;
          for (let j = 0; j < win; j++) {
            const v = ch0[i + j];
            s += v * v;
          }
          env.push(Math.sqrt(s / win));
        }
        // Differentiate to get onset strength
        const onset = new Float32Array(env.length);
        let prev = env[0] || 0;
        for (let i = 0; i < env.length; i++) {
          const v = env[i];
          onset[i] = Math.max(0, v - prev);
          prev = v;
        }
        // Autocorrelation to estimate tempo between 60-200 bpm
        const minBpm = 60, maxBpm = 200;
        const minLag = Math.floor((60 / maxBpm) * sr / hop);
        const maxLag = Math.floor((60 / minBpm) * sr / hop);
        let bestLag = minLag, best = -1;
        for (let lag = minLag; lag <= maxLag; lag++) {
          let sum = 0;
          for (let i = 0; i + lag < onset.length; i++) sum += onset[i] * onset[i + lag];
          if (sum > best) { best = sum; bestLag = lag; }
        }
        const bpm = 60 / ((bestLag * hop) / sr);
        // Peak pick for beats
        const beats = [];
        const period = bestLag;
        let i = 0;
        // Find first strong onset
        let maxOn = 0; for (let k = 0; k < onset.length; k++) maxOn = Math.max(maxOn, onset[k]);
        const thr = maxOn * 0.35;
        while (i < onset.length && onset[i] < thr) i++;
        if (i >= onset.length) i = 0;
        for (let step = 0; step < 20000; step++) {
          const t = (i * hop) / sr;
          if (t > project.settings.duration + 0.5) break;
          beats.push(t);
          // Search around expected period for local maximum
          const center = i + period;
          let bestJ = center;
          let bestV = -1;
          const search = Math.floor(period * 0.25);
          for (let j = Math.max(0, center - search); j < Math.min(onset.length, center + search); j++) {
            if (onset[j] > bestV) { bestV = onset[j]; bestJ = j; }
          }
          i = bestJ;
          if (i >= onset.length - 1) break;
        }
        try { ctx2.close(); } catch {}
        return { bpm, beats };
      }

      // --- Export ---
      function updateExportStats() {
        const fps = safeParseFloat($("#exFps").value, project.settings.fps);
        const scale = safeParseFloat($("#exScale").value, 1);
        const range = $("#exRange").value;
        const dur = range === "full" ? project.settings.duration : range === "2s" ? Math.min(2, project.settings.duration) : Math.min(1, project.settings.duration);
        const frames = Math.max(1, Math.round(dur * fps));
        const w = Math.round(project.settings.width * scale);
        const h = Math.round(project.settings.height * scale);
        $("#exFrames").textContent = `${frames} (${fmtTime(dur)}s)`;
        $("#exProjInfo").textContent = `${project.settings.width}×${project.settings.height} @ ${project.settings.fps}fps`;
        $("#exProjInfo").title = `Export will render at ${w}×${h} @ ${fps}fps`;
      }

      async function exportWebM({ fps, dur, w, h, bgMode, watermark }) {
        $("#exStatus").textContent = "Preparing WebM (real-time)…";
        const tmp = document.createElement("canvas");
        tmp.width = w; tmp.height = h;
        tmp.style.position = "fixed";
        tmp.style.left = "-9999px";
        tmp.style.top = "-9999px";
        document.body.appendChild(tmp);
        const tctx = tmp.getContext("2d");

        const stream = tmp.captureStream(fps);
        const mimeCandidates = [
          "video/webm;codecs=vp9",
          "video/webm;codecs=vp8",
          "video/webm",
        ];
        let mime = "";
        for (const m of mimeCandidates) {
          if (window.MediaRecorder && MediaRecorder.isTypeSupported(m)) { mime = m; break; }
        }
        if (!window.MediaRecorder) throw new Error("MediaRecorder not supported");
        const rec = new MediaRecorder(stream, mime ? { mimeType: mime, videoBitsPerSecond: 12_000_000 } : undefined);
        const chunks = [];
        rec.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
        rec.start(200);
        const start = now();
        const frameMs = 1000 / fps;
        let frame = 0;
        const totalFrames = Math.max(1, Math.round(dur * fps));

        await new Promise((resolve, reject) => {
          const tick = () => {
            if (state.export.cancel) { reject(new Error("Export cancelled")); return; }
            const t = frame / fps;
            const v = getValuesAtTime(t);
            drawFrame(tctx, t, v, { bgMode, guides:false, watermark, motionBlur: project.text.motionBlur });
            const p = clamp(frame / totalFrames, 0, 1);
            $("#exProg").style.width = (p * 100).toFixed(1) + "%";
            $("#exStatus").textContent = `Recording… ${Math.round(p * 100)}%`;
            frame++;
            if (frame > totalFrames) {
              try { rec.stop(); } catch {}
              resolve();
              return;
            }
            const elapsed = now() - start;
            const target = frame * frameMs;
            const wait = Math.max(0, target - elapsed);
            setTimeout(tick, wait);
          };
          setTimeout(tick, 0);
        });

        await new Promise((resolve) => {
          rec.onstop = () => resolve();
        });
        tmp.remove();
        return new Blob(chunks, { type: mime || "video/webm" });
      }

      async function ensureGIF() {
        if (window.GIF) return;
        await loadScript("https://cdn.jsdelivr.net/npm/gif.js.optimized@1.0.1/dist/gif.js");
        // worker script will be fetched by gif.js automatically
      }

      async function exportGIF({ fps, dur, w, h, bgMode, watermark }) {
        await ensureGIF();
        $("#exStatus").textContent = "Rendering GIF…";
        const tmp = document.createElement("canvas");
        tmp.width = w; tmp.height = h;
        const tctx = tmp.getContext("2d");
        const totalFrames = Math.max(1, Math.round(dur * fps));

        const gif = new GIF({
          workers: Math.min(4, navigator.hardwareConcurrency || 4),
          quality: 10,
          workerScript: "https://cdn.jsdelivr.net/npm/gif.js.optimized@1.0.1/dist/gif.worker.js",
          width: w,
          height: h,
        });

        for (let frame = 0; frame <= totalFrames; frame++) {
          if (state.export.cancel) throw new Error("Export cancelled");
          const t = frame / fps;
          const v = getValuesAtTime(t);
          drawFrame(tctx, t, v, { bgMode, guides:false, watermark, motionBlur: project.text.motionBlur });
          gif.addFrame(tctx, { copy: true, delay: Math.round(1000 / fps) });
          const p = clamp(frame / totalFrames, 0, 1);
          $("#exProg").style.width = (p * 100).toFixed(1) + "%";
          $("#exStatus").textContent = `Rendering frames… ${Math.round(p * 100)}%`;
          if (frame % 10 === 0) await new Promise(r => setTimeout(r, 0));
        }
        const blob = await new Promise((resolve, reject) => {
          gif.on("finished", (b) => resolve(b));
          gif.on("abort", () => reject(new Error("GIF aborted")));
          gif.render();
        });
        return blob;
      }

      async function ensureJSZip() {
        if (window.JSZip) return;
        await loadScript("https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js");
      }

      async function exportPNGZip({ fps, dur, w, h, bgMode, watermark }) {
        await ensureJSZip();
        $("#exStatus").textContent = "Rendering PNG frames…";
        const zip = new JSZip();
        const tmp = document.createElement("canvas");
        tmp.width = w; tmp.height = h;
        const tctx = tmp.getContext("2d");
        const totalFrames = Math.max(1, Math.round(dur * fps));

        const pad = (n, width=5) => String(n).padStart(width, "0");
        for (let frame = 0; frame <= totalFrames; frame++) {
          if (state.export.cancel) throw new Error("Export cancelled");
          const t = frame / fps;
          const v = getValuesAtTime(t);
          drawFrame(tctx, t, v, { bgMode, guides:false, watermark, motionBlur: project.text.motionBlur });
          const blob = await new Promise((resolve) => tmp.toBlob(resolve, "image/png"));
          zip.file(`frames/frame_${pad(frame)}.png`, blob);
          const p = clamp(frame / totalFrames, 0, 1);
          $("#exProg").style.width = (p * 100).toFixed(1) + "%";
          $("#exStatus").textContent = `Encoding… ${Math.round(p * 100)}%`;
          if (frame % 8 === 0) await new Promise(r => setTimeout(r, 0));
        }
        $("#exStatus").textContent = "Zipping…";
        const out = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }, (meta) => {
          $("#exProg").style.width = clamp(meta.percent, 0, 100).toFixed(1) + "%";
        });
        return out;
      }

      async function ensureFFmpeg() {
        if (window.FFmpeg && window.FFmpeg.createFFmpeg) return;
        // UMD build
        await loadScript("https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js");
      }

      async function exportMP4ViaFFmpeg({ fps, dur, w, h, bgMode, watermark }) {
        await ensureFFmpeg();
        $("#exStatus").textContent = "Rendering frames for MP4…";
        const { createFFmpeg, fetchFile } = window.FFmpeg;
        const ffmpeg = createFFmpeg({ log: false, corePath: "https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js" });
        if (!ffmpeg.isLoaded()) {
          $("#exStatus").textContent = "Loading ffmpeg.wasm… (large download)";
          await ffmpeg.load();
        }
        const tmp = document.createElement("canvas");
        tmp.width = w; tmp.height = h;
        const tctx = tmp.getContext("2d");
        const totalFrames = Math.max(1, Math.round(dur * fps));
        const pad = (n, width=5) => String(n).padStart(width, "0");

        for (let frame = 0; frame <= totalFrames; frame++) {
          if (state.export.cancel) throw new Error("Export cancelled");
          const t = frame / fps;
          const v = getValuesAtTime(t);
          drawFrame(tctx, t, v, { bgMode, guides:false, watermark, motionBlur: project.text.motionBlur });
          const blob = await new Promise((resolve) => tmp.toBlob(resolve, "image/png"));
          ffmpeg.FS("writeFile", `frame_${pad(frame)}.png`, await fetchFile(blob));
          const p = clamp(frame / totalFrames, 0, 1);
          $("#exProg").style.width = (p * 100).toFixed(1) + "%";
          $("#exStatus").textContent = `Frames… ${Math.round(p * 100)}%`;
          if (frame % 6 === 0) await new Promise(r => setTimeout(r, 0));
        }

        $("#exStatus").textContent = "Encoding MP4…";
        await ffmpeg.run(
          "-framerate", String(fps),
          "-i", "frame_%05d.png",
          "-vf", `scale=${w}:${h}:flags=lanczos,format=yuv420p`,
          "-pix_fmt", "yuv420p",
          "-movflags", "+faststart",
          "out.mp4"
        );
        const data = ffmpeg.FS("readFile", "out.mp4");
        // Cleanup
        try { ffmpeg.FS("unlink", "out.mp4"); } catch {}
        for (let frame = 0; frame <= totalFrames; frame++) {
          try { ffmpeg.FS("unlink", `frame_${pad(frame)}.png`); } catch {}
        }
        return new Blob([data.buffer], { type: "video/mp4" });
      }

      async function startExport() {
        if (state.export.busy) return;
        state.export.busy = true;
        state.export.cancel = false;
        $("#exProg").style.width = "0%";
        $("#exStatus").textContent = "Starting…";

        const format = $("#exFormat").value;
        const fps = safeParseFloat($("#exFps").value, project.settings.fps);
        const scale = safeParseFloat($("#exScale").value, 1);
        const range = $("#exRange").value;
        const dur = range === "full" ? project.settings.duration : range === "2s" ? Math.min(2, project.settings.duration) : Math.min(1, project.settings.duration);
        const w = Math.round(project.settings.width * scale);
        const h = Math.round(project.settings.height * scale);
        const bgMode = $("#exBgMode").value;
        const watermark = $("#exChrome").value === "watermark";

        const oldPlaying = state.playing;
        setPlaying(false);
        try {
          let blob;
          if (format === "webm") blob = await exportWebM({ fps, dur, w, h, bgMode, watermark });
          else if (format === "gif") blob = await exportGIF({ fps, dur, w, h, bgMode, watermark });
          else if (format === "png") blob = await exportPNGZip({ fps, dur, w, h, bgMode, watermark });
          else if (format === "mp4") blob = await exportMP4ViaFFmpeg({ fps, dur, w, h, bgMode, watermark });
          else throw new Error("Unknown export format");

          $("#exProg").style.width = "100%";
          $("#exStatus").textContent = "Done. Downloading…";
          const stamp = new Date().toISOString().replaceAll(":","").slice(0, 15);
          const nameBase = `kinetic-typography_${stamp}_${w}x${h}_${fps}fps`;
          const ext = format === "png" ? "zip" : format;
          downloadBlob(blob, `${nameBase}.${ext}`);
          toast("Export complete: " + ext.toUpperCase());
        } catch (e) {
          $("#exStatus").textContent = "Export failed: " + (e?.message || String(e));
          toast("Export failed");
        } finally {
          state.export.busy = false;
          if (oldPlaying) setPlaying(true);
        }
      }

      // --- Control Sync ---
      function syncMotionInputsFromSelected(updateSelectionLabel=true) {
        const kf = getSelectedKeyframe();
        if (updateSelectionLabel) $("#kvSel").textContent = kf ? `${kf.time.toFixed(3)}s` : "none";
        const v = kf ? kf.values : getValuesAtTime(state.t);
        $("#inTracking").value = String(v.tracking ?? project.motion.base.tracking);
        $("#inOpacity").value = String(v.opacity ?? project.motion.base.opacity);
        $("#inPosX").value = String(v.posX ?? project.motion.base.posX);
        $("#inPosY").value = String(v.posY ?? project.motion.base.posY);
        $("#inScale").value = String(v.scale ?? project.motion.base.scale);
        $("#inRot").value = String(v.rot ?? project.motion.base.rot);
        $("#inLetterOffset").value = String(v.letterOffset ?? project.motion.base.letterOffset);
        $("#inWordOffset").value = String(v.wordOffset ?? project.motion.base.wordOffset);
        const preset = (kf?.ease?.preset || project.motion.easePreset) ?? "easeInOut";
        $("#inEasePreset").value = preset;
        drawEaseEditor();
      }

      function applyMotionInputsToSelected() {
        const kf = getSelectedKeyframe();
        const v = {
          tracking: safeParseFloat($("#inTracking").value, 1),
          opacity: safeParseFloat($("#inOpacity").value, 1),
          posX: safeParseFloat($("#inPosX").value, 50),
          posY: safeParseFloat($("#inPosY").value, 50),
          scale: safeParseFloat($("#inScale").value, 1),
          rot: safeParseFloat($("#inRot").value, 0),
          letterOffset: safeParseFloat($("#inLetterOffset").value, 0),
          wordOffset: safeParseFloat($("#inWordOffset").value, 0),
        };
        if (kf) {
          kf.values = v;
          const p = $("#inEasePreset").value;
          if (!kf.ease) kf.ease = { mode:"preset", preset:p, bezier: deepClone(project.motion.customBezier) };
          kf.ease.preset = p;
        } else {
          project.motion.base = v;
        }
        state.layoutCache.key = ""; // invalidate wrap if tracking changed
        renderOnce();
      }

      function setupInputs() {
        // Sidebar toggle (mobile)
        const sidebar = $("#sidebar");
        $("#btnSidebar").addEventListener("click", () => {
          const shown = sidebar.style.display !== "none";
          sidebar.style.display = shown ? "none" : "flex";
        });

        // Text
        $("#inText").addEventListener("input", (e) => { project.text.content = e.target.value; state.layoutCache.key=""; renderOnce(); });
        $("#inAlign").addEventListener("change", (e) => { project.text.align = e.target.value; state.layoutCache.key=""; renderOnce(); });
        $("#inLineHeight").addEventListener("change", (e) => { project.text.lineHeight = safeParseFloat(e.target.value, 1.05); state.layoutCache.key=""; renderOnce(); });
        $("#inBoxW").addEventListener("change", (e) => { project.text.boxWPercent = clamp(safeParseFloat(e.target.value, 86), 20, 100); state.layoutCache.key=""; renderOnce(); });
        $("#inMaxLines").addEventListener("change", (e) => { project.text.maxLines = clamp(Math.floor(safeParseFloat(e.target.value, 10)), 1, 20); state.layoutCache.key=""; renderOnce(); });

        // Style
        $("#inFont").addEventListener("change", (e) => { project.text.fontFamily = e.target.value; state.layoutCache.key=""; renderOnce(); });
        $("#inFontSize").addEventListener("change", (e) => { project.text.fontSize = clamp(safeParseFloat(e.target.value, 120), 10, 420); state.layoutCache.key=""; renderOnce(); });
        $("#inWeight").addEventListener("change", (e) => { project.text.fontWeight = clamp(Math.floor(safeParseFloat(e.target.value, 800)), 100, 900); state.layoutCache.key=""; renderOnce(); });
        $("#inItalic").addEventListener("change", (e) => { project.text.fontStyle = e.target.value; state.layoutCache.key=""; renderOnce(); });
        $("#inFill").addEventListener("input", (e) => { project.text.fill = e.target.value; renderOnce(); });
        $("#inBg").addEventListener("input", (e) => { project.settings.bgColor = e.target.value; renderOnce(); });

        const swOutline = $("#swOutline");
        const swShadow = $("#swShadow");
        const swGrad = $("#swGrad");
        const swBlur = $("#swBlur");
        const swGrid = $("#swGrid");
        const swSafe = $("#swSafe");
        const swAudioReactive = $("#swAudioReactive");

        function bindSwitch(sw, getVal, setVal) {
          const toggle = () => { setVal(!getVal()); cssSwitch(sw, getVal()); renderOnce(); };
          sw.addEventListener("click", toggle);
          sw.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggle(); } });
          cssSwitch(sw, getVal());
        }
        bindSwitch(swOutline, () => project.text.outlineOn, (v) => project.text.outlineOn = v);
        bindSwitch(swShadow, () => project.text.shadowOn, (v) => project.text.shadowOn = v);
        bindSwitch(swGrad, () => project.text.gradOn, (v) => project.text.gradOn = v);
        bindSwitch(swBlur, () => project.text.motionBlur, (v) => project.text.motionBlur = v);
        bindSwitch(swGrid, () => project.settings.gridOn, (v) => project.settings.gridOn = v);
        bindSwitch(swSafe, () => project.settings.safeOn, (v) => project.settings.safeOn = v);
        bindSwitch(swAudioReactive, () => project.audio.reactiveOn, (v) => project.audio.reactiveOn = v);

        $("#inOutlineW").addEventListener("change", (e) => { project.text.outlineW = clamp(safeParseFloat(e.target.value, 3), 0, 32); renderOnce(); });
        $("#inOutlineC").addEventListener("input", (e) => { project.text.outlineC = e.target.value; renderOnce(); });
        $("#inShadowBlur").addEventListener("change", (e) => { project.text.shadowBlur = clamp(safeParseFloat(e.target.value, 18), 0, 80); renderOnce(); });
        $("#inShadowA").addEventListener("change", (e) => { project.text.shadowA = clamp(safeParseFloat(e.target.value, 0.35), 0, 1); renderOnce(); });
        $("#inShadowX").addEventListener("change", (e) => { project.text.shadowX = clamp(safeParseFloat(e.target.value, 0), -120, 120); renderOnce(); });
        $("#inShadowY").addEventListener("change", (e) => { project.text.shadowY = clamp(safeParseFloat(e.target.value, 12), -120, 120); renderOnce(); });
        $("#inGradA").addEventListener("input", (e) => { project.text.gradA = e.target.value; renderOnce(); });
        $("#inGradB").addEventListener("input", (e) => { project.text.gradB = e.target.value; renderOnce(); });

        // Motion
        $("#inPreset").addEventListener("change", (e) => { project.motion.preset = e.target.value; renderOnce(); });
        $("#inStaggerMode").addEventListener("change", (e) => { project.motion.staggerMode = e.target.value; renderOnce(); });
        $("#inStagger").addEventListener("change", (e) => { project.motion.stagger = clamp(safeParseFloat(e.target.value, 0.02), 0, 1.5); renderOnce(); });
        $("#inLocalDur").addEventListener("change", (e) => { project.motion.localDur = clamp(safeParseFloat(e.target.value, 0.7), 0.1, 3); renderOnce(); });

        const motionFields = ["#inTracking","#inOpacity","#inPosX","#inPosY","#inScale","#inRot","#inLetterOffset","#inWordOffset","#inEasePreset"];
        for (const sel of motionFields) {
          $(sel).addEventListener("input", applyMotionInputsToSelected);
          $(sel).addEventListener("change", applyMotionInputsToSelected);
        }
        $("#inEasePreset").addEventListener("change", (e) => {
          project.motion.easePreset = e.target.value;
          const kf = getSelectedKeyframe();
          if (kf && kf.ease && kf.ease.mode !== "bezier") kf.ease.preset = e.target.value;
          drawEaseEditor();
          renderOnce();
        });

        $("#btnApplyPreset").addEventListener("click", () => rebuildKeyframesFromPreset(project.motion.preset));
        $("#btnResetMotion").addEventListener("click", () => {
          project.motion.base = { posX:50,posY:50,scale:1,rot:0,opacity:1,tracking:1,letterOffset:28,wordOffset:0 };
          rebuildKeyframesFromPreset(project.motion.preset);
          renderOnce();
        });

        // Audio
        $("#inSnapMode").addEventListener("change", (e) => {
          project.audio.snapMode = e.target.value;
          $("#snapRead").textContent = project.audio.snapMode;
          renderOnce();
        });
        $("#inBeatsPerBar").addEventListener("change", (e) => { project.audio.beatsPerBar = clamp(Math.floor(safeParseFloat(e.target.value, 4)), 2, 12); renderOnce(); });
        $("#inBpm").addEventListener("change", (e) => { project.audio.bpm = clamp(safeParseFloat(e.target.value, 120), 40, 220); });
        $("#inReactScale").addEventListener("change", (e) => { project.audio.reactScale = clamp(safeParseFloat(e.target.value, 0.18), 0, 1.5); });
        $("#inReactGlitch").addEventListener("change", (e) => { project.audio.reactGlitch = clamp(safeParseFloat(e.target.value, 0.25), 0, 1.5); });

        $("#inAudioFile").addEventListener("change", async (e) => {
          const f = e.target.files && e.target.files[0];
          if (!f) return;
          const url = URL.createObjectURL(f);
          project.audio.fileName = f.name;
          project.audio.url = url;
          $("#audStatus").textContent = f.name;
          attachAudioElement(url);
          toast("Audio loaded");
        });
        $("#btnDetect").addEventListener("click", async () => {
          const f = $("#inAudioFile").files && $("#inAudioFile").files[0];
          if (!f) { toast("Load an audio file first"); return; }
          try {
            $("#audStatus").textContent = "detecting…";
            const buf = await f.arrayBuffer();
            const res = await detectBeatsFromArrayBuffer(buf);
            project.audio.bpm = res.bpm;
            $("#inBpm").value = res.bpm.toFixed(1);
            project.audio.beatTimes = res.beats.filter(t => t <= project.settings.duration + 1);
            project.audio.detected = true;
            $("#audStatus").textContent = `beats: ${project.audio.beatTimes.length} @ ${res.bpm.toFixed(1)} bpm`;
            toast("Beats detected");
            renderOnce();
          } catch (err) {
            $("#audStatus").textContent = "detect failed";
            toast("Beat detection failed");
          }
        });
        $("#btnSnapKeyframe").addEventListener("click", applySnapToSelected);

        // Layout
        $("#inAspect").addEventListener("change", (e) => {
          project.settings.aspect = e.target.value;
          // If resolution not custom, set a reasonable default for aspect.
          const a = project.settings.aspect;
          let w = project.settings.width, h = project.settings.height;
          if (a === "16:9") { w = 1280; h = 720; }
          if (a === "9:16") { w = 1080; h = 1920; }
          if (a === "1:1") { w = 1080; h = 1080; }
          if (a === "4:5") { w = 1080; h = 1350; }
          project.settings.width = w; project.settings.height = h;
          $("#inW").value = String(w);
          $("#inH").value = String(h);
          $("#inRes").value = "custom";
          setCanvasSize(w, h);
          updateExportStats();
          toast("Aspect set: " + a);
        });
        $("#inRes").addEventListener("change", (e) => {
          const v = e.target.value;
          if (v === "custom") return;
          const [w, h] = v.split("x").map(n => parseInt(n, 10));
          if (!w || !h) return;
          project.settings.width = w; project.settings.height = h;
          $("#inW").value = String(w);
          $("#inH").value = String(h);
          setCanvasSize(w, h);
          updateExportStats();
          toast("Resolution set");
        });
        $("#inW").addEventListener("change", (e) => {
          project.settings.width = clamp(Math.floor(safeParseFloat(e.target.value, project.settings.width)), 240, 4096);
          setCanvasSize(project.settings.width, project.settings.height);
          updateExportStats();
        });
        $("#inH").addEventListener("change", (e) => {
          project.settings.height = clamp(Math.floor(safeParseFloat(e.target.value, project.settings.height)), 240, 4096);
          setCanvasSize(project.settings.width, project.settings.height);
          updateExportStats();
        });
        $("#inMargins").addEventListener("change", (e) => { project.settings.marginsPct = clamp(safeParseFloat(e.target.value, 8), 0, 25); renderOnce(); });
        $("#inGrid").addEventListener("change", (e) => { project.settings.gridN = clamp(parseInt(e.target.value, 10), 6, 24); renderOnce(); });
        $("#inBgFit").addEventListener("change", (e) => { project.settings.bgFit = e.target.value; renderOnce(); });
        $("#inBgImg").addEventListener("change", (e) => {
          const f = e.target.files && e.target.files[0];
          if (!f) return;
          const url = URL.createObjectURL(f);
          const img = new Image();
          img.onload = () => {
            project.settings.bgImage = img;
            toast("Background image loaded");
            renderOnce();
          };
          img.src = url;
        });

        // Project
        $("#inDur").addEventListener("change", (e) => {
          project.settings.duration = clamp(safeParseFloat(e.target.value, 5), 0.5, 60);
          // Clamp keyframes + playhead into new duration.
          for (const kf of project.keyframes) kf.time = clamp(kf.time, 0, project.settings.duration);
          sortKeyframes();
          if (state.t > project.settings.duration) state.t = project.settings.duration;
          $("#timeDur").textContent = fmtTime(project.settings.duration);
          updateExportStats();
          resizeTimelineCanvas(true);
          renderOnce();
        });
        $("#inFps").addEventListener("change", (e) => {
          project.settings.fps = clamp(Math.floor(safeParseFloat(e.target.value, 30)), 12, 60);
          updateExportStats();
          renderOnce();
        });
        $("#btnCenter").addEventListener("click", () => {
          const kf = getSelectedKeyframe();
          if (kf) { kf.values.posX = 50; kf.values.posY = 50; syncMotionInputsFromSelected(false); }
          renderOnce();
          toast("Centered");
        });
        $("#btnFit").addEventListener("click", () => {
          project.text.boxWPercent = 100 - project.settings.marginsPct * 2;
          $("#inBoxW").value = String(Math.round(project.text.boxWPercent));
          state.layoutCache.key = "";
          renderOnce();
          toast("Fit to safe area");
        });
        $("#btnClearAudio").addEventListener("click", () => {
          if (project.audio.url) { try { URL.revokeObjectURL(project.audio.url); } catch {} }
          project.audio.fileName = ""; project.audio.url = ""; project.audio.beatTimes = []; project.audio.detected = false;
          $("#audStatus").textContent = "no file";
          $("#inAudioFile").value = "";
          if (state.audio.el) { try { state.audio.el.pause(); } catch {} state.audio.el = null; }
          toast("Audio cleared");
          renderOnce();
        });

        // Export dialog
        $("#btnExport").addEventListener("click", () => openDialog($("#dlgExport")));
        $("#btnStartExport").addEventListener("click", startExport);
        $("#btnCancelExport").addEventListener("click", () => { state.export.cancel = true; $("#exStatus").textContent = "Cancelling…"; });
        $("#exFps").addEventListener("input", updateExportStats);
        $("#exScale").addEventListener("change", updateExportStats);
        $("#exRange").addEventListener("change", updateExportStats);
        $("#exFormat").addEventListener("change", updateExportStats);

        // Timeline controls
        $("#btnPlay").addEventListener("click", () => setPlaying(!state.playing));
        $("#btnTlPlay").addEventListener("click", () => setPlaying(!state.playing));
        $("#btnTlStop").addEventListener("click", stopPlayback);
        $("#btnStepBack").addEventListener("click", () => stepFrames(-1));
        $("#btnStepFwd").addEventListener("click", () => stepFrames(1));

        $("#btnKeyframe").addEventListener("click", () => addKeyframe(state.t));
        $("#btnAddKF2").addEventListener("click", () => addKeyframe(state.t));
        $("#btnDelKF").addEventListener("click", deleteSelectedKeyframe);

        $("#inZoom").addEventListener("input", (e) => {
          state.tl.zoom = clamp(safeParseFloat(e.target.value, 1), 0.5, 4);
          $("#zoomRead").textContent = state.tl.zoom.toFixed(2) + "×";
          resizeTimelineCanvas(true);
        });

        // Help
        $("#btnHelp").addEventListener("click", () => openDialog($("#dlgHelp")));
        $("#dlgHelp").addEventListener("close", () => {});
        $("#dlgExport").addEventListener("close", () => { state.export.cancel = true; });
        $$("[data-close]").forEach(b => b.addEventListener("click", (e) => closeParentDialog(e.target)));

        // Reduced motion badge
        if (prefersReducedMotion) $("#chipReduced").style.display = "";

        // Initial reads
        $("#snapRead").textContent = project.audio.snapMode;
        $("#zoomRead").textContent = state.tl.zoom.toFixed(2) + "×";
        updateExportStats();
      }

      function openDialog(dlg) {
        try { dlg.showModal(); } catch {}
      }
      function closeParentDialog(el) {
        const dlg = el.closest("dialog");
        if (!dlg) return;
        try { dlg.close(); } catch {}
      }

      // --- Keyboard shortcuts ---
      function onKeyDown(e) {
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
        const typing = tag === "input" || tag === "textarea" || e.target?.isContentEditable;
        const modKey = (e.ctrlKey || e.metaKey);
        if (modKey && e.key.toLowerCase() === "e") { e.preventDefault(); openDialog($("#dlgExport")); return; }
        if (e.key === "?" && !typing) { e.preventDefault(); openDialog($("#dlgHelp")); return; }
        if (e.key.toLowerCase() === "s" && !typing && !modKey) { e.preventDefault(); $("#btnSidebar").click(); return; }
        if (typing) return;
        if (e.key === " ") {
          e.preventDefault();
          if (e.shiftKey) stopPlayback(); else setPlaying(!state.playing);
          return;
        }
        if (e.key.toLowerCase() === "k") { e.preventDefault(); addKeyframe(state.t); return; }
        if (e.key === "Delete" || e.key === "Backspace") { e.preventDefault(); deleteSelectedKeyframe(); return; }
        if (e.key === "ArrowLeft") { e.preventDefault(); seekTo(state.t - (e.shiftKey ? 0.1 : 0.02), true); return; }
        if (e.key === "ArrowRight") { e.preventDefault(); seekTo(state.t + (e.shiftKey ? 0.1 : 0.02), true); return; }
        if (e.key === ",") { e.preventDefault(); stepFrames(-1); return; }
        if (e.key === ".") { e.preventDefault(); stepFrames(1); return; }
      }

      // --- Boot ---
      function boot() {
        ensureDefaultKeyframes();
        setupInputs();
        document.addEventListener("keydown", onKeyDown);
        // Initial values sync
        $("#inPreset").value = project.motion.preset;
        $("#inStaggerMode").value = project.motion.staggerMode;
        $("#inStagger").value = String(project.motion.stagger);
        $("#inLocalDur").value = String(project.motion.localDur);
        $("#inDur").value = String(project.settings.duration);
        $("#inFps").value = String(project.settings.fps);
        $("#inBg").value = project.settings.bgColor;
        $("#inBoxW").value = String(project.text.boxWPercent);
        $("#inMaxLines").value = String(project.text.maxLines);
        $("#inFont").value = project.text.fontFamily;
        $("#inFontSize").value = String(project.text.fontSize);
        $("#inWeight").value = String(project.text.fontWeight);
        $("#inItalic").value = project.text.fontStyle;
        $("#inFill").value = project.text.fill;
        $("#inOutlineW").value = String(project.text.outlineW);
        $("#inOutlineC").value = project.text.outlineC;
        $("#inShadowBlur").value = String(project.text.shadowBlur);
        $("#inShadowA").value = String(project.text.shadowA);
        $("#inShadowX").value = String(project.text.shadowX);
        $("#inShadowY").value = String(project.text.shadowY);
        $("#inGradA").value = project.text.gradA;
        $("#inGradB").value = project.text.gradB;
        $("#inAspect").value = project.settings.aspect;
        $("#inRes").value = "1280x720";
        $("#inW").value = String(project.settings.width);
        $("#inH").value = String(project.settings.height);
        $("#inMargins").value = String(project.settings.marginsPct);
        $("#inGrid").value = String(project.settings.gridN);
        $("#inBgFit").value = project.settings.bgFit;
        $("#inSnapMode").value = project.audio.snapMode;
        $("#inBeatsPerBar").value = String(project.audio.beatsPerBar);
        $("#inBpm").value = String(project.audio.bpm);
        $("#inReactScale").value = String(project.audio.reactScale);
        $("#inReactGlitch").value = String(project.audio.reactGlitch);
        $("#exFps").value = String(project.settings.fps);

        setCanvasSize(project.settings.width, project.settings.height);
        syncMotionInputsFromSelected();
        drawEaseEditor();
        const track = $("#tlTrack");
        if (track) new ResizeObserver(() => resizeTimelineCanvas(true)).observe(track);
        resizeTimelineCanvas(true);

        renderOnce();
        toast("Ready. Press ? for help.");
      }

      boot();
    })();
  </script>
</body>
</html>
