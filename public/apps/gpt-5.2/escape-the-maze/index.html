<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark light" />
    <title>Escape the Maze</title>
    <style>
      :root {
        --bg0: #080a12;
        --bg1: #0b1020;
        --card: rgba(255, 255, 255, 0.06);
        --card2: rgba(255, 255, 255, 0.09);
        --stroke: rgba(255, 255, 255, 0.12);
        --text: rgba(255, 255, 255, 0.9);
        --muted: rgba(255, 255, 255, 0.62);
        --muted2: rgba(255, 255, 255, 0.45);
        --shadow: 0 14px 50px rgba(0, 0, 0, 0.45);
        --shadow2: 0 10px 30px rgba(0, 0, 0, 0.35);
        --accent: #7c5cff;
        --accent2: #24d2ff;
        --good: #20e3a5;
        --warn: #ffd166;
        --bad: #ff4d6d;
        --wall: rgba(255, 255, 255, 0.85);
        --wall2: rgba(255, 255, 255, 0.22);
        --tile: rgba(255, 255, 255, 0.06);
        --tile2: rgba(255, 255, 255, 0.08);
        --glow: 0 0 0 1px rgba(255, 255, 255, 0.08), 0 0 40px rgba(124, 92, 255, 0.22);
        --radius: 18px;
        --radius2: 14px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: var(--sans);
        color: var(--text);
        background: radial-gradient(1000px 700px at 25% 15%, rgba(124, 92, 255, 0.25), transparent 55%),
          radial-gradient(800px 560px at 80% 0%, rgba(36, 210, 255, 0.18), transparent 60%),
          radial-gradient(900px 700px at 75% 85%, rgba(32, 227, 165, 0.12), transparent 60%),
          linear-gradient(180deg, var(--bg1), var(--bg0));
        overflow-x: hidden;
      }

      .wrap {
        width: min(1200px, 100%);
        margin: 0 auto;
        padding: 22px 18px 26px;
        display: grid;
        gap: 16px;
        grid-template-rows: auto 1fr;
      }

      header {
        display: grid;
        gap: 10px;
        align-items: end;
        grid-template-columns: 1fr auto;
      }

      .brand {
        display: grid;
        gap: 6px;
      }
      .title {
        display: flex;
        align-items: center;
        gap: 10px;
        line-height: 1;
      }
      .logo {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        background: radial-gradient(20px 20px at 30% 30%, rgba(255, 255, 255, 0.22), transparent 50%),
          linear-gradient(135deg, rgba(124, 92, 255, 0.95), rgba(36, 210, 255, 0.75));
        box-shadow: 0 14px 36px rgba(124, 92, 255, 0.25), 0 8px 16px rgba(0, 0, 0, 0.3);
        position: relative;
      }
      .logo:before {
        content: "";
        position: absolute;
        inset: 9px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.25);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.18);
      }
      h1 {
        margin: 0;
        font-size: clamp(22px, 3.2vw, 32px);
        letter-spacing: -0.03em;
      }
      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: 13px;
      }

      .topActions {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: flex-end;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 999px;
        padding: 10px 12px;
        box-shadow: var(--shadow2);
        backdrop-filter: blur(10px);
      }

      .select,
      button {
        appearance: none;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        padding: 10px 12px;
        font-size: 13px;
        line-height: 1;
        cursor: pointer;
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
        user-select: none;
      }
      .select {
        padding-right: 30px;
        background-image: linear-gradient(45deg, transparent 50%, rgba(255, 255, 255, 0.75) 50%),
          linear-gradient(135deg, rgba(255, 255, 255, 0.75) 50%, transparent 50%);
        background-position: calc(100% - 16px) 50%, calc(100% - 11px) 50%;
        background-size: 5px 5px, 5px 5px;
        background-repeat: no-repeat;
      }
      button:hover,
      .select:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.22);
        transform: translateY(-1px);
      }
      button:active,
      .select:active {
        transform: translateY(0px);
      }
      button:focus-visible,
      .select:focus-visible,
      canvas:focus-visible {
        outline: 3px solid rgba(36, 210, 255, 0.35);
        outline-offset: 3px;
      }

      button.primary {
        background: linear-gradient(135deg, rgba(124, 92, 255, 0.95), rgba(36, 210, 255, 0.65));
        border-color: rgba(255, 255, 255, 0.18);
        box-shadow: 0 14px 36px rgba(124, 92, 255, 0.22), 0 10px 26px rgba(0, 0, 0, 0.28);
      }
      button.primary:hover {
        background: linear-gradient(135deg, rgba(124, 92, 255, 0.98), rgba(36, 210, 255, 0.75));
      }
      button.ghost {
        background: rgba(255, 255, 255, 0.06);
      }
      button.danger {
        background: rgba(255, 77, 109, 0.15);
        border-color: rgba(255, 77, 109, 0.35);
      }

      main {
        display: grid;
        grid-template-columns: 1.2fr 0.8fr;
        gap: 16px;
        min-height: 0;
      }
      @media (max-width: 980px) {
        main {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        min-height: 0;
      }

      .mazeCard {
        display: grid;
        grid-template-rows: auto 1fr auto;
        overflow: hidden;
      }

      .mazeHeader {
        padding: 14px 14px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .mazeHeader .left {
        display: grid;
        gap: 2px;
      }
      .mazeHeader .kicker {
        font-size: 12px;
        color: var(--muted);
      }
      .mazeHeader .hint {
        font-size: 12px;
        color: var(--muted2);
      }
      .mazeHeader .right {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .canvasWrap {
        position: relative;
        min-height: 360px;
        padding: 12px;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        border-radius: calc(var(--radius) - 8px);
        background: radial-gradient(700px 500px at 35% 20%, rgba(124, 92, 255, 0.14), transparent 60%),
          radial-gradient(700px 500px at 75% 10%, rgba(36, 210, 255, 0.10), transparent 60%),
          radial-gradient(700px 500px at 70% 85%, rgba(32, 227, 165, 0.08), transparent 60%),
          rgba(0, 0, 0, 0.18);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
        outline: none;
      }
      .overlayNote {
        position: absolute;
        left: 22px;
        top: 18px;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.14);
        color: rgba(255, 255, 255, 0.85);
        font-size: 12px;
        letter-spacing: 0.01em;
        box-shadow: 0 12px 34px rgba(0, 0, 0, 0.3);
        pointer-events: none;
        opacity: 0;
        transform: translateY(-4px);
        transition: opacity 220ms ease, transform 220ms ease;
      }
      .overlayNote.show {
        opacity: 1;
        transform: translateY(0);
      }
      .kbd {
        font-family: var(--mono);
        font-size: 11px;
        padding: 2px 7px;
        border-radius: 7px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        color: rgba(255, 255, 255, 0.86);
      }

      .mazeFooter {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        padding: 12px 14px 14px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        align-items: center;
      }
      .legend {
        display: flex;
        gap: 14px;
        flex-wrap: wrap;
        align-items: center;
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        display: inline-block;
        margin-right: 7px;
        transform: translateY(1px);
      }
      .legend span {
        font-size: 12px;
        color: var(--muted);
      }
      .legend .start .dot {
        background: linear-gradient(135deg, rgba(32, 227, 165, 1), rgba(36, 210, 255, 0.9));
      }
      .legend .goal .dot {
        background: linear-gradient(135deg, rgba(255, 209, 102, 1), rgba(124, 92, 255, 1));
      }
      .legend .you .dot {
        background: linear-gradient(135deg, rgba(255, 255, 255, 1), rgba(36, 210, 255, 0.95));
      }
      .legend .path .dot {
        background: rgba(124, 92, 255, 0.75);
      }

      .hudCard {
        display: grid;
        grid-template-rows: auto auto 1fr;
        overflow: hidden;
      }
      .hudHeader {
        padding: 14px 14px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .hudHeader .label {
        color: var(--muted);
        font-size: 12px;
      }
      .hudHeader .value {
        font-family: var(--mono);
        font-size: 13px;
        color: rgba(255, 255, 255, 0.86);
      }
      .hudBody {
        padding: 14px;
        display: grid;
        gap: 12px;
        min-height: 0;
      }

      .metricGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .metric {
        border-radius: var(--radius2);
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
        padding: 11px 11px;
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
        min-height: 56px;
      }
      .metric .k {
        font-size: 12px;
        color: var(--muted2);
        margin-bottom: 6px;
      }
      .metric .v {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
      }
      .metric .big {
        font-family: var(--mono);
        font-size: 20px;
        letter-spacing: -0.02em;
      }
      .metric .tiny {
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
      }

      .statusBox {
        border-radius: var(--radius2);
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.05);
        padding: 12px;
        display: grid;
        gap: 8px;
      }
      .statusTitle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .statusTitle .t {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.86);
      }
      .badge {
        font-family: var(--mono);
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        color: rgba(255, 255, 255, 0.82);
      }
      .badge.good {
        border-color: rgba(32, 227, 165, 0.35);
        background: rgba(32, 227, 165, 0.12);
      }
      .badge.bad {
        border-color: rgba(255, 77, 109, 0.35);
        background: rgba(255, 77, 109, 0.12);
      }
      .statusText {
        font-size: 12px;
        line-height: 1.45;
        color: var(--muted);
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .controls button {
        width: 100%;
      }
      @media (max-width: 980px) {
        .controls {
          grid-template-columns: 1fr;
        }
      }

      .microHelp {
        padding: 12px;
        border-radius: var(--radius2);
        border: 1px dashed rgba(255, 255, 255, 0.16);
        background: rgba(255, 255, 255, 0.03);
        color: var(--muted);
        font-size: 12px;
        line-height: 1.5;
      }
      .microHelp code {
        font-family: var(--mono);
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 7px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        color: rgba(255, 255, 255, 0.86);
      }

      .mobilePad {
        display: none;
        gap: 10px;
        grid-template-columns: 64px 64px 64px;
        justify-content: center;
        align-items: center;
      }
      .mobilePad button {
        height: 56px;
        border-radius: 16px;
        font-size: 14px;
      }
      .mobilePad .mid {
        display: grid;
        gap: 10px;
      }
      @media (hover: none) and (pointer: coarse) {
        .mobilePad {
          display: grid;
        }
      }

      .modalBackdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.58);
        backdrop-filter: blur(10px);
        display: grid;
        place-items: center;
        padding: 18px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 220ms ease;
        z-index: 50;
      }
      .modalBackdrop.show {
        opacity: 1;
        pointer-events: auto;
      }
      .modal {
        width: min(680px, 100%);
        border-radius: 22px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.09), rgba(255, 255, 255, 0.05));
        box-shadow: 0 24px 90px rgba(0, 0, 0, 0.55);
        overflow: hidden;
      }
      .modalHeader {
        padding: 16px 16px 14px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .modalHeader h2 {
        margin: 0;
        font-size: 16px;
        letter-spacing: -0.01em;
      }
      .modalBody {
        padding: 16px;
        display: grid;
        gap: 12px;
      }
      .modalBody .summary {
        display: grid;
        gap: 8px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.55;
      }
      .resultGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      @media (max-width: 560px) {
        .resultGrid {
          grid-template-columns: 1fr;
        }
      }
      .result {
        border-radius: var(--radius2);
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.22);
        padding: 12px;
      }
      .result .k {
        font-size: 12px;
        color: var(--muted2);
        margin-bottom: 6px;
      }
      .result .v {
        font-family: var(--mono);
        font-size: 18px;
        letter-spacing: -0.01em;
      }
      .modalFooter {
        padding: 14px 16px 16px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
      }

      .toast {
        position: fixed;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%) translateY(14px);
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.42);
        border: 1px solid rgba(255, 255, 255, 0.14);
        color: rgba(255, 255, 255, 0.86);
        font-size: 12px;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.4);
        opacity: 0;
        transition: opacity 200ms ease, transform 200ms ease;
        pointer-events: none;
        z-index: 60;
        max-width: calc(100% - 24px);
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          transition: none !important;
          scroll-behavior: auto !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="brand">
          <div class="title">
            <div class="logo" aria-hidden="true"></div>
            <h1>Escape the Maze</h1>
          </div>
          <p class="subtitle">
            Reach the exit as fast as possible. Finish in the shortest number of steps to earn the bonus.
          </p>
        </div>
        <div class="topActions">
          <div class="pill" title="Difficulty">
            <span style="color: var(--muted); font-size: 12px">Size</span>
            <select id="sizeSelect" class="select" aria-label="Maze size">
              <option value="small">Small (15×11)</option>
              <option value="medium" selected>Medium (23×17)</option>
              <option value="large">Large (31×23)</option>
              <option value="xl">XL (41×31)</option>
            </select>
          </div>
          <button id="newMazeBtn" class="primary" type="button" title="Generate a new maze (R)">Replay</button>
          <button id="restartBtn" class="ghost" type="button" title="Restart the same maze (Shift+R)">Restart</button>
        </div>
      </header>

      <main>
        <section class="card mazeCard" aria-label="Maze">
          <div class="mazeHeader">
            <div class="left">
              <div class="kicker">
                Use <span class="kbd">↑</span> <span class="kbd">↓</span> <span class="kbd">←</span> <span class="kbd">→</span>
                (or <span class="kbd">WASD</span>)
              </div>
              <div class="hint">
                <span class="kbd">H</span> toggles hint • <span class="kbd">Space</span> pauses • click/tap the maze to focus
              </div>
            </div>
            <div class="right">
              <button id="hintBtn" type="button" title="Toggle hint (H)">Hint</button>
              <button id="centerBtn" type="button" title="Center view">Center</button>
            </div>
          </div>
          <div class="canvasWrap">
            <div id="overlayNote" class="overlayNote" aria-live="polite">
              <span class="kbd">Arrow keys</span> to move • Finish in <span class="kbd" id="shortestBadge">—</span> steps for bonus
            </div>
            <canvas id="mazeCanvas" tabindex="0" role="application" aria-label="Maze canvas"></canvas>
          </div>
          <div class="mazeFooter">
            <div class="legend" aria-label="Legend">
              <span class="start"><i class="dot"></i>Start</span>
              <span class="goal"><i class="dot"></i>Exit</span>
              <span class="you"><i class="dot"></i>You</span>
              <span class="path"><i class="dot"></i>Hint path</span>
            </div>
            <div class="mobilePad" aria-label="On-screen controls">
              <div></div>
              <button id="padUp" type="button" aria-label="Move up">▲</button>
              <div></div>
              <button id="padLeft" type="button" aria-label="Move left">◀</button>
              <div class="mid">
                <button id="padPause" type="button" aria-label="Pause or resume">⏯</button>
              </div>
              <button id="padRight" type="button" aria-label="Move right">▶</button>
              <div></div>
              <button id="padDown" type="button" aria-label="Move down">▼</button>
              <div></div>
            </div>
          </div>
        </section>

        <aside class="card hudCard" aria-label="Stats">
          <div class="hudHeader">
            <div class="label">Run</div>
            <div class="value" id="runLabel">Ready</div>
          </div>
          <div class="hudBody">
            <div class="metricGrid" aria-label="Metrics">
              <div class="metric">
                <div class="k">Time</div>
                <div class="v">
                  <div class="big" id="timeText">0:00.0</div>
                  <div class="tiny" id="bestTimeText">Best —</div>
                </div>
              </div>
              <div class="metric">
                <div class="k">Moves</div>
                <div class="v">
                  <div class="big" id="movesText">0</div>
                  <div class="tiny" id="stepsText">0 / —</div>
                </div>
              </div>
              <div class="metric">
                <div class="k">Score</div>
                <div class="v">
                  <div class="big" id="scoreText">0</div>
                  <div class="tiny" id="bestScoreText">Best —</div>
                </div>
              </div>
              <div class="metric">
                <div class="k">Bonus</div>
                <div class="v">
                  <div class="big" id="bonusText">—</div>
                  <div class="tiny" id="bonusStateText">Shortest path</div>
                </div>
              </div>
            </div>

            <div class="statusBox" aria-label="Status">
              <div class="statusTitle">
                <div class="t">Shortest Path Bonus</div>
                <div id="bonusBadge" class="badge">INACTIVE</div>
              </div>
              <div class="statusText" id="bonusExplain">
                Stay optimal: if <code>stepsTaken + distanceToExit == shortest</code> the bonus remains available.
              </div>
            </div>

            <div class="controls" aria-label="Controls">
              <button id="copyBtn" class="ghost" type="button" title="Copy result text after finishing">Copy Result</button>
              <button id="helpBtn" type="button" title="Show help">Help</button>
            </div>

            <div class="microHelp" id="helpBox" hidden>
              <div style="margin-bottom: 8px; color: rgba(255, 255, 255, 0.86); font-weight: 600">How it works</div>
              <div>
                Each maze is a “perfect maze” (one unique path between any two cells). Your goal is to reach the exit with as
                few steps as possible.
              </div>
              <div style="margin-top: 8px">
                Controls:
                <code>Arrow keys</code>/<code>WASD</code> move • <code>H</code> hint • <code>R</code> replay •
                <code>Shift+R</code> restart • <code>Space</code> pause.
              </div>
            </div>
          </div>
        </aside>
      </main>
    </div>

    <div id="modalBackdrop" class="modalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="modalHeader">
          <h2 id="modalTitle">You escaped!</h2>
          <button id="closeModalBtn" type="button" class="ghost" title="Close">Close</button>
        </div>
        <div class="modalBody">
          <div class="summary" id="modalSummary"></div>
          <div class="resultGrid" aria-label="Results">
            <div class="result">
              <div class="k">Time</div>
              <div class="v" id="modalTime">—</div>
            </div>
            <div class="result">
              <div class="k">Moves</div>
              <div class="v" id="modalMoves">—</div>
            </div>
            <div class="result">
              <div class="k">Shortest Path</div>
              <div class="v" id="modalShortest">—</div>
            </div>
            <div class="result">
              <div class="k">Score</div>
              <div class="v" id="modalScore">—</div>
            </div>
          </div>
        </div>
        <div class="modalFooter">
          <button id="modalCopyBtn" class="ghost" type="button">Copy Result</button>
          <div style="display: flex; gap: 10px; flex-wrap: wrap">
            <button id="modalRestartBtn" class="ghost" type="button">Restart</button>
            <button id="modalReplayBtn" class="primary" type="button">Replay</button>
          </div>
        </div>
      </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <script>
      (() => {
        "use strict";

        const $ = (sel, root = document) => root.querySelector(sel);
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

        const DIRS = [
          { name: "N", dx: 0, dy: -1, bit: 1, opp: 4 },
          { name: "E", dx: 1, dy: 0, bit: 2, opp: 8 },
          { name: "S", dx: 0, dy: 1, bit: 4, opp: 1 },
          { name: "W", dx: -1, dy: 0, bit: 8, opp: 2 },
        ];
        const DIR_BY_KEY = new Map([
          ["ArrowUp", "N"],
          ["KeyW", "N"],
          ["ArrowRight", "E"],
          ["KeyD", "E"],
          ["ArrowDown", "S"],
          ["KeyS", "S"],
          ["ArrowLeft", "W"],
          ["KeyA", "W"],
          // fallback to e.key in some environments
          ["w", "N"],
          ["W", "N"],
          ["d", "E"],
          ["D", "E"],
          ["s", "S"],
          ["S", "S"],
          ["a", "W"],
          ["A", "W"],
        ]);

        function mulberry32(seed) {
          let t = seed >>> 0;
          return function () {
            t += 0x6d2b79f5;
            let x = t;
            x = Math.imul(x ^ (x >>> 15), x | 1);
            x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
            return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
          };
        }

        function nowMs() {
          return performance.now();
        }

        function formatTime(ms) {
          const t = Math.max(0, ms);
          const totalSeconds = Math.floor(t / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          const tenths = Math.floor((t % 1000) / 100);
          return `${minutes}:${String(seconds).padStart(2, "0")}.${tenths}`;
        }

        function formatInt(n) {
          return new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 }).format(n);
        }

        function pickMazeDims(sizeKey) {
          switch (sizeKey) {
            case "small":
              return { cols: 15, rows: 11 };
            case "medium":
              return { cols: 23, rows: 17 };
            case "large":
              return { cols: 31, rows: 23 };
            case "xl":
              return { cols: 41, rows: 31 };
            default:
              return { cols: 23, rows: 17 };
          }
        }

        class Maze {
          constructor(cols, rows, rng) {
            this.cols = cols;
            this.rows = rows;
            this.rng = rng;
            this.walls = new Uint8Array(cols * rows);
            this.walls.fill(1 | 2 | 4 | 8);
          }
          idx(x, y) {
            return y * this.cols + x;
          }
          inBounds(x, y) {
            return x >= 0 && y >= 0 && x < this.cols && y < this.rows;
          }
          hasWall(x, y, dirName) {
            const bit = DIRS.find((d) => d.name === dirName).bit;
            return (this.walls[this.idx(x, y)] & bit) !== 0;
          }
          carve(x, y, dir) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            const a = this.idx(x, y);
            const b = this.idx(nx, ny);
            this.walls[a] &= ~dir.bit;
            this.walls[b] &= ~dir.opp;
          }
          neighbors(x, y) {
            const out = [];
            for (const d of DIRS) {
              const nx = x + d.dx;
              const ny = y + d.dy;
              if (this.inBounds(nx, ny)) out.push({ x: nx, y: ny, dir: d });
            }
            return out;
          }
          generate() {
            const visited = new Uint8Array(this.cols * this.rows);
            const startX = Math.floor(this.rng() * this.cols);
            const startY = Math.floor(this.rng() * this.rows);
            const stack = [{ x: startX, y: startY }];
            visited[this.idx(startX, startY)] = 1;

            while (stack.length) {
              const cur = stack[stack.length - 1];
              const unvisited = [];
              for (const n of this.neighbors(cur.x, cur.y)) {
                if (!visited[this.idx(n.x, n.y)]) unvisited.push(n);
              }
              if (!unvisited.length) {
                stack.pop();
                continue;
              }
              const pick = unvisited[Math.floor(this.rng() * unvisited.length)];
              this.carve(cur.x, cur.y, pick.dir);
              visited[this.idx(pick.x, pick.y)] = 1;
              stack.push({ x: pick.x, y: pick.y });
            }
          }
          canMove(x, y, dirName) {
            const d = DIRS.find((dd) => dd.name === dirName);
            const nx = x + d.dx;
            const ny = y + d.dy;
            if (!this.inBounds(nx, ny)) return false;
            return (this.walls[this.idx(x, y)] & d.bit) === 0;
          }
          bfsDistanceFromGoal(goalX, goalY) {
            const dist = new Int32Array(this.cols * this.rows);
            dist.fill(-1);
            const qx = new Int32Array(this.cols * this.rows);
            const qy = new Int32Array(this.cols * this.rows);
            let qh = 0,
              qt = 0;
            dist[this.idx(goalX, goalY)] = 0;
            qx[qt] = goalX;
            qy[qt] = goalY;
            qt++;
            while (qh < qt) {
              const x = qx[qh];
              const y = qy[qh];
              const base = dist[this.idx(x, y)];
              qh++;
              for (const d of DIRS) {
                const nx = x + d.dx;
                const ny = y + d.dy;
                if (!this.inBounds(nx, ny)) continue;
                // to move from nx,ny to x,y we need the opposite wall open
                const open = (this.walls[this.idx(nx, ny)] & d.opp) === 0;
                if (!open) continue;
                const ni = this.idx(nx, ny);
                if (dist[ni] !== -1) continue;
                dist[ni] = base + 1;
                qx[qt] = nx;
                qy[qt] = ny;
                qt++;
              }
            }
            return dist;
          }
        }

        class Confetti {
          constructor(rng) {
            this.rng = rng;
            this.active = false;
            this.particles = [];
            this.t0 = 0;
          }
          burst(cx, cy, strength) {
            this.active = true;
            this.particles.length = 0;
            this.t0 = nowMs();
            const count = Math.floor(clamp(90 + strength * 40, 90, 160));
            const palette = ["#7c5cff", "#24d2ff", "#20e3a5", "#ffd166", "#ffffff", "#ff4d6d"];
            for (let i = 0; i < count; i++) {
              const a = this.rng() * Math.PI * 2;
              const sp = 2.0 + this.rng() * (4.2 + strength * 1.5);
              this.particles.push({
                x: cx + (this.rng() - 0.5) * 10,
                y: cy + (this.rng() - 0.5) * 10,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp - (2.0 + this.rng() * 1.5),
                r: 2 + this.rng() * 3.5,
                c: palette[Math.floor(this.rng() * palette.length)],
                w: 1 + this.rng() * 2.2,
                rot: this.rng() * Math.PI,
                vr: (this.rng() - 0.5) * 0.25,
              });
            }
          }
          draw(ctx, scale) {
            if (!this.active) return;
            const t = (nowMs() - this.t0) / 1000;
            const g = 12.5;
            let alive = 0;
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.globalAlpha = 0.9;
            for (const p of this.particles) {
              const x = p.x + p.vx * t * 60;
              const y = p.y + (p.vy * t + 0.5 * g * t * t) * 60;
              if (y > 10000) continue;
              const a = clamp(1 - t / 1.6, 0, 1);
              if (a <= 0) continue;
              alive++;
              ctx.globalAlpha = 0.9 * a;
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(p.rot + p.vr * t * 60);
              ctx.fillStyle = p.c;
              ctx.beginPath();
              ctx.roundRect(-p.r * scale, -p.r * 0.65 * scale, p.r * 2 * scale, p.r * 1.3 * scale, p.w * scale);
              ctx.fill();
              ctx.restore();
            }
            ctx.restore();
            if (!alive) this.active = false;
          }
        }

        const state = {
          sizeKey: "medium",
          seed: (Date.now() ^ (Math.random() * 1e9)) >>> 0,
          rng: null,
          maze: null,
          player: { x: 0, y: 0 },
          start: { x: 0, y: 0 },
          goal: { x: 0, y: 0 },
          distToGoal: null,
          shortest: 0,
          steps: 0,
          path: [],
          showHint: false,
          paused: false,
          finished: false,
          started: false,
          startAt: 0,
          elapsedMs: 0,
          score: 0,
          confetti: null,
          lastMoveAt: 0,
        };

        const els = {
          canvas: $("#mazeCanvas"),
          overlayNote: $("#overlayNote"),
          shortestBadge: $("#shortestBadge"),
          sizeSelect: $("#sizeSelect"),
          newMazeBtn: $("#newMazeBtn"),
          restartBtn: $("#restartBtn"),
          hintBtn: $("#hintBtn"),
          centerBtn: $("#centerBtn"),
          timeText: $("#timeText"),
          movesText: $("#movesText"),
          stepsText: $("#stepsText"),
          scoreText: $("#scoreText"),
          bonusText: $("#bonusText"),
          bonusBadge: $("#bonusBadge"),
          bonusStateText: $("#bonusStateText"),
          bonusExplain: $("#bonusExplain"),
          runLabel: $("#runLabel"),
          bestTimeText: $("#bestTimeText"),
          bestScoreText: $("#bestScoreText"),
          copyBtn: $("#copyBtn"),
          helpBtn: $("#helpBtn"),
          helpBox: $("#helpBox"),
          modalBackdrop: $("#modalBackdrop"),
          closeModalBtn: $("#closeModalBtn"),
          modalSummary: $("#modalSummary"),
          modalTime: $("#modalTime"),
          modalMoves: $("#modalMoves"),
          modalShortest: $("#modalShortest"),
          modalScore: $("#modalScore"),
          modalCopyBtn: $("#modalCopyBtn"),
          modalRestartBtn: $("#modalRestartBtn"),
          modalReplayBtn: $("#modalReplayBtn"),
          toast: $("#toast"),
          padUp: $("#padUp"),
          padDown: $("#padDown"),
          padLeft: $("#padLeft"),
          padRight: $("#padRight"),
          padPause: $("#padPause"),
        };

        const ctx = els.canvas.getContext("2d", { alpha: true, desynchronized: true });
        if (!ctx) {
          document.body.innerHTML = "<p style='padding:16px'>Canvas not supported.</p>";
          return;
        }

        const view = {
          dpr: Math.max(1, Math.min(2.25, window.devicePixelRatio || 1)),
          w: 0,
          h: 0,
          cell: 22,
          pad: 16,
          originX: 0,
          originY: 0,
          line: 2.4,
          wallGlow: 0.3,
        };

        function toast(msg) {
          els.toast.textContent = msg;
          els.toast.classList.add("show");
          clearTimeout(toast._t);
          toast._t = setTimeout(() => els.toast.classList.remove("show"), 1600);
        }

        function storageKeyBase() {
          const dims = pickMazeDims(state.sizeKey);
          return `escape-maze:v1:${dims.cols}x${dims.rows}`;
        }

        function loadBests() {
          const base = storageKeyBase();
          const bestTime = Number(localStorage.getItem(`${base}:bestTimeMs`) || "0");
          const bestScore = Number(localStorage.getItem(`${base}:bestScore`) || "0");
          els.bestTimeText.textContent = bestTime ? `Best ${formatTime(bestTime)}` : "Best —";
          els.bestScoreText.textContent = bestScore ? `Best ${formatInt(bestScore)}` : "Best —";
        }

        function saveBestsIfNeeded() {
          const base = storageKeyBase();
          const bestTime = Number(localStorage.getItem(`${base}:bestTimeMs`) || "0");
          const bestScore = Number(localStorage.getItem(`${base}:bestScore`) || "0");
          if (state.elapsedMs > 0 && (!bestTime || state.elapsedMs < bestTime)) {
            localStorage.setItem(`${base}:bestTimeMs`, String(Math.floor(state.elapsedMs)));
          }
          if (state.score > 0 && state.score > bestScore) {
            localStorage.setItem(`${base}:bestScore`, String(Math.floor(state.score)));
          }
          loadBests();
        }

        function resetRunState(keepMaze) {
          state.player.x = state.start.x;
          state.player.y = state.start.y;
          state.steps = 0;
          state.path = [{ x: state.start.x, y: state.start.y }];
          state.paused = false;
          state.finished = false;
          state.started = false;
          state.elapsedMs = 0;
          state.startAt = 0;
          state.score = 0;
          state.lastMoveAt = 0;
          els.runLabel.textContent = keepMaze ? "Ready" : "Generating…";
          updateHud();
          updateBonusStatus();
          if (state.confetti) state.confetti.active = false;
        }

        function newMaze(withNewSeed = true) {
          if (withNewSeed) state.seed = (Date.now() ^ (Math.random() * 1e9)) >>> 0;
          state.rng = mulberry32(state.seed);
          const { cols, rows } = pickMazeDims(state.sizeKey);
          state.maze = new Maze(cols, rows, state.rng);
          state.maze.generate();
          state.start = { x: 0, y: 0 };
          state.goal = { x: cols - 1, y: rows - 1 };
          state.distToGoal = state.maze.bfsDistanceFromGoal(state.goal.x, state.goal.y);
          state.shortest = state.distToGoal[state.maze.idx(state.start.x, state.start.y)];
          state.confetti = new Confetti(state.rng);
          resetRunState(true);
          els.shortestBadge.textContent = `${state.shortest}`;
          els.runLabel.textContent = "Ready";
          els.overlayNote.classList.add("show");
          setTimeout(() => els.overlayNote.classList.remove("show"), 2400);
          resizeCanvas();
          render();
        }

        function computeHintPath() {
          const path = [];
          let x = state.start.x;
          let y = state.start.y;
          path.push({ x, y });
          const maxSteps = state.shortest + 2;
          for (let i = 0; i < maxSteps; i++) {
            if (x === state.goal.x && y === state.goal.y) break;
            const curD = state.distToGoal[state.maze.idx(x, y)];
            let next = null;
            for (const d of DIRS) {
              const nx = x + d.dx;
              const ny = y + d.dy;
              if (!state.maze.inBounds(nx, ny)) continue;
              if ((state.maze.walls[state.maze.idx(x, y)] & d.bit) !== 0) continue;
              const nd = state.distToGoal[state.maze.idx(nx, ny)];
              if (nd === curD - 1) {
                next = { x: nx, y: ny };
                break;
              }
            }
            if (!next) break;
            x = next.x;
            y = next.y;
            path.push({ x, y });
          }
          return path;
        }

        function updateBonusStatus() {
          if (!state.distToGoal || state.shortest < 0) return;
          const here = state.distToGoal[state.maze.idx(state.player.x, state.player.y)];
          const possible = state.steps + here === state.shortest;
          const badge = els.bonusBadge;
          if (state.finished) {
            const got = state.steps === state.shortest;
            badge.textContent = got ? "BONUS WON" : "NO BONUS";
            badge.classList.toggle("good", got);
            badge.classList.toggle("bad", !got);
            els.bonusText.textContent = got ? "+1000" : "0";
            els.bonusStateText.textContent = got ? "Optimal run" : "Not optimal";
          } else {
            badge.textContent = possible ? "ACTIVE" : "INACTIVE";
            badge.classList.toggle("good", possible);
            badge.classList.toggle("bad", !possible);
            els.bonusText.textContent = possible ? "Ready" : "Lost";
            els.bonusStateText.textContent = "Shortest path";
          }
        }

        function computeScore(elapsedMs, steps, shortest, finished) {
          // Strongly reward speed, gently reward efficiency; keep values intuitive.
          const t = elapsedMs / 1000;
          const timeScore = Math.max(0, 7000 - t * 90);
          const extra = Math.max(0, steps - shortest);
          const stepPenalty = extra * 120;
          const efficiencyScore = Math.max(0, 2600 - extra * 140);
          const base = Math.max(0, timeScore + efficiencyScore - stepPenalty);
          const bonus = finished && steps === shortest ? 1000 : 0;
          return Math.round(base + bonus);
        }

        function updateHud() {
          els.timeText.textContent = formatTime(state.elapsedMs);
          els.movesText.textContent = `${state.steps}`;
          els.stepsText.textContent = `${state.steps} / ${state.shortest || "—"}`;
          els.scoreText.textContent = formatInt(state.score);
          if (state.finished) {
            els.runLabel.textContent = "Finished";
          } else if (state.paused) {
            els.runLabel.textContent = state.started ? "Paused" : "Ready";
          } else {
            els.runLabel.textContent = state.started ? "Running" : "Ready";
          }
        }

        function showModal(show) {
          els.modalBackdrop.classList.toggle("show", !!show);
          els.modalBackdrop.setAttribute("aria-hidden", show ? "false" : "true");
          if (show) {
            els.closeModalBtn.focus();
          } else {
            els.canvas.focus();
          }
        }

        function buildResultText() {
          const dims = pickMazeDims(state.sizeKey);
          const gotBonus = state.steps === state.shortest;
          return [
            `Escape the Maze — ${dims.cols}×${dims.rows}`,
            `Time: ${formatTime(state.elapsedMs)}`,
            `Moves: ${state.steps} (Shortest: ${state.shortest})`,
            `Score: ${state.score}${gotBonus ? " (+1000 bonus)" : ""}`,
          ].join("\n");
        }

        async function copyResult() {
          if (!state.finished) {
            toast("Finish a run to copy results.");
            return;
          }
          const text = buildResultText();
          try {
            await navigator.clipboard.writeText(text);
            toast("Copied result to clipboard.");
          } catch {
            // Fallback
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            ta.remove();
            toast("Copied result to clipboard.");
          }
        }

        function move(dirName) {
          if (!state.maze || state.finished) return;
          if (state.paused) return;
          if (!DIRS.some((d) => d.name === dirName)) return;
          if (!state.started) {
            state.started = true;
            state.startAt = nowMs();
          }
          if (!state.maze.canMove(state.player.x, state.player.y, dirName)) {
            const t = nowMs();
            if (t - state.lastMoveAt > 280) {
              state.lastMoveAt = t;
              // subtle feedback (soundless)
              els.canvas.animate(
                [
                  { transform: "translateX(0px)" },
                  { transform: "translateX(-1px)" },
                  { transform: "translateX(1px)" },
                  { transform: "translateX(0px)" },
                ],
                { duration: 120, easing: "ease-out" },
              );
            }
            return;
          }
          const d = DIRS.find((dd) => dd.name === dirName);
          state.player.x += d.dx;
          state.player.y += d.dy;
          state.steps++;
          state.path.push({ x: state.player.x, y: state.player.y });
          state.score = computeScore(state.elapsedMs, state.steps, state.shortest, false);
          updateBonusStatus();
          updateHud();
          render();
          if (state.player.x === state.goal.x && state.player.y === state.goal.y) {
            finishRun();
          }
        }

        function finishRun() {
          if (state.finished) return;
          state.finished = true;
          state.paused = false;
          if (state.started) state.elapsedMs = nowMs() - state.startAt;
          state.score = computeScore(state.elapsedMs, state.steps, state.shortest, true);
          updateBonusStatus();
          updateHud();
          saveBestsIfNeeded();
          const gotBonus = state.steps === state.shortest;
          const extra = Math.max(0, state.steps - state.shortest);
          const msg = gotBonus
            ? "Perfect route — bonus secured."
            : extra
              ? `Escaped with +${extra} extra step${extra === 1 ? "" : "s"}.`
              : "Escaped.";
          els.modalSummary.innerHTML = `
            <div style="color: rgba(255,255,255,0.86); font-weight: 700">Nice run.</div>
            <div>${msg}</div>
            <div style="color: rgba(255,255,255,0.78)">Tip: <span class="kbd">H</span> shows one shortest path, but speed still matters.</div>
          `;
          els.modalTime.textContent = formatTime(state.elapsedMs);
          els.modalMoves.textContent = `${state.steps}`;
          els.modalShortest.textContent = `${state.shortest}${gotBonus ? " ✓" : ""}`;
          els.modalScore.textContent = formatInt(state.score);
          showModal(true);
          toast(gotBonus ? "Bonus won!" : "Escaped!");
          // confetti burst near goal cell center
          const p = cellCenter(state.goal.x, state.goal.y);
          state.confetti.burst(p.x, p.y, gotBonus ? 1.2 : 0.8);
          render();
        }

        function togglePause() {
          if (state.finished) return;
          state.paused = !state.paused;
          if (state.paused) {
            if (state.started) {
              state.elapsedMs = nowMs() - state.startAt;
              state.startAt = 0;
              state.started = false;
            }
          } else {
            // resume
            state.started = true;
            state.startAt = nowMs() - state.elapsedMs;
          }
          updateHud();
          toast(state.paused ? "Paused" : "Resumed");
          render();
        }

        function restartSameMaze() {
          if (!state.maze) return;
          resetRunState(true);
          state.score = 0;
          updateHud();
          render();
          toast("Restarted.");
        }

        function replayNewMaze() {
          resetRunState(false);
          newMaze(true);
          toast("New maze.");
        }

        function toggleHint() {
          state.showHint = !state.showHint;
          els.hintBtn.textContent = state.showHint ? "Hint: ON" : "Hint";
          toast(state.showHint ? "Hint enabled." : "Hint disabled.");
          render();
        }

        function resizeCanvas() {
          const rect = els.canvas.getBoundingClientRect();
          const w = Math.max(320, Math.floor(rect.width));
          const h = Math.max(320, Math.floor(rect.height));
          view.w = w;
          view.h = h;
          const dpr = (view.dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1)));
          els.canvas.width = Math.floor(w * dpr);
          els.canvas.height = Math.floor(h * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          const cols = state.maze?.cols || 23;
          const rows = state.maze?.rows || 17;
          const pad = 18;
          view.pad = pad;
          const cell = Math.floor(Math.min((w - pad * 2) / cols, (h - pad * 2) / rows));
          view.cell = clamp(cell, 12, 30);
          view.originX = Math.floor((w - view.cell * cols) / 2);
          view.originY = Math.floor((h - view.cell * rows) / 2);
          view.line = clamp(view.cell * 0.12, 1.6, 3.2);
          render();
        }

        function cellRect(x, y) {
          return {
            x: view.originX + x * view.cell,
            y: view.originY + y * view.cell,
            w: view.cell,
            h: view.cell,
          };
        }

        function cellCenter(x, y) {
          const r = cellRect(x, y);
          return { x: r.x + r.w / 2, y: r.y + r.h / 2 };
        }

        function drawRoundedTile(r, fillStyle, strokeStyle) {
          ctx.save();
          ctx.beginPath();
          ctx.roundRect(r.x + 1, r.y + 1, r.w - 2, r.h - 2, Math.max(6, view.cell * 0.25));
          if (fillStyle) {
            ctx.fillStyle = fillStyle;
            ctx.fill();
          }
          if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
          ctx.restore();
        }

        function render() {
          const m = state.maze;
          if (!m) return;
          const w = view.w;
          const h = view.h;
          ctx.clearRect(0, 0, w, h);

          // background tint
          ctx.save();
          const g = ctx.createRadialGradient(w * 0.35, h * 0.25, 20, w * 0.45, h * 0.35, Math.max(w, h));
          g.addColorStop(0, "rgba(124,92,255,0.10)");
          g.addColorStop(0.45, "rgba(36,210,255,0.06)");
          g.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, w, h);
          ctx.restore();

          // tiles (subtle)
          ctx.save();
          ctx.globalAlpha = 0.55;
          for (let y = 0; y < m.rows; y++) {
            for (let x = 0; x < m.cols; x++) {
              const r = cellRect(x, y);
              if ((x + y) % 2 === 0) {
                drawRoundedTile(r, "rgba(255,255,255,0.035)", null);
              }
            }
          }
          ctx.restore();

          // start/goal
          const rs = cellRect(state.start.x, state.start.y);
          const rg = cellRect(state.goal.x, state.goal.y);
          drawRoundedTile(
            rs,
            "rgba(32,227,165,0.14)",
            "rgba(32,227,165,0.22)",
          );
          drawRoundedTile(
            rg,
            "rgba(255,209,102,0.12)",
            "rgba(255,209,102,0.24)",
          );

          // hint path
          if (state.showHint) {
            const hp = computeHintPath();
            if (hp.length > 1) {
              ctx.save();
              ctx.lineCap = "round";
              ctx.lineJoin = "round";
              ctx.lineWidth = Math.max(2.4, view.cell * 0.18);
              ctx.strokeStyle = "rgba(124,92,255,0.35)";
              ctx.beginPath();
              const c0 = cellCenter(hp[0].x, hp[0].y);
              ctx.moveTo(c0.x, c0.y);
              for (let i = 1; i < hp.length; i++) {
                const c = cellCenter(hp[i].x, hp[i].y);
                ctx.lineTo(c.x, c.y);
              }
              ctx.stroke();
              ctx.lineWidth = Math.max(1.6, view.cell * 0.09);
              ctx.strokeStyle = "rgba(36,210,255,0.32)";
              ctx.stroke();
              ctx.restore();
            }
          }

          // player's trail
          if (state.path.length > 1) {
            ctx.save();
            ctx.globalAlpha = 0.85;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.lineWidth = Math.max(2, view.cell * 0.12);
            ctx.strokeStyle = "rgba(255,255,255,0.11)";
            ctx.beginPath();
            const c0 = cellCenter(state.path[0].x, state.path[0].y);
            ctx.moveTo(c0.x, c0.y);
            for (let i = 1; i < state.path.length; i++) {
              const c = cellCenter(state.path[i].x, state.path[i].y);
              ctx.lineTo(c.x, c.y);
            }
            ctx.stroke();
            ctx.restore();
          }

          // walls
          ctx.save();
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.lineWidth = view.line;
          // glow layer
          ctx.shadowColor = "rgba(124,92,255,0.22)";
          ctx.shadowBlur = Math.max(6, view.cell * 0.5);
          ctx.strokeStyle = "rgba(255,255,255,0.14)";
          ctx.beginPath();
          for (let y = 0; y < m.rows; y++) {
            for (let x = 0; x < m.cols; x++) {
              const r = cellRect(x, y);
              const wbits = m.walls[m.idx(x, y)];
              if (wbits & 1) {
                ctx.moveTo(r.x, r.y);
                ctx.lineTo(r.x + r.w, r.y);
              }
              if (wbits & 2) {
                ctx.moveTo(r.x + r.w, r.y);
                ctx.lineTo(r.x + r.w, r.y + r.h);
              }
              if (wbits & 4) {
                ctx.moveTo(r.x, r.y + r.h);
                ctx.lineTo(r.x + r.w, r.y + r.h);
              }
              if (wbits & 8) {
                ctx.moveTo(r.x, r.y);
                ctx.lineTo(r.x, r.y + r.h);
              }
            }
          }
          ctx.stroke();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = "rgba(255,255,255,0.82)";
          ctx.lineWidth = view.line;
          ctx.beginPath();
          for (let y = 0; y < m.rows; y++) {
            for (let x = 0; x < m.cols; x++) {
              const r = cellRect(x, y);
              const wbits = m.walls[m.idx(x, y)];
              if (wbits & 1) {
                ctx.moveTo(r.x, r.y);
                ctx.lineTo(r.x + r.w, r.y);
              }
              if (wbits & 2) {
                ctx.moveTo(r.x + r.w, r.y);
                ctx.lineTo(r.x + r.w, r.y + r.h);
              }
              if (wbits & 4) {
                ctx.moveTo(r.x, r.y + r.h);
                ctx.lineTo(r.x + r.w, r.y + r.h);
              }
              if (wbits & 8) {
                ctx.moveTo(r.x, r.y);
                ctx.lineTo(r.x, r.y + r.h);
              }
            }
          }
          ctx.stroke();
          ctx.restore();

          // start/goal icons
          ctx.save();
          const cs = cellCenter(state.start.x, state.start.y);
          const cg = cellCenter(state.goal.x, state.goal.y);
          ctx.fillStyle = "rgba(32,227,165,0.55)";
          ctx.beginPath();
          ctx.arc(cs.x, cs.y, Math.max(3.5, view.cell * 0.12), 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "rgba(255,209,102,0.62)";
          ctx.beginPath();
          ctx.arc(cg.x, cg.y, Math.max(4, view.cell * 0.14), 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          // player
          ctx.save();
          const cp = cellCenter(state.player.x, state.player.y);
          const pr = Math.max(4.5, view.cell * 0.18);
          const grad = ctx.createRadialGradient(cp.x - pr * 0.3, cp.y - pr * 0.3, 1, cp.x, cp.y, pr * 1.2);
          grad.addColorStop(0, "rgba(255,255,255,0.98)");
          grad.addColorStop(0.55, "rgba(36,210,255,0.85)");
          grad.addColorStop(1, "rgba(124,92,255,0.65)");
          ctx.shadowColor = "rgba(36,210,255,0.35)";
          ctx.shadowBlur = Math.max(10, view.cell * 0.8);
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(cp.x, cp.y, pr, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = "rgba(0,0,0,0.28)";
          ctx.lineWidth = Math.max(1.2, view.cell * 0.05);
          ctx.stroke();
          ctx.restore();

          // paused overlay
          if (state.paused) {
            ctx.save();
            ctx.fillStyle = "rgba(0,0,0,0.34)";
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = "rgba(255,255,255,0.92)";
            ctx.font = `700 ${Math.max(18, view.cell * 0.9)}px ${getComputedStyle(document.documentElement).getPropertyValue("--sans")}`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Paused", w / 2, h / 2 - 12);
            ctx.fillStyle = "rgba(255,255,255,0.65)";
            ctx.font = `500 ${Math.max(12, view.cell * 0.45)}px ${getComputedStyle(document.documentElement).getPropertyValue("--sans")}`;
            ctx.fillText("Press Space to resume", w / 2, h / 2 + 20);
            ctx.restore();
          }

          // confetti
          if (state.confetti) state.confetti.draw(ctx, 1);
        }

        function tick() {
          if (!state.finished && state.started && !state.paused) {
            state.elapsedMs = nowMs() - state.startAt;
            state.score = computeScore(state.elapsedMs, state.steps, state.shortest, false);
            updateHud();
          }
          if (state.confetti?.active) render();
          requestAnimationFrame(tick);
        }

        function centerView() {
          resizeCanvas();
          toast("Centered.");
        }

        function handleKeyDown(e) {
          const code = e.code || "";
          const key = e.key || "";
          const keyLower = typeof key === "string" ? key.toLowerCase() : "";

          if (code === "Space" || key === " ") {
            e.preventDefault();
            togglePause();
            return;
          }
          if (code === "KeyH" || keyLower === "h") {
            e.preventDefault();
            toggleHint();
            return;
          }
          if (code === "KeyR" || keyLower === "r") {
            e.preventDefault();
            if (e.shiftKey) restartSameMaze();
            else replayNewMaze();
            return;
          }
          if (code === "Escape" || key === "Escape") {
            if (els.modalBackdrop.classList.contains("show")) showModal(false);
            else if (state.paused) togglePause();
            return;
          }
          const dir = DIR_BY_KEY.get(code) || DIR_BY_KEY.get(key);
          if (dir) {
            e.preventDefault();
            move(dir);
          }
        }

        function bindUi() {
          window.addEventListener("resize", () => resizeCanvas(), { passive: true });
          els.canvas.addEventListener("keydown", handleKeyDown);
          // Also listen on document to feel responsive; avoid scrolling on arrows.
          document.addEventListener("keydown", (e) => {
            const code = e.code || "";
            const key = e.key || "";
            const keyLower = typeof key === "string" ? key.toLowerCase() : "";
            const shouldHandle =
              code === "Space" ||
              key === " " ||
              code === "KeyH" ||
              keyLower === "h" ||
              code === "KeyR" ||
              keyLower === "r" ||
              code === "Escape" ||
              key === "Escape" ||
              DIR_BY_KEY.has(code) ||
              DIR_BY_KEY.has(key);
            if (shouldHandle) handleKeyDown(e);
          });

          els.canvas.addEventListener("pointerdown", () => els.canvas.focus());

          els.sizeSelect.addEventListener("change", () => {
            state.sizeKey = els.sizeSelect.value;
            loadBests();
            replayNewMaze();
          });

          els.newMazeBtn.addEventListener("click", replayNewMaze);
          els.restartBtn.addEventListener("click", restartSameMaze);
          els.hintBtn.addEventListener("click", toggleHint);
          els.centerBtn.addEventListener("click", centerView);

          els.helpBtn.addEventListener("click", () => {
            els.helpBox.hidden = !els.helpBox.hidden;
            els.helpBtn.textContent = els.helpBox.hidden ? "Help" : "Hide";
          });

          els.copyBtn.addEventListener("click", copyResult);
          els.modalCopyBtn.addEventListener("click", copyResult);
          els.modalRestartBtn.addEventListener("click", () => {
            showModal(false);
            restartSameMaze();
          });
          els.modalReplayBtn.addEventListener("click", () => {
            showModal(false);
            replayNewMaze();
          });
          els.closeModalBtn.addEventListener("click", () => showModal(false));
          els.modalBackdrop.addEventListener("pointerdown", (e) => {
            if (e.target === els.modalBackdrop) showModal(false);
          });

          const padMove = (dir) => () => {
            els.canvas.focus();
            move(dir);
          };
          els.padUp?.addEventListener("click", padMove("N"));
          els.padDown?.addEventListener("click", padMove("S"));
          els.padLeft?.addEventListener("click", padMove("W"));
          els.padRight?.addEventListener("click", padMove("E"));
          els.padPause?.addEventListener("click", () => {
            els.canvas.focus();
            togglePause();
          });
        }

        // Polyfill: roundRect for older browsers (very small)
        if (!CanvasRenderingContext2D.prototype.roundRect) {
          CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            const rr = Array.isArray(r) ? r : [r, r, r, r];
            const [r1, r2, r3, r4] = rr.map((v) => Math.max(0, Math.min(v, Math.min(w, h) / 2)));
            this.beginPath();
            this.moveTo(x + r1, y);
            this.lineTo(x + w - r2, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r2);
            this.lineTo(x + w, y + h - r3);
            this.quadraticCurveTo(x + w, y + h, x + w - r3, y + h);
            this.lineTo(x + r4, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r4);
            this.lineTo(x, y + r1);
            this.quadraticCurveTo(x, y, x + r1, y);
            return this;
          };
        }

        function init() {
          bindUi();
          state.sizeKey = els.sizeSelect.value || "medium";
          loadBests();
          newMaze(true);
          updateBonusStatus();
          updateHud();
          els.canvas.focus({ preventScroll: true });
          requestAnimationFrame(tick);
        }

        init();
      })();
    </script>
  </body>
</html>
