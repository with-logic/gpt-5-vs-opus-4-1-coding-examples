<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="color-scheme" content="dark light" />
    <title>Data Visualization Playground</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
      :root {
        --bg0: #070a12;
        --bg1: #0b1221;
        --card: rgba(255, 255, 255, 0.06);
        --card2: rgba(255, 255, 255, 0.08);
        --stroke: rgba(255, 255, 255, 0.12);
        --stroke2: rgba(255, 255, 255, 0.18);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.64);
        --muted2: rgba(255, 255, 255, 0.46);
        --shadow: 0 30px 80px rgba(0, 0, 0, 0.55);
        --shadow2: 0 18px 45px rgba(0, 0, 0, 0.35);
        --ring: rgba(117, 168, 255, 0.38);
        --accent: #7c6cff;
        --accent2: #38bdf8;
        --good: #22c55e;
        --warn: #fbbf24;
        --bad: #fb7185;
        --radius: 18px;
        --radius2: 14px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        --sans: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,
          "Apple Color Emoji", "Segoe UI Emoji";
        --chart-bg: rgba(7, 10, 18, 0.55);
        --grid: rgba(255, 255, 255, 0.12);
      }

      [data-theme="light"] {
        --bg0: #f7f7ff;
        --bg1: #eef2ff;
        --card: rgba(10, 20, 40, 0.06);
        --card2: rgba(10, 20, 40, 0.08);
        --stroke: rgba(10, 20, 40, 0.14);
        --stroke2: rgba(10, 20, 40, 0.18);
        --text: rgba(12, 18, 33, 0.92);
        --muted: rgba(12, 18, 33, 0.66);
        --muted2: rgba(12, 18, 33, 0.5);
        --shadow: 0 30px 80px rgba(15, 23, 42, 0.18);
        --shadow2: 0 18px 45px rgba(15, 23, 42, 0.12);
        --ring: rgba(80, 120, 255, 0.26);
        --chart-bg: rgba(255, 255, 255, 0.82);
        --grid: rgba(12, 18, 33, 0.12);
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: var(--sans);
        color: var(--text);
        background:
          radial-gradient(1200px 800px at 20% 15%, rgba(124, 108, 255, 0.32), transparent 55%),
          radial-gradient(1000px 700px at 80% 30%, rgba(56, 189, 248, 0.22), transparent 60%),
          radial-gradient(1000px 800px at 40% 85%, rgba(34, 197, 94, 0.12), transparent 55%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        overflow-x: hidden;
      }

      a {
        color: inherit;
        text-decoration: none;
      }

      .app {
        min-height: 100%;
        display: flex;
        flex-direction: column;
      }

      .topbar {
        position: sticky;
        top: 0;
        z-index: 50;
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        background: linear-gradient(180deg, rgba(7, 10, 18, 0.8), rgba(7, 10, 18, 0.35));
        border-bottom: 1px solid var(--stroke);
      }

      [data-theme="light"] .topbar {
        background: linear-gradient(180deg, rgba(247, 247, 255, 0.82), rgba(247, 247, 255, 0.5));
      }

      .topbar-inner {
        max-width: 1200px;
        margin: 0 auto;
        padding: 18px 18px 14px;
        display: flex;
        gap: 14px;
        align-items: center;
        justify-content: space-between;
      }

      .brand {
        display: flex;
        gap: 12px;
        align-items: center;
        min-width: 0;
      }
      .logo {
        width: 42px;
        height: 42px;
        border-radius: 14px;
        background: linear-gradient(135deg, rgba(124, 108, 255, 0.95), rgba(56, 189, 248, 0.9));
        box-shadow:
          0 14px 30px rgba(124, 108, 255, 0.22),
          inset 0 0 0 1px rgba(255, 255, 255, 0.18);
        display: grid;
        place-items: center;
        flex: 0 0 auto;
      }
      .logo svg {
        width: 22px;
        height: 22px;
        opacity: 0.95;
      }
      .brand h1 {
        margin: 0;
        font-size: 16px;
        line-height: 1.2;
        letter-spacing: -0.02em;
        font-weight: 700;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .brand p {
        margin: 4px 0 0;
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex: 0 0 auto;
      }

      .btn {
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, var(--card2), var(--card));
        color: var(--text);
        border-radius: 12px;
        padding: 9px 12px;
        font-size: 13px;
        font-weight: 600;
        letter-spacing: -0.01em;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
        user-select: none;
      }
      .btn svg {
        width: 16px;
        height: 16px;
        opacity: 0.92;
      }
      .btn:hover {
        transform: translateY(-1px);
        border-color: var(--stroke2);
      }
      .btn:active {
        transform: translateY(0);
      }
      .btn.primary {
        border-color: rgba(124, 108, 255, 0.55);
        background: linear-gradient(135deg, rgba(124, 108, 255, 0.36), rgba(56, 189, 248, 0.22));
      }
      .btn.ghost {
        background: transparent;
      }
      .btn:focus-visible {
        outline: 0;
        box-shadow: 0 0 0 4px var(--ring);
      }

      .layout {
        max-width: 1200px;
        margin: 0 auto;
        padding: 18px;
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 16px;
        width: 100%;
      }

      @media (max-width: 980px) {
        .layout {
          grid-template-columns: 1fr;
        }
        .topbar-inner {
          padding: 14px 14px 10px;
        }
      }

      .panel {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .card {
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.04));
        border-radius: var(--radius);
        box-shadow: var(--shadow2);
        overflow: hidden;
      }
      [data-theme="light"] .card {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.5));
      }

      .card-h {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 14px 14px 10px;
        border-bottom: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0));
      }
      .card-h h2 {
        margin: 0;
        font-size: 13px;
        letter-spacing: -0.01em;
      }
      .card-h .meta {
        font-size: 12px;
        color: var(--muted);
        font-family: var(--mono);
      }

      .card-b {
        padding: 12px 14px 14px;
      }

      .muted {
        color: var(--muted);
      }
      .tiny {
        font-size: 12px;
      }

      .drop {
        border: 1px dashed rgba(255, 255, 255, 0.22);
        background: linear-gradient(180deg, rgba(124, 108, 255, 0.14), rgba(56, 189, 248, 0.06));
        border-radius: 16px;
        padding: 14px;
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
      }
      [data-theme="light"] .drop {
        border-color: rgba(10, 20, 40, 0.22);
      }
      .drop strong {
        font-size: 13px;
      }
      .drop p {
        margin: 3px 0 0;
        font-size: 12px;
        color: var(--muted);
      }
      .drop .drop-actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex: 0 0 auto;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      @media (max-width: 980px) {
        .row {
          grid-template-columns: 1fr;
        }
      }

      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .control {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid var(--stroke);
        border-radius: 12px;
        padding: 10px 10px;
        color: var(--text);
        width: 100%;
        font-size: 13px;
        outline: none;
      }
      [data-theme="light"] .control {
        background: rgba(255, 255, 255, 0.72);
      }
      .control:focus-visible {
        box-shadow: 0 0 0 4px var(--ring);
      }
      .control[disabled] {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .switch {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        user-select: none;
      }
      .switch input {
        width: 42px;
        height: 26px;
        appearance: none;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid var(--stroke);
        border-radius: 999px;
        position: relative;
        cursor: pointer;
        transition: background 140ms ease;
      }
      .switch input:before {
        content: "";
        position: absolute;
        top: 50%;
        left: 3px;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.86);
        transition: left 140ms ease;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
      }
      [data-theme="light"] .switch input:before {
        background: rgba(12, 18, 33, 0.82);
      }
      .switch input:checked {
        background: rgba(124, 108, 255, 0.35);
        border-color: rgba(124, 108, 255, 0.45);
      }
      .switch input:checked:before {
        left: 19px;
      }
      .switch span {
        font-size: 12px;
        color: var(--muted);
      }

      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.06);
        padding: 7px 10px;
        border-radius: 999px;
        font-size: 12px;
        color: var(--muted);
      }
      .chip b {
        color: var(--text);
        font-weight: 700;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .y-list {
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.04);
        border-radius: 14px;
        padding: 10px;
        max-height: 220px;
        overflow: auto;
      }
      .y-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 7px 8px;
        border-radius: 12px;
      }
      .y-item:hover {
        background: rgba(255, 255, 255, 0.05);
      }
      .y-item input[type="checkbox"] {
        width: 16px;
        height: 16px;
      }
      .y-item .name {
        font-size: 13px;
        color: var(--text);
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .badge {
        font-size: 11px;
        font-family: var(--mono);
        padding: 3px 7px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        color: var(--muted);
        background: rgba(255, 255, 255, 0.05);
      }

      .stage {
        display: grid;
        grid-template-rows: 1fr auto;
        gap: 14px;
        min-height: 520px;
      }
      @media (max-width: 980px) {
        .stage {
          min-height: 460px;
        }
      }

      .chart-wrap {
        position: relative;
        border-radius: var(--radius);
        border: 1px solid var(--stroke);
        box-shadow: var(--shadow);
        overflow: hidden;
        background:
          radial-gradient(900px 700px at 20% 30%, rgba(124, 108, 255, 0.18), transparent 60%),
          radial-gradient(700px 600px at 85% 35%, rgba(56, 189, 248, 0.12), transparent 65%),
          linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.03));
      }

      .chart-inner {
        position: relative;
        padding: 12px;
      }

      .chart-top {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        padding: 14px 14px 0;
      }
      .chart-top .title {
        display: flex;
        flex-direction: column;
        gap: 2px;
        min-width: 0;
      }
      .chart-top .title strong {
        font-size: 14px;
        letter-spacing: -0.01em;
      }
      .chart-top .title span {
        font-size: 12px;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .chart-top .toolbar {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      canvas {
        width: 100% !important;
        height: 420px !important;
      }
      @media (max-width: 980px) {
        canvas {
          height: 360px !important;
        }
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 24px;
        pointer-events: none;
      }
      .overlay .empty {
        pointer-events: auto;
        max-width: 520px;
        text-align: left;
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
        border-radius: 18px;
        padding: 16px;
        box-shadow: var(--shadow2);
      }
      .overlay .empty h3 {
        margin: 0;
        font-size: 14px;
        letter-spacing: -0.01em;
      }
      .overlay .empty p {
        margin: 8px 0 0;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.45;
      }
      .overlay .empty .tips {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      @media (max-width: 980px) {
        .overlay .empty .tips {
          grid-template-columns: 1fr;
        }
      }
      .tip {
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.05);
        border-radius: 14px;
        padding: 10px;
      }
      .tip strong {
        display: block;
        font-size: 12px;
      }
      .tip span {
        display: block;
        margin-top: 3px;
        font-size: 12px;
        color: var(--muted);
      }

      .tabbar {
        display: flex;
        gap: 8px;
        padding: 10px 12px 0;
      }
      .tab {
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.05);
        border-radius: 999px;
        padding: 7px 10px;
        font-size: 12px;
        color: var(--muted);
        cursor: pointer;
        user-select: none;
      }
      .tab[aria-selected="true"] {
        color: var(--text);
        border-color: rgba(124, 108, 255, 0.45);
        background: rgba(124, 108, 255, 0.16);
      }

      .data-card {
        border: 1px solid var(--stroke);
        border-radius: var(--radius);
        overflow: hidden;
        background: rgba(255, 255, 255, 0.04);
        box-shadow: var(--shadow2);
      }
      .data-body {
        padding: 12px 12px 14px;
      }

      .grid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      @media (max-width: 980px) {
        .grid2 {
          grid-template-columns: 1fr;
        }
      }

      .stat {
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.04);
        border-radius: 16px;
        padding: 12px;
      }
      .stat .k {
        font-size: 12px;
        color: var(--muted);
      }
      .stat .v {
        margin-top: 4px;
        font-size: 16px;
        font-weight: 800;
        letter-spacing: -0.02em;
      }
      .stat .s {
        margin-top: 4px;
        font-size: 12px;
        color: var(--muted);
        font-family: var(--mono);
      }

      .table-wrap {
        border: 1px solid var(--stroke);
        border-radius: 16px;
        overflow: auto;
        max-height: 260px;
        background: rgba(0, 0, 0, 0.06);
      }
      [data-theme="light"] .table-wrap {
        background: rgba(255, 255, 255, 0.65);
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }
      thead th {
        position: sticky;
        top: 0;
        background: rgba(0, 0, 0, 0.26);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        color: var(--muted);
        text-align: left;
        padding: 10px;
        border-bottom: 1px solid var(--stroke);
        white-space: nowrap;
      }
      [data-theme="light"] thead th {
        background: rgba(255, 255, 255, 0.85);
      }
      tbody td {
        padding: 9px 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        color: var(--text);
        max-width: 300px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      [data-theme="light"] tbody td {
        border-bottom-color: rgba(12, 18, 33, 0.08);
      }

      .color-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }
      .color-input {
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 10px;
        border: 1px solid var(--stroke);
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.04);
      }
      .color-input input[type="color"] {
        width: 36px;
        height: 26px;
        border: none;
        background: transparent;
        padding: 0;
        cursor: pointer;
      }
      .color-input .label {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-size: 12px;
        color: var(--muted);
      }
      .slider {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }
      input[type="range"] {
        width: 100%;
      }
      .val {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--muted);
      }

      .toast {
        position: fixed;
        left: 18px;
        bottom: 18px;
        z-index: 80;
        display: grid;
        gap: 10px;
        width: min(420px, calc(100vw - 36px));
        pointer-events: none;
      }
      .toast .t {
        pointer-events: auto;
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
        border-radius: 16px;
        padding: 12px 12px;
        box-shadow: var(--shadow2);
        display: flex;
        gap: 10px;
        align-items: flex-start;
      }
      .dot {
        width: 10px;
        height: 10px;
        margin-top: 4px;
        border-radius: 999px;
        background: var(--accent2);
      }
      .dot.good {
        background: var(--good);
      }
      .dot.warn {
        background: var(--warn);
      }
      .dot.bad {
        background: var(--bad);
      }
      .toast .t strong {
        font-size: 13px;
        display: block;
        margin: 0;
      }
      .toast .t span {
        display: block;
        margin-top: 4px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }

      footer {
        max-width: 1200px;
        margin: 0 auto;
        width: 100%;
        padding: 10px 18px 20px;
        color: var(--muted2);
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      footer code {
        font-family: var(--mono);
        color: var(--muted);
      }

      @media (prefers-reduced-motion: reduce) {
        .btn {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="app" id="app" data-theme="dark">
      <header class="topbar">
        <div class="topbar-inner">
          <div class="brand" title="Data Visualization Playground">
            <div class="logo" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none">
                <path
                  d="M5 17V14M9 17V7M13 17v-4m4 4V9"
                  stroke="white"
                  stroke-width="2"
                  stroke-linecap="round"
                />
                <path
                  d="M4 20h16"
                  stroke="white"
                  stroke-opacity="0.7"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
            </div>
            <div style="min-width: 0">
              <h1>Data Visualization Playground</h1>
              <p>Upload a CSV, map columns, and export beautiful charts.</p>
            </div>
          </div>
          <div class="actions">
            <button class="btn ghost" id="btnSample" type="button" title="Load sample CSV">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M7 3h7l3 3v15a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2Z"
                  stroke="currentColor"
                  stroke-width="2"
                />
                <path d="M14 3v4h4" stroke="currentColor" stroke-width="2" />
                <path d="M8 12h8M8 16h8" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
              </svg>
              Sample
            </button>
            <label class="switch" title="Toggle light/dark">
              <input id="themeToggle" type="checkbox" />
              <span>Light</span>
            </label>
            <button class="btn" id="btnFullscreen" type="button" title="Fullscreen chart">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3M3 16v3a2 2 0 0 0 2 2h3m13 0h-3m3-5v3a2 2 0 0 1-2 2"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
              Fullscreen
            </button>
            <button class="btn primary" id="btnDownload" type="button" title="Download chart as PNG">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path
                  d="M12 3v10m0 0 4-4m-4 4-4-4"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
              Export PNG
            </button>
          </div>
        </div>
      </header>

      <main class="layout">
        <aside class="panel">
          <section class="card" id="cardData">
            <div class="card-h">
              <h2>Data</h2>
              <div class="meta" id="dataMeta">No file</div>
            </div>
            <div class="card-b stack">
              <div class="drop" id="dropZone">
                <div>
                  <strong>Drop CSV here</strong>
                  <p>or choose a file. We’ll infer columns and build charts instantly.</p>
                </div>
                <div class="drop-actions">
                  <input
                    id="fileInput"
                    type="file"
                    accept=".csv,text/csv"
                    style="display: none"
                  />
                  <button class="btn" id="btnChoose" type="button">Choose file</button>
                </div>
              </div>

              <div class="row">
                <div>
                  <label for="delimiter">Delimiter</label>
                  <select class="control" id="delimiter">
                    <option value="auto">Auto</option>
                    <option value=",">Comma (,)</option>
                    <option value=";">Semicolon (;)</option>
                    <option value="\t">Tab (\\t)</option>
                    <option value="|">Pipe (|)</option>
                  </select>
                </div>
                <div>
                  <label for="headerRow">Header row</label>
                  <select class="control" id="headerRow">
                    <option value="true" selected>First row is header</option>
                    <option value="false">No header (generate names)</option>
                  </select>
                </div>
              </div>

              <div class="row">
                <div>
                  <label for="maxPoints">Max plotted points</label>
                  <div class="slider">
                    <input id="maxPoints" type="range" min="300" max="20000" step="100" value="4000" />
                    <div class="val" id="maxPointsVal">4000</div>
                  </div>
                </div>
                <div>
                  <label for="sortByX">Sort by X</label>
                  <select class="control" id="sortByX">
                    <option value="off" selected>Off</option>
                    <option value="asc">Ascending</option>
                    <option value="desc">Descending</option>
                  </select>
                </div>
              </div>

              <div class="chips" id="dataChips" aria-live="polite"></div>
            </div>
          </section>

          <section class="card" id="cardMap">
            <div class="card-h">
              <h2>Chart</h2>
              <div class="meta" id="mapMeta">Awaiting data</div>
            </div>
            <div class="card-b stack">
              <div class="row">
                <div>
                  <label for="chartType">Type</label>
                  <select class="control" id="chartType" disabled>
                    <option value="line">Line</option>
                    <option value="area">Area</option>
                    <option value="bar">Bar</option>
                    <option value="stackedBar">Stacked Bar</option>
                    <option value="scatter">Scatter</option>
                    <option value="pie">Pie</option>
                    <option value="doughnut">Doughnut</option>
                    <option value="radar">Radar</option>
                    <option value="polarArea">Polar Area</option>
                  </select>
                </div>
                <div>
                  <label for="legendPos">Legend</label>
                  <select class="control" id="legendPos" disabled>
                    <option value="top" selected>Top</option>
                    <option value="right">Right</option>
                    <option value="bottom">Bottom</option>
                    <option value="left">Left</option>
                    <option value="none">Hidden</option>
                  </select>
                </div>
              </div>

              <div id="mappingStandard" class="stack">
                <div class="row">
                  <div>
                    <label for="xCol">X axis</label>
                    <select class="control" id="xCol" disabled></select>
                  </div>
                  <div>
                    <label for="yScale">Y scale</label>
                    <select class="control" id="yScale" disabled>
                      <option value="linear" selected>Linear</option>
                      <option value="logarithmic">Logarithmic</option>
                    </select>
                  </div>
                </div>

                <div>
                  <label>Y series</label>
                  <div class="y-list" id="yCols" aria-label="Y columns list"></div>
                  <div class="tiny muted" style="margin-top: 8px">
                    Tip: pick multiple numeric columns for multi-series charts.
                  </div>
                </div>
              </div>

              <div id="mappingScatter" class="stack" style="display: none">
                <div class="row">
                  <div>
                    <label for="scatterX">X (numeric)</label>
                    <select class="control" id="scatterX" disabled></select>
                  </div>
                  <div>
                    <label for="scatterY">Y (numeric)</label>
                    <select class="control" id="scatterY" disabled></select>
                  </div>
                </div>
                <div class="tiny muted">Scatter works best with numeric columns; empty values are skipped.</div>
              </div>

              <div id="mappingPie" class="stack" style="display: none">
                <div class="row">
                  <div>
                    <label for="pieLabel">Label (category)</label>
                    <select class="control" id="pieLabel" disabled></select>
                  </div>
                  <div>
                    <label for="pieValue">Value (numeric)</label>
                    <select class="control" id="pieValue" disabled></select>
                  </div>
                </div>
                <div class="row">
                  <div>
                    <label for="pieAgg">Aggregation</label>
                    <select class="control" id="pieAgg" disabled>
                      <option value="sum" selected>Sum</option>
                      <option value="avg">Average</option>
                      <option value="count">Count</option>
                    </select>
                  </div>
                  <div>
                    <label for="pieTopN">Top N slices</label>
                    <select class="control" id="pieTopN" disabled>
                      <option value="8" selected>8</option>
                      <option value="12">12</option>
                      <option value="20">20</option>
                      <option value="9999">All</option>
                    </select>
                  </div>
                </div>
                <div class="tiny muted">
                  Categories beyond Top N are grouped into <span style="font-family: var(--mono)">Other</span>.
                </div>
              </div>
            </div>
          </section>

          <section class="card" id="cardStyle">
            <div class="card-h">
              <h2>Style</h2>
              <div class="meta" id="styleMeta">Theme & palette</div>
            </div>
            <div class="card-b stack">
              <div class="row">
                <div>
                  <label for="palette">Palette</label>
                  <select class="control" id="palette" disabled>
                    <option value="aurora" selected>Aurora</option>
                    <option value="neon">Neon</option>
                    <option value="pastel">Pastel</option>
                    <option value="classic">Classic</option>
                    <option value="mono">Mono</option>
                  </select>
                </div>
                <div>
                  <label for="lineTension">Smoothing</label>
                  <div class="slider">
                    <input id="lineTension" type="range" min="0" max="0.5" step="0.02" value="0.25" disabled />
                    <div class="val" id="lineTensionVal">0.25</div>
                  </div>
                </div>
              </div>

              <div class="row">
                <div>
                  <label for="chartBg">Chart background</label>
                  <div class="color-row">
                    <input class="control" id="chartBg" type="text" value="auto" disabled />
                    <button class="btn" id="btnBgAuto" type="button" disabled>Auto</button>
                  </div>
                  <div class="tiny muted" style="margin-top: 6px">
                    Use <span style="font-family: var(--mono)">auto</span> or a CSS color like
                    <span style="font-family: var(--mono)">#0b1221</span>.
                  </div>
                </div>
                <div>
                  <label for="gridOpacity">Grid opacity</label>
                  <div class="slider">
                    <input id="gridOpacity" type="range" min="0.02" max="0.35" step="0.01" value="0.12" disabled />
                    <div class="val" id="gridOpacityVal">0.12</div>
                  </div>
                </div>
              </div>

              <div class="row">
                <div>
                  <label for="pointRadius">Point size</label>
                  <div class="slider">
                    <input id="pointRadius" type="range" min="0" max="8" step="1" value="3" disabled />
                    <div class="val" id="pointRadiusVal">3</div>
                  </div>
                </div>
                <div>
                  <label for="strokeWidth">Stroke width</label>
                  <div class="slider">
                    <input id="strokeWidth" type="range" min="1" max="6" step="1" value="3" disabled />
                    <div class="val" id="strokeWidthVal">3</div>
                  </div>
                </div>
              </div>

              <div>
                <label>Series colors</label>
                <div class="stack" id="seriesColors"></div>
                <div class="tiny muted" style="margin-top: 8px">
                  Color edits persist for the current session and re-apply when you switch chart types.
                </div>
              </div>

              <div class="row">
                <label class="switch" style="margin-top: 4px">
                  <input id="transparentBg" type="checkbox" disabled />
                  <span>Transparent export</span>
                </label>
                <label class="switch" style="margin-top: 4px">
                  <input id="showDataLabels" type="checkbox" disabled />
                  <span>Show values (pie)</span>
                </label>
              </div>
            </div>
          </section>

          <section class="card" id="cardExport">
            <div class="card-h">
              <h2>Export</h2>
              <div class="meta" id="exportMeta">PNG & clipboard</div>
            </div>
            <div class="card-b stack">
              <div class="row">
                <div>
                  <label for="exportScale">Resolution</label>
                  <select class="control" id="exportScale" disabled>
                    <option value="1" selected>1× (fast)</option>
                    <option value="2">2×</option>
                    <option value="3">3×</option>
                  </select>
                </div>
                <div>
                  <label for="exportName">Filename</label>
                  <input class="control" id="exportName" type="text" value="chart" disabled />
                </div>
              </div>

              <div class="row">
                <button class="btn primary" id="btnDownload2" type="button" disabled>Download PNG</button>
                <button class="btn" id="btnCopy" type="button" disabled>Copy image</button>
              </div>

              <div class="tiny muted">
                Export uses the browser’s canvas pipeline. For best results: pick a background (or enable transparent),
                then export at 2× or 3×.
              </div>
            </div>
          </section>
        </aside>

        <section class="stage">
          <section class="chart-wrap" id="chartWrap">
            <div class="chart-top">
              <div class="title">
                <strong id="chartTitle">Your chart will appear here</strong>
                <span id="chartSubtitle">Upload a CSV or load the sample dataset.</span>
              </div>
              <div class="toolbar">
                <button class="btn" id="btnResetView" type="button" title="Reset mapping & styling" disabled>
                  <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M20 12a8 8 0 1 1-2.35-5.65"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                    />
                    <path
                      d="M20 4v6h-6"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    />
                  </svg>
                  Reset
                </button>
                <button class="btn" id="btnClear" type="button" title="Clear dataset" disabled>
                  <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path
                      d="M6 7h12m-10 0 1-2h6l1 2M9 7v12m6-12v12M7 7l1 14h8l1-14"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                    />
                  </svg>
                  Clear
                </button>
              </div>
            </div>
            <div class="chart-inner">
              <canvas id="chartCanvas" aria-label="Chart preview" role="img"></canvas>
              <div class="overlay" id="overlay">
                <div class="empty">
                  <h3>Turn a CSV into a beautiful chart — instantly</h3>
                  <p>
                    Upload a CSV, pick the chart type, map your X and Y columns, customize colors, then export the
                    result as a PNG for reports and slides.
                  </p>
                  <div class="tips">
                    <div class="tip">
                      <strong>Fast setup</strong>
                      <span>We auto-detect numeric/date columns and choose sensible defaults.</span>
                    </div>
                    <div class="tip">
                      <strong>Polished exports</strong>
                      <span>Pick background + resolution, then download or copy to clipboard.</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <section class="data-card">
            <div class="tabbar" role="tablist" aria-label="Data panel tabs">
              <button class="tab" id="tabSummary" role="tab" aria-selected="true" type="button">Summary</button>
              <button class="tab" id="tabPreview" role="tab" aria-selected="false" type="button">Preview</button>
            </div>
            <div class="data-body">
              <div id="panelSummary">
                <div class="grid2">
                  <div class="stat">
                    <div class="k">Rows</div>
                    <div class="v" id="statRows">—</div>
                    <div class="s" id="statRows2">Loaded: —</div>
                  </div>
                  <div class="stat">
                    <div class="k">Columns</div>
                    <div class="v" id="statCols">—</div>
                    <div class="s" id="statCols2">Numeric: —</div>
                  </div>
                </div>
                <div style="margin-top: 12px" class="stat">
                  <div class="k">Inferred column types</div>
                  <div class="chips" id="colTypeChips"></div>
                </div>
              </div>

              <div id="panelPreview" style="display: none">
                <div class="row" style="margin-bottom: 10px">
                  <div>
                    <label for="search">Search</label>
                    <input class="control" id="search" placeholder="Filter preview rows…" disabled />
                  </div>
                  <div>
                    <label for="previewCount">Preview rows</label>
                    <select class="control" id="previewCount" disabled>
                      <option value="15">15</option>
                      <option value="25" selected>25</option>
                      <option value="50">50</option>
                      <option value="100">100</option>
                    </select>
                  </div>
                </div>
                <div class="table-wrap" id="tableWrap" aria-label="CSV preview table"></div>
              </div>
            </div>
          </section>
        </section>
      </main>

      <footer>
        <div>
          Built with <code>PapaParse</code> + <code>Chart.js</code>. All-in-one file.
        </div>
        <div class="muted2">Tip: try “Stacked Bar” for comparison and “Area” for trends.</div>
      </footer>

      <div class="toast" id="toast" aria-live="polite" aria-atomic="true"></div>
    </div>

    <script>
      (() => {
        const SAMPLE_CSV = `date,visitors,signups,revenue
2025-01-01,1200,85,4200
2025-01-02,1450,103,5130
2025-01-03,1380,97,4890
2025-01-04,1605,128,6120
2025-01-05,1520,111,5610
2025-01-06,1710,139,6590
2025-01-07,1895,152,7420
2025-01-08,2050,169,8120
2025-01-09,1960,161,7850
2025-01-10,2140,176,8490
2025-01-11,1990,163,8010
2025-01-12,2210,185,8920
2025-01-13,2350,201,9460
2025-01-14,2280,196,9240
2025-01-15,2420,208,9750
2025-01-16,2570,219,10320
2025-01-17,2490,212,10010
2025-01-18,2685,231,10980
2025-01-19,2810,242,11520
2025-01-20,2730,236,11240
2025-01-21,2950,258,12130
2025-01-22,3110,270,12880
2025-01-23,3040,266,12540
2025-01-24,3260,287,13490
2025-01-25,3420,301,14210
2025-01-26,3580,318,14980
2025-01-27,3490,310,14630
2025-01-28,3725,333,15640
2025-01-29,3890,347,16390
2025-01-30,4020,359,17020`;

        const PALETTES = {
          aurora: ["#7c6cff", "#38bdf8", "#22c55e", "#fbbf24", "#fb7185", "#a78bfa", "#34d399", "#60a5fa"],
          neon: ["#00f5d4", "#00bbf9", "#f15bb5", "#fee440", "#9b5de5", "#f26419", "#43aa8b", "#4d96ff"],
          pastel: ["#a7c7e7", "#cdb4db", "#bde0fe", "#ffc8dd", "#cdeac0", "#ffd6a5", "#fdffb6", "#b5ead7"],
          classic: ["#2563eb", "#10b981", "#f59e0b", "#ef4444", "#8b5cf6", "#0ea5e9", "#14b8a6", "#64748b"],
          mono: ["#cbd5e1", "#94a3b8", "#e2e8f0", "#a1a1aa", "#d4d4d8", "#9ca3af", "#f1f5f9", "#7dd3fc"],
        };

        const els = {
          app: document.getElementById("app"),
          themeToggle: document.getElementById("themeToggle"),
          dropZone: document.getElementById("dropZone"),
          fileInput: document.getElementById("fileInput"),
          btnChoose: document.getElementById("btnChoose"),
          btnSample: document.getElementById("btnSample"),
          btnFullscreen: document.getElementById("btnFullscreen"),
          btnDownload: document.getElementById("btnDownload"),
          btnDownload2: document.getElementById("btnDownload2"),
          btnCopy: document.getElementById("btnCopy"),
          btnResetView: document.getElementById("btnResetView"),
          btnClear: document.getElementById("btnClear"),
          delimiter: document.getElementById("delimiter"),
          headerRow: document.getElementById("headerRow"),
          maxPoints: document.getElementById("maxPoints"),
          maxPointsVal: document.getElementById("maxPointsVal"),
          sortByX: document.getElementById("sortByX"),
          dataMeta: document.getElementById("dataMeta"),
          dataChips: document.getElementById("dataChips"),
          chartType: document.getElementById("chartType"),
          legendPos: document.getElementById("legendPos"),
          xCol: document.getElementById("xCol"),
          yScale: document.getElementById("yScale"),
          yCols: document.getElementById("yCols"),
          mappingStandard: document.getElementById("mappingStandard"),
          mappingScatter: document.getElementById("mappingScatter"),
          mappingPie: document.getElementById("mappingPie"),
          scatterX: document.getElementById("scatterX"),
          scatterY: document.getElementById("scatterY"),
          pieLabel: document.getElementById("pieLabel"),
          pieValue: document.getElementById("pieValue"),
          pieAgg: document.getElementById("pieAgg"),
          pieTopN: document.getElementById("pieTopN"),
          mapMeta: document.getElementById("mapMeta"),
          palette: document.getElementById("palette"),
          lineTension: document.getElementById("lineTension"),
          lineTensionVal: document.getElementById("lineTensionVal"),
          chartBg: document.getElementById("chartBg"),
          btnBgAuto: document.getElementById("btnBgAuto"),
          gridOpacity: document.getElementById("gridOpacity"),
          gridOpacityVal: document.getElementById("gridOpacityVal"),
          pointRadius: document.getElementById("pointRadius"),
          pointRadiusVal: document.getElementById("pointRadiusVal"),
          strokeWidth: document.getElementById("strokeWidth"),
          strokeWidthVal: document.getElementById("strokeWidthVal"),
          seriesColors: document.getElementById("seriesColors"),
          transparentBg: document.getElementById("transparentBg"),
          showDataLabels: document.getElementById("showDataLabels"),
          exportScale: document.getElementById("exportScale"),
          exportName: document.getElementById("exportName"),
          chartTitle: document.getElementById("chartTitle"),
          chartSubtitle: document.getElementById("chartSubtitle"),
          overlay: document.getElementById("overlay"),
          chartCanvas: document.getElementById("chartCanvas"),
          chartWrap: document.getElementById("chartWrap"),
          tabSummary: document.getElementById("tabSummary"),
          tabPreview: document.getElementById("tabPreview"),
          panelSummary: document.getElementById("panelSummary"),
          panelPreview: document.getElementById("panelPreview"),
          statRows: document.getElementById("statRows"),
          statRows2: document.getElementById("statRows2"),
          statCols: document.getElementById("statCols"),
          statCols2: document.getElementById("statCols2"),
          colTypeChips: document.getElementById("colTypeChips"),
          search: document.getElementById("search"),
          previewCount: document.getElementById("previewCount"),
          tableWrap: document.getElementById("tableWrap"),
          toast: document.getElementById("toast"),
        };

        let chart = null;

        const state = {
          rawName: null,
          rawText: null,
          headers: [],
          rows: [],
          columns: {}, // name -> {type, nonEmpty, unique, numericMin, numericMax}
          numericCols: [],
          categoricalCols: [],
          dateCols: [],
          chosen: {
            chartType: "line",
            legendPos: "top",
            x: null,
            ys: new Set(),
            yScale: "linear",
            scatterX: null,
            scatterY: null,
            pieLabel: null,
            pieValue: null,
            pieAgg: "sum",
            pieTopN: 8,
            palette: "aurora",
            tension: 0.25,
            gridOpacity: 0.12,
            pointRadius: 3,
            strokeWidth: 3,
            chartBg: "auto",
            transparentBg: false,
            showDataLabels: false,
            exportScale: 1,
            maxPoints: 4000,
            sortByX: "off",
          },
          seriesStyle: new Map(), // key -> {color, alpha}
        };

        const chartAreaBackground = {
          id: "chartAreaBackground",
          beforeDraw(chartInstance, _args, opts) {
            const { ctx, chartArea } = chartInstance;
            if (!chartArea) return;
            const bg = opts?.color;
            if (!bg) return;
            ctx.save();
            ctx.fillStyle = bg;
            ctx.fillRect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            ctx.restore();
          },
        };

        const pieValueLabels = {
          id: "pieValueLabels",
          afterDatasetsDraw(chartInstance, _args, opts) {
            if (!opts?.enabled) return;
            const { ctx } = chartInstance;
            const meta = chartInstance.getDatasetMeta(0);
            if (!meta?.data?.length) return;
            const ds = chartInstance.data.datasets[0];
            const total = (ds.data || []).reduce((a, b) => a + (Number.isFinite(b) ? b : 0), 0);
            if (!total) return;
            ctx.save();
            ctx.font = `600 11px ${getComputedStyle(document.documentElement).getPropertyValue("--sans")}`;
            ctx.fillStyle = opts.color || "rgba(255,255,255,0.85)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            meta.data.forEach((arc, i) => {
              const v = Number(ds.data[i]);
              if (!Number.isFinite(v) || v <= 0) return;
              const p = v / total;
              if (p < 0.045) return; // avoid clutter
              const pos = arc.tooltipPosition();
              ctx.fillText(`${Math.round(p * 100)}%`, pos.x, pos.y);
            });
            ctx.restore();
          },
        };

        function toast(title, message, tone = "info") {
          const dotClass = tone === "good" ? "good" : tone === "warn" ? "warn" : tone === "bad" ? "bad" : "";
          const el = document.createElement("div");
          el.className = "t";
          el.innerHTML = `
            <div class="dot ${dotClass}"></div>
            <div>
              <strong>${escapeHtml(title)}</strong>
              <span>${escapeHtml(message)}</span>
            </div>
          `;
          els.toast.appendChild(el);
          setTimeout(() => {
            el.style.opacity = "0";
            el.style.transform = "translateY(2px)";
            el.style.transition = "opacity 250ms ease, transform 250ms ease";
          }, 3400);
          setTimeout(() => el.remove(), 3900);
        }

        function escapeHtml(str) {
          return String(str)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
        }

        function clamp(n, a, b) {
          return Math.max(a, Math.min(b, n));
        }

        function isProbablyNumber(v) {
          if (v === null || v === undefined) return false;
          const s = String(v).trim();
          if (!s) return false;
          if (/^(na|nan|null|undefined|n\/a)$/i.test(s)) return false;
          const x = Number(s.replaceAll(",", ""));
          return Number.isFinite(x);
        }

        function asNumber(v) {
          if (v === null || v === undefined) return null;
          const s = String(v).trim();
          if (!s) return null;
          if (/^(na|nan|null|undefined|n\/a)$/i.test(s)) return null;
          const x = Number(s.replaceAll(",", ""));
          return Number.isFinite(x) ? x : null;
        }

        function isProbablyDate(v) {
          if (v === null || v === undefined) return false;
          const s = String(v).trim();
          if (!s) return false;
          const t = Date.parse(s);
          return Number.isFinite(t);
        }

        function asDate(v) {
          const s = String(v ?? "").trim();
          if (!s) return null;
          const t = Date.parse(s);
          return Number.isFinite(t) ? new Date(t) : null;
        }

        function hexToRgba(hex, alpha = 1) {
          const h = String(hex || "").trim();
          const m = /^#?([0-9a-f]{6}|[0-9a-f]{3})$/i.exec(h);
          if (!m) return `rgba(255,255,255,${alpha})`;
          let v = m[1];
          if (v.length === 3) v = v.split("").map((c) => c + c).join("");
          const r = parseInt(v.slice(0, 2), 16);
          const g = parseInt(v.slice(2, 4), 16);
          const b = parseInt(v.slice(4, 6), 16);
          return `rgba(${r},${g},${b},${alpha})`;
        }

        function withAlpha(color, alpha) {
          if (!color) return hexToRgba("#ffffff", alpha);
          if (color.startsWith("rgba(")) return color.replace(/rgba\(([^)]+),[^)]+\)/, `rgba($1,${alpha})`);
          if (color.startsWith("rgb(")) return color.replace("rgb(", "rgba(").replace(")", `,${alpha})`);
          if (color.startsWith("#")) return hexToRgba(color, alpha);
          return color;
        }

        function getCssVar(name) {
          return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        function enableControls(enabled) {
          const all = [
            els.chartType,
            els.legendPos,
            els.xCol,
            els.yScale,
            els.scatterX,
            els.scatterY,
            els.pieLabel,
            els.pieValue,
            els.pieAgg,
            els.pieTopN,
            els.palette,
            els.lineTension,
            els.chartBg,
            els.btnBgAuto,
            els.gridOpacity,
            els.pointRadius,
            els.strokeWidth,
            els.transparentBg,
            els.showDataLabels,
            els.exportScale,
            els.exportName,
            els.btnDownload2,
            els.btnCopy,
            els.btnResetView,
            els.btnClear,
            els.search,
            els.previewCount,
          ];
          all.forEach((el) => (el.disabled = !enabled));
        }

        function setTheme(theme) {
          els.app.setAttribute("data-theme", theme);
          els.themeToggle.checked = theme === "light";
          localStorage.setItem("dvp_theme", theme);
          // Update chart colors when theme changes
          updateChart({ silentToast: true });
        }

        function initTheme() {
          const saved = localStorage.getItem("dvp_theme");
          if (saved === "light" || saved === "dark") return setTheme(saved);
          const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
          setTheme(prefersLight ? "light" : "dark");
        }

        function setActiveTab(which) {
          const isSummary = which === "summary";
          els.tabSummary.setAttribute("aria-selected", String(isSummary));
          els.tabPreview.setAttribute("aria-selected", String(!isSummary));
          els.panelSummary.style.display = isSummary ? "" : "none";
          els.panelPreview.style.display = isSummary ? "none" : "";
        }

        function populateSelect(select, items, selected) {
          select.innerHTML = "";
          for (const it of items) {
            const opt = document.createElement("option");
            opt.value = it.value;
            opt.textContent = it.label ?? it.value;
            select.appendChild(opt);
          }
          if (selected && items.some((x) => x.value === selected)) select.value = selected;
        }

        function detectColumns(headers, rows) {
          const info = {};
          for (const h of headers) {
            const values = rows
              .map((r) => r[h])
              .filter((v) => v !== null && v !== undefined && String(v).trim() !== "");
            const sample = values.slice(0, 300);
            const nonEmpty = values.length;
            const unique = new Set(values.map((v) => String(v))).size;
            let numCount = 0;
            let dateCount = 0;
            let numericMin = Infinity;
            let numericMax = -Infinity;
            for (const v of sample) {
              if (isProbablyNumber(v)) {
                numCount++;
                const n = asNumber(v);
                if (n !== null) {
                  numericMin = Math.min(numericMin, n);
                  numericMax = Math.max(numericMax, n);
                }
              }
              if (isProbablyDate(v)) dateCount++;
            }
            const denom = Math.max(1, sample.length);
            const numRatio = numCount / denom;
            const dateRatio = dateCount / denom;
            let type = "string";
            if (nonEmpty === 0) type = "empty";
            else if (dateRatio > 0.86 && numRatio < 0.75) type = "date";
            else if (numRatio > 0.92) type = "number";
            info[h] = {
              type,
              nonEmpty,
              unique,
              numericMin: Number.isFinite(numericMin) ? numericMin : null,
              numericMax: Number.isFinite(numericMax) ? numericMax : null,
            };
          }
          const numericCols = headers.filter((h) => info[h].type === "number");
          const dateCols = headers.filter((h) => info[h].type === "date");
          const categoricalCols = headers.filter((h) => info[h].type === "string");
          return { info, numericCols, dateCols, categoricalCols };
        }

        function bestDefaultX(headers, cols) {
          if (!headers.length) return null;
          const date = cols.dateCols[0];
          if (date) return date;
          const cat = cols.categoricalCols[0];
          if (cat) return cat;
          return headers[0];
        }

        function pickDefaultYs(numericCols) {
          return numericCols.slice(0, 3);
        }

        function fillChips() {
          els.dataChips.innerHTML = "";
          const rowCount = state.rows.length;
          const colCount = state.headers.length;
          const numericCount = state.numericCols.length;
          const dateCount = state.dateCols.length;
          const catCount = state.categoricalCols.length;

          const chips = [
            { k: "Rows", v: rowCount.toLocaleString() },
            { k: "Cols", v: colCount.toLocaleString() },
            { k: "Numeric", v: numericCount.toLocaleString() },
            { k: "Date", v: dateCount.toLocaleString() },
            { k: "Text", v: catCount.toLocaleString() },
          ];
          for (const c of chips) {
            const el = document.createElement("div");
            el.className = "chip";
            el.innerHTML = `<b>${escapeHtml(c.v)}</b> ${escapeHtml(c.k)}`;
            els.dataChips.appendChild(el);
          }
        }

        function fillSummary() {
          els.statRows.textContent = state.rows.length ? state.rows.length.toLocaleString() : "—";
          els.statRows2.textContent = state.rawName ? `Loaded: ${state.rawName}` : "Loaded: —";
          els.statCols.textContent = state.headers.length ? state.headers.length.toLocaleString() : "—";
          els.statCols2.textContent = `Numeric: ${state.numericCols.length.toLocaleString()}`;

          els.colTypeChips.innerHTML = "";
          for (const h of state.headers.slice(0, 30)) {
            const meta = state.columns[h];
            const el = document.createElement("div");
            el.className = "chip";
            const t = meta?.type || "—";
            let suffix = "";
            if (t === "number" && meta.numericMin !== null) suffix = ` min ${meta.numericMin} max ${meta.numericMax}`;
            if (t === "date") suffix = ` parsed`;
            if (t === "string") suffix = ` uniques ${meta.unique}`;
            el.innerHTML = `<b>${escapeHtml(h)}</b> ${escapeHtml(t)} <span style="opacity:.75; font-family:var(--mono)">${escapeHtml(
              suffix.trim()
            )}</span>`;
            els.colTypeChips.appendChild(el);
          }
        }

        function buildPreviewTable() {
          const limit = Number(els.previewCount.value || 25);
          const q = String(els.search.value || "").trim().toLowerCase();
          const headers = state.headers;
          const rows = state.rows;
          const filtered = q
            ? rows.filter((r) => headers.some((h) => String(r[h] ?? "").toLowerCase().includes(q)))
            : rows;
          const slice = filtered.slice(0, limit);
          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const trh = document.createElement("tr");
          for (const h of headers) {
            const th = document.createElement("th");
            th.textContent = h;
            trh.appendChild(th);
          }
          thead.appendChild(trh);
          table.appendChild(thead);
          const tbody = document.createElement("tbody");
          for (const r of slice) {
            const tr = document.createElement("tr");
            for (const h of headers) {
              const td = document.createElement("td");
              td.textContent = r[h] ?? "";
              tr.appendChild(td);
            }
            tbody.appendChild(tr);
          }
          table.appendChild(tbody);
          els.tableWrap.innerHTML = "";
          els.tableWrap.appendChild(table);
        }

        function showOverlay(show) {
          els.overlay.style.display = show ? "" : "none";
        }

        function configureMappingUI() {
          const t = state.chosen.chartType;
          els.mappingStandard.style.display = t === "scatter" || t === "pie" || t === "doughnut" || t === "polarArea" ? "none" : "";
          els.mappingScatter.style.display = t === "scatter" ? "" : "none";
          els.mappingPie.style.display = t === "pie" || t === "doughnut" || t === "polarArea" ? "" : "none";
          const showLabels = t === "pie" || t === "doughnut" || t === "polarArea";
          els.showDataLabels.parentElement.style.display = showLabels ? "" : "none";
        }

        function syncControlValuesToUI() {
          els.chartType.value = state.chosen.chartType;
          els.legendPos.value = state.chosen.legendPos;
          els.yScale.value = state.chosen.yScale;
          els.palette.value = state.chosen.palette;
          els.lineTension.value = state.chosen.tension;
          els.lineTensionVal.textContent = state.chosen.tension.toFixed(2);
          els.gridOpacity.value = state.chosen.gridOpacity;
          els.gridOpacityVal.textContent = state.chosen.gridOpacity.toFixed(2);
          els.pointRadius.value = state.chosen.pointRadius;
          els.pointRadiusVal.textContent = String(state.chosen.pointRadius);
          els.strokeWidth.value = state.chosen.strokeWidth;
          els.strokeWidthVal.textContent = String(state.chosen.strokeWidth);
          els.transparentBg.checked = state.chosen.transparentBg;
          els.showDataLabels.checked = state.chosen.showDataLabels;
          els.exportScale.value = String(state.chosen.exportScale);
          els.exportName.value = els.exportName.value || "chart";
          els.chartBg.value = state.chosen.chartBg;
          els.maxPoints.value = String(state.chosen.maxPoints);
          els.maxPointsVal.textContent = String(state.chosen.maxPoints);
          els.sortByX.value = state.chosen.sortByX;
        }

        function buildYList() {
          els.yCols.innerHTML = "";
          const yCandidates = state.numericCols.length ? state.numericCols : state.headers;
          for (const name of yCandidates) {
            const meta = state.columns[name];
            const item = document.createElement("label");
            item.className = "y-item";
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = state.chosen.ys.has(name);
            cb.addEventListener("change", () => {
              if (cb.checked) state.chosen.ys.add(name);
              else state.chosen.ys.delete(name);
              updateSeriesStylesFromSelection();
              updateChart();
            });
            const span = document.createElement("span");
            span.className = "name";
            span.textContent = name;
            const badge = document.createElement("span");
            badge.className = "badge";
            badge.textContent = meta?.type || "—";
            item.appendChild(cb);
            item.appendChild(span);
            item.appendChild(badge);
            els.yCols.appendChild(item);
          }
        }

        function paletteColorAt(i) {
          const arr = PALETTES[state.chosen.palette] || PALETTES.aurora;
          return arr[i % arr.length];
        }

        function updateSeriesStylesFromSelection() {
          const existing = state.seriesStyle;
          const palette = PALETTES[state.chosen.palette] || PALETTES.aurora;
          let idx = 0;

          function ensure(key) {
            if (existing.has(key)) return;
            existing.set(key, { color: palette[idx % palette.length], alpha: 0.9 });
          }

          const t = state.chosen.chartType;
          if (t === "scatter") {
            ensure("Scatter");
            return;
          }
          if (t === "pie" || t === "doughnut" || t === "polarArea") {
            ensure("Slices");
            return;
          }
          const ys = Array.from(state.chosen.ys);
          for (const y of ys) {
            ensure(y);
            idx++;
          }
        }

        function buildSeriesColorControls(datasets) {
          els.seriesColors.innerHTML = "";
          for (const ds of datasets) {
            const key = ds.__styleKey || ds.label || "Series";
            const style = state.seriesStyle.get(key) || { color: paletteColorAt(0), alpha: 0.9 };
            if (!state.seriesStyle.has(key)) state.seriesStyle.set(key, style);

            const row = document.createElement("div");
            row.className = "color-input";
            const c = document.createElement("input");
            c.type = "color";
            c.value = normalizeHex(style.color);
            c.title = "Pick color";
            c.addEventListener("input", () => {
              style.color = c.value;
              state.seriesStyle.set(key, style);
              updateChart({ silentToast: true });
            });

            const label = document.createElement("div");
            label.className = "label";
            label.textContent = key;

            const alpha = document.createElement("input");
            alpha.type = "range";
            alpha.min = "0.15";
            alpha.max = "1";
            alpha.step = "0.05";
            alpha.value = String(style.alpha ?? 0.9);
            alpha.style.maxWidth = "130px";
            alpha.title = "Opacity";
            alpha.addEventListener("input", () => {
              style.alpha = Number(alpha.value);
              state.seriesStyle.set(key, style);
              updateChart({ silentToast: true });
            });
            row.appendChild(c);
            row.appendChild(label);
            row.appendChild(alpha);
            els.seriesColors.appendChild(row);
          }
          if (!datasets.length) {
            const empty = document.createElement("div");
            empty.className = "tiny muted";
            empty.textContent = "Select series to customize colors.";
            els.seriesColors.appendChild(empty);
          }
        }

        function normalizeHex(color) {
          const s = String(color || "").trim();
          if (/^#[0-9a-f]{6}$/i.test(s)) return s;
          if (/^#[0-9a-f]{3}$/i.test(s)) return (
            "#" +
            s
              .slice(1)
              .split("")
              .map((c) => c + c)
              .join("")
          );
          // best-effort fallback: palette
          return paletteColorAt(0);
        }

        function sortedRowsForX(rows, xKey) {
          if (state.chosen.sortByX === "off") return rows;
          const dir = state.chosen.sortByX === "desc" ? -1 : 1;
          const type = state.columns[xKey]?.type;
          const copy = rows.slice();
          copy.sort((a, b) => {
            const av = a[xKey];
            const bv = b[xKey];
            if (type === "number") {
              const an = asNumber(av);
              const bn = asNumber(bv);
              if (an === null && bn === null) return 0;
              if (an === null) return 1;
              if (bn === null) return -1;
              return (an - bn) * dir;
            }
            if (type === "date") {
              const ad = asDate(av)?.getTime();
              const bd = asDate(bv)?.getTime();
              if (!Number.isFinite(ad) && !Number.isFinite(bd)) return 0;
              if (!Number.isFinite(ad)) return 1;
              if (!Number.isFinite(bd)) return -1;
              return (ad - bd) * dir;
            }
            const as = String(av ?? "");
            const bs = String(bv ?? "");
            return as.localeCompare(bs) * dir;
          });
          return copy;
        }

        function downsampleRows(rows) {
          const max = state.chosen.maxPoints || 4000;
          if (rows.length <= max) return rows;
          const step = Math.ceil(rows.length / max);
          const sampled = [];
          for (let i = 0; i < rows.length; i += step) sampled.push(rows[i]);
          return sampled;
        }

        function buildConfig() {
          if (!state.headers.length || !state.rows.length) return null;

          const themeText = getCssVar("--text");
          const themeMuted = getCssVar("--muted");
          const grid = `rgba(255,255,255,${state.chosen.gridOpacity})`;
          const gridLight = `rgba(12,18,33,${state.chosen.gridOpacity})`;
          const isLight = els.app.getAttribute("data-theme") === "light";
          const gridColor = isLight ? gridLight : grid;
          const bgAuto = getCssVar("--chart-bg");
          const bg = state.chosen.transparentBg
            ? null
            : state.chosen.chartBg === "auto"
              ? bgAuto
              : state.chosen.chartBg;

          const legendPos = state.chosen.legendPos === "none" ? "top" : state.chosen.legendPos;
          const showLegend = state.chosen.legendPos !== "none";

          const basePlugins = {
            legend: {
              display: showLegend,
              position: legendPos,
              labels: {
                color: themeMuted,
                boxWidth: 10,
                boxHeight: 10,
                usePointStyle: true,
                pointStyle: "circle",
              },
            },
            tooltip: {
              backgroundColor: isLight ? "rgba(255,255,255,0.92)" : "rgba(12,18,33,0.92)",
              titleColor: isLight ? "rgba(12,18,33,0.9)" : "rgba(255,255,255,0.9)",
              bodyColor: isLight ? "rgba(12,18,33,0.82)" : "rgba(255,255,255,0.82)",
              borderColor: isLight ? "rgba(12,18,33,0.14)" : "rgba(255,255,255,0.14)",
              borderWidth: 1,
              cornerRadius: 12,
              padding: 10,
            },
          };

          const t = state.chosen.chartType;
          if (t === "pie" || t === "doughnut" || t === "polarArea") {
            const labelKey = state.chosen.pieLabel || state.headers[0];
            const valueKey = state.chosen.pieValue || state.numericCols[0] || state.headers[0];
            const agg = state.chosen.pieAgg;
            const topN = Number(state.chosen.pieTopN || 8);
            const buckets = new Map(); // label -> {sum,count}

            for (const r of state.rows) {
              const label = String(r[labelKey] ?? "").trim() || "(blank)";
              const v = asNumber(r[valueKey]);
              const entry = buckets.get(label) || { sum: 0, count: 0 };
              entry.count += 1;
              if (v !== null) entry.sum += v;
              buckets.set(label, entry);
            }

            let items = Array.from(buckets.entries()).map(([k, v]) => {
              let out = 0;
              if (agg === "count") out = v.count;
              else if (agg === "avg") out = v.count ? v.sum / v.count : 0;
              else out = v.sum;
              return { label: k, value: out };
            });
            items.sort((a, b) => b.value - a.value);

            const shown = items.slice(0, topN);
            const rest = items.slice(topN);
            const restSum = rest.reduce((a, b) => a + b.value, 0);
            if (rest.length && restSum > 0) shown.push({ label: "Other", value: restSum });

            const colors = shown.map((_, i) => paletteColorAt(i));
            const dsKey = "Slices";
            const dsStyle = state.seriesStyle.get(dsKey) || { color: paletteColorAt(0), alpha: 0.9 };

            const data = {
              labels: shown.map((x) => x.label),
              datasets: [
                {
                  label: `${agg.toUpperCase()} of ${valueKey} by ${labelKey}`,
                  data: shown.map((x) => x.value),
                  backgroundColor: colors.map((c) => withAlpha(c, dsStyle.alpha)),
                  borderColor: colors.map((c) => withAlpha(c, clamp(dsStyle.alpha + 0.06, 0.2, 1))),
                  borderWidth: 1,
                  __styleKey: dsKey,
                },
              ],
            };

            const title = `${capitalize(t)} • ${labelKey} → ${agg}(${valueKey})`;
            const subtitle = `${state.rows.length.toLocaleString()} rows • ${shown.length} slices`;
            return {
              type: t,
              data,
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 450 },
                plugins: {
                  ...basePlugins,
                  title: { display: false },
                  pieValueLabels: {
                    enabled: state.chosen.showDataLabels,
                    color: isLight ? "rgba(12,18,33,0.82)" : "rgba(255,255,255,0.86)",
                  },
                },
              },
              plugins: [chartAreaBackground, pieValueLabels],
              __meta: { title, subtitle, bg },
            };
          }

          if (t === "scatter") {
            const xKey = state.chosen.scatterX || state.numericCols[0] || state.headers[0];
            const yKey = state.chosen.scatterY || state.numericCols[1] || state.numericCols[0] || state.headers[0];
            const key = "Scatter";
            const style = state.seriesStyle.get(key) || { color: paletteColorAt(0), alpha: 0.85 };
            const rows = downsampleRows(state.rows);
            const points = rows
              .map((r) => {
                const x = asNumber(r[xKey]);
                const y = asNumber(r[yKey]);
                return x === null || y === null ? null : { x, y };
              })
              .filter(Boolean);
            const data = {
              datasets: [
                {
                  label: `${yKey} vs ${xKey}`,
                  data: points,
                  pointRadius: state.chosen.pointRadius + 1,
                  backgroundColor: withAlpha(style.color, clamp(style.alpha, 0.15, 1)),
                  borderColor: withAlpha(style.color, clamp(style.alpha + 0.08, 0.2, 1)),
                  __styleKey: key,
                },
              ],
            };
            const title = `Scatter • ${xKey} ↔ ${yKey}`;
            const subtitle = `${points.length.toLocaleString()} points${rows.length !== state.rows.length ? " (downsampled)" : ""}`;
            return {
              type: "scatter",
              data,
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 450 },
                plugins: { ...basePlugins },
                scales: {
                  x: {
                    grid: { color: gridColor },
                    ticks: { color: themeMuted },
                    title: { display: true, text: xKey, color: themeMuted },
                  },
                  y: {
                    type: state.chosen.yScale,
                    grid: { color: gridColor },
                    ticks: { color: themeMuted },
                    title: { display: true, text: yKey, color: themeMuted },
                  },
                },
              },
              plugins: [chartAreaBackground],
              __meta: { title, subtitle, bg },
            };
          }

          // Standard axes charts
          const xKey = state.chosen.x || state.headers[0];
          const xType = state.columns[xKey]?.type || "string";
          const yKeys = Array.from(state.chosen.ys);
          const effectiveY = yKeys.length ? yKeys : state.numericCols.slice(0, 1);
          const isStacked = t === "stackedBar";
          const resolvedType = t === "stackedBar" ? "bar" : t === "area" ? "line" : t;

          const rowsSorted = sortedRowsForX(state.rows, xKey);
          const rows = downsampleRows(rowsSorted);
          const timeScale = xType === "date";

          const datasets = [];
          for (let i = 0; i < effectiveY.length; i++) {
            const yKey = effectiveY[i];
            const style = state.seriesStyle.get(yKey) || { color: paletteColorAt(i), alpha: 0.9 };
            const color = style.color || paletteColorAt(i);
            const alpha = clamp(style.alpha ?? 0.9, 0.15, 1);
            const common = {
              label: yKey,
              borderColor: withAlpha(color, clamp(alpha + 0.05, 0.2, 1)),
              backgroundColor: withAlpha(color, resolvedType === "bar" || resolvedType === "radar" ? alpha : alpha * 0.38),
              borderWidth: state.chosen.strokeWidth,
              pointRadius: resolvedType === "line" || resolvedType === "radar" ? state.chosen.pointRadius : 0,
              tension: resolvedType === "line" ? state.chosen.tension : 0,
              fill: t === "area" ? true : false,
              __styleKey: yKey,
            };

            if (timeScale) {
              common.data = rows
                .map((r) => {
                  const x = asDate(r[xKey]);
                  const y = asNumber(r[yKey]);
                  if (!x || y === null) return null;
                  return { x, y };
                })
                .filter(Boolean);
            } else {
              common.data = rows.map((r) => asNumber(r[yKey]));
            }
            datasets.push(common);
          }

          const labels = timeScale ? undefined : rows.map((r) => String(r[xKey] ?? ""));
          const data = { labels, datasets };

          const title = `${capitalize(t)} • ${xKey} → ${effectiveY.join(", ") || "Y"}`;
          const subtitle = `${rows.length.toLocaleString()} rows${rows.length !== state.rows.length ? " (downsampled)" : ""}`;

          const scales = {
            x: {
              stacked: isStacked,
              grid: { color: gridColor },
              ticks: { color: themeMuted, maxRotation: 0, autoSkip: true },
              title: { display: true, text: xKey, color: themeMuted },
            },
            y: {
              type: state.chosen.yScale,
              stacked: isStacked,
              grid: { color: gridColor },
              ticks: { color: themeMuted },
              title: { display: true, text: effectiveY.length > 1 ? "Value" : effectiveY[0] || "Value", color: themeMuted },
            },
          };

          if (timeScale) {
            scales.x.type = "time";
            scales.x.time = { unit: "day", tooltipFormat: "yyyy-MM-dd" };
            // Chart.js time scale needs an adapter; fallback gracefully if missing
            // If no adapter, Chart.js will treat Date objects as numbers (ms); still charts OK.
          }

          const options = {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 450 },
            plugins: { ...basePlugins },
            scales: resolvedType === "radar" ? undefined : scales,
          };

          if (resolvedType === "radar") {
            options.scales = {
              r: {
                grid: { color: gridColor },
                angleLines: { color: gridColor },
                pointLabels: { color: themeMuted },
                ticks: { color: themeMuted, backdropColor: "transparent" },
              },
            };
          }

          return {
            type: resolvedType,
            data,
            options,
            plugins: [chartAreaBackground],
            __meta: { title, subtitle, bg },
          };
        }

        function destroyChart() {
          if (chart) {
            chart.destroy();
            chart = null;
          }
        }

        function updateChart({ silentToast = false } = {}) {
          const cfg = buildConfig();
          if (!cfg) {
            destroyChart();
            showOverlay(true);
            return;
          }

          const { __meta } = cfg;
          els.chartTitle.textContent = __meta.title;
          els.chartSubtitle.textContent = __meta.subtitle;
          showOverlay(false);

          // Update background plugin options
          const bgColor = __meta.bg;

          // Build series controls from current datasets
          buildSeriesColorControls(cfg.data.datasets || []);

          if (!chart) {
            chart = new Chart(els.chartCanvas.getContext("2d"), {
              ...cfg,
              options: {
                ...cfg.options,
                plugins: {
                  ...cfg.options.plugins,
                  chartAreaBackground: { color: bgColor },
                },
              },
            });
          } else {
            chart.config.type = cfg.type;
            chart.config.data = cfg.data;
            chart.config.options = {
              ...cfg.options,
              plugins: {
                ...cfg.options.plugins,
                chartAreaBackground: { color: bgColor },
              },
            };
            chart.update();
          }

          const disabled = !chart;
          els.btnDownload.disabled = disabled;
          els.btnDownload2.disabled = disabled;
          els.btnCopy.disabled = disabled;
          if (!silentToast) {
            const kind = state.chosen.chartType;
            toast("Chart updated", `Rendering ${kind} chart.`, "good");
          }
        }

        function capitalize(s) {
          const str = String(s || "");
          if (!str) return str;
          return str[0].toUpperCase() + str.slice(1).replaceAll(/([A-Z])/g, " $1").trim();
        }

        function resetView() {
          if (!state.headers.length) return;
          state.seriesStyle = new Map();
          state.chosen.chartType = "line";
          state.chosen.legendPos = "top";
          state.chosen.yScale = "linear";
          state.chosen.palette = "aurora";
          state.chosen.tension = 0.25;
          state.chosen.gridOpacity = 0.12;
          state.chosen.pointRadius = 3;
          state.chosen.strokeWidth = 3;
          state.chosen.chartBg = "auto";
          state.chosen.transparentBg = false;
          state.chosen.showDataLabels = false;
          state.chosen.exportScale = 1;
          state.chosen.sortByX = "off";
          state.chosen.maxPoints = Number(els.maxPoints.value || 4000);

          state.chosen.x = bestDefaultX(state.headers, state);
          state.chosen.ys = new Set(pickDefaultYs(state.numericCols));
          state.chosen.scatterX = state.numericCols[0] || state.headers[0];
          state.chosen.scatterY = state.numericCols[1] || state.numericCols[0] || state.headers[0];
          state.chosen.pieLabel = state.categoricalCols[0] || state.headers[0];
          state.chosen.pieValue = state.numericCols[0] || state.headers[0];
          state.chosen.pieAgg = "sum";
          state.chosen.pieTopN = 8;
          updateSeriesStylesFromSelection();
          syncControlValuesToUI();
          configureMappingUI();
          buildYList();
          updateChart();
        }

        function clearData() {
          destroyChart();
          state.rawName = null;
          state.rawText = null;
          state.headers = [];
          state.rows = [];
          state.columns = {};
          state.numericCols = [];
          state.categoricalCols = [];
          state.dateCols = [];
          state.chosen.x = null;
          state.chosen.ys = new Set();
          state.seriesStyle = new Map();
          enableControls(false);
          els.dataMeta.textContent = "No file";
          els.mapMeta.textContent = "Awaiting data";
          els.dataChips.innerHTML = "";
          els.colTypeChips.innerHTML = "";
          els.tableWrap.innerHTML = "";
          els.statRows.textContent = "—";
          els.statCols.textContent = "—";
          els.statRows2.textContent = "Loaded: —";
          els.statCols2.textContent = "Numeric: —";
          els.seriesColors.innerHTML = `<div class="tiny muted">Upload data to customize.</div>`;
          els.chartTitle.textContent = "Your chart will appear here";
          els.chartSubtitle.textContent = "Upload a CSV or load the sample dataset.";
          showOverlay(true);
          toast("Cleared", "Dataset removed.", "warn");
        }

        function parseCsvText(text, name = "CSV") {
          const delimiter = els.delimiter.value === "auto" ? "" : els.delimiter.value;
          const hasHeader = els.headerRow.value === "true";

          const parsed = Papa.parse(text, {
            header: hasHeader,
            skipEmptyLines: true,
            delimiter: delimiter || undefined,
            dynamicTyping: false,
            transform: (v) => (typeof v === "string" ? v.trim() : v),
          });

          if (parsed.errors?.length) {
            const e = parsed.errors[0];
            toast("Parse warning", e.message || "CSV parsed with warnings.", "warn");
          }

          let headers = [];
          let rows = [];
          if (hasHeader) {
            headers = parsed.meta.fields || [];
            rows = (parsed.data || []).filter((r) => r && typeof r === "object");
          } else {
            const arr = parsed.data || [];
            const maxLen = arr.reduce((m, r) => Math.max(m, Array.isArray(r) ? r.length : 0), 0);
            headers = Array.from({ length: maxLen }, (_, i) => `Column ${i + 1}`);
            rows = arr
              .filter((r) => Array.isArray(r))
              .map((r) => {
                const o = {};
                headers.forEach((h, i) => (o[h] = r[i] ?? ""));
                return o;
              });
          }

          headers = headers.map((h) => String(h || "").trim()).filter(Boolean);
          if (!headers.length || !rows.length) {
            toast("No data", "Could not find rows/columns in that CSV.", "bad");
            return;
          }

          // Hard safety: keep memory sane for huge files (still allow charting)
          const MAX_ROWS = 200000;
          if (rows.length > MAX_ROWS) {
            toast("Large dataset", `Loaded ${rows.length.toLocaleString()} rows — capping to ${MAX_ROWS.toLocaleString()} for performance.`, "warn");
            rows = rows.slice(0, MAX_ROWS);
          }

          const { info, numericCols, dateCols, categoricalCols } = detectColumns(headers, rows);
          state.rawName = name;
          state.rawText = text;
          state.headers = headers;
          state.rows = rows;
          state.columns = info;
          state.numericCols = numericCols;
          state.dateCols = dateCols;
          state.categoricalCols = categoricalCols;

          // defaults
          state.chosen.chartType = "line";
          state.chosen.legendPos = "top";
          state.chosen.yScale = "linear";
          state.chosen.x = bestDefaultX(headers, state);
          state.chosen.ys = new Set(pickDefaultYs(numericCols));
          state.chosen.scatterX = numericCols[0] || headers[0];
          state.chosen.scatterY = numericCols[1] || numericCols[0] || headers[0];
          state.chosen.pieLabel = categoricalCols[0] || headers[0];
          state.chosen.pieValue = numericCols[0] || headers[0];
          state.chosen.pieAgg = "sum";
          state.chosen.pieTopN = 8;
          state.seriesStyle = new Map();
          updateSeriesStylesFromSelection();

          enableControls(true);
          configureMappingUI();

          els.dataMeta.textContent = `${name} • ${rows.length.toLocaleString()}×${headers.length.toLocaleString()}`;
          els.mapMeta.textContent = "Ready";
          fillChips();
          fillSummary();

          populateSelect(
            els.xCol,
            headers.map((h) => ({ value: h, label: h })),
            state.chosen.x
          );
          populateSelect(
            els.scatterX,
            state.numericCols.map((h) => ({ value: h, label: h })).concat(headers.map((h) => ({ value: h, label: h }))),
            state.chosen.scatterX
          );
          populateSelect(
            els.scatterY,
            state.numericCols.map((h) => ({ value: h, label: h })).concat(headers.map((h) => ({ value: h, label: h }))),
            state.chosen.scatterY
          );
          populateSelect(
            els.pieLabel,
            headers.map((h) => ({ value: h, label: h })),
            state.chosen.pieLabel
          );
          populateSelect(
            els.pieValue,
            state.numericCols.map((h) => ({ value: h, label: h })).concat(headers.map((h) => ({ value: h, label: h }))),
            state.chosen.pieValue
          );

          buildYList();
          syncControlValuesToUI();
          buildPreviewTable();
          updateChart({ silentToast: true });
          toast("Loaded", `Parsed ${rows.length.toLocaleString()} rows from ${name}.`, "good");
        }

        async function loadFile(file) {
          if (!file) return;
          const name = file.name || "CSV";
          if (file.size > 35 * 1024 * 1024) toast("Large file", "This CSV is large; parsing may take a moment.", "warn");
          const text = await file.text();
          parseCsvText(text, name);
        }

        function downloadPng() {
          if (!chart) return;
          const scale = Number(state.chosen.exportScale || 1);
          const filename = (els.exportName.value || "chart").replace(/[^\w\-]+/g, "_");
          const bgBefore = state.chosen.transparentBg ? null : state.chosen.chartBg;

          const canvas = chart.canvas;
          const w = canvas.width;
          const h = canvas.height;

          // Upscale export by drawing onto an offscreen canvas
          const out = document.createElement("canvas");
          out.width = Math.floor(w * scale);
          out.height = Math.floor(h * scale);
          const ctx = out.getContext("2d");
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";

          if (!state.chosen.transparentBg) {
            const fill = bgBefore === "auto" ? getCssVar("--chart-bg") : bgBefore;
            ctx.fillStyle = fill || "transparent";
            ctx.fillRect(0, 0, out.width, out.height);
          }
          ctx.drawImage(canvas, 0, 0, out.width, out.height);

          const url = out.toDataURL("image/png");
          const a = document.createElement("a");
          a.href = url;
          a.download = `${filename}.png`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          toast("Exported", `Downloaded ${a.download} at ${scale}×.`, "good");
        }

        function dataUrlToBlob(dataUrl) {
          const [meta, b64] = dataUrl.split(",");
          const typeMatch = /data:([^;]+)/.exec(meta);
          const type = typeMatch ? typeMatch[1] : "image/png";
          const bin = atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
          return new Blob([arr], { type });
        }

        async function copyImage() {
          if (!chart) return;
          const scale = Number(state.chosen.exportScale || 1);
          const canvas = chart.canvas;
          const out = document.createElement("canvas");
          out.width = Math.floor(canvas.width * scale);
          out.height = Math.floor(canvas.height * scale);
          const ctx = out.getContext("2d");
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";
          if (!state.chosen.transparentBg) {
            const fill = state.chosen.chartBg === "auto" ? getCssVar("--chart-bg") : state.chosen.chartBg;
            ctx.fillStyle = fill || "transparent";
            ctx.fillRect(0, 0, out.width, out.height);
          }
          ctx.drawImage(canvas, 0, 0, out.width, out.height);
          const dataUrl = out.toDataURL("image/png");

          try {
            if (!navigator.clipboard || !window.ClipboardItem) throw new Error("Clipboard API unavailable");
            const blob = dataUrlToBlob(dataUrl);
            await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
            toast("Copied", "Chart image copied to clipboard.", "good");
          } catch (e) {
            toast("Copy failed", "Your browser blocked clipboard access. Use “Download PNG” instead.", "warn");
          }
        }

        function wireEvents() {
          initTheme();

          els.themeToggle.addEventListener("change", () => setTheme(els.themeToggle.checked ? "light" : "dark"));

          els.btnChoose.addEventListener("click", () => els.fileInput.click());
          els.fileInput.addEventListener("change", (e) => {
            const file = e.target.files?.[0];
            loadFile(file);
            e.target.value = "";
          });

          // Drag & drop
          ["dragenter", "dragover"].forEach((ev) => {
            els.dropZone.addEventListener(ev, (e) => {
              e.preventDefault();
              e.stopPropagation();
              els.dropZone.style.borderColor = "rgba(124,108,255,0.65)";
            });
          });
          ["dragleave", "drop"].forEach((ev) => {
            els.dropZone.addEventListener(ev, (e) => {
              e.preventDefault();
              e.stopPropagation();
              els.dropZone.style.borderColor = "";
            });
          });
          els.dropZone.addEventListener("drop", (e) => {
            const file = e.dataTransfer?.files?.[0];
            if (!file) return;
            loadFile(file);
          });

          els.btnSample.addEventListener("click", () => parseCsvText(SAMPLE_CSV, "Sample dataset"));

          els.delimiter.addEventListener("change", () => {
            if (state.rawText) parseCsvText(state.rawText, state.rawName || "CSV");
          });
          els.headerRow.addEventListener("change", () => {
            if (state.rawText) parseCsvText(state.rawText, state.rawName || "CSV");
          });

          els.maxPoints.addEventListener("input", () => {
            state.chosen.maxPoints = Number(els.maxPoints.value);
            els.maxPointsVal.textContent = String(state.chosen.maxPoints);
            updateChart({ silentToast: true });
          });

          els.sortByX.addEventListener("change", () => {
            state.chosen.sortByX = els.sortByX.value;
            updateChart({ silentToast: true });
          });

          els.chartType.addEventListener("change", () => {
            state.chosen.chartType = els.chartType.value;
            configureMappingUI();
            updateSeriesStylesFromSelection();
            updateChart();
          });

          els.legendPos.addEventListener("change", () => {
            state.chosen.legendPos = els.legendPos.value;
            updateChart({ silentToast: true });
          });

          els.xCol.addEventListener("change", () => {
            state.chosen.x = els.xCol.value;
            updateChart();
          });

          els.yScale.addEventListener("change", () => {
            state.chosen.yScale = els.yScale.value;
            updateChart({ silentToast: true });
          });

          els.scatterX.addEventListener("change", () => {
            state.chosen.scatterX = els.scatterX.value;
            updateChart();
          });
          els.scatterY.addEventListener("change", () => {
            state.chosen.scatterY = els.scatterY.value;
            updateChart();
          });

          els.pieLabel.addEventListener("change", () => {
            state.chosen.pieLabel = els.pieLabel.value;
            updateChart();
          });
          els.pieValue.addEventListener("change", () => {
            state.chosen.pieValue = els.pieValue.value;
            updateChart();
          });
          els.pieAgg.addEventListener("change", () => {
            state.chosen.pieAgg = els.pieAgg.value;
            updateChart({ silentToast: true });
          });
          els.pieTopN.addEventListener("change", () => {
            state.chosen.pieTopN = Number(els.pieTopN.value);
            updateChart({ silentToast: true });
          });

          els.palette.addEventListener("change", () => {
            state.chosen.palette = els.palette.value;
            // re-assign missing styles for selected series
            const next = new Map();
            // keep existing edits, but for all current keys ensure palette-based defaults exist
            for (const [k, v] of state.seriesStyle.entries()) next.set(k, v);
            state.seriesStyle = next;
            updateSeriesStylesFromSelection();
            updateChart();
          });

          els.lineTension.addEventListener("input", () => {
            state.chosen.tension = Number(els.lineTension.value);
            els.lineTensionVal.textContent = state.chosen.tension.toFixed(2);
            updateChart({ silentToast: true });
          });

          els.gridOpacity.addEventListener("input", () => {
            state.chosen.gridOpacity = Number(els.gridOpacity.value);
            els.gridOpacityVal.textContent = state.chosen.gridOpacity.toFixed(2);
            updateChart({ silentToast: true });
          });

          els.pointRadius.addEventListener("input", () => {
            state.chosen.pointRadius = Number(els.pointRadius.value);
            els.pointRadiusVal.textContent = String(state.chosen.pointRadius);
            updateChart({ silentToast: true });
          });

          els.strokeWidth.addEventListener("input", () => {
            state.chosen.strokeWidth = Number(els.strokeWidth.value);
            els.strokeWidthVal.textContent = String(state.chosen.strokeWidth);
            updateChart({ silentToast: true });
          });

          els.chartBg.addEventListener("change", () => {
            const v = String(els.chartBg.value || "").trim() || "auto";
            state.chosen.chartBg = v;
            updateChart({ silentToast: true });
          });
          els.btnBgAuto.addEventListener("click", () => {
            state.chosen.chartBg = "auto";
            els.chartBg.value = "auto";
            updateChart({ silentToast: true });
          });

          els.transparentBg.addEventListener("change", () => {
            state.chosen.transparentBg = els.transparentBg.checked;
            updateChart({ silentToast: true });
          });

          els.showDataLabels.addEventListener("change", () => {
            state.chosen.showDataLabels = els.showDataLabels.checked;
            updateChart({ silentToast: true });
          });

          els.exportScale.addEventListener("change", () => {
            state.chosen.exportScale = Number(els.exportScale.value);
          });

          els.btnDownload.addEventListener("click", downloadPng);
          els.btnDownload2.addEventListener("click", downloadPng);
          els.btnCopy.addEventListener("click", copyImage);

          els.btnResetView.addEventListener("click", resetView);
          els.btnClear.addEventListener("click", clearData);

          els.btnFullscreen.addEventListener("click", async () => {
            try {
              if (!document.fullscreenElement) await els.chartWrap.requestFullscreen();
              else await document.exitFullscreen();
            } catch {
              toast("Fullscreen", "Fullscreen not supported by this browser.", "warn");
            }
          });

          els.tabSummary.addEventListener("click", () => setActiveTab("summary"));
          els.tabPreview.addEventListener("click", () => setActiveTab("preview"));

          els.search.addEventListener("input", () => buildPreviewTable());
          els.previewCount.addEventListener("change", () => buildPreviewTable());

          window.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "e") {
              e.preventDefault();
              downloadPng();
            }
          });
        }

        function boot() {
          // Global Chart defaults
          Chart.defaults.font.family = getCssVar("--sans") || "Inter, system-ui, sans-serif";
          Chart.defaults.color = getCssVar("--muted") || "rgba(255,255,255,0.7)";
          Chart.defaults.plugins.legend.labels.color = getCssVar("--muted") || "rgba(255,255,255,0.7)";

          enableControls(false);
          els.seriesColors.innerHTML = `<div class="tiny muted">Upload data to customize.</div>`;
          syncControlValuesToUI();
          wireEvents();
          showOverlay(true);
        }

        boot();
      })();
    </script>
  </body>
</html>
