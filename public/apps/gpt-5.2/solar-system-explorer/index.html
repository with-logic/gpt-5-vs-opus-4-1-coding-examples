<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <meta name="color-scheme" content="dark" />
    <title>Solar System Explorer</title>
    <style>
      :root {
        --bg0: #060712;
        --bg1: #0b1030;
        --panel: rgba(12, 16, 34, 0.72);
        --panel2: rgba(12, 16, 34, 0.52);
        --stroke: rgba(255, 255, 255, 0.10);
        --stroke2: rgba(255, 255, 255, 0.16);
        --text: rgba(245, 247, 255, 0.92);
        --muted: rgba(245, 247, 255, 0.62);
        --muted2: rgba(245, 247, 255, 0.48);
        --accent: #7c5cff;
        --accent2: #3cf1ff;
        --good: #48f9b2;
        --warn: #ffd86b;
        --shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
        --radius: 16px;
        --radius2: 12px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        overflow: hidden;
        background:
          radial-gradient(1200px 900px at 30% 20%, rgba(124, 92, 255, 0.25), transparent 60%),
          radial-gradient(1100px 900px at 70% 35%, rgba(60, 241, 255, 0.16), transparent 62%),
          radial-gradient(900px 700px at 55% 70%, rgba(255, 216, 107, 0.10), transparent 58%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        color: var(--text);
        font-family: var(--sans);
      }

      #app {
        position: fixed;
        inset: 0;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
      }

      canvas {
        display: block;
      }

      #labels {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .hud {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .panel {
        pointer-events: auto;
        position: absolute;
        top: 18px;
        left: 18px;
        width: min(420px, calc(100vw - 36px));
        padding: 16px 16px 14px;
        border-radius: var(--radius);
        border: 1px solid var(--stroke);
        background: var(--panel);
        box-shadow: var(--shadow);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
      }

      .panel h1 {
        margin: 0;
        font-size: 14px;
        font-weight: 650;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .badge {
        font-family: var(--mono);
        font-size: 11px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid var(--stroke2);
        color: var(--muted);
        background: rgba(10, 12, 22, 0.35);
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .badge i {
        width: 8px;
        height: 8px;
        display: inline-block;
        border-radius: 999px;
        background: linear-gradient(135deg, var(--accent), var(--accent2));
        box-shadow: 0 0 18px rgba(124, 92, 255, 0.5);
      }

      .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
        margin-top: 12px;
      }

      .row label {
        color: var(--muted);
        font-size: 12px;
        letter-spacing: 0.01em;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .row label .kbd {
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(245, 247, 255, 0.66);
        border: 1px solid var(--stroke2);
        border-bottom-color: rgba(255, 255, 255, 0.08);
        background: rgba(0, 0, 0, 0.25);
        padding: 2px 6px;
        border-radius: 8px;
      }

      .row .right {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        justify-content: flex-end;
      }

      .pill {
        font-family: var(--mono);
        font-size: 11px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid var(--stroke2);
        color: rgba(245, 247, 255, 0.80);
        background: rgba(0, 0, 0, 0.18);
      }

      .btn {
        appearance: none;
        border: 1px solid var(--stroke2);
        background: linear-gradient(180deg, rgba(124, 92, 255, 0.20), rgba(12, 16, 34, 0.35));
        color: rgba(245, 247, 255, 0.92);
        border-radius: 12px;
        padding: 9px 11px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.01em;
        cursor: pointer;
        transition: transform 140ms ease, border-color 140ms ease, background 140ms ease, opacity 140ms ease;
        user-select: none;
      }
      .btn:hover {
        transform: translateY(-1px);
        border-color: rgba(124, 92, 255, 0.35);
        background: linear-gradient(180deg, rgba(124, 92, 255, 0.28), rgba(12, 16, 34, 0.40));
      }
      .btn:active {
        transform: translateY(0px);
        opacity: 0.95;
      }
      .btn.secondary {
        background: rgba(0, 0, 0, 0.18);
      }
      .btn.secondary:hover {
        border-color: rgba(255, 255, 255, 0.22);
        background: rgba(0, 0, 0, 0.24);
      }
      .btn:focus-visible {
        outline: 3px solid rgba(124, 92, 255, 0.35);
        outline-offset: 2px;
      }

      .slider {
        width: 100%;
        accent-color: var(--accent);
      }

      .split {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        font-size: 12px;
        color: var(--muted);
      }
      .toggle input {
        width: 42px;
        height: 24px;
        appearance: none;
        background: rgba(0, 0, 0, 0.30);
        border: 1px solid var(--stroke2);
        border-radius: 999px;
        position: relative;
        cursor: pointer;
        transition: background 140ms ease, border-color 140ms ease;
      }
      .toggle input::after {
        content: "";
        width: 18px;
        height: 18px;
        position: absolute;
        top: 50%;
        left: 3px;
        transform: translateY(-50%);
        border-radius: 999px;
        background: rgba(245, 247, 255, 0.78);
        box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
        transition: transform 160ms cubic-bezier(0.2, 0.9, 0.2, 1), background 140ms ease;
      }
      .toggle input:checked {
        background: rgba(124, 92, 255, 0.35);
        border-color: rgba(124, 92, 255, 0.35);
      }
      .toggle input:checked::after {
        transform: translate(18px, -50%);
        background: rgba(255, 255, 255, 0.92);
      }

      .hint {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        color: var(--muted2);
        font-size: 12px;
        line-height: 1.35;
      }

      .info {
        pointer-events: auto;
        position: absolute;
        top: 18px;
        right: 18px;
        width: min(420px, calc(100vw - 36px));
        padding: 16px 16px 14px;
        border-radius: var(--radius);
        border: 1px solid var(--stroke);
        background: var(--panel);
        box-shadow: var(--shadow);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        overflow: hidden;
      }

      .infoHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .titleBlock {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 0;
      }

      .planetIcon {
        width: 44px;
        height: 44px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.18), rgba(0,0,0,0.08));
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        flex: 0 0 auto;
        overflow: hidden;
      }

      .info h2 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.01em;
        line-height: 1.1;
      }

      .subtitle {
        margin-top: 4px;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }

      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }

      .chip {
        font-family: var(--mono);
        font-size: 11px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.18);
        color: rgba(245, 247, 255, 0.84);
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .chip b {
        font-weight: 700;
        color: rgba(245, 247, 255, 0.92);
      }

      .divider {
        height: 1px;
        background: rgba(255, 255, 255, 0.08);
        margin: 12px 0;
      }

      .desc {
        color: rgba(245, 247, 255, 0.78);
        font-size: 13px;
        line-height: 1.45;
        white-space: pre-line;
      }

      .actions {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .toast {
        position: absolute;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(12, 16, 34, 0.55);
        box-shadow: 0 16px 50px rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        color: rgba(245, 247, 255, 0.84);
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 200ms ease, transform 200ms ease;
        max-width: min(680px, calc(100vw - 36px));
        text-align: center;
      }
      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-2px);
      }

      .tooltip {
        position: absolute;
        top: 0;
        left: 0;
        transform: translate(-50%, calc(-100% - 12px));
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(10, 12, 22, 0.55);
        color: rgba(245, 247, 255, 0.90);
        font-size: 12px;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        pointer-events: none;
        opacity: 0;
        transition: opacity 120ms ease;
        white-space: nowrap;
      }
      .tooltip.show {
        opacity: 1;
      }

      .label {
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(245, 247, 255, 0.86);
        padding: 4px 7px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.10);
        background: rgba(0, 0, 0, 0.26);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        transform: translate(-50%, -130%);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.22);
      }

      .loading {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background:
          radial-gradient(1200px 900px at 30% 20%, rgba(124, 92, 255, 0.22), transparent 60%),
          radial-gradient(1100px 900px at 70% 35%, rgba(60, 241, 255, 0.14), transparent 62%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        z-index: 20;
        transition: opacity 300ms ease;
      }
      .loading.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .loadingCard {
        width: min(560px, calc(100vw - 36px));
        padding: 18px;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(12, 16, 34, 0.55);
        box-shadow: 0 24px 70px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
      }

      .loadingTitle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .loadingTitle h2 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.01em;
      }
      .loadingTitle .small {
        color: rgba(245, 247, 255, 0.65);
        font-size: 12px;
        font-family: var(--mono);
      }
      .bar {
        margin-top: 12px;
        height: 10px;
        border-radius: 999px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.18);
      }
      .bar > div {
        height: 100%;
        width: 20%;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(124, 92, 255, 0.75), rgba(60, 241, 255, 0.75));
        box-shadow: 0 0 22px rgba(124, 92, 255, 0.35);
        animation: load 1.1s ease-in-out infinite alternate;
      }
      @keyframes load {
        from {
          width: 18%;
          filter: saturate(1);
        }
        to {
          width: 78%;
          filter: saturate(1.2);
        }
      }
      .loadingText {
        margin-top: 12px;
        color: rgba(245, 247, 255, 0.68);
        font-size: 12px;
        line-height: 1.45;
      }

      @media (max-width: 980px) {
        .info {
          top: auto;
          right: 18px;
          left: 18px;
          bottom: 18px;
          width: auto;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .btn {
          transition: none;
        }
        .toast {
          transition: none;
        }
        .bar > div {
          animation: none;
          width: 60%;
        }
      }
    </style>
  </head>
  <body>
    <div id="app" aria-label="Solar System Explorer interactive canvas">
      <div id="labels"></div>

      <div class="hud">
        <div class="panel" role="region" aria-label="Controls">
          <h1>
            Solar System Explorer
            <span class="badge"><i></i><span id="fpsLabel">— fps</span></span>
          </h1>

          <div class="row">
            <label for="speed">
              Orbit speed
              <span class="kbd">S</span>
            </label>
            <span class="pill" id="speedValue">1.0×</span>
          </div>
          <input id="speed" class="slider" type="range" min="-2" max="2" value="0" step="0.01" />

          <div class="split">
            <button class="btn" id="pauseBtn" type="button">Pause</button>
            <button class="btn secondary" id="resetBtn" type="button">Reset view</button>
          </div>

          <div class="row">
            <label class="toggle" title="Keep the camera target on the selected planet">
              <input id="followToggle" type="checkbox" />
              Follow selection
            </label>
            <label class="toggle" title="Show floating labels above planets">
              <input id="labelsToggle" type="checkbox" checked />
              Labels
            </label>
          </div>

          <div class="hint">
            Drag to rotate, scroll to zoom, right-drag to pan. Click a planet for details.
            <span class="kbd" style="margin-left: 6px">Space</span> pause •
            <span class="kbd">F</span> focus •
            <span class="kbd">H</span> help
          </div>
        </div>

        <div class="info" role="region" aria-label="Planet info">
          <div class="infoHeader">
            <div class="titleBlock">
              <canvas class="planetIcon" id="planetIcon" width="88" height="88" aria-hidden="true"></canvas>
              <div style="min-width: 0">
                <h2 id="planetName">Click a planet</h2>
                <div class="subtitle" id="planetSubtitle">Select Mercury through Neptune to explore.</div>
              </div>
            </div>
            <span class="badge" title="Simulation time scale"><i></i><span id="timeLabel">Realtime</span></span>
          </div>

          <div class="chips" id="chips" aria-live="polite"></div>
          <div class="divider"></div>
          <div class="desc" id="planetDesc">
            Tip: turn on “Follow selection” to watch a planet sweep its orbit. Use “Focus” to frame it.
          </div>
          <div class="actions">
            <button class="btn" id="focusBtn" type="button" disabled>Focus</button>
            <button class="btn secondary" id="clearBtn" type="button" disabled>Clear</button>
          </div>
        </div>

        <div class="tooltip" id="tooltip">Planet</div>
        <div class="toast" id="toast">—</div>
      </div>

      <div class="loading" id="loading" aria-label="Loading">
        <div class="loadingCard">
          <div class="loadingTitle">
            <h2>Building your solar system…</h2>
            <div class="small">Three.js</div>
          </div>
          <div class="bar"><div></div></div>
          <div class="loadingText">
            Procedural planet textures, orbit paths, and a starfield are generated locally. No external assets.
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
      import { CSS2DRenderer, CSS2DObject } from "https://unpkg.com/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js";

      const $ = (sel) => document.querySelector(sel);
      const app = $("#app");

      const els = {
        loading: $("#loading"),
        speed: $("#speed"),
        speedValue: $("#speedValue"),
        pauseBtn: $("#pauseBtn"),
        resetBtn: $("#resetBtn"),
        followToggle: $("#followToggle"),
        labelsToggle: $("#labelsToggle"),
        planetName: $("#planetName"),
        planetSubtitle: $("#planetSubtitle"),
        planetDesc: $("#planetDesc"),
        chips: $("#chips"),
        focusBtn: $("#focusBtn"),
        clearBtn: $("#clearBtn"),
        planetIcon: $("#planetIcon"),
        tooltip: $("#tooltip"),
        toast: $("#toast"),
        fpsLabel: $("#fpsLabel"),
        timeLabel: $("#timeLabel"),
        labelsRoot: $("#labels"),
      };

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const smoothstep = (t) => t * t * (3 - 2 * t);

      function formatNumber(n, digits = 1) {
        if (!Number.isFinite(n)) return "—";
        const abs = Math.abs(n);
        if (abs >= 1e9) return (n / 1e9).toFixed(digits) + "B";
        if (abs >= 1e6) return (n / 1e6).toFixed(digits) + "M";
        if (abs >= 1e3) return (n / 1e3).toFixed(digits) + "k";
        return n.toFixed(digits);
      }

      function toast(message, ms = 1600) {
        els.toast.textContent = message;
        els.toast.classList.add("show");
        window.clearTimeout(toast._t);
        toast._t = window.setTimeout(() => els.toast.classList.remove("show"), ms);
      }

      function makeCanvasTexture(w, h, paintFn) {
        const c = document.createElement("canvas");
        c.width = w;
        c.height = h;
        const ctx = c.getContext("2d", { willReadFrequently: false });
        paintFn(ctx, w, h);
        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = 8;
        return tex;
      }

      function seededRandom(seed) {
        let s = seed >>> 0;
        return () => {
          s = (s * 1664525 + 1013904223) >>> 0;
          return s / 4294967296;
        };
      }

      function fbm2(ctx, w, h, seed, octaves = 5) {
        const rnd = seededRandom(seed);
        const data = ctx.createImageData(w, h);
        const p = data.data;
        const grad = new Float32Array((w + 1) * (h + 1) * 2);
        for (let i = 0; i < grad.length; i++) grad[i] = rnd() * 2 - 1;
        const dot = (gx, gy, x, y) => gx * x + gy * y;
        const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10);
        const noise = (x, y) => {
          const x0 = Math.floor(x);
          const y0 = Math.floor(y);
          const x1 = x0 + 1;
          const y1 = y0 + 1;
          const sx = fade(x - x0);
          const sy = fade(y - y0);
          const idx = (xx, yy) => ((yy * (w + 1) + xx) * 2) | 0;
          const g00i = idx(x0, y0);
          const g10i = idx(x1, y0);
          const g01i = idx(x0, y1);
          const g11i = idx(x1, y1);
          const n00 = dot(grad[g00i], grad[g00i + 1], x - x0, y - y0);
          const n10 = dot(grad[g10i], grad[g10i + 1], x - x1, y - y0);
          const n01 = dot(grad[g01i], grad[g01i + 1], x - x0, y - y1);
          const n11 = dot(grad[g11i], grad[g11i + 1], x - x1, y - y1);
          const ix0 = lerp(n00, n10, sx);
          const ix1 = lerp(n01, n11, sx);
          return lerp(ix0, ix1, sy);
        };
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let amp = 1;
            let freq = 1;
            let sum = 0;
            let norm = 0;
            for (let o = 0; o < octaves; o++) {
              sum += amp * noise((x / w) * 8 * freq, (y / h) * 4 * freq);
              norm += amp;
              amp *= 0.5;
              freq *= 2;
            }
            const v = sum / norm;
            const vv = (v * 0.5 + 0.5) * 255;
            const i = (y * w + x) * 4;
            p[i] = vv;
            p[i + 1] = vv;
            p[i + 2] = vv;
            p[i + 3] = 255;
          }
        }
        ctx.putImageData(data, 0, 0);
      }

      function paintTerrestrialTexture(ctx, w, h, opts) {
        const { base, accent, seed, ice = 0.12, clouds = 0.14, rough = 0.55 } = opts;
        ctx.clearRect(0, 0, w, h);

        const g = ctx.createLinearGradient(0, 0, w, 0);
        g.addColorStop(0.0, base);
        g.addColorStop(0.45, accent);
        g.addColorStop(1.0, base);
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);

        // Terrain
        ctx.globalAlpha = 0.80;
        fbm2(ctx, w, h, seed, 6);
        ctx.globalCompositeOperation = "multiply";
        ctx.fillStyle = `rgba(0,0,0,${rough})`;
        ctx.fillRect(0, 0, w, h);
        ctx.globalCompositeOperation = "overlay";
        ctx.globalAlpha = 0.40;
        ctx.fillStyle = accent;
        ctx.fillRect(0, 0, w, h);

        // Polar ice caps
        ctx.globalCompositeOperation = "screen";
        ctx.globalAlpha = ice;
        ctx.fillStyle = "rgba(220,240,255,1)";
        ctx.beginPath();
        ctx.ellipse(w * 0.5, h * 0.08, w * 0.55, h * 0.18, 0, 0, Math.PI * 2);
        ctx.ellipse(w * 0.5, h * 0.92, w * 0.55, h * 0.18, 0, 0, Math.PI * 2);
        ctx.fill();

        // Clouds
        ctx.globalCompositeOperation = "screen";
        ctx.globalAlpha = clouds;
        const rnd = seededRandom(seed ^ 0x9e3779b9);
        for (let i = 0; i < 180; i++) {
          const x = rnd() * w;
          const y = rnd() * h;
          const r = 6 + rnd() * 24;
          ctx.fillStyle = `rgba(255,255,255,${0.08 + rnd() * 0.08})`;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
      }

      function paintGasGiantTexture(ctx, w, h, opts) {
        const { a, b, c, seed, storms = true } = opts;
        ctx.clearRect(0, 0, w, h);

        const rnd = seededRandom(seed);
        const bands = 14;
        for (let i = 0; i < bands; i++) {
          const t = i / (bands - 1);
          const wobble = (rnd() - 0.5) * 0.08;
          const y0 = (t + wobble) * h;
          const y1 = (t + 1 / bands + wobble) * h;
          const col = i % 3 === 0 ? a : i % 3 === 1 ? b : c;
          ctx.fillStyle = col;
          ctx.fillRect(0, y0, w, y1 - y0 + 2);
        }

        // Add turbulence
        ctx.globalAlpha = 0.55;
        fbm2(ctx, w, h, seed ^ 0x51ed270b, 6);
        ctx.globalCompositeOperation = "overlay";
        ctx.fillStyle = "rgba(255,255,255,0.35)";
        ctx.fillRect(0, 0, w, h);

        if (storms) {
          ctx.globalCompositeOperation = "screen";
          ctx.globalAlpha = 0.55;
          for (let i = 0; i < 8; i++) {
            const x = (0.2 + rnd() * 0.6) * w;
            const y = (0.2 + rnd() * 0.6) * h;
            const rx = 24 + rnd() * 60;
            const ry = 12 + rnd() * 32;
            const gg = ctx.createRadialGradient(x, y, 0, x, y, rx);
            gg.addColorStop(0, "rgba(255,255,255,0.22)");
            gg.addColorStop(1, "rgba(255,255,255,0)");
            ctx.fillStyle = gg;
            ctx.beginPath();
            ctx.ellipse(x, y, rx, ry, rnd() * 0.6 - 0.3, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
      }

      function paintRingTexture(ctx, w, h, opts) {
        const { inner, outer, seed } = opts;
        ctx.clearRect(0, 0, w, h);
        const g = ctx.createLinearGradient(0, 0, w, 0);
        g.addColorStop(0, inner);
        g.addColorStop(0.45, outer);
        g.addColorStop(1, inner);
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);

        const rnd = seededRandom(seed);
        ctx.globalCompositeOperation = "overlay";
        for (let i = 0; i < 1200; i++) {
          const x = rnd() * w;
          const y = rnd() * h;
          const a = 0.02 + rnd() * 0.10;
          ctx.fillStyle = `rgba(255,255,255,${a})`;
          ctx.fillRect(x, y, 1 + rnd() * 2, 1 + rnd() * 1.5);
        }
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1;
      }

      function paintIcon(canvas, palette, label) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        const g = ctx.createRadialGradient(w * 0.33, h * 0.30, 0, w * 0.55, h * 0.55, w * 0.65);
        g.addColorStop(0, palette.hi);
        g.addColorStop(0.55, palette.mid);
        g.addColorStop(1, palette.lo);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, w * 0.46, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalCompositeOperation = "overlay";
        ctx.globalAlpha = 0.25;
        for (let i = 0; i < 24; i++) {
          ctx.fillStyle = `rgba(255,255,255,${0.06 + i * 0.004})`;
          ctx.beginPath();
          ctx.ellipse(w * 0.5, h * (0.26 + i * 0.022), w * 0.42, h * 0.06, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1;

        ctx.font = `700 ${Math.floor(w * 0.22)}px ${getComputedStyle(document.documentElement).getPropertyValue("--mono") || "monospace"}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillText(label, w / 2 + 1, h / 2 + 1);
        ctx.fillStyle = "rgba(255,255,255,0.82)";
        ctx.fillText(label, w / 2, h / 2);
      }

      const planetData = [
        {
          key: "mercury",
          name: "Mercury",
          type: "Terrestrial",
          aAU: 0.387,
          e: 0.2056,
          incDeg: 7.0,
          radiusEarth: 0.383,
          periodDays: 87.97,
          dayHours: 1407.6,
          color: { base: "#7a7a83", accent: "#9f9fa8", hi: "rgba(255,255,255,0.12)" },
          blurb: "A sun-scorched world of craters and cliffs, with wild temperature swings and the fastest orbit in the Solar System.",
          facts: ["No moons", "Thin exosphere", "Resonant day: 3:2"],
          seed: 101,
        },
        {
          key: "venus",
          name: "Venus",
          type: "Terrestrial",
          aAU: 0.723,
          e: 0.0068,
          incDeg: 3.4,
          radiusEarth: 0.949,
          periodDays: 224.70,
          dayHours: -5832.5,
          color: { base: "#c7a070", accent: "#e0c48f", hi: "rgba(255,255,255,0.12)" },
          blurb: "A veiled planet with crushing pressure and sulfuric clouds—its slow, retrograde spin makes sunsets last for months.",
          facts: ["Retrograde rotation", "Hottest planet", "Runaway greenhouse"],
          seed: 202,
        },
        {
          key: "earth",
          name: "Earth",
          type: "Terrestrial",
          aAU: 1.0,
          e: 0.0167,
          incDeg: 0.0,
          radiusEarth: 1.0,
          periodDays: 365.26,
          dayHours: 23.93,
          color: { base: "#1b3f9a", accent: "#1e9b6b", hi: "rgba(255,255,255,0.18)" },
          blurb: "Our ocean planet—dynamic continents, swirling weather, and a protective magnetic field that helps life thrive.",
          facts: ["Liquid water", "Active plate tectonics", "One large Moon"],
          seed: 303,
          atmosphere: true,
        },
        {
          key: "mars",
          name: "Mars",
          type: "Terrestrial",
          aAU: 1.524,
          e: 0.0934,
          incDeg: 1.85,
          radiusEarth: 0.532,
          periodDays: 686.98,
          dayHours: 24.62,
          color: { base: "#9b3b2e", accent: "#d58056", hi: "rgba(255,255,255,0.10)" },
          blurb: "A cold desert with towering volcanoes and ancient river valleys—today it hosts dust storms that can engulf the globe.",
          facts: ["Olympus Mons", "Two tiny moons", "Polar ice caps"],
          seed: 404,
        },
        {
          key: "jupiter",
          name: "Jupiter",
          type: "Gas giant",
          aAU: 5.203,
          e: 0.0484,
          incDeg: 1.3,
          radiusEarth: 11.21,
          periodDays: 4332.59,
          dayHours: 9.93,
          color: { a: "#b88e69", b: "#e1c7a8", c: "#8a6a4d", hi: "rgba(255,255,255,0.10)" },
          blurb: "A colossal world of bands and storms, powered by deep convection. Its Great Red Spot is a hurricane bigger than Earth.",
          facts: ["Great Red Spot", "Powerful magnetosphere", "Many moons"],
          seed: 505,
          gas: true,
        },
        {
          key: "saturn",
          name: "Saturn",
          type: "Gas giant",
          aAU: 9.537,
          e: 0.0541,
          incDeg: 2.49,
          radiusEarth: 9.45,
          periodDays: 10759.22,
          dayHours: 10.7,
          color: { a: "#c8b58d", b: "#f1e0bd", c: "#bfae84", hi: "rgba(255,255,255,0.10)" },
          blurb: "A pale giant encircled by shimmering rings of ice and rock. Its moons sculpt the rings into intricate structures.",
          facts: ["Iconic rings", "Titan’s thick atmosphere", "Low density"],
          seed: 606,
          gas: true,
          ring: { inner: 1.22, outer: 2.10, tiltDeg: 26.7, innerCol: "#c7b9a0", outerCol: "#f2e7cf" },
        },
        {
          key: "uranus",
          name: "Uranus",
          type: "Ice giant",
          aAU: 19.191,
          e: 0.0472,
          incDeg: 0.77,
          radiusEarth: 4.01,
          periodDays: 30688.5,
          dayHours: -17.2,
          color: { a: "#7bc4d5", b: "#aee8f1", c: "#4c93a6", hi: "rgba(255,255,255,0.10)" },
          blurb: "An ice giant tipped on its side—its extreme axial tilt creates decades-long seasons and a strangely oriented magnetic field.",
          facts: ["98° axial tilt", "Faint rings", "Methane-blue hue"],
          seed: 707,
          gas: true,
          ring: { inner: 1.35, outer: 1.85, tiltDeg: 97.8, innerCol: "#86cbd6", outerCol: "#4b8597" },
        },
        {
          key: "neptune",
          name: "Neptune",
          type: "Ice giant",
          aAU: 30.07,
          e: 0.0086,
          incDeg: 1.77,
          radiusEarth: 3.88,
          periodDays: 60182,
          dayHours: 16.1,
          color: { a: "#2347c7", b: "#3a7cff", c: "#0f2a7b", hi: "rgba(255,255,255,0.10)" },
          blurb: "A distant, windy world with supersonic jet streams. Its storms can form dark spots that drift and dissipate over time.",
          facts: ["Fastest winds", "Triton’s odd orbit", "Deep blue color"],
          seed: 808,
          gas: true,
        },
      ];

      function orbitRadiusFromAU(aAU) {
        // Visually compress outer distances while preserving order.
        return 10 * Math.pow(aAU, 0.65);
      }

      function radiusFromEarth(rE) {
        // Compress large planets for readability without losing relative scale.
        return 0.9 * Math.pow(rE, 0.52);
      }

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050612, 0.0009);

      const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 3000);
      camera.position.set(0, 40, 120);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;

      const labelRenderer = new CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = "absolute";
      labelRenderer.domElement.style.inset = "0";
      labelRenderer.domElement.style.pointerEvents = "none";
      els.labelsRoot.appendChild(labelRenderer.domElement);

      app.prepend(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.enablePan = true;
      controls.minDistance = 18;
      controls.maxDistance = 820;
      controls.target.set(0, 0, 0);
      controls.update();

      // Lighting
      const ambient = new THREE.AmbientLight(0x9bb6ff, 0.24);
      scene.add(ambient);

      const sunLight = new THREE.PointLight(0xfff2c6, 380, 1500, 1.8);
      sunLight.position.set(0, 0, 0);
      scene.add(sunLight);

      // Starfield
      function addStarfield() {
        const count = 9000;
        const pos = new Float32Array(count * 3);
        const col = new Float32Array(count * 3);
        const rnd = seededRandom(1337);
        const color = new THREE.Color();
        for (let i = 0; i < count; i++) {
          const u = rnd();
          const v = rnd();
          const theta = 2 * Math.PI * u;
          const phi = Math.acos(2 * v - 1);
          const r = 850 + rnd() * 850;
          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.cos(phi) * 0.82;
          const z = r * Math.sin(phi) * Math.sin(theta);
          pos[i * 3] = x;
          pos[i * 3 + 1] = y;
          pos[i * 3 + 2] = z;

          const t = rnd();
          const hue = lerp(0.56, 0.68, t);
          const sat = lerp(0.15, 0.35, rnd());
          const lum = lerp(0.78, 1.0, rnd());
          color.setHSL(hue, sat, lum);
          col[i * 3] = color.r;
          col[i * 3 + 1] = color.g;
          col[i * 3 + 2] = color.b;
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        geo.setAttribute("color", new THREE.BufferAttribute(col, 3));
        const mat = new THREE.PointsMaterial({
          size: 1.55,
          sizeAttenuation: true,
          depthWrite: false,
          vertexColors: true,
          transparent: true,
          opacity: 0.85,
          blending: THREE.AdditiveBlending,
        });
        const points = new THREE.Points(geo, mat);
        points.renderOrder = -100;
        scene.add(points);
      }
      addStarfield();

      // Sun
      const sunGroup = new THREE.Group();
      scene.add(sunGroup);

      const sunTexture = makeCanvasTexture(512, 256, (ctx, w, h) => {
        ctx.clearRect(0, 0, w, h);
        const g = ctx.createLinearGradient(0, 0, w, 0);
        g.addColorStop(0, "#ffd88c");
        g.addColorStop(0.4, "#fff0c7");
        g.addColorStop(1, "#ffb55a");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
        ctx.globalCompositeOperation = "overlay";
        ctx.globalAlpha = 0.65;
        fbm2(ctx, w, h, 42, 7);
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.fillRect(0, 0, w, h);
        ctx.globalCompositeOperation = "source-over";
        ctx.globalAlpha = 1;
      });

      const sunRadius = 4.9;
      const sunMesh = new THREE.Mesh(
        new THREE.SphereGeometry(sunRadius, 72, 48),
        new THREE.MeshStandardMaterial({
          map: sunTexture,
          emissive: new THREE.Color(0xffcc7a),
          emissiveIntensity: 1.7,
          roughness: 0.62,
          metalness: 0.0,
        })
      );
      sunMesh.name = "Sun";
      sunGroup.add(sunMesh);

      // Sun glow sprite
      const glowTex = makeCanvasTexture(256, 256, (ctx, w, h) => {
        ctx.clearRect(0, 0, w, h);
        const x = w / 2,
          y = h / 2;
        const g = ctx.createRadialGradient(x, y, 0, x, y, w * 0.5);
        g.addColorStop(0.0, "rgba(255, 235, 190, 0.80)");
        g.addColorStop(0.35, "rgba(255, 200, 120, 0.22)");
        g.addColorStop(1.0, "rgba(255, 180, 90, 0.0)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
      });
      const glow = new THREE.Sprite(
        new THREE.SpriteMaterial({
          map: glowTex,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          opacity: 0.92,
        })
      );
      glow.scale.set(36, 36, 1);
      glow.renderOrder = -10;
      sunGroup.add(glow);

      // Subtle plane to catch the glow in fog
      const halo = new THREE.Mesh(
        new THREE.RingGeometry(sunRadius * 1.2, sunRadius * 2.2, 96),
        new THREE.MeshBasicMaterial({
          color: 0xffcc7a,
          transparent: true,
          opacity: 0.10,
          side: THREE.DoubleSide,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        })
      );
      halo.rotation.x = Math.PI / 2;
      halo.renderOrder = -9;
      sunGroup.add(halo);

      // Planet system
      const system = new THREE.Group();
      scene.add(system);

      const orbitLines = new THREE.Group();
      orbitLines.name = "Orbits";
      system.add(orbitLines);

      const planetsGroup = new THREE.Group();
      planetsGroup.name = "Planets";
      system.add(planetsGroup);

      function makeOrbitLine({ a, e, incRad }, colorHex) {
        const seg = 260;
        const points = [];
        for (let i = 0; i <= seg; i++) {
          const t = (i / seg) * Math.PI * 2;
          const r = (a * (1 - e * e)) / (1 + e * Math.cos(t));
          const x = r * Math.cos(t);
          const z = r * Math.sin(t);
          const v = new THREE.Vector3(x, 0, z);
          v.applyAxisAngle(new THREE.Vector3(1, 0, 0), incRad);
          points.push(v);
        }
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const mat = new THREE.LineBasicMaterial({
          color: colorHex,
          transparent: true,
          opacity: 0.26,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });
        const line = new THREE.Line(geo, mat);
        line.computeLineDistances?.();
        return line;
      }

      function makePlanetMaterial(p) {
        if (p.gas) {
          const map = makeCanvasTexture(768, 384, (ctx, w, h) =>
            paintGasGiantTexture(ctx, w, h, { a: p.color.a, b: p.color.b, c: p.color.c, seed: p.seed, storms: true })
          );
          return new THREE.MeshStandardMaterial({
            map,
            roughness: 0.65,
            metalness: 0.0,
            emissive: new THREE.Color(0x000000),
          });
        }
        const map = makeCanvasTexture(768, 384, (ctx, w, h) =>
          paintTerrestrialTexture(ctx, w, h, { base: p.color.base, accent: p.color.accent, seed: p.seed, ice: 0.16, clouds: p.key === "earth" ? 0.20 : 0.08 })
        );
        return new THREE.MeshStandardMaterial({
          map,
          roughness: p.key === "mercury" ? 0.96 : 0.78,
          metalness: 0.0,
          emissive: new THREE.Color(0x000000),
        });
      }

      function makeRingMesh(p, planetRadius) {
        if (!p.ring) return null;
        const { inner, outer, tiltDeg, innerCol, outerCol } = p.ring;
        const tex = makeCanvasTexture(1024, 128, (ctx, w, h) =>
          paintRingTexture(ctx, w, h, { inner: innerCol, outer: outerCol, seed: p.seed ^ 0xaa55aa55 })
        );
        const mat = new THREE.MeshStandardMaterial({
          map: tex,
          transparent: true,
          opacity: 0.85,
          side: THREE.DoubleSide,
          roughness: 0.78,
          metalness: 0.0,
          emissive: new THREE.Color(0x000000),
        });
        const geo = new THREE.RingGeometry(planetRadius * inner, planetRadius * outer, 160, 1);
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = THREE.MathUtils.degToRad(90 - tiltDeg);
        mesh.renderOrder = 2;
        return mesh;
      }

      function addAtmosphere(planetRadius) {
        const mat = new THREE.MeshPhysicalMaterial({
          transparent: true,
          opacity: 0.12,
          transmission: 0.9,
          thickness: 0.6,
          roughness: 0.0,
          metalness: 0.0,
          clearcoat: 1.0,
          clearcoatRoughness: 0.08,
          color: new THREE.Color(0x78d4ff),
          emissive: new THREE.Color(0x1a4fff),
          emissiveIntensity: 0.12,
        });
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(planetRadius * 1.04, 64, 48), mat);
        mesh.name = "Atmosphere";
        return mesh;
      }

      const planetMeshes = [];

      for (const p of planetData) {
        const orbitRadius = orbitRadiusFromAU(p.aAU);
        const incRad = THREE.MathUtils.degToRad(p.incDeg);

        const orbitColor = new THREE.Color(
          p.gas ? (p.color?.b || "#8aa3ff") : (p.color?.accent || "#8aa3ff")
        );
        orbitColor.offsetHSL(0.02, -0.18, -0.05);
        const orbit = makeOrbitLine({ a: orbitRadius, e: p.e, incRad }, orbitColor.getHex());
        orbit.userData = { key: p.key };
        orbitLines.add(orbit);

        const pivot = new THREE.Group();
        pivot.name = p.name + "_Pivot";
        planetsGroup.add(pivot);

        const planetRadius = radiusFromEarth(p.radiusEarth);
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(planetRadius, 64, 48), makePlanetMaterial(p));
        mesh.name = p.name;
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        mesh.userData = { ...p, orbitRadius, incRad, planetRadius };
        pivot.add(mesh);

        const ring = makeRingMesh(p, planetRadius);
        if (ring) {
          ring.name = p.name + "_Ring";
          mesh.add(ring);
        }

        if (p.atmosphere) {
          mesh.add(addAtmosphere(planetRadius));
        }

        // Place at periapsis initially (theta=0)
        const r0 = (orbitRadius * (1 - p.e * p.e)) / (1 + p.e);
        mesh.position.set(r0, 0, 0);
        mesh.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), incRad);

        // Label
        const labelEl = document.createElement("div");
        labelEl.className = "label";
        labelEl.textContent = p.name;
        const labelObj = new CSS2DObject(labelEl);
        labelObj.position.set(0, planetRadius + 0.2, 0);
        mesh.add(labelObj);

        planetMeshes.push(mesh);
      }

      // Selection / raycasting
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      let hovered = null;
      let selected = null;
      let paused = false;
      let timeScale = 1.0;
      let simTimeDays = 0;

      const highlight = {
        selectedRing: new THREE.Mesh(
          new THREE.RingGeometry(1, 1.32, 72),
          new THREE.MeshBasicMaterial({
            color: 0x7c5cff,
            transparent: true,
            opacity: 0.0,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
          })
        ),
        hoverRing: new THREE.Mesh(
          new THREE.RingGeometry(1, 1.32, 72),
          new THREE.MeshBasicMaterial({
            color: 0x3cf1ff,
            transparent: true,
            opacity: 0.0,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
          })
        ),
      };
      highlight.selectedRing.rotation.x = Math.PI / 2;
      highlight.selectedRing.renderOrder = 5;
      highlight.hoverRing.rotation.x = Math.PI / 2;
      highlight.hoverRing.renderOrder = 5;
      scene.add(highlight.selectedRing);
      scene.add(highlight.hoverRing);

      function setHighlightPlanet(mesh) {
        if (!mesh) {
          highlight.selectedRing.material.opacity = 0;
          return;
        }
        const r = mesh.userData.planetRadius ?? 1.0;
        highlight.selectedRing.geometry.dispose();
        highlight.selectedRing.geometry = new THREE.RingGeometry(r * 1.22, r * 1.55, 88);
        highlight.selectedRing.position.copy(mesh.getWorldPosition(new THREE.Vector3()));
        highlight.selectedRing.material.opacity = 0.55;
      }

      function setTooltip(mesh, clientX, clientY) {
        if (!mesh) {
          els.tooltip.classList.remove("show");
          return;
        }
        els.tooltip.textContent = mesh.userData.name;
        els.tooltip.style.left = `${clientX}px`;
        els.tooltip.style.top = `${clientY}px`;
        els.tooltip.classList.add("show");
      }

      function renderChips(p) {
        els.chips.innerHTML = "";
        if (!p) return;
        const chip = (label, value) => {
          const el = document.createElement("div");
          el.className = "chip";
          el.innerHTML = `<b>${label}</b> ${value}`;
          return el;
        };

        const orbitAU = p.aAU.toFixed(3).replace(/0+$/, "").replace(/\.$/, "");
        const orbitVis = orbitRadiusFromAU(p.aAU);
        const year = p.periodDays / 365.26;
        const spin = Math.abs(p.dayHours);
        const retro = p.dayHours < 0 ? " (retrograde)" : "";

        els.chips.appendChild(chip("Type", p.type));
        els.chips.appendChild(chip("Orbit", `${orbitAU} AU`));
        els.chips.appendChild(chip("Year", `${year.toFixed(year < 10 ? 2 : 1)} Earth-yrs`));
        els.chips.appendChild(chip("Day", `${spin.toFixed(spin < 100 ? 1 : 0)} hrs${retro}`));
        els.chips.appendChild(chip("Size", `${(p.radiusEarth).toFixed(2)}× Earth`));
        els.chips.appendChild(chip("Ecc", `${p.e.toFixed(3)}`));

        // A tiny “scale” chip to communicate this is visually compressed.
        els.chips.appendChild(chip("Viz", `${formatNumber(orbitVis, 0)}u radius`));
      }

      function setSelected(mesh) {
        if (selected === mesh) return;
        selected = mesh;
        setHighlightPlanet(mesh);
        els.focusBtn.disabled = !mesh;
        els.clearBtn.disabled = !mesh;

        for (const m of planetMeshes) {
          const mat = m.material;
          if (mat && "emissive" in mat) {
            mat.emissive.setHex(0x000000);
            if ("emissiveIntensity" in mat) mat.emissiveIntensity = 1.0;
          }
        }
        if (mesh?.material && "emissive" in mesh.material) {
          mesh.material.emissive.setHex(0x2211aa);
          mesh.material.emissiveIntensity = 0.55;
        }

        if (!mesh) {
          els.planetName.textContent = "Click a planet";
          els.planetSubtitle.textContent = "Select Mercury through Neptune to explore.";
          els.planetDesc.textContent = "Tip: turn on “Follow selection” to watch a planet sweep its orbit. Use “Focus” to frame it.";
          els.chips.innerHTML = "";
          paintIcon(els.planetIcon, { hi: "rgba(255,255,255,0.14)", mid: "rgba(124,92,255,0.32)", lo: "rgba(0,0,0,0.18)" }, "—");
          return;
        }

        const p = mesh.userData;
        els.planetName.textContent = p.name;
        els.planetSubtitle.textContent = `${p.type} • Click & drag to orbit • Wheel to zoom`;
        els.planetDesc.textContent = p.blurb + (p.facts?.length ? `\n\nHighlights: ${p.facts.join(" • ")}` : "");
        renderChips(p);
        paintIcon(
          els.planetIcon,
          {
            hi: p.color?.hi || "rgba(255,255,255,0.10)",
            mid: p.gas ? (p.color?.b || "rgba(60,241,255,0.25)") : (p.color?.accent || "rgba(60,241,255,0.25)"),
            lo: p.gas ? (p.color?.c || "rgba(0,0,0,0.20)") : (p.color?.base || "rgba(0,0,0,0.20)"),
          },
          p.name[0]
        );
        toast(`Selected ${p.name}`);
      }

      function focusOn(mesh) {
        if (!mesh) return;
        const worldPos = mesh.getWorldPosition(new THREE.Vector3());
        const r = mesh.userData.planetRadius ?? 1;
        const desiredDist = clamp(16 + r * 10, 18, 140);
        const dir = camera.position.clone().sub(controls.target).normalize();
        const nextCam = worldPos.clone().add(dir.multiplyScalar(desiredDist));
        focusTween.start(worldPos, nextCam);
      }

      const focusTween = (() => {
        let active = false;
        let t = 0;
        const startTarget = new THREE.Vector3();
        const startCam = new THREE.Vector3();
        const endTarget = new THREE.Vector3();
        const endCam = new THREE.Vector3();
        const duration = 0.75;
        return {
          start(target, camPos) {
            active = true;
            t = 0;
            startTarget.copy(controls.target);
            startCam.copy(camera.position);
            endTarget.copy(target);
            endCam.copy(camPos);
          },
          update(dt) {
            if (!active) return;
            t = Math.min(1, t + dt / duration);
            const k = smoothstep(t);
            controls.target.lerpVectors(startTarget, endTarget, k);
            camera.position.lerpVectors(startCam, endCam, k);
            controls.update();
            if (t >= 1) active = false;
          },
          get active() {
            return active;
          },
        };
      })();

      function setTimeScaleFromSlider() {
        // Slider in log10 space: [-2..2] => 0.01x..100x
        const v = parseFloat(els.speed.value);
        timeScale = Math.pow(10, v);
        els.speedValue.textContent = `${timeScale.toFixed(timeScale < 10 ? 2 : 1)}×`;
        const label =
          timeScale < 0.02
            ? "Slow-mo"
            : timeScale < 0.2
              ? "Cinematic"
              : timeScale < 1.6
                ? "Realtime"
                : timeScale < 12
                  ? "Fast"
                  : "Warp";
        els.timeLabel.textContent = label;
      }

      els.speed.addEventListener("input", setTimeScaleFromSlider);
      setTimeScaleFromSlider();

      function setPaused(next) {
        paused = next;
        els.pauseBtn.textContent = paused ? "Play" : "Pause";
        toast(paused ? "Paused" : "Playing");
      }

      els.pauseBtn.addEventListener("click", () => setPaused(!paused));

      els.resetBtn.addEventListener("click", () => {
        setSelected(null);
        els.followToggle.checked = false;
        focusTween.start(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 40, 120));
        toast("View reset");
      });

      els.labelsToggle.addEventListener("change", () => {
        els.labelsRoot.style.display = els.labelsToggle.checked ? "block" : "none";
      });

      els.focusBtn.addEventListener("click", () => focusOn(selected));
      els.clearBtn.addEventListener("click", () => setSelected(null));

      function updatePointerFromEvent(ev) {
        const rect = renderer.domElement.getBoundingClientRect();
        const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);
        pointer.set(x, y);
      }

      function pick(ev) {
        updatePointerFromEvent(ev);
        raycaster.setFromCamera(pointer, camera);
        const hits = raycaster.intersectObjects(planetMeshes, true);
        const hit = hits.find((h) => planetMeshes.includes(h.object)) ?? hits[0];
        if (!hit) return null;
        let obj = hit.object;
        while (obj && !planetMeshes.includes(obj)) obj = obj.parent;
        return obj ?? null;
      }

      renderer.domElement.addEventListener("pointermove", (ev) => {
        const hit = pick(ev);
        hovered = hit;
        renderer.domElement.style.cursor = hit ? "pointer" : "grab";
        setTooltip(hit, ev.clientX, ev.clientY);
      });
      renderer.domElement.addEventListener("pointerleave", () => {
        hovered = null;
        renderer.domElement.style.cursor = "grab";
        els.tooltip.classList.remove("show");
      });

      renderer.domElement.addEventListener("pointerdown", () => {
        if (!hovered) renderer.domElement.style.cursor = "grabbing";
      });
      renderer.domElement.addEventListener("pointerup", () => {
        renderer.domElement.style.cursor = hovered ? "pointer" : "grab";
      });

      renderer.domElement.addEventListener("click", (ev) => {
        const hit = pick(ev);
        if (!hit) return;
        setSelected(hit);
      });

      // Keyboard shortcuts
      window.addEventListener("keydown", (ev) => {
        if (ev.key === " " || ev.code === "Space") {
          ev.preventDefault();
          setPaused(!paused);
          return;
        }
        const k = ev.key.toLowerCase();
        if (k === "f") {
          if (selected) focusOn(selected);
          else toast("Select a planet first");
        } else if (k === "c") {
          setSelected(null);
        } else if (k === "h") {
          toast("Drag rotate • Scroll zoom • Click select • Space pause • F focus • S adjust speed");
        } else if (k === "s") {
          els.speed.focus();
          toast("Orbit speed: use the slider");
        } else if (k === "l") {
          els.labelsToggle.checked = !els.labelsToggle.checked;
          els.labelsRoot.style.display = els.labelsToggle.checked ? "block" : "none";
          toast(els.labelsToggle.checked ? "Labels on" : "Labels off");
        }
      });

      // Simulation update
      const clock = new THREE.Clock();
      let lastFpsUpdate = performance.now();
      let fpsFrames = 0;

      function updatePlanetPositions(deltaSeconds) {
        // 1 simulated day per second at timeScale=1 (fast, but intuitive)
        const simDaysPerSec = 1.0;
        const dtDays = paused ? 0 : deltaSeconds * simDaysPerSec * timeScale;
        simTimeDays += dtDays;

        // Sun subtle rotation & pulsing glow
        sunMesh.rotation.y += deltaSeconds * 0.08;
        glow.material.opacity = 0.80 + 0.12 * Math.sin(performance.now() * 0.0012);
        halo.material.opacity = 0.08 + 0.03 * Math.sin(performance.now() * 0.0010 + 1.1);

        for (const mesh of planetMeshes) {
          const p = mesh.userData;
          const orbitR = p.orbitRadius;
          const incRad = p.incRad;
          const yearDays = p.periodDays;

          const theta = ((simTimeDays / yearDays) * Math.PI * 2) % (Math.PI * 2);
          const r = (orbitR * (1 - p.e * p.e)) / (1 + p.e * Math.cos(theta));

          const x = r * Math.cos(theta);
          const z = r * Math.sin(theta);
          const pos = new THREE.Vector3(x, 0, z);
          pos.applyAxisAngle(new THREE.Vector3(1, 0, 0), incRad);
          mesh.position.copy(pos);

          // Spin
          const spinHours = Math.abs(p.dayHours);
          const spinDir = p.dayHours < 0 ? -1 : 1;
          const spinPerDay = (24 / spinHours) * Math.PI * 2 * spinDir;
          mesh.rotation.y += deltaSeconds * spinPerDay * (paused ? 0 : timeScale * 0.25);

          // Slight axial tilt visual (for ringed planets, ring already encodes tilt)
          if (!mesh.userData._tilted) {
            mesh.userData._tilted = true;
            const tiltDeg =
              p.key === "earth"
                ? 23.44
                : p.key === "mars"
                  ? 25.19
                  : p.key === "jupiter"
                    ? 3.13
                    : p.key === "saturn"
                      ? 26.73
                      : p.key === "uranus"
                        ? 97.77
                        : p.key === "neptune"
                          ? 28.32
                          : p.key === "venus"
                            ? 177.36
                            : 0.03;
            mesh.rotateOnAxis(new THREE.Vector3(0, 0, 1), THREE.MathUtils.degToRad(tiltDeg));
          }

          // Update selection highlight position
          if (mesh === selected) {
            highlight.selectedRing.position.copy(mesh.getWorldPosition(new THREE.Vector3()));
          }
        }

        if (els.followToggle.checked && selected && !focusTween.active) {
          const targetPos = selected.getWorldPosition(new THREE.Vector3());
          controls.target.lerp(targetPos, 1 - Math.pow(0.001, deltaSeconds));
        }
      }

      function onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(w, h);
        labelRenderer.setSize(w, h);
      }
      window.addEventListener("resize", onResize, { passive: true });
      onResize();

      // Ensure we don't burn CPU in background tabs.
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) paused = true;
        els.pauseBtn.textContent = paused ? "Play" : "Pause";
      });

      // Initial info state
      paintIcon(els.planetIcon, { hi: "rgba(255,255,255,0.14)", mid: "rgba(124,92,255,0.30)", lo: "rgba(0,0,0,0.18)" }, "—");

      // Prime the renderer, then hide loading overlay.
      renderer.compile(scene, camera);
      requestAnimationFrame(() => {
        els.loading.classList.add("hidden");
        toast("Ready. Click a planet to explore.", 2200);
      });

      // Animation loop
      function animate() {
        const dt = clock.getDelta();
        updatePlanetPositions(dt);
        focusTween.update(dt);
        controls.update();

        // Hover highlight (soft)
        if (hovered && hovered !== selected) {
          const pos = hovered.getWorldPosition(new THREE.Vector3());
          highlight.hoverRing.position.lerp(pos, 1 - Math.pow(0.001, dt));
          const r = hovered.userData.planetRadius ?? 1;
          if (!highlight.hoverRing.geometry._r || highlight.hoverRing.geometry._r !== r) {
            highlight.hoverRing.geometry.dispose();
            const g = new THREE.RingGeometry(r * 1.16, r * 1.44, 88);
            g._r = r;
            highlight.hoverRing.geometry = g;
          }
          highlight.hoverRing.material.opacity = 0.32;
        } else {
          highlight.hoverRing.material.opacity = 0.0;
        }

        // Selected highlight (steady)
        if (selected) {
          highlight.selectedRing.material.opacity = 0.55;
        } else {
          highlight.selectedRing.material.opacity = 0.0;
        }

        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);

        fpsFrames++;
        const now = performance.now();
        if (now - lastFpsUpdate > 500) {
          const fps = (fpsFrames * 1000) / (now - lastFpsUpdate);
          els.fpsLabel.textContent = `${Math.round(fps)} fps`;
          fpsFrames = 0;
          lastFpsUpdate = now;
        }
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
