<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Falling Fruit Catcher</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@500;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --sky-a: #86e7ff;
      --sky-b: #d9f9ff;
      --grass-a: #59db73;
      --grass-b: #42c45d;
      --panel: rgba(255, 255, 255, 0.9);
      --text: #213547;
      --accent: #ff7a2f;
      --danger: #ff4d6d;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-family: "Baloo 2", system-ui, sans-serif;
      color: var(--text);
      background: linear-gradient(180deg, var(--sky-a), var(--sky-b));
    }

    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: grid;
      place-items: center;
    }

    .sky-decor {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }

    .cloud {
      position: absolute;
      background: rgba(255, 255, 255, 0.65);
      border-radius: 999px;
      filter: blur(0.2px);
      animation: drift linear infinite;
    }

    .cloud::before,
    .cloud::after {
      content: "";
      position: absolute;
      background: inherit;
      border-radius: inherit;
    }

    .cloud::before { width: 60%; height: 120%; left: 15%; top: -45%; }
    .cloud::after { width: 45%; height: 100%; right: 10%; top: -35%; }

    @keyframes drift {
      from { transform: translateX(-18vw); }
      to { transform: translateX(118vw); }
    }

    .hud {
      position: absolute;
      top: 14px;
      left: 14px;
      right: 14px;
      display: flex;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      z-index: 3;
      user-select: none;
    }

    .pill {
      background: var(--panel);
      border: 3px solid rgba(255,255,255,0.95);
      border-radius: 18px;
      padding: 8px 16px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.12);
      font-size: clamp(20px, 3vw, 30px);
      font-weight: 800;
      line-height: 1;
      letter-spacing: 0.4px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .score-val {
      color: #0e7c3f;
      min-width: 2ch;
      text-align: right;
    }

    .lives {
      color: var(--danger);
      letter-spacing: 2px;
      min-width: 4ch;
      text-align: center;
    }

    #gameWrap {
      position: relative;
      width: min(98vw, 980px);
      height: min(82vh, 700px);
      border-radius: 28px;
      overflow: hidden;
      box-shadow:
        0 24px 50px rgba(11, 86, 116, 0.22),
        0 10px 20px rgba(20, 90, 33, 0.18);
      border: 4px solid rgba(255,255,255,0.85);
      background: linear-gradient(180deg, #8de9ff 0%, #cff8ff 62%, #76dc73 62%, #50c95f 100%);
      touch-action: none;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: none;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(9, 49, 71, 0.4);
      backdrop-filter: blur(2px);
      z-index: 4;
      padding: 16px;
      text-align: center;
    }

    .overlay.show { display: grid; }

    .card {
      width: min(420px, 92vw);
      background: rgba(255,255,255,0.95);
      border: 4px solid #fff;
      border-radius: 24px;
      padding: 20px 18px 24px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.2);
    }

    .card h1 {
      margin: 0;
      font-size: clamp(34px, 6vw, 48px);
      line-height: 1;
      color: #ff5f2f;
    }

    .card p {
      margin: 10px 0 16px;
      font-size: clamp(22px, 3.5vw, 28px);
      line-height: 1.15;
    }

    .bigScore {
      color: #067e43;
      font-weight: 800;
    }

    button {
      border: none;
      border-radius: 16px;
      padding: 12px 18px;
      font-size: clamp(20px, 3.5vw, 26px);
      font-weight: 800;
      font-family: inherit;
      color: white;
      background: linear-gradient(180deg, #ff9d42, #ff6e2e);
      box-shadow: 0 8px 0 #cf4f1a;
      cursor: pointer;
      transform: translateY(0);
      transition: transform 120ms ease, filter 150ms ease;
    }

    button:hover { filter: brightness(1.04); }
    button:active { transform: translateY(4px); box-shadow: 0 4px 0 #cf4f1a; }

    .hint {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.8);
      border-radius: 999px;
      padding: 6px 14px;
      font-size: clamp(15px, 2.3vw, 18px);
      font-weight: 700;
      z-index: 2;
      user-select: none;
    }

    @media (max-width: 640px) {
      .hud { top: 8px; left: 8px; right: 8px; }
      .pill { padding: 7px 12px; border-radius: 14px; }
      #gameWrap {
        width: 100vw;
        height: 100vh;
        max-height: none;
        border-radius: 0;
        border: none;
      }
      .hint { bottom: 14px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="sky-decor" aria-hidden="true">
      <div class="cloud" style="top: 8%; width: 160px; height: 50px; animation-duration: 30s;"></div>
      <div class="cloud" style="top: 22%; width: 220px; height: 65px; animation-duration: 42s; animation-delay: -10s;"></div>
      <div class="cloud" style="top: 15%; width: 130px; height: 42px; animation-duration: 36s; animation-delay: -20s;"></div>
      <div class="cloud" style="top: 30%; width: 180px; height: 56px; animation-duration: 48s; animation-delay: -4s;"></div>
    </div>

    <div class="hud">
      <div class="pill">Score: <span class="score-val" id="score">0</span></div>
      <div class="pill">Misses: <span class="lives" id="lives">‚ô°‚ô°‚ô°</span></div>
    </div>

    <div id="gameWrap">
      <canvas id="game" aria-label="Falling Fruit Catcher game"></canvas>
      <div class="hint">Move basket with mouse, touch, or ‚Üê ‚Üí keys</div>

      <div class="overlay" id="overlay">
        <div class="card">
          <h1>Game Over!</h1>
          <p>You caught <span class="bigScore" id="finalScore">0</span> fruits!</p>
          <button id="restartBtn">Play Again</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const wrap = document.getElementById('gameWrap');
      const scoreEl = document.getElementById('score');
      const livesEl = document.getElementById('lives');
      const overlay = document.getElementById('overlay');
      const finalScoreEl = document.getElementById('finalScore');
      const restartBtn = document.getElementById('restartBtn');

      const fruitsIcons = ['üçé', 'üçì', 'üçä', 'üçå', 'üçç', 'üçê', 'üçâ', 'üçá'];
      const keys = { left: false, right: false };

      let w = 0;
      let h = 0;
      let gameOver = false;
      let score = 0;
      let misses = 0;
      let spawnTimer = 0;
      let spawnEvery = 750;
      let lastTime = performance.now();
      let shake = 0;

      const fruits = [];
      const particles = [];

      const basket = {
        x: 0,
        y: 0,
        w: 140,
        h: 38,
        speed: 520,
        targetX: null
      };

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const rect = wrap.getBoundingClientRect();
        w = Math.max(320, Math.floor(rect.width));
        h = Math.max(400, Math.floor(rect.height));
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        basket.w = Math.max(120, Math.min(180, w * 0.17));
        basket.h = Math.max(34, Math.min(46, h * 0.065));
        basket.y = h - basket.h - 22;
        basket.x = Math.min(Math.max(basket.x, 12), w - basket.w - 12);
      }

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function updateHud() {
        scoreEl.textContent = String(score);
        const left = Math.max(0, 3 - misses);
        livesEl.textContent = '‚ô°'.repeat(left) + '¬∑'.repeat(3 - left);
      }

      function emitParticles(x, y, count, warm) {
        for (let i = 0; i < count; i++) {
          particles.push({
            x,
            y,
            vx: rand(-170, 170),
            vy: rand(-300, -80),
            size: rand(5, 10),
            life: rand(420, 740),
            maxLife: 740,
            color: warm
              ? `hsl(${rand(18, 55)}, 96%, ${rand(52, 67)}%)`
              : `hsl(${rand(180, 230)}, 96%, ${rand(55, 70)}%)`
          });
        }
      }

      function spawnFruit() {
        const size = rand(24, 36);
        fruits.push({
          x: rand(size + 8, w - size - 8),
          y: -size - 8,
          size,
          vy: rand(110, 170) + Math.min(score * 5, 130),
          spin: rand(-2.8, 2.8),
          ang: rand(0, Math.PI * 2),
          icon: fruitsIcons[(Math.random() * fruitsIcons.length) | 0],
          glow: rand(0, 1)
        });
      }

      function resetGame() {
        fruits.length = 0;
        particles.length = 0;
        gameOver = false;
        score = 0;
        misses = 0;
        spawnTimer = 0;
        spawnEvery = 730;
        shake = 0;
        basket.x = w * 0.5 - basket.w * 0.5;
        basket.targetX = null;
        updateHud();
        overlay.classList.remove('show');
        lastTime = performance.now();
      }

      function endGame() {
        gameOver = true;
        finalScoreEl.textContent = String(score);
        overlay.classList.add('show');
      }

      function handlePointer(clientX) {
        const rect = wrap.getBoundingClientRect();
        const x = clientX - rect.left;
        basket.targetX = x - basket.w / 2;
      }

      function update(dtMs) {
        if (gameOver) return;

        const dt = dtMs / 1000;

        if (keys.left) basket.x -= basket.speed * dt;
        if (keys.right) basket.x += basket.speed * dt;

        if (basket.targetX !== null) {
          const dx = basket.targetX - basket.x;
          basket.x += dx * Math.min(1, dt * 12);
        }

        basket.x = Math.max(10, Math.min(w - basket.w - 10, basket.x));

        spawnEvery = Math.max(280, 730 - score * 8);
        spawnTimer += dtMs;
        while (spawnTimer >= spawnEvery) {
          spawnTimer -= spawnEvery;
          spawnFruit();
        }

        for (let i = fruits.length - 1; i >= 0; i--) {
          const f = fruits[i];
          f.y += f.vy * dt;
          f.ang += f.spin * dt;

          const catchY = basket.y - 8;
          const basketTop = catchY;
          const basketBottom = basket.y + basket.h;
          const basketLeft = basket.x - 4;
          const basketRight = basket.x + basket.w + 4;

          const overlapsY = f.y + f.size >= basketTop && f.y - f.size <= basketBottom;
          const overlapsX = f.x >= basketLeft && f.x <= basketRight;

          if (overlapsX && overlapsY) {
            score += 1;
            emitParticles(f.x, f.y, 12, true);
            fruits.splice(i, 1);
            updateHud();
            continue;
          }

          if (f.y - f.size > h + 8) {
            misses += 1;
            emitParticles(f.x, h - 16, 10, false);
            shake = 11;
            fruits.splice(i, 1);
            updateHud();
            if (misses >= 3) {
              endGame();
              return;
            }
          }
        }

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life -= dtMs;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 460 * dt;
          p.vx *= 0.992;
          if (p.life <= 0) particles.splice(i, 1);
        }

        shake *= 0.84;
      }

      function drawGround() {
        const grassY = h * 0.62;
        ctx.fillStyle = '#6fe177';
        ctx.fillRect(0, grassY, w, h - grassY);

        ctx.fillStyle = '#57cf64';
        for (let i = 0; i < w; i += 28) {
          const bump = Math.sin((i / 28) * 0.9 + performance.now() * 0.002) * 4;
          ctx.fillRect(i, grassY + 8 + bump, 16, h - grassY);
        }
      }

      function drawBasket(t) {
        const bob = Math.sin(t * 0.006) * 2;
        const x = basket.x;
        const y = basket.y + bob;
        const bw = basket.w;
        const bh = basket.h;

        ctx.save();

        ctx.fillStyle = '#b86a2f';
        ctx.beginPath();
        ctx.roundRect(x, y, bw, bh, 14);
        ctx.fill();

        ctx.fillStyle = '#d58845';
        for (let i = 0; i < 6; i++) {
          const sx = x + 12 + i * ((bw - 24) / 5);
          ctx.fillRect(sx, y + 6, 4, bh - 12);
        }

        ctx.lineWidth = 4;
        ctx.strokeStyle = '#935325';
        ctx.beginPath();
        ctx.roundRect(x, y, bw, bh, 14);
        ctx.stroke();

        ctx.strokeStyle = '#935325';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(x + bw / 2, y + 6, bw / 2.6, Math.PI, 2 * Math.PI);
        ctx.stroke();

        ctx.restore();
      }

      function drawFruit(f) {
        ctx.save();
        ctx.translate(f.x, f.y);
        ctx.rotate(f.ang);

        const grd = ctx.createRadialGradient(-f.size * 0.3, -f.size * 0.35, f.size * 0.25, 0, 0, f.size * 1.15);
        grd.addColorStop(0, `hsla(${45 + f.glow * 30}, 100%, 88%, 0.95)`);
        grd.addColorStop(1, `hsla(${12 + f.glow * 20}, 100%, 58%, 0.9)`);

        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(0, 0, f.size, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.beginPath();
        ctx.arc(-f.size * 0.35, -f.size * 0.32, f.size * 0.3, 0, Math.PI * 2);
        ctx.fill();

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `${Math.floor(f.size * 1.2)}px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif`;
        ctx.fillText(f.icon, 0, f.size * 0.05);

        ctx.restore();
      }

      function drawParticles() {
        for (const p of particles) {
          const a = Math.max(0, p.life / p.maxLife);
          ctx.globalAlpha = a;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * (0.55 + a), 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      function render(t) {
        const now = t;
        const dtMs = Math.min(32, now - lastTime || 16);
        lastTime = now;

        update(dtMs);

        const sx = shake ? rand(-shake, shake) : 0;
        const sy = shake ? rand(-shake * 0.7, shake * 0.7) : 0;

        ctx.save();
        ctx.translate(sx, sy);

        ctx.clearRect(-24, -24, w + 48, h + 48);
        drawGround();

        for (const f of fruits) drawFruit(f);
        drawParticles();
        drawBasket(t);

        ctx.restore();

        requestAnimationFrame(render);
      }

      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') {
          keys.left = true;
          basket.targetX = null;
          e.preventDefault();
        }
        if (e.key === 'ArrowRight') {
          keys.right = true;
          basket.targetX = null;
          e.preventDefault();
        }
        if (e.key === ' ' && gameOver) {
          resetGame();
          e.preventDefault();
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'ArrowRight') keys.right = false;
      });

      wrap.addEventListener('mousemove', (e) => handlePointer(e.clientX));
      wrap.addEventListener('touchstart', (e) => {
        if (e.touches[0]) handlePointer(e.touches[0].clientX);
      }, { passive: true });
      wrap.addEventListener('touchmove', (e) => {
        if (e.touches[0]) handlePointer(e.touches[0].clientX);
      }, { passive: true });

      restartBtn.addEventListener('click', resetGame);
      window.addEventListener('resize', resize);

      resize();
      resetGame();
      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
