<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Resonance Voice Lab</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;600;700;800&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-1: #051522;
      --bg-2: #071d2e;
      --bg-3: #0b2c3f;
      --ink: #e8f3f7;
      --muted: #a8c1cf;
      --line: rgba(255, 255, 255, 0.14);
      --glass: rgba(11, 36, 53, 0.5);
      --accent: #5de1c4;
      --accent-2: #f8c97f;
      --danger: #ff7d6f;
      --ok: #89f5a1;
      --shadow: 0 24px 64px rgba(0, 0, 0, 0.35);
      --radius: 22px;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      min-height: 100%;
      background: radial-gradient(circle at 80% -20%, #0f4258 0%, transparent 40%),
                  radial-gradient(circle at 20% -10%, #1a6f76 0%, transparent 38%),
                  linear-gradient(155deg, var(--bg-1), var(--bg-2) 48%, var(--bg-3));
      color: var(--ink);
      font-family: "Sora", sans-serif;
      overflow-x: hidden;
    }

    .grain::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.25;
      z-index: 0;
      background-image: radial-gradient(rgba(255, 255, 255, 0.06) 0.7px, transparent 0.7px);
      background-size: 3px 3px;
      mix-blend-mode: soft-light;
    }

    #fxCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      opacity: 0.9;
    }

    .wrap {
      position: relative;
      z-index: 2;
      width: min(1120px, 92vw);
      margin: 0 auto;
      padding: clamp(28px, 5vh, 56px) 0 clamp(28px, 6vh, 64px);
    }

    .hero {
      display: grid;
      gap: 24px;
      grid-template-columns: 1.1fr 0.9fr;
      align-items: end;
      margin-bottom: 26px;
    }

    .kicker {
      display: inline-flex;
      align-items: center;
      gap: 9px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 8px 12px;
      margin-bottom: 14px;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 18px rgba(93, 225, 196, 0.9);
      animation: pulse 1.6s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.45); opacity: 1; }
    }

    h1 {
      font-size: clamp(2.1rem, 5.8vw, 4.25rem);
      line-height: 1.02;
      margin: 0;
      letter-spacing: -0.03em;
      text-wrap: balance;
      max-width: 16ch;
    }

    .sub {
      color: var(--muted);
      margin: 16px 0 0;
      max-width: 56ch;
      font-size: clamp(0.98rem, 1.8vw, 1.12rem);
      line-height: 1.7;
    }

    .metrics {
      display: grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 10px;
    }

    .metric {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 14px;
      background: rgba(255,255,255,0.04);
      backdrop-filter: blur(6px);
    }

    .metric .label {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.11em;
    }

    .metric .value {
      margin-top: 6px;
      font-size: clamp(1rem, 2vw, 1.4rem);
      font-weight: 700;
      letter-spacing: -0.02em;
    }

    .panel {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(165deg, rgba(255,255,255,0.09), rgba(255,255,255,0.03));
      backdrop-filter: blur(14px) saturate(120%);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .grid {
      display: grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: 16px;
    }

    .left {
      padding: 22px;
      display: grid;
      gap: 14px;
    }

    .visual-wrap {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 10px;
      background: rgba(0,0,0,0.2);
    }

    #viz {
      width: 100%;
      height: 180px;
      display: block;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(14,41,58,0.4), rgba(5,17,30,0.72));
    }

    .status-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      color: var(--muted);
      font-size: 0.92rem;
      padding: 2px 4px 0;
    }

    .status-chip {
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.81rem;
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 5px 10px;
      color: #d6f8ee;
      background: rgba(93,225,196,0.12);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    label {
      display: grid;
      gap: 6px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      color: var(--muted);
    }

    select, input[type="range"], textarea {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(8, 23, 33, 0.75);
      color: var(--ink);
      font: inherit;
    }

    select {
      padding: 10px;
    }

    input[type="range"] {
      accent-color: var(--accent);
      height: 32px;
      padding: 0;
    }

    .text-area {
      display: grid;
      gap: 8px;
    }

    textarea {
      resize: vertical;
      min-height: 120px;
      max-height: 280px;
      padding: 13px 14px;
      line-height: 1.55;
    }

    .char-count {
      justify-self: end;
      color: var(--muted);
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
    }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 4px;
    }

    button {
      border: none;
      cursor: pointer;
      border-radius: 999px;
      font-family: inherit;
      font-weight: 600;
      padding: 10px 16px;
      transition: transform .18s ease, box-shadow .18s ease, background .22s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    .primary {
      background: linear-gradient(135deg, #59d3ba, #7ef2d6);
      color: #062219;
      box-shadow: 0 8px 24px rgba(89, 211, 186, 0.35);
    }

    .secondary {
      background: rgba(255,255,255,0.09);
      color: var(--ink);
      border: 1px solid var(--line);
    }

    .warn {
      background: rgba(255, 125, 111, 0.16);
      color: #ffd6d0;
      border: 1px solid rgba(255, 125, 111, 0.45);
    }

    button:hover {
      transform: translateY(-1px);
    }

    .right {
      border-left: 1px solid var(--line);
      padding: 20px;
      display: grid;
      gap: 12px;
      align-content: start;
      background: linear-gradient(180deg, rgba(0,0,0,0.1), rgba(0,0,0,0.2));
    }

    .card-title {
      margin: 0;
      font-size: 0.88rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .preset-list {
      display: grid;
      gap: 8px;
    }

    .preset {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color: var(--ink);
      border-radius: 12px;
      padding: 11px 12px;
      text-align: left;
      font-size: 0.9rem;
      line-height: 1.45;
    }

    .preset strong {
      display: block;
      font-size: 0.83rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #a9d7cc;
      margin-bottom: 4px;
    }

    .preset:hover {
      border-color: rgba(93, 225, 196, 0.45);
      background: rgba(93, 225, 196, 0.08);
    }

    .tip {
      border: 1px dashed rgba(248, 201, 127, 0.45);
      color: #f6d9a7;
      border-radius: 12px;
      padding: 11px;
      font-size: 0.84rem;
      line-height: 1.5;
      background: rgba(248, 201, 127, 0.07);
    }

    .footer {
      margin-top: 18px;
      color: #9db7c4;
      font-size: 0.78rem;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .mono {
      font-family: "IBM Plex Mono", monospace;
    }

    .hidden {
      display: none;
    }

    @media (max-width: 980px) {
      .hero { grid-template-columns: 1fr; }
      .grid { grid-template-columns: 1fr; }
      .right { border-left: none; border-top: 1px solid var(--line); }
    }

    @media (max-width: 720px) {
      .controls { grid-template-columns: 1fr; }
      .metrics { grid-template-columns: repeat(2, minmax(0,1fr)); }
      .footer { font-size: 0.74rem; }
      h1 { font-size: clamp(2rem, 11vw, 3rem); }
    }
  </style>
</head>
<body>
  <div class="grain"></div>
  <canvas id="fxCanvas" aria-hidden="true"></canvas>

  <main class="wrap">
    <section class="hero">
      <div>
        <span class="kicker"><span class="dot"></span> Real-time voice playground</span>
        <h1>Shape words into motion, tone, and rhythm.</h1>
        <p class="sub">An OpenAI.fm-inspired voice lab: pick a voice, tune pacing, and watch a responsive waveform while your script is spoken in-browser.</p>
      </div>
      <div class="metrics panel">
        <article class="metric">
          <div class="label">Voices Detected</div>
          <div class="value" id="voiceCount">0</div>
        </article>
        <article class="metric">
          <div class="label">Language</div>
          <div class="value" id="langMetric">-</div>
        </article>
        <article class="metric">
          <div class="label">Session State</div>
          <div class="value" id="stateMetric">Idle</div>
        </article>
      </div>
    </section>

    <section class="panel grid">
      <div class="left">
        <div class="visual-wrap">
          <canvas id="viz" width="1200" height="340"></canvas>
          <div class="status-row">
            <span id="statusText">Waiting for input</span>
            <span class="status-chip" id="clockTag">00.00s</span>
          </div>
        </div>

        <div class="controls">
          <label>Voice
            <select id="voiceSelect"></select>
          </label>
          <label>Rate <span class="mono" id="rateValue">1.00</span>
            <input id="rate" type="range" min="0.7" max="1.3" step="0.01" value="1" />
          </label>
          <label>Pitch <span class="mono" id="pitchValue">1.00</span>
            <input id="pitch" type="range" min="0.6" max="1.7" step="0.01" value="1" />
          </label>
        </div>

        <div class="text-area">
          <label for="script">Script</label>
          <textarea id="script" spellcheck="true">Welcome to Resonance Voice Lab. This is a browser-based audio playground inspired by OpenAI dot fm. Tune the voice, adjust rhythm and pitch, then let language paint the waveform in real time.</textarea>
          <span class="char-count" id="charCount">0 characters</span>
        </div>

        <div class="buttons">
          <button class="primary" id="speakBtn">Speak</button>
          <button class="secondary" id="pauseBtn">Pause</button>
          <button class="secondary" id="resumeBtn">Resume</button>
          <button class="warn" id="stopBtn">Stop</button>
        </div>
      </div>

      <aside class="right">
        <h2 class="card-title">Prompt Presets</h2>
        <div class="preset-list" id="presetList"></div>

        <div class="tip">
          If voices do not appear immediately, interact once and wait a moment. Different browsers expose different voice catalogs.
        </div>

        <div class="footer">
          <span>Engine: <span class="mono">SpeechSynthesis API</span></span>
          <span id="browserLabel"></span>
        </div>
      </aside>
    </section>
  </main>

  <script>
    (() => {
      const $ = (id) => document.getElementById(id);
      const speech = window.speechSynthesis;
      const hasSpeech = !!(speech && window.SpeechSynthesisUtterance);

      const state = {
        speaking: false,
        paused: false,
        startedAt: 0,
        elapsed: 0,
        level: 0,
        target: 0,
        burst: 0,
        voices: [],
        raf: 0,
        fxRaf: 0,
        frame: 0,
        utterance: null
      };

      const presets = [
        {
          title: "Product Launch",
          text: "Today we unveil a voice interface that feels warm, articulate, and immediate. It adapts pacing in real time so every sentence lands with confidence."
        },
        {
          title: "Futurist",
          text: "In the next decade, conversation becomes the primary operating system. Software listens, reasons, and replies with clarity at the speed of thought."
        },
        {
          title: "Calm Narration",
          text: "Breathe in. Exhale slowly. Let the sound settle into the room. Every word arrives softly, with space between moments."
        },
        {
          title: "AI Radio",
          text: "You are tuned to Resonance FM, where synthetic voices and human ideas collide. Stay with us for a journey through sound design and language."
        }
      ];

      const voiceSelect = $("voiceSelect");
      const rate = $("rate");
      const pitch = $("pitch");
      const rateValue = $("rateValue");
      const pitchValue = $("pitchValue");
      const script = $("script");
      const charCount = $("charCount");
      const statusText = $("statusText");
      const clockTag = $("clockTag");
      const stateMetric = $("stateMetric");
      const langMetric = $("langMetric");
      const voiceCount = $("voiceCount");
      const browserLabel = $("browserLabel");

      const speakBtn = $("speakBtn");
      const pauseBtn = $("pauseBtn");
      const resumeBtn = $("resumeBtn");
      const stopBtn = $("stopBtn");
      const presetList = $("presetList");

      const viz = $("viz");
      const vctx = viz.getContext("2d");
      const fxCanvas = $("fxCanvas");
      const fctx = fxCanvas.getContext("2d");

      function updateClock() {
        if (state.speaking && !state.paused) {
          state.elapsed = (performance.now() - state.startedAt) / 1000;
        }
        clockTag.textContent = `${state.elapsed.toFixed(2)}s`;
      }

      function updateTextMeta() {
        charCount.textContent = `${script.value.length} characters`;
      }

      function detectBrowser() {
        const ua = navigator.userAgent;
        let name = "Browser";
        if (ua.includes("Firefox")) name = "Firefox";
        else if (ua.includes("Edg")) name = "Edge";
        else if (ua.includes("Chrome")) name = "Chrome";
        else if (ua.includes("Safari")) name = "Safari";
        browserLabel.textContent = `${name} • ${navigator.platform || "Unknown"}`;
      }

      function setStatus(text, mode) {
        statusText.textContent = text;
        stateMetric.textContent = mode;
      }

      function mapLang(lang) {
        if (!lang) return "-";
        return lang.split("-")[0].toUpperCase();
      }

      function fillVoices() {
        if (!hasSpeech) {
          setStatus("Speech synthesis is not supported in this browser", "Unsupported");
          voiceSelect.innerHTML = `<option>Unsupported</option>`;
          speakBtn.disabled = true;
          pauseBtn.disabled = true;
          resumeBtn.disabled = true;
          stopBtn.disabled = true;
          return;
        }

        const voices = speech.getVoices().slice().sort((a, b) => {
          const scoreA = Number(!a.default) + Number(!(a.lang || "").startsWith("en"));
          const scoreB = Number(!b.default) + Number(!(b.lang || "").startsWith("en"));
          return scoreA - scoreB || a.name.localeCompare(b.name);
        });

        state.voices = voices;
        voiceCount.textContent = String(voices.length);

        if (!voices.length) {
          voiceSelect.innerHTML = `<option>Loading voices…</option>`;
          langMetric.textContent = "-";
          return;
        }

        const current = voiceSelect.value;
        voiceSelect.innerHTML = "";

        voices.forEach((v, idx) => {
          const option = document.createElement("option");
          option.value = String(idx);
          option.textContent = `${v.name} (${v.lang})${v.default ? " • default" : ""}`;
          voiceSelect.appendChild(option);
        });

        const enIndex = voices.findIndex((v) => v.default || v.lang.startsWith("en"));
        voiceSelect.value = current && voices[Number(current)] ? current : String(Math.max(enIndex, 0));
        const sel = voices[Number(voiceSelect.value)] || voices[0];
        langMetric.textContent = mapLang(sel.lang);
      }

      function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      function stopSpeech() {
        if (!hasSpeech) return;
        speech.cancel();
        state.speaking = false;
        state.paused = false;
        state.target = 0;
        state.burst = 0;
        setStatus("Stopped", "Stopped");
      }

      function speak() {
        if (!hasSpeech) return;
        const text = script.value.trim();
        if (!text) {
          setStatus("Add text before speaking", "Idle");
          return;
        }

        stopSpeech();

        const utter = new SpeechSynthesisUtterance(text);
        state.utterance = utter;

        const selected = state.voices[Number(voiceSelect.value)];
        if (selected) {
          utter.voice = selected;
          utter.lang = selected.lang;
          langMetric.textContent = mapLang(selected.lang);
        }

        utter.rate = parseFloat(rate.value);
        utter.pitch = parseFloat(pitch.value);

        utter.onstart = () => {
          state.speaking = true;
          state.paused = false;
          state.startedAt = performance.now();
          state.elapsed = 0;
          state.target = 0.6;
          setStatus("Speaking", "Live");
        };

        utter.onboundary = (e) => {
          if (e.name === "word" || e.charIndex >= 0) {
            state.burst = 1;
            const density = Math.min(1, text.length / 300);
            state.target = clamp(0.45 + Math.random() * 0.5 + density * 0.1, 0.25, 1);
          }
        };

        utter.onpause = () => {
          state.paused = true;
          setStatus("Paused", "Paused");
        };

        utter.onresume = () => {
          state.paused = false;
          setStatus("Speaking", "Live");
        };

        utter.onerror = () => {
          state.speaking = false;
          state.target = 0;
          setStatus("Speech error occurred", "Error");
        };

        utter.onend = () => {
          state.speaking = false;
          state.paused = false;
          state.target = 0;
          state.burst = 0;
          setStatus("Playback complete", "Idle");
        };

        speech.speak(utter);
      }

      function pause() {
        if (hasSpeech && speech.speaking && !speech.paused) {
          speech.pause();
        }
      }

      function resume() {
        if (hasSpeech && speech.paused) {
          speech.resume();
        }
      }

      function resizeCanvas(canvas, ctx, heightScale = 1) {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.height * dpr * heightScale);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function drawVisualizer() {
        const w = viz.clientWidth;
        const h = viz.clientHeight;

        state.level += (state.target - state.level) * (state.paused ? 0.03 : 0.08);
        state.target *= state.speaking ? 0.98 : 0.92;
        state.burst *= 0.9;
        const t = performance.now() * 0.001;

        vctx.clearRect(0, 0, w, h);

        const grad = vctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, "rgba(87, 204, 176, 0.13)");
        grad.addColorStop(0.45, "rgba(109, 191, 255, 0.08)");
        grad.addColorStop(1, "rgba(248, 201, 127, 0.12)");
        vctx.fillStyle = grad;
        vctx.fillRect(0, 0, w, h);

        const lines = 4;
        for (let layer = 0; layer < lines; layer++) {
          const yBase = h * (0.23 + layer * 0.18);
          const amp = 14 + state.level * (32 + layer * 7);
          const speed = 0.7 + layer * 0.19;
          const hue = 158 + layer * 15;

          vctx.beginPath();
          for (let x = 0; x <= w; x += 7) {
            const nx = x / w;
            const wobble = Math.sin(nx * 13 + t * speed + layer * 0.9) * amp;
            const ripple = Math.sin(nx * 42 - t * (0.9 + layer * 0.14)) * (amp * 0.13);
            const burst = Math.sin(nx * 120 + t * 10 + layer) * (state.burst * 9);
            const y = yBase + wobble + ripple + burst;
            if (x === 0) vctx.moveTo(x, y);
            else vctx.lineTo(x, y);
          }

          vctx.strokeStyle = `hsla(${hue}, 88%, ${68 - layer * 6}%, ${0.78 - layer * 0.12})`;
          vctx.lineWidth = 1.8 + layer * 0.45;
          vctx.stroke();
        }

        const bars = 54;
        const gap = w / bars;
        for (let i = 0; i < bars; i++) {
          const x = i * gap + gap * 0.2;
          const n = Math.sin(i * 0.71 + t * 3.1) * 0.5 + 0.5;
          const energy = clamp(n * 0.5 + state.level * 0.9 + state.burst * 0.6, 0, 1);
          const bh = 8 + energy * (h * 0.38);
          vctx.fillStyle = `rgba(${90 + i * 2}, ${215 - i}, ${190 - i * 0.5}, ${0.11 + energy * 0.22})`;
          vctx.fillRect(x, h - bh - 6, Math.max(2, gap * 0.58), bh);
        }

        updateClock();
        state.raf = requestAnimationFrame(drawVisualizer);
      }

      function drawBackground() {
        const w = fxCanvas.clientWidth;
        const h = fxCanvas.clientHeight;
        const t = performance.now() * 0.00035;
        state.frame++;

        fctx.clearRect(0, 0, w, h);

        const blobs = 3;
        for (let i = 0; i < blobs; i++) {
          const pct = i / blobs;
          const x = w * (0.1 + pct * 0.45 + Math.sin(t * (1 + i * 0.2) + i) * 0.07);
          const y = h * (0.25 + pct * 0.26 + Math.cos(t * (0.8 + i * 0.3) + i * 0.8) * 0.09);
          const r = Math.min(w, h) * (0.22 + i * 0.06 + state.level * 0.05);
          const g = fctx.createRadialGradient(x, y, 0, x, y, r);
          if (i === 0) {
            g.addColorStop(0, `rgba(90, 219, 190, ${0.16 + state.level * 0.1})`);
            g.addColorStop(1, "rgba(90, 219, 190, 0)");
          } else if (i === 1) {
            g.addColorStop(0, `rgba(114, 181, 255, ${0.12 + state.level * 0.06})`);
            g.addColorStop(1, "rgba(114, 181, 255, 0)");
          } else {
            g.addColorStop(0, `rgba(248, 201, 127, ${0.1 + state.level * 0.06})`);
            g.addColorStop(1, "rgba(248, 201, 127, 0)");
          }
          fctx.fillStyle = g;
          fctx.beginPath();
          fctx.arc(x, y, r, 0, Math.PI * 2);
          fctx.fill();
        }

        fxCanvas.style.opacity = state.speaking ? "0.98" : "0.82";
        state.fxRaf = requestAnimationFrame(drawBackground);
      }

      function renderPresets() {
        presetList.innerHTML = "";
        for (const p of presets) {
          const btn = document.createElement("button");
          btn.className = "preset";
          btn.innerHTML = `<strong>${p.title}</strong>${p.text}`;
          btn.addEventListener("click", () => {
            script.value = p.text;
            updateTextMeta();
            setStatus(`Loaded preset: ${p.title}`, state.speaking ? "Live" : "Idle");
          });
          presetList.appendChild(btn);
        }
      }

      function bind() {
        voiceSelect.addEventListener("change", () => {
          const v = state.voices[Number(voiceSelect.value)];
          langMetric.textContent = mapLang(v?.lang);
        });

        rate.addEventListener("input", () => {
          rateValue.textContent = Number(rate.value).toFixed(2);
          state.target = Math.max(state.target, 0.16);
        });

        pitch.addEventListener("input", () => {
          pitchValue.textContent = Number(pitch.value).toFixed(2);
          state.target = Math.max(state.target, 0.16);
        });

        script.addEventListener("input", updateTextMeta);

        speakBtn.addEventListener("click", speak);
        pauseBtn.addEventListener("click", pause);
        resumeBtn.addEventListener("click", resume);
        stopBtn.addEventListener("click", stopSpeech);

        window.addEventListener("beforeunload", () => {
          cancelAnimationFrame(state.raf);
          cancelAnimationFrame(state.fxRaf);
          if (hasSpeech) speech.cancel();
        });

        window.addEventListener("resize", () => {
          resizeCanvas(viz, vctx);
          resizeCanvas(fxCanvas, fctx);
        });
      }

      function init() {
        detectBrowser();
        renderPresets();
        bind();
        updateTextMeta();
        rateValue.textContent = Number(rate.value).toFixed(2);
        pitchValue.textContent = Number(pitch.value).toFixed(2);
        setStatus("Ready", "Idle");

        resizeCanvas(viz, vctx);
        resizeCanvas(fxCanvas, fctx);
        drawVisualizer();
        drawBackground();

        if (hasSpeech) {
          fillVoices();
          if (typeof speech.onvoiceschanged !== "undefined") {
            speech.onvoiceschanged = fillVoices;
          }

          setTimeout(fillVoices, 150);
          setTimeout(fillVoices, 800);
        } else {
          fillVoices();
        }
      }

      init();
    })();
  </script>
</body>
</html>
