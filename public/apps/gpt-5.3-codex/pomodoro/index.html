<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pomodoro</title>
  <style>
    :root {
      --bg: #f7f9ff;
      --bg-2: #eaf0ff;
      --card: rgba(255, 255, 255, 0.84);
      --text: #17203a;
      --muted: #5d6788;
      --accent: #ff5a3c;
      --accent-2: #ff9f1c;
      --accent-3: #24c2ff;
      --good: #27bf74;
      --danger: #d64f6f;
      --ring-track: #d9e1fb;
      --shadow: 0 20px 40px rgba(38, 56, 120, 0.14);
      --border: rgba(84, 100, 157, 0.16);
    }

    body.dark {
      --bg: #0d1324;
      --bg-2: #111a30;
      --card: rgba(17, 25, 45, 0.82);
      --text: #e7ecff;
      --muted: #a4afd5;
      --accent: #ff7758;
      --accent-2: #ffba49;
      --accent-3: #38d7ff;
      --good: #45d68f;
      --danger: #f06a89;
      --ring-track: #2a365f;
      --shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      --border: rgba(141, 162, 230, 0.16);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Avenir Next", "Segoe UI", "Helvetica Neue", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at -10% -20%, rgba(255, 159, 28, 0.22), transparent 45%),
        radial-gradient(900px 600px at 115% -10%, rgba(36, 194, 255, 0.22), transparent 48%),
        linear-gradient(160deg, var(--bg), var(--bg-2));
      transition: background 0.25s ease, color 0.25s ease;
    }

    .app {
      width: min(1120px, 94vw);
      margin: 24px auto 40px;
      display: grid;
      gap: 16px;
      grid-template-columns: 1.45fr 1fr;
      grid-template-areas:
        "head head"
        "timer side"
        "charts side";
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 22px;
      box-shadow: var(--shadow);
    }

    .header {
      grid-area: head;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 18px;
    }

    .title-wrap h1 {
      margin: 0;
      font-size: 1.45rem;
      letter-spacing: 0.4px;
    }

    .title-wrap p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.94rem;
    }

    .top-actions {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .switch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 0.9rem;
      user-select: none;
    }

    .switch input { display: none; }

    .pill {
      position: relative;
      width: 48px;
      height: 27px;
      border-radius: 999px;
      background: var(--ring-track);
      transition: background 0.2s ease;
      border: 1px solid var(--border);
    }

    .pill::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 19px;
      height: 19px;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s ease;
    }

    .switch input:checked + .pill {
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
    }

    .switch input:checked + .pill::after {
      transform: translateX(21px);
    }

    .timer-card {
      grid-area: timer;
      padding: 18px;
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 18px;
      align-items: center;
    }

    .ring-wrap {
      position: relative;
      width: 100%;
      max-width: 280px;
      margin: 0 auto;
      aspect-ratio: 1 / 1;
    }

    .ring-wrap svg { width: 100%; height: 100%; }

    .ring-center {
      position: absolute;
      inset: 0;
      display: grid;
      place-content: center;
      text-align: center;
      padding: 16px;
    }

    .phase {
      margin: 0;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 1.6px;
      color: var(--muted);
      font-weight: 700;
    }

    .time {
      margin: 6px 0 4px;
      font-size: clamp(2.35rem, 5.3vw, 3.2rem);
      font-weight: 800;
      line-height: 1;
      letter-spacing: 1px;
      font-variant-numeric: tabular-nums;
    }

    .session-counter {
      margin: 0;
      color: var(--muted);
      font-size: 0.88rem;
    }

    .timer-info {
      display: grid;
      gap: 14px;
    }

    .badges {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .badge {
      padding: 7px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 700;
      color: #fff;
      letter-spacing: 0.2px;
    }

    .badge.focus { background: linear-gradient(120deg, var(--accent), #ff3a66); }
    .badge.break { background: linear-gradient(120deg, var(--accent-3), #2bb7d6); }
    .badge.long { background: linear-gradient(120deg, #7f84ff, #53a2ff); }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      border: 0;
      cursor: pointer;
      border-radius: 12px;
      padding: 11px 14px;
      font-weight: 700;
      font-size: 0.93rem;
      transition: transform 0.12s ease, opacity 0.2s ease, box-shadow 0.2s ease;
    }

    button:active { transform: translateY(1px) scale(0.99); }

    .primary {
      color: #fff;
      background: linear-gradient(125deg, var(--accent), var(--accent-2));
      box-shadow: 0 12px 22px rgba(255, 90, 60, 0.28);
    }

    .secondary {
      color: var(--text);
      background: rgba(127, 145, 210, 0.14);
      border: 1px solid var(--border);
    }

    .danger {
      color: #fff;
      background: linear-gradient(125deg, var(--danger), #ef6e59);
      box-shadow: 0 12px 22px rgba(214, 79, 111, 0.24);
    }

    .primary:hover, .danger:hover { opacity: 0.92; }
    .secondary:hover { background: rgba(127, 145, 210, 0.22); }

    .status-line {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 0.92rem;
    }

    .side {
      grid-area: side;
      display: grid;
      gap: 16px;
      align-content: start;
    }

    .panel {
      padding: 14px;
    }

    .panel h2 {
      margin: 4px 0 12px;
      font-size: 1rem;
      letter-spacing: 0.3px;
    }

    .grid-inputs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .input-wrap {
      display: grid;
      gap: 4px;
    }

    .input-wrap label {
      font-size: 0.82rem;
      color: var(--muted);
      font-weight: 600;
    }

    input[type="number"] {
      width: 100%;
      background: rgba(119, 136, 200, 0.12);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 10px;
      font: inherit;
      font-size: 0.93rem;
    }

    .checks {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }

    .checks .switch {
      justify-content: space-between;
      width: 100%;
      font-size: 0.89rem;
      color: var(--text);
      padding: 5px 0;
    }

    .log-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .log-head small { color: var(--muted); }

    .log-list {
      max-height: 240px;
      overflow: auto;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(127, 145, 210, 0.08);
    }

    .log-item {
      display: grid;
      grid-template-columns: 72px 1fr auto;
      gap: 8px;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid rgba(127, 145, 210, 0.16);
      font-size: 0.87rem;
    }

    .log-item:last-child { border-bottom: 0; }
    .log-time { color: var(--muted); font-variant-numeric: tabular-nums; }
    .log-type { font-weight: 700; }
    .log-mins { color: var(--good); font-weight: 700; }

    .empty {
      padding: 14px;
      color: var(--muted);
      font-size: 0.9rem;
      text-align: center;
    }

    .charts {
      grid-area: charts;
      padding: 14px;
      display: grid;
      gap: 14px;
    }

    .chart-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .chart-box {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(127, 145, 210, 0.08);
      padding: 10px;
    }

    .chart-box h3 {
      margin: 0 0 8px;
      font-size: 0.88rem;
      color: var(--muted);
      letter-spacing: 0.3px;
      font-weight: 700;
    }

    .chart-box svg {
      display: block;
      width: 100%;
      height: 190px;
    }

    .footer-stats {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 0.88rem;
      padding: 2px 2px 0;
    }

    .dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 5px;
      vertical-align: middle;
    }

    @media (max-width: 980px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-areas:
          "head"
          "timer"
          "side"
          "charts";
      }
      .timer-card { grid-template-columns: 1fr; }
      .chart-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="header card">
      <div class="title-wrap">
        <h1>Pomodoro</h1>
        <p>Focus with intensity, recover with intent.</p>
      </div>
      <div class="top-actions">
        <label class="switch" title="Dark mode">
          <span>Dark</span>
          <input id="darkToggle" type="checkbox" />
          <span class="pill"></span>
        </label>
      </div>
    </header>

    <section class="timer-card card">
      <div class="ring-wrap">
        <svg viewBox="0 0 260 260" role="img" aria-label="Timer progress">
          <circle cx="130" cy="130" r="108" fill="none" stroke="var(--ring-track)" stroke-width="16"></circle>
          <circle id="progressRing" cx="130" cy="130" r="108" fill="none" stroke="url(#ringGradient)" stroke-width="16" stroke-linecap="round" transform="rotate(-90 130 130)"></circle>
          <defs>
            <linearGradient id="ringGradient" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="var(--accent)"></stop>
              <stop offset="100%" stop-color="var(--accent-2)"></stop>
            </linearGradient>
          </defs>
        </svg>
        <div class="ring-center">
          <p id="phaseLabel" class="phase">Focus</p>
          <p id="timeDisplay" class="time">25:00</p>
          <p id="sessionCounter" class="session-counter">0 focus sessions done today</p>
        </div>
      </div>

      <div class="timer-info">
        <div class="badges">
          <span id="badgeFocus" class="badge focus">Focus</span>
          <span id="badgeBreak" class="badge break" style="opacity:0.45;">Short break</span>
          <span id="badgeLong" class="badge long" style="opacity:0.45;">Long break</span>
        </div>

        <div class="controls">
          <button id="startPauseBtn" class="primary">Start</button>
          <button id="resetBtn" class="secondary">Reset</button>
          <button id="skipBtn" class="secondary">Skip</button>
        </div>

        <div class="status-line">
          <span id="statusText">Ready to start your next sprint.</span>
          <span id="todayFocusMins">Today: 0 focus min</span>
        </div>
      </div>
    </section>

    <aside class="side">
      <section class="panel card">
        <h2>Settings</h2>
        <div class="grid-inputs">
          <div class="input-wrap">
            <label for="focusInput">Focus (minutes)</label>
            <input id="focusInput" type="number" min="1" max="120" value="25" />
          </div>
          <div class="input-wrap">
            <label for="shortInput">Short break</label>
            <input id="shortInput" type="number" min="1" max="60" value="5" />
          </div>
          <div class="input-wrap">
            <label for="longInput">Long break</label>
            <input id="longInput" type="number" min="1" max="90" value="15" />
          </div>
          <div class="input-wrap">
            <label for="longEveryInput">Long break every</label>
            <input id="longEveryInput" type="number" min="2" max="12" value="4" />
          </div>
        </div>
        <div class="checks">
          <label class="switch">
            <span>Auto-start next session</span>
            <input id="autoStartInput" type="checkbox" checked />
            <span class="pill"></span>
          </label>
          <label class="switch">
            <span>Sound alert</span>
            <input id="soundInput" type="checkbox" checked />
            <span class="pill"></span>
          </label>
        </div>
      </section>

      <section class="panel card">
        <div class="log-head">
          <div>
            <h2 style="margin:0;">Session Log</h2>
            <small>Completed sessions</small>
          </div>
          <button id="clearLogBtn" class="secondary" style="padding:8px 10px; font-size:0.82rem;">Clear</button>
        </div>
        <div id="logList" class="log-list"></div>
      </section>
    </aside>

    <section class="charts card">
      <div class="chart-grid">
        <div class="chart-box">
          <h3>Last 7 Days Focus Minutes</h3>
          <svg id="barChart" viewBox="0 0 380 190" preserveAspectRatio="none"></svg>
        </div>
        <div class="chart-box">
          <h3>Session Mix</h3>
          <svg id="donutChart" viewBox="0 0 380 190" preserveAspectRatio="none"></svg>
        </div>
      </div>
      <div id="footerStats" class="footer-stats"></div>
    </section>
  </main>

  <script>
    (function () {
      const STORAGE_KEY = "pomodoro-energy-v1";
      const SVG_NS = "http://www.w3.org/2000/svg";

      const defaults = {
        durations: { focus: 25, short: 5, long: 15 },
        longEvery: 4,
        autoStart: true,
        sound: true,
        dark: window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches,
        completedFocusInCycle: 0,
        phase: "focus",
        remaining: 25 * 60,
        log: []
      };

      const state = loadState();
      let timerId = null;

      const els = {
        darkToggle: document.getElementById("darkToggle"),
        progressRing: document.getElementById("progressRing"),
        phaseLabel: document.getElementById("phaseLabel"),
        timeDisplay: document.getElementById("timeDisplay"),
        sessionCounter: document.getElementById("sessionCounter"),
        startPauseBtn: document.getElementById("startPauseBtn"),
        resetBtn: document.getElementById("resetBtn"),
        skipBtn: document.getElementById("skipBtn"),
        statusText: document.getElementById("statusText"),
        todayFocusMins: document.getElementById("todayFocusMins"),
        badgeFocus: document.getElementById("badgeFocus"),
        badgeBreak: document.getElementById("badgeBreak"),
        badgeLong: document.getElementById("badgeLong"),
        focusInput: document.getElementById("focusInput"),
        shortInput: document.getElementById("shortInput"),
        longInput: document.getElementById("longInput"),
        longEveryInput: document.getElementById("longEveryInput"),
        autoStartInput: document.getElementById("autoStartInput"),
        soundInput: document.getElementById("soundInput"),
        clearLogBtn: document.getElementById("clearLogBtn"),
        logList: document.getElementById("logList"),
        barChart: document.getElementById("barChart"),
        donutChart: document.getElementById("donutChart"),
        footerStats: document.getElementById("footerStats")
      };

      const radius = 108;
      const circumference = 2 * Math.PI * radius;
      els.progressRing.style.strokeDasharray = String(circumference);

      init();

      function init() {
        applyTheme(state.dark);
        bind();
        fillSettingsInputs();
        renderAll();
      }

      function bind() {
        els.startPauseBtn.addEventListener("click", toggleTimer);
        els.resetBtn.addEventListener("click", resetCurrentPhase);
        els.skipBtn.addEventListener("click", completePhase);
        els.clearLogBtn.addEventListener("click", clearLog);

        els.darkToggle.addEventListener("change", (e) => {
          state.dark = e.target.checked;
          applyTheme(state.dark);
          saveState();
        });

        els.autoStartInput.addEventListener("change", (e) => {
          state.autoStart = e.target.checked;
          saveState();
          renderStatus();
        });

        els.soundInput.addEventListener("change", (e) => {
          state.sound = e.target.checked;
          saveState();
        });

        ["focusInput", "shortInput", "longInput", "longEveryInput"].forEach((id) => {
          els[id].addEventListener("change", applySettingsFromInputs);
        });
      }

      function toggleTimer() {
        if (timerId) {
          stopTimer();
        } else {
          startTimer();
        }
      }

      function startTimer() {
        if (state.remaining <= 0) state.remaining = getPhaseDurationSeconds(state.phase);
        timerId = window.setInterval(() => {
          state.remaining -= 1;
          if (state.remaining <= 0) {
            state.remaining = 0;
            stopTimer();
            completePhase();
            return;
          }
          renderTimer();
        }, 1000);
        renderStatus();
        renderControls();
      }

      function stopTimer() {
        if (timerId) {
          clearInterval(timerId);
          timerId = null;
        }
        renderStatus();
        renderControls();
      }

      function resetCurrentPhase() {
        state.remaining = getPhaseDurationSeconds(state.phase);
        stopTimer();
        saveState();
        renderAll();
      }

      function completePhase() {
        stopTimer();
        const justCompleted = state.phase;
        const durationMin = state.durations[justCompleted];

        addLogEntry(justCompleted, durationMin);

        if (state.sound) beep();

        if (justCompleted === "focus") {
          state.completedFocusInCycle += 1;
          state.phase = state.completedFocusInCycle % state.longEvery === 0 ? "long" : "short";
        } else {
          state.phase = "focus";
        }

        state.remaining = getPhaseDurationSeconds(state.phase);
        saveState();
        renderAll();

        if (state.autoStart) {
          startTimer();
        }
      }

      function addLogEntry(type, durationMin) {
        const now = new Date();
        state.log.push({
          id: now.getTime() + Math.random().toString(16).slice(2),
          type,
          durationMin,
          timestamp: now.toISOString(),
          dateKey: now.toISOString().slice(0, 10)
        });
        if (state.log.length > 500) state.log = state.log.slice(-500);
      }

      function clearLog() {
        state.log = [];
        saveState();
        renderCharts();
        renderLog();
        renderTodayStats();
      }

      function applySettingsFromInputs() {
        const focus = clampInt(els.focusInput.value, 1, 120, state.durations.focus);
        const short = clampInt(els.shortInput.value, 1, 60, state.durations.short);
        const long = clampInt(els.longInput.value, 1, 90, state.durations.long);
        const longEvery = clampInt(els.longEveryInput.value, 2, 12, state.longEvery);

        state.durations = { focus, short, long };
        state.longEvery = longEvery;

        if (!timerId) {
          state.remaining = getPhaseDurationSeconds(state.phase);
        }

        fillSettingsInputs();
        saveState();
        renderAll();
      }

      function fillSettingsInputs() {
        els.focusInput.value = state.durations.focus;
        els.shortInput.value = state.durations.short;
        els.longInput.value = state.durations.long;
        els.longEveryInput.value = state.longEvery;
        els.autoStartInput.checked = !!state.autoStart;
        els.soundInput.checked = !!state.sound;
        els.darkToggle.checked = !!state.dark;
      }

      function renderAll() {
        renderTimer();
        renderControls();
        renderStatus();
        renderTodayStats();
        renderLog();
        renderCharts();
      }

      function renderTimer() {
        const total = getPhaseDurationSeconds(state.phase);
        const progress = total ? (total - state.remaining) / total : 0;
        const offset = circumference * (1 - progress);

        els.progressRing.style.strokeDashoffset = String(offset);
        els.timeDisplay.textContent = formatTime(state.remaining);
        els.phaseLabel.textContent = phaseText(state.phase);

        els.badgeFocus.style.opacity = state.phase === "focus" ? "1" : "0.45";
        els.badgeBreak.style.opacity = state.phase === "short" ? "1" : "0.45";
        els.badgeLong.style.opacity = state.phase === "long" ? "1" : "0.45";
      }

      function renderControls() {
        els.startPauseBtn.textContent = timerId ? "Pause" : "Start";
      }

      function renderStatus() {
        if (timerId) {
          els.statusText.textContent = state.phase === "focus" ? "Deep work in progress." : "Recharge and breathe.";
        } else {
          els.statusText.textContent = state.autoStart
            ? "Auto-start is on. Next session launches automatically."
            : "Auto-start is off. You choose when to continue.";
        }
      }

      function renderTodayStats() {
        const today = dateKeyOf(new Date());
        const todayFocusSessions = state.log.filter((x) => x.dateKey === today && x.type === "focus");
        const todayFocusMin = todayFocusSessions.reduce((sum, x) => sum + x.durationMin, 0);
        els.todayFocusMins.textContent = `Today: ${todayFocusMin} focus min`;
        els.sessionCounter.textContent = `${todayFocusSessions.length} focus sessions done today`;
      }

      function renderLog() {
        const items = state.log.slice().reverse().slice(0, 20);
        if (!items.length) {
          els.logList.innerHTML = '<div class="empty">No sessions yet. Press Start and build momentum.</div>';
          return;
        }

        els.logList.innerHTML = items.map((item) => {
          const d = new Date(item.timestamp);
          const time = d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
          return `<div class="log-item">
            <span class="log-time">${escapeHtml(time)}</span>
            <span class="log-type">${escapeHtml(phaseText(item.type))}</span>
            <span class="log-mins">${item.durationMin}m</span>
          </div>`;
        }).join("");
      }

      function renderCharts() {
        renderBarChart();
        renderDonutChart();
        renderFooterStats();
      }

      function renderBarChart() {
        clearSvg(els.barChart);

        const days = lastNDays(7);
        const focusByDay = new Map(days.map((d) => [d, 0]));
        state.log.forEach((entry) => {
          if (entry.type === "focus" && focusByDay.has(entry.dateKey)) {
            focusByDay.set(entry.dateKey, focusByDay.get(entry.dateKey) + entry.durationMin);
          }
        });

        const values = days.map((d) => focusByDay.get(d));
        const maxVal = Math.max(30, ...values);

        const W = 380;
        const H = 190;
        const baseY = 160;
        const chartH = 122;
        const left = 26;
        const step = 48;

        for (let i = 0; i < 4; i += 1) {
          const y = baseY - (chartH / 3) * i;
          const line = svgEl("line", {
            x1: left - 8,
            y1: y,
            x2: W - 12,
            y2: y,
            stroke: "var(--border)",
            "stroke-width": 1
          });
          els.barChart.appendChild(line);
        }

        values.forEach((val, idx) => {
          const x = left + idx * step;
          const h = Math.max(4, (val / maxVal) * chartH);
          const y = baseY - h;

          const bar = svgEl("rect", {
            x,
            y,
            width: 30,
            height: h,
            rx: 8,
            fill: "url(#barGrad)"
          });
          els.barChart.appendChild(bar);

          const dayLabel = new Date(days[idx] + "T00:00:00").toLocaleDateString([], { weekday: "short" }).slice(0, 2);
          const label = svgEl("text", {
            x: x + 15,
            y: 178,
            "text-anchor": "middle",
            "font-size": "11",
            fill: "var(--muted)",
            "font-weight": "700"
          });
          label.textContent = dayLabel;
          els.barChart.appendChild(label);

          const v = svgEl("text", {
            x: x + 15,
            y: y - 6,
            "text-anchor": "middle",
            "font-size": "10",
            fill: "var(--text)"
          });
          v.textContent = String(val);
          els.barChart.appendChild(v);
        });

        const defs = svgEl("defs", {});
        const grad = svgEl("linearGradient", { id: "barGrad", x1: "0", y1: "0", x2: "0", y2: "1" });
        grad.appendChild(svgEl("stop", { offset: "0%", "stop-color": "var(--accent-3)" }));
        grad.appendChild(svgEl("stop", { offset: "100%", "stop-color": "var(--accent)" }));
        defs.appendChild(grad);
        els.barChart.appendChild(defs);
      }

      function renderDonutChart() {
        clearSvg(els.donutChart);

        const sums = { focus: 0, short: 0, long: 0 };
        state.log.forEach((entry) => {
          sums[entry.type] += entry.durationMin;
        });

        const values = [sums.focus, sums.short, sums.long];
        const labels = ["Focus", "Short", "Long"];
        const colors = ["var(--accent)", "var(--accent-3)", "#7f84ff"];
        const total = values.reduce((a, b) => a + b, 0);

        if (!total) {
          const t = svgEl("text", {
            x: 190,
            y: 98,
            "text-anchor": "middle",
            "font-size": "14",
            fill: "var(--muted)",
            "font-weight": "700"
          });
          t.textContent = "Complete sessions to see mix";
          els.donutChart.appendChild(t);
          return;
        }

        const cx = 110;
        const cy = 95;
        const r = 54;
        const stroke = 22;

        let start = -Math.PI / 2;
        values.forEach((v, i) => {
          if (!v) return;
          const angle = (v / total) * Math.PI * 2;
          const end = start + angle;
          const path = donutArcPath(cx, cy, r, start, end);
          const arc = svgEl("path", {
            d: path,
            fill: "none",
            stroke: colors[i],
            "stroke-width": stroke,
            "stroke-linecap": "round"
          });
          els.donutChart.appendChild(arc);
          start = end;
        });

        const centerTop = svgEl("text", {
          x: cx,
          y: cy - 3,
          "text-anchor": "middle",
          "font-size": "11",
          fill: "var(--muted)",
          "font-weight": "700"
        });
        centerTop.textContent = "TOTAL";

        const centerVal = svgEl("text", {
          x: cx,
          y: cy + 18,
          "text-anchor": "middle",
          "font-size": "22",
          fill: "var(--text)",
          "font-weight": "800"
        });
        centerVal.textContent = `${total}m`;

        els.donutChart.appendChild(centerTop);
        els.donutChart.appendChild(centerVal);

        labels.forEach((label, i) => {
          const rowY = 52 + i * 36;
          const dot = svgEl("circle", { cx: 230, cy: rowY - 5, r: 5, fill: colors[i] });
          const txt = svgEl("text", {
            x: 242,
            y: rowY,
            "font-size": "13",
            fill: "var(--text)",
            "font-weight": "700"
          });
          txt.textContent = `${label} ${values[i]}m`;
          els.donutChart.appendChild(dot);
          els.donutChart.appendChild(txt);
        });
      }

      function renderFooterStats() {
        const totalFocus = state.log.filter((x) => x.type === "focus").reduce((a, b) => a + b.durationMin, 0);
        const totalSessions = state.log.length;
        const streak = calcFocusDayStreak(state.log);

        els.footerStats.innerHTML = `
          <span><i class="dot" style="background:var(--accent);"></i>Total focus: <strong>${totalFocus}m</strong></span>
          <span><i class="dot" style="background:var(--accent-3);"></i>Sessions: <strong>${totalSessions}</strong></span>
          <span><i class="dot" style="background:var(--good);"></i>Day streak: <strong>${streak}</strong></span>
        `;
      }

      function applyTheme(dark) {
        document.body.classList.toggle("dark", !!dark);
      }

      function getPhaseDurationSeconds(phase) {
        return (state.durations[phase] || 1) * 60;
      }

      function phaseText(phase) {
        if (phase === "focus") return "Focus";
        if (phase === "short") return "Short Break";
        return "Long Break";
      }

      function formatTime(sec) {
        const s = Math.max(0, sec);
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
      }

      function clampInt(raw, min, max, fallback) {
        const n = Math.round(Number(raw));
        if (!Number.isFinite(n)) return fallback;
        return Math.max(min, Math.min(max, n));
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return { ...defaults };
          const parsed = JSON.parse(raw);
          return {
            ...defaults,
            ...parsed,
            durations: { ...defaults.durations, ...(parsed.durations || {}) },
            log: Array.isArray(parsed.log) ? parsed.log : []
          };
        } catch (e) {
          return { ...defaults };
        }
      }

      function saveState() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      function beep() {
        try {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (!Ctx) return;
          const ctx = new Ctx();
          const now = ctx.currentTime;
          [0, 0.15, 0.3].forEach((offset, i) => {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = "sine";
            osc.frequency.value = i === 2 ? 960 : 820;
            gain.gain.setValueAtTime(0.0001, now + offset);
            gain.gain.exponentialRampToValueAtTime(0.2, now + offset + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + offset + 0.12);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(now + offset);
            osc.stop(now + offset + 0.13);
          });
          setTimeout(() => ctx.close(), 700);
        } catch (e) {
          // Silently ignore audio failures.
        }
      }

      function dateKeyOf(d) {
        return new Date(d).toISOString().slice(0, 10);
      }

      function lastNDays(n) {
        const out = [];
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        for (let i = n - 1; i >= 0; i -= 1) {
          const d = new Date(today);
          d.setDate(today.getDate() - i);
          out.push(dateKeyOf(d));
        }
        return out;
      }

      function calcFocusDayStreak(log) {
        const focusDays = new Set(log.filter((x) => x.type === "focus").map((x) => x.dateKey));
        let streak = 0;
        const cursor = new Date();
        cursor.setHours(0, 0, 0, 0);
        while (focusDays.has(dateKeyOf(cursor))) {
          streak += 1;
          cursor.setDate(cursor.getDate() - 1);
        }
        return streak;
      }

      function clearSvg(svg) {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
      }

      function svgEl(tag, attrs) {
        const el = document.createElementNS(SVG_NS, tag);
        Object.keys(attrs).forEach((k) => el.setAttribute(k, String(attrs[k])));
        return el;
      }

      function donutArcPath(cx, cy, r, startAngle, endAngle) {
        const sx = cx + r * Math.cos(startAngle);
        const sy = cy + r * Math.sin(startAngle);
        const ex = cx + r * Math.cos(endAngle);
        const ey = cy + r * Math.sin(endAngle);
        const largeArc = endAngle - startAngle > Math.PI ? 1 : 0;
        return `M ${sx} ${sy} A ${r} ${r} 0 ${largeArc} 1 ${ex} ${ey}`;
      }

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      window.addEventListener("beforeunload", saveState);
      window.addEventListener("visibilitychange", () => {
        if (document.hidden) saveState();
      });
    })();
  </script>
</body>
</html>
