<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Webcam Filter Playground</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap');

    :root {
      --bg-0: #08111f;
      --bg-1: #0f1f36;
      --bg-2: #1d3154;
      --glass: rgba(255, 255, 255, 0.08);
      --glass-border: rgba(255, 255, 255, 0.2);
      --text: #e8f2ff;
      --muted: #b5c4da;
      --accent: #45f0ff;
      --accent-2: #ff4fd8;
      --ok: #58ff95;
      --warn: #ffd35f;
      --shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      --radius: 18px;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      font-family: 'Space Grotesk', 'Segoe UI', 'Helvetica Neue', sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 700px at 10% -20%, #284c86 0%, transparent 45%),
                  radial-gradient(900px 600px at 95% 10%, #4f1f62 0%, transparent 45%),
                  linear-gradient(140deg, var(--bg-0), var(--bg-1) 45%, var(--bg-2));
      overflow: hidden;
    }

    .grain::before {
      content: '';
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.09;
      background-image: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.4) 1px, transparent 1px);
      background-size: 3px 3px;
      mix-blend-mode: soft-light;
    }

    .app {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 24px;
      position: relative;
      z-index: 1;
    }

    .shell {
      width: min(960px, 100%);
      display: grid;
      gap: 14px;
      animation: rise 700ms ease;
    }

    @keyframes rise {
      from { transform: translateY(18px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .title {
      margin: 0;
      font-size: clamp(1.2rem, 2.4vw, 1.9rem);
      letter-spacing: 0.02em;
    }

    .status {
      font-size: 0.86rem;
      color: var(--muted);
      padding: 8px 12px;
      border-radius: 999px;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(8px);
      white-space: nowrap;
    }

    .preview-wrap {
      position: relative;
      border-radius: calc(var(--radius) + 6px);
      overflow: hidden;
      border: 1px solid var(--glass-border);
      background: rgba(0,0,0,0.35);
      box-shadow: var(--shadow);
      aspect-ratio: 16 / 9;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #02060d;
    }

    .hud {
      position: absolute;
      left: 10px;
      top: 10px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.2);
      color: #d8ecff;
      font-size: 0.75rem;
      border-radius: 999px;
      padding: 5px 10px;
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 99px;
      background: var(--ok);
      box-shadow: 0 0 8px rgba(88,255,149,0.85);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(0.7); opacity: 0.55; }
    }

    .controls {
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 12px;
      backdrop-filter: blur(10px);
      display: grid;
      gap: 12px;
    }

    .effects {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 999px;
      font: inherit;
      font-size: 0.86rem;
      padding: 8px 12px;
      cursor: pointer;
      transition: 160ms ease;
    }

    .chip:hover {
      transform: translateY(-1px);
      border-color: rgba(255,255,255,0.45);
    }

    .chip.active {
      background: linear-gradient(120deg, rgba(69,240,255,0.22), rgba(255,79,216,0.22));
      border-color: rgba(149, 243, 255, 0.9);
      box-shadow: 0 0 0 1px rgba(69,240,255,0.25) inset;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }

    .label {
      color: var(--muted);
      font-size: 0.9rem;
      min-width: 70px;
    }

    input[type="range"] {
      flex: 1;
      min-width: 180px;
      accent-color: #73f7ff;
    }

    .val {
      min-width: 44px;
      text-align: right;
      font-size: 0.88rem;
      color: #e9fbff;
    }

    .btns {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn {
      font: inherit;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      padding: 9px 12px;
      cursor: pointer;
      transition: 160ms ease;
    }

    .btn:hover { transform: translateY(-1px); }
    .btn.primary {
      background: linear-gradient(120deg, rgba(69,240,255,0.3), rgba(255,79,216,0.28));
      border-color: rgba(255,255,255,0.45);
    }

    .strip {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 2px;
      scrollbar-width: thin;
    }

    .shot {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.25);
      flex: 0 0 auto;
      width: 120px;
      height: 68px;
      background: rgba(0,0,0,0.35);
    }

    .shot img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .empty {
      color: var(--muted);
      font-size: 0.85rem;
      padding: 6px 0;
    }

    video { display: none; }

    @media (max-width: 640px) {
      .app { padding: 10px; }
      .controls { padding: 10px; }
      .status { font-size: 0.76rem; }
    }
  </style>
</head>
<body class="grain">
  <main class="app">
    <section class="shell">
      <header class="head">
        <h1 class="title">Webcam Filter Playground</h1>
        <div id="status" class="status">Initializing camera...</div>
      </header>

      <div class="preview-wrap">
        <canvas id="preview" width="1280" height="720" aria-label="Live webcam preview"></canvas>
        <div class="hud"><span class="dot"></span><span id="hudText">LIVE · Clean</span></div>
      </div>

      <section class="controls">
        <div id="effects" class="effects" aria-label="Filter effects"></div>

        <div class="row">
          <span class="label">Intensity</span>
          <input id="intensity" type="range" min="0" max="100" value="55" />
          <span id="intensityVal" class="val">55%</span>
        </div>

        <div class="btns">
          <button id="captureBtn" class="btn primary">Capture Snapshot</button>
          <button id="saveBtn" class="btn">Save Current Frame</button>
          <button id="flipBtn" class="btn" title="Mirror webcam">Mirror: On</button>
        </div>

        <div id="strip" class="strip" aria-label="Snapshots"></div>
        <div id="empty" class="empty">No snapshots yet. Press <strong>Capture Snapshot</strong>.</div>
      </section>
    </section>
  </main>

  <video id="video" autoplay playsinline muted></video>

  <script>
    (() => {
      const effects = [
        { key: 'clean', name: 'Clean' },
        { key: 'vhs', name: 'VHS Drift' },
        { key: 'night', name: 'Night Vision' },
        { key: 'poster', name: 'Pop Poster' },
        { key: 'edge', name: 'Neon Edge' },
        { key: 'warp', name: 'Wave Warp' }
      ];

      const els = {
        video: document.getElementById('video'),
        canvas: document.getElementById('preview'),
        status: document.getElementById('status'),
        hudText: document.getElementById('hudText'),
        effects: document.getElementById('effects'),
        intensity: document.getElementById('intensity'),
        intensityVal: document.getElementById('intensityVal'),
        captureBtn: document.getElementById('captureBtn'),
        saveBtn: document.getElementById('saveBtn'),
        flipBtn: document.getElementById('flipBtn'),
        strip: document.getElementById('strip'),
        empty: document.getElementById('empty')
      };

      const ctx = els.canvas.getContext('2d', { willReadFrequently: true });
      const workA = document.createElement('canvas');
      const workB = document.createElement('canvas');
      const workCtxA = workA.getContext('2d', { willReadFrequently: true });
      const workCtxB = workB.getContext('2d', { willReadFrequently: true });

      let activeEffect = 'clean';
      let intensity = 0.55;
      let mirror = true;
      let running = false;
      let rafId = 0;
      let frame = 0;

      function setStatus(msg, tone = 'muted') {
        els.status.textContent = msg;
        els.status.style.color = tone === 'ok' ? '#e9ffef' : tone === 'warn' ? '#fff3c7' : 'var(--muted)';
        els.status.style.borderColor = tone === 'ok' ? 'rgba(88,255,149,0.65)' : tone === 'warn' ? 'rgba(255,211,95,0.65)' : 'var(--glass-border)';
      }

      function makeEffectChips() {
        const frag = document.createDocumentFragment();
        effects.forEach((effect) => {
          const btn = document.createElement('button');
          btn.className = 'chip' + (effect.key === activeEffect ? ' active' : '');
          btn.textContent = effect.name;
          btn.type = 'button';
          btn.dataset.effect = effect.key;
          btn.addEventListener('click', () => {
            activeEffect = effect.key;
            [...els.effects.children].forEach((el) => el.classList.toggle('active', el.dataset.effect === activeEffect));
            updateHud();
          });
          frag.appendChild(btn);
        });
        els.effects.appendChild(frag);
      }

      function updateHud() {
        const effectName = effects.find((e) => e.key === activeEffect)?.name || 'Clean';
        els.hudText.textContent = `LIVE · ${effectName}`;
      }

      function fitCanvases(w, h) {
        [els.canvas, workA, workB].forEach((c) => {
          c.width = w;
          c.height = h;
        });
      }

      function clamp(v) {
        return v < 0 ? 0 : v > 255 ? 255 : v;
      }

      function effectVhs(data, w, h, power) {
        const arr = data.data;
        const src = new Uint8ClampedArray(arr);
        const shift = Math.max(1, Math.floor(8 * power));
        const jitter = Math.floor((Math.sin(frame * 0.08) + Math.sin(frame * 0.021)) * 4 * power);

        for (let y = 0; y < h; y++) {
          const lineOffset = ((y + jitter) % h) * w;
          const scan = 1 - ((y % 3) * 0.06 + 0.12 * power);
          for (let x = 0; x < w; x++) {
            const i = (y * w + x) * 4;
            const rX = Math.min(w - 1, x + shift);
            const bX = Math.max(0, x - shift);
            const iR = (lineOffset + rX) * 4;
            const iB = (lineOffset + bX) * 4;
            arr[i] = src[iR] * scan;
            arr[i + 1] = src[i + 1] * (0.96 + Math.random() * 0.04);
            arr[i + 2] = src[iB + 2] * scan;
          }
        }
      }

      function effectNight(data, w, h, power) {
        const arr = data.data;
        const bloom = 35 + power * 80;

        for (let i = 0; i < arr.length; i += 4) {
          const r = arr[i], g = arr[i + 1], b = arr[i + 2];
          const lum = 0.3 * r + 0.59 * g + 0.11 * b;
          const noise = (Math.random() - 0.5) * 70 * power;
          arr[i] = clamp(lum * 0.08 + noise * 0.15);
          arr[i + 1] = clamp(lum + bloom + noise);
          arr[i + 2] = clamp(lum * 0.2 + noise * 0.2);
        }

        for (let y = 0; y < h; y += 2) {
          const row = y * w * 4;
          for (let x = 0; x < w; x++) {
            const i = row + x * 4;
            arr[i + 1] = clamp(arr[i + 1] * (0.75 + 0.25 * (1 - power)));
          }
        }
      }

      function effectPoster(data, w, h, power) {
        const arr = data.data;
        const levels = Math.max(2, 8 - Math.floor(power * 5));
        const step = 255 / (levels - 1);

        for (let i = 0; i < arr.length; i += 4) {
          const r = Math.round(arr[i] / step) * step;
          const g = Math.round(arr[i + 1] / step) * step;
          const b = Math.round(arr[i + 2] / step) * step;

          const mix = 0.4 + power * 0.6;
          arr[i] = clamp(r * mix + arr[i] * (1 - mix));
          arr[i + 1] = clamp(g * mix + arr[i + 1] * (1 - mix));
          arr[i + 2] = clamp(b * mix + arr[i + 2] * (1 - mix));
        }

        const dots = Math.max(6, Math.floor(18 - power * 12));
        for (let y = 0; y < h; y += dots) {
          for (let x = 0; x < w; x += dots) {
            const i = (y * w + x) * 4;
            const lum = (arr[i] + arr[i + 1] + arr[i + 2]) / 3;
            const radius = ((255 - lum) / 255) * (dots * 0.45);
            if (radius > 1.2) {
              for (let yy = -radius; yy <= radius; yy++) {
                const py = y + yy;
                if (py < 0 || py >= h) continue;
                for (let xx = -radius; xx <= radius; xx++) {
                  const px = x + xx;
                  if (px < 0 || px >= w) continue;
                  if (xx * xx + yy * yy > radius * radius) continue;
                  const p = (py * w + px) * 4;
                  arr[p] = clamp(arr[p] * 0.72);
                  arr[p + 1] = clamp(arr[p + 1] * 0.72);
                  arr[p + 2] = clamp(arr[p + 2] * 0.72);
                }
              }
            }
          }
        }
      }

      function effectEdge(data, w, h, power) {
        const arr = data.data;
        const src = new Uint8ClampedArray(arr);
        const t = 120 - power * 70;

        for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
            const i = (y * w + x) * 4;
            const getLum = (xx, yy) => {
              const p = (yy * w + xx) * 4;
              return (src[p] + src[p + 1] + src[p + 2]) / 3;
            };

            const gx =
              -getLum(x - 1, y - 1) - 2 * getLum(x - 1, y) - getLum(x - 1, y + 1) +
              getLum(x + 1, y - 1) + 2 * getLum(x + 1, y) + getLum(x + 1, y + 1);
            const gy =
              -getLum(x - 1, y - 1) - 2 * getLum(x, y - 1) - getLum(x + 1, y - 1) +
              getLum(x - 1, y + 1) + 2 * getLum(x, y + 1) + getLum(x + 1, y + 1);

            const mag = Math.sqrt(gx * gx + gy * gy);
            const glow = mag > t ? mag : 0;

            arr[i] = clamp(glow * 0.45 + src[i] * 0.2);
            arr[i + 1] = clamp(glow * 0.95 + src[i + 1] * 0.15);
            arr[i + 2] = clamp(glow * 1.4 + src[i + 2] * 0.22);
          }
        }
      }

      function effectWarp(srcData, dstData, w, h, power) {
        const src = srcData.data;
        const dst = dstData.data;
        const amp = 8 + power * 40;
        const f = 0.012 + power * 0.02;

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const dx = Math.round(x + Math.sin(y * f + frame * 0.06) * amp);
            const dy = Math.round(y + Math.cos(x * f * 0.9 + frame * 0.04) * amp * 0.6);
            const sx = Math.max(0, Math.min(w - 1, dx));
            const sy = Math.max(0, Math.min(h - 1, dy));
            const s = (sy * w + sx) * 4;
            const d = (y * w + x) * 4;
            dst[d] = src[s];
            dst[d + 1] = src[s + 1];
            dst[d + 2] = src[s + 2];
            dst[d + 3] = 255;
          }
        }
      }

      function render() {
        if (!running) return;
        frame++;

        const w = workA.width;
        const h = workA.height;

        if (mirror) {
          workCtxA.save();
          workCtxA.scale(-1, 1);
          workCtxA.drawImage(els.video, -w, 0, w, h);
          workCtxA.restore();
        } else {
          workCtxA.drawImage(els.video, 0, 0, w, h);
        }

        if (activeEffect === 'warp') {
          const src = workCtxA.getImageData(0, 0, w, h);
          const out = workCtxB.createImageData(w, h);
          effectWarp(src, out, w, h, intensity);
          ctx.putImageData(out, 0, 0);
        } else {
          const img = workCtxA.getImageData(0, 0, w, h);
          if (activeEffect === 'vhs') effectVhs(img, w, h, intensity);
          if (activeEffect === 'night') effectNight(img, w, h, intensity);
          if (activeEffect === 'poster') effectPoster(img, w, h, intensity);
          if (activeEffect === 'edge') effectEdge(img, w, h, intensity);
          ctx.putImageData(img, 0, 0);
        }

        rafId = requestAnimationFrame(render);
      }

      function snapshotDataURL() {
        return els.canvas.toDataURL('image/png');
      }

      function captureSnapshot() {
        const url = snapshotDataURL();
        const card = document.createElement('div');
        card.className = 'shot';

        const img = document.createElement('img');
        img.src = url;
        img.alt = 'Snapshot';

        card.appendChild(img);
        els.strip.prepend(card);
        els.empty.style.display = 'none';
      }

      function saveCurrentFrame() {
        const a = document.createElement('a');
        const stamp = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = snapshotDataURL();
        a.download = `webcam-filter-${activeEffect}-${stamp}.png`;
        a.click();
      }

      function bindUI() {
        els.intensity.addEventListener('input', () => {
          intensity = Number(els.intensity.value) / 100;
          els.intensityVal.textContent = `${els.intensity.value}%`;
        });

        els.captureBtn.addEventListener('click', captureSnapshot);
        els.saveBtn.addEventListener('click', saveCurrentFrame);

        els.flipBtn.addEventListener('click', () => {
          mirror = !mirror;
          els.flipBtn.textContent = `Mirror: ${mirror ? 'On' : 'Off'}`;
        });

        window.addEventListener('keydown', (e) => {
          if (e.code === 'Space') {
            e.preventDefault();
            captureSnapshot();
          }
        });
      }

      async function initCamera() {
        try {
          setStatus('Requesting webcam access...', 'warn');
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'user',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            },
            audio: false
          });

          els.video.srcObject = stream;
          await els.video.play();

          const w = Math.max(640, els.video.videoWidth || 1280);
          const h = Math.max(360, els.video.videoHeight || 720);
          fitCanvases(w, h);

          running = true;
          setStatus('Camera live. Choose an effect.', 'ok');
          updateHud();
          render();
        } catch (err) {
          console.warn('Webcam initialization failed:', err);
          setStatus('Camera blocked. Allow webcam and refresh.', 'warn');

          ctx.fillStyle = '#02060d';
          ctx.fillRect(0, 0, els.canvas.width, els.canvas.height);
          ctx.fillStyle = '#cfe0ff';
          ctx.font = '600 28px Space Grotesk, sans-serif';
          ctx.fillText('Webcam unavailable', 40, 80);
          ctx.font = '500 18px Space Grotesk, sans-serif';
          ctx.fillStyle = '#9fb5d8';
          ctx.fillText('Enable camera permissions to start the playground.', 40, 116);
        }
      }

      window.addEventListener('beforeunload', () => {
        running = false;
        if (rafId) cancelAnimationFrame(rafId);
        const stream = els.video.srcObject;
        if (stream && stream.getTracks) {
          stream.getTracks().forEach((t) => t.stop());
        }
      });

      makeEffectChips();
      bindUI();
      initCamera();
    })();
  </script>
</body>
</html>
