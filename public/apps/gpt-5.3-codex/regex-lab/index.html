<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Regex Lab</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #121b2e;
      --panel-2: #0f1728;
      --text: #dce7ff;
      --muted: #8ea0c8;
      --line: #23304e;
      --accent: #5dd6ff;
      --ok: #65f2ae;
      --warn: #ffd06e;
      --err: #ff7b9b;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --token: #c8f2ff;
    }

    body.light {
      --bg: #f3f7ff;
      --panel: #ffffff;
      --panel-2: #f9fbff;
      --text: #11213d;
      --muted: #4a5f87;
      --line: #cfdaee;
      --accent: #006be6;
      --ok: #007c44;
      --warn: #946100;
      --err: #be1743;
      --shadow: 0 10px 26px rgba(13, 32, 74, .12);
      --token: #09386f;
    }

    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; }
    body {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background:
        radial-gradient(1000px 450px at 80% -10%, rgba(93,214,255,.18), transparent 70%),
        radial-gradient(800px 400px at 0% 120%, rgba(136,255,185,.14), transparent 72%),
        var(--bg);
      color: var(--text);
      min-height: 100%;
      padding: 18px;
    }

    .window {
      max-width: 1200px;
      margin: 0 auto;
      border: 1px solid var(--line);
      border-radius: 14px;
      overflow: hidden;
      box-shadow: var(--shadow);
      background: var(--panel);
    }

    .titlebar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: linear-gradient(180deg, color-mix(in oklab, var(--panel), #000 10%), var(--panel-2));
      border-bottom: 1px solid var(--line);
      gap: 12px;
    }

    .dots { display: flex; gap: 8px; }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      opacity: .9;
    }
    .dot.r { background: #ff6f7f; }
    .dot.y { background: #ffc566; }
    .dot.g { background: #63dc95; }

    .brand {
      font-weight: 700;
      letter-spacing: .04em;
      color: var(--token);
      text-transform: uppercase;
      font-size: 13px;
    }

    .title-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    button, .mini-input {
      border: 1px solid var(--line);
      background: color-mix(in oklab, var(--panel), #000 8%);
      color: var(--text);
      border-radius: 8px;
      padding: 7px 10px;
      font: inherit;
      font-size: 12px;
      cursor: pointer;
      transition: .15s ease;
    }

    button:hover { border-color: color-mix(in oklab, var(--accent), var(--line) 45%); }
    button:active { transform: translateY(1px); }
    button.primary {
      background: color-mix(in oklab, var(--accent), #111 70%);
      border-color: color-mix(in oklab, var(--accent), #000 30%);
      color: #eaf8ff;
    }

    .content {
      display: grid;
      gap: 12px;
      padding: 14px;
      grid-template-columns: 1fr;
    }

    .panel {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: linear-gradient(180deg, color-mix(in oklab, var(--panel), #fff 1%), var(--panel-2));
      overflow: hidden;
    }

    .panel h2 {
      margin: 0;
      padding: 10px 12px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--muted);
      border-bottom: 1px solid var(--line);
      background: color-mix(in oklab, var(--panel), #000 8%);
    }

    .panel-inner { padding: 12px; }

    .row {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr auto;
      align-items: end;
    }

    .regex-input-wrap {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr;
    }

    label {
      display: block;
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 5px;
      letter-spacing: .03em;
      text-transform: uppercase;
    }

    input[type="text"], textarea {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: color-mix(in oklab, var(--panel), #000 12%);
      color: var(--text);
      padding: 9px 10px;
      font: inherit;
      font-size: 14px;
      line-height: 1.45;
      outline: none;
    }

    input[type="text"]:focus, textarea:focus {
      border-color: color-mix(in oklab, var(--accent), var(--line) 30%);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent), transparent 84%);
    }

    textarea { min-height: 180px; resize: vertical; }

    .flags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 8px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: color-mix(in oklab, var(--panel), #000 10%);
      min-width: 225px;
    }

    .flag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 6px;
      border-radius: 6px;
      background: color-mix(in oklab, var(--panel), #000 6%);
      border: 1px solid color-mix(in oklab, var(--line), transparent 20%);
      color: var(--muted);
      font-size: 12px;
      text-transform: none;
      margin: 0;
    }

    .flag input { accent-color: var(--accent); }

    .token-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .token-grid button {
      padding: 5px 8px;
      font-size: 12px;
      border-radius: 6px;
    }

    .status {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .status .ok { color: var(--ok); }
    .status .err { color: var(--err); }

    .split {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }

    .highlight {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 10px;
      min-height: 180px;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      background: color-mix(in oklab, var(--panel), #000 12%);
      line-height: 1.45;
    }

    .seg { border-radius: 3px; padding: 0 1px; }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
      font-size: 11px;
      color: var(--muted);
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: color-mix(in oklab, var(--panel), #000 6%);
    }

    .swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,.18);
      display: inline-block;
    }

    .table-wrap {
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 8px;
      max-height: 300px;
      background: color-mix(in oklab, var(--panel), #000 10%);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    th, td {
      text-align: left;
      border-bottom: 1px solid color-mix(in oklab, var(--line), transparent 25%);
      padding: 8px;
      vertical-align: top;
    }

    th {
      color: var(--muted);
      position: sticky;
      top: 0;
      background: color-mix(in oklab, var(--panel), #000 12%);
      z-index: 1;
    }

    .mono { font-family: inherit; }
    .muted { color: var(--muted); }

    .explain {
      border: 1px solid var(--line);
      border-radius: 8px;
      background: color-mix(in oklab, var(--panel), #000 12%);
      overflow: hidden;
    }

    .exp-item {
      padding: 8px 10px;
      border-bottom: 1px solid color-mix(in oklab, var(--line), transparent 30%);
      font-size: 12px;
      display: grid;
      grid-template-columns: minmax(60px, 160px) 1fr;
      gap: 10px;
    }

    .exp-item:last-child { border-bottom: 0; }
    .tok {
      color: var(--token);
      word-break: break-all;
    }

    .error-box {
      margin-top: 8px;
      border: 1px solid color-mix(in oklab, var(--err), transparent 35%);
      border-radius: 8px;
      padding: 8px 10px;
      background: color-mix(in oklab, var(--err), transparent 88%);
      color: var(--err);
      font-size: 12px;
      white-space: pre-wrap;
    }

    @media (min-width: 940px) {
      .content { grid-template-columns: 1.15fr 1fr; }
      .panel.input { grid-column: 1 / span 2; }
      .split { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <div class="window">
    <div class="titlebar">
      <div style="display:flex; align-items:center; gap:10px;">
        <div class="dots" aria-hidden="true">
          <span class="dot r"></span><span class="dot y"></span><span class="dot g"></span>
        </div>
        <div class="brand">Regex Lab</div>
      </div>
      <div class="title-actions">
        <button id="themeToggle" title="Toggle light/dark">Light Mode</button>
        <button id="copyLink" class="primary">Copy Share Link</button>
        <button id="clearBtn">Clear</button>
      </div>
    </div>

    <div class="content">
      <section class="panel input">
        <h2>Input</h2>
        <div class="panel-inner">
          <div class="row">
            <div class="regex-input-wrap">
              <div>
                <label for="pattern">Pattern</label>
                <input id="pattern" type="text" placeholder="e.g. (\\w+)@(\\w+\\.\\w+)" spellcheck="false" />
              </div>
            </div>
            <div>
              <label>Flags</label>
              <div class="flags" id="flagsWrap"></div>
            </div>
          </div>

          <div style="margin-top:10px;">
            <label for="testText">Test Text</label>
            <textarea id="testText" spellcheck="false" placeholder="Paste or type text here..."></textarea>
          </div>

          <div style="margin-top:10px;">
            <label>Quick Inserts</label>
            <div class="token-grid" id="tokenGrid"></div>
          </div>

          <div id="status" class="status"></div>
          <div id="errorBox" class="error-box" hidden></div>
        </div>
      </section>

      <section class="panel">
        <h2>Highlighted Matches</h2>
        <div class="panel-inner">
          <div id="highlight" class="highlight"></div>
          <div id="legend" class="legend"></div>
        </div>
      </section>

      <section class="panel">
        <h2>Pattern Explanation</h2>
        <div class="panel-inner">
          <div id="explain" class="explain"></div>
        </div>
      </section>

      <section class="panel" style="grid-column: 1 / -1;">
        <h2>Matches Table</h2>
        <div class="panel-inner">
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th>#</th>
                  <th>Match</th>
                  <th>Index</th>
                  <th>Capture Groups</th>
                </tr>
              </thead>
              <tbody id="matchesBody"></tbody>
            </table>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const SUPPORTS_INDICES = (() => {
      try {
        const m = /a/d.exec('a');
        return !!(m && m.indices);
      } catch {
        return false;
      }
    })();

    const FLAG_SET = ['g', 'i', 'm', 's', 'u', 'y'];
    const GROUP_COLORS = [
      '#7bdff2', '#ff8fab', '#ffd166', '#90f1b8', '#c9a4ff', '#ffb570', '#9ad8ff', '#a8ff95'
    ];
    const MATCH_COLORS = [
      'rgba(93, 214, 255, .23)', 'rgba(255, 150, 108, .24)', 'rgba(181, 255, 117, .20)', 'rgba(191, 141, 255, .20)'
    ];

    const QUICK_TOKENS = [
      ['\\d', '\\d'], ['\\w', '\\w'], ['\\s', '\\s'],
      ['[A-Z]', '[A-Z]'], ['[a-z]', '[a-z]'], ['[0-9]', '[0-9]'],
      ['^', '^'], ['$', '$'], ['.', '.'], ['+', '+'], ['*', '*'], ['?', '?'],
      ['( )', '()'], ['(?: )', '(?:)'], ['(?<name> )', '(?<name>)'],
      ['(?= )', '(?=)'], ['(?! )', '(?!)'], ['(?<= )', '(?<=)'], ['(?<! )', '(?<!)'],
      ['|', '|'], ['{m,n}', '{1,3}'], ['\\b', '\\b']
    ];

    const el = {
      pattern: document.getElementById('pattern'),
      testText: document.getElementById('testText'),
      flagsWrap: document.getElementById('flagsWrap'),
      tokenGrid: document.getElementById('tokenGrid'),
      status: document.getElementById('status'),
      highlight: document.getElementById('highlight'),
      legend: document.getElementById('legend'),
      matchesBody: document.getElementById('matchesBody'),
      explain: document.getElementById('explain'),
      errorBox: document.getElementById('errorBox'),
      copyLink: document.getElementById('copyLink'),
      clearBtn: document.getElementById('clearBtn'),
      themeToggle: document.getElementById('themeToggle')
    };

    function escapeHtml(s) {
      return s
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function selectedFlags() {
      return [...el.flagsWrap.querySelectorAll('input[type="checkbox"]:checked')]
        .map(n => n.value)
        .join('');
    }

    function setFlags(flagString) {
      const has = new Set((flagString || '').split(''));
      for (const cb of el.flagsWrap.querySelectorAll('input[type="checkbox"]')) {
        cb.checked = has.has(cb.value);
      }
    }

    function renderFlags() {
      el.flagsWrap.innerHTML = '';
      for (const f of FLAG_SET) {
        const label = document.createElement('label');
        label.className = 'flag';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = f;
        cb.addEventListener('change', updateAll);
        label.appendChild(cb);
        label.append(document.createTextNode(f));
        el.flagsWrap.appendChild(label);
      }
    }

    function renderQuickTokens() {
      el.tokenGrid.innerHTML = '';
      QUICK_TOKENS.forEach(([label, token]) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.textContent = label;
        b.addEventListener('click', () => insertPatternToken(token));
        el.tokenGrid.appendChild(b);
      });
    }

    function insertPatternToken(token) {
      const input = el.pattern;
      const start = input.selectionStart ?? input.value.length;
      const end = input.selectionEnd ?? input.value.length;
      input.value = input.value.slice(0, start) + token + input.value.slice(end);
      const cursorInside = token.endsWith(')') && token.includes('(') ? start + token.length - 1 : start + token.length;
      input.focus();
      input.setSelectionRange(cursorInside, cursorInside);
      updateAll();
    }

    function buildRegex(pattern, flags, forExec = false) {
      const uniqueFlags = [...new Set((flags || '').split('').filter(f => FLAG_SET.includes(f)))].join('');
      let compileFlags = uniqueFlags;
      if (forExec && SUPPORTS_INDICES && !compileFlags.includes('d')) compileFlags += 'd';
      return new RegExp(pattern, compileFlags);
    }

    function getErrorPosition(message) {
      const m = String(message).match(/position\s+(\d+)/i);
      return m ? Number(m[1]) : null;
    }

    function getCaretSnippet(pattern, pos) {
      if (pos == null || Number.isNaN(pos)) return '';
      return `${pattern}\n${' '.repeat(Math.max(0, pos))}^`;
    }

    function computeMatches(regex, text, flags) {
      const out = [];
      if (flags.includes('g') || flags.includes('y')) {
        let m;
        const limit = 2000;
        while ((m = regex.exec(text)) && out.length < limit) {
          out.push(m);
          if (m[0] === '') regex.lastIndex += 1;
        }
      } else {
        const m = regex.exec(text);
        if (m) out.push(m);
      }
      return out;
    }

    function buildRanges(matches) {
      const ranges = [];
      matches.forEach((m, mi) => {
        const start = m.index;
        const end = start + m[0].length;
        ranges.push({ start, end, kind: 'match', matchIdx: mi, groupIdx: 0 });

        if (m.indices && m.indices.length > 1) {
          for (let gi = 1; gi < m.indices.length; gi++) {
            const pair = m.indices[gi];
            if (!pair || pair[0] === -1) continue;
            const [gs, ge] = pair;
            if (ge > gs) ranges.push({ start: gs, end: ge, kind: 'group', matchIdx: mi, groupIdx: gi });
          }
        }
      });
      return ranges;
    }

    function styleForRange(r) {
      if (r.kind === 'group') {
        const color = GROUP_COLORS[(r.groupIdx - 1) % GROUP_COLORS.length];
        return `background:${color}33;border-bottom:2px solid ${color};`;
      }
      const color = MATCH_COLORS[r.matchIdx % MATCH_COLORS.length];
      return `background:${color};`;
    }

    function pickTopRange(active) {
      if (!active.length) return null;
      const groups = active.filter(r => r.kind === 'group');
      if (groups.length) {
        groups.sort((a, b) => {
          const lenA = a.end - a.start;
          const lenB = b.end - b.start;
          return lenA - lenB || a.groupIdx - b.groupIdx || a.matchIdx - b.matchIdx;
        });
        return groups[0];
      }
      return active[0];
    }

    function renderHighlighted(text, matches) {
      if (!text) {
        el.highlight.textContent = '';
        el.legend.innerHTML = '<span class="muted">No test text.</span>';
        return;
      }

      const ranges = buildRanges(matches).filter(r => r.end > r.start);
      if (!ranges.length) {
        el.highlight.textContent = text;
        el.legend.innerHTML = '<span class="muted">No matches.</span>';
        return;
      }

      const points = new Set([0, text.length]);
      for (const r of ranges) {
        points.add(Math.max(0, Math.min(text.length, r.start)));
        points.add(Math.max(0, Math.min(text.length, r.end)));
      }
      const sorted = [...points].sort((a, b) => a - b);

      let html = '';
      for (let i = 0; i < sorted.length - 1; i++) {
        const s = sorted[i], e = sorted[i + 1];
        if (s === e) continue;
        const segment = text.slice(s, e);
        const active = ranges.filter(r => r.start < e && r.end > s);
        const chosen = pickTopRange(active);
        const safe = escapeHtml(segment);
        if (!chosen) {
          html += safe;
        } else {
          const label = chosen.kind === 'group'
            ? `Group ${chosen.groupIdx} | Match ${chosen.matchIdx + 1}`
            : `Match ${chosen.matchIdx + 1}`;
          html += `<span class="seg" style="${styleForRange(chosen)}" title="${escapeHtml(label)}">${safe}</span>`;
        }
      }
      el.highlight.innerHTML = html;

      const groupIds = [...new Set(ranges.filter(r => r.kind === 'group').map(r => r.groupIdx))].sort((a, b) => a - b);
      const chips = [
        `<span class="chip"><span class="swatch" style="background:${MATCH_COLORS[0]}"></span>Match</span>`
      ];
      for (const gi of groupIds.slice(0, 10)) {
        const c = GROUP_COLORS[(gi - 1) % GROUP_COLORS.length];
        chips.push(`<span class="chip"><span class="swatch" style="background:${c}55; border-color:${c}"></span>Group ${gi}</span>`);
      }
      if (groupIds.length > 10) chips.push('<span class="chip">more groups...</span>');
      el.legend.innerHTML = chips.join(' ');
    }

    function renderMatchesTable(matches) {
      if (!matches.length) {
        el.matchesBody.innerHTML = `<tr><td colspan="4" class="muted">No matches.</td></tr>`;
        return;
      }

      const rows = [];
      matches.slice(0, 500).forEach((m, idx) => {
        const groups = [];
        for (let i = 1; i < m.length; i++) {
          const val = m[i] == null ? '<span class="muted">&empty;</span>' : `<span class="mono">${escapeHtml(m[i])}</span>`;
          let pos = '';
          if (m.indices && m.indices[i] && m.indices[i][0] !== -1) {
            pos = ` <span class="muted">@ ${m.indices[i][0]}..${m.indices[i][1]}</span>`;
          }
          groups.push(`<div>${i}: ${val}${pos}</div>`);
        }
        rows.push(`
          <tr>
            <td>${idx + 1}</td>
            <td class="mono">${escapeHtml(m[0])}</td>
            <td>${m.index}</td>
            <td>${groups.length ? groups.join('') : '<span class="muted">(none)</span>'}</td>
          </tr>
        `);
      });

      if (matches.length > 500) {
        rows.push(`<tr><td colspan="4" class="muted">Showing first 500 of ${matches.length} matches.</td></tr>`);
      }

      el.matchesBody.innerHTML = rows.join('');
    }

    function explainPattern(pattern) {
      if (!pattern) return [{ tok: '(empty)', desc: 'No pattern entered yet.' }];
      const out = [];
      let i = 0;

      const push = (tok, desc) => out.push({ tok, desc });

      while (i < pattern.length) {
        const ch = pattern[i];

        if (ch === '\\') {
          const n = pattern[i + 1] || '';
          const tok = pattern.slice(i, i + 2);
          const map = {
            d: 'Digit (0-9)', D: 'Non-digit',
            w: 'Word char (letter, digit, _)', W: 'Non-word char',
            s: 'Whitespace char', S: 'Non-whitespace char',
            b: 'Word boundary', B: 'Non-word boundary',
            n: 'Line feed', r: 'Carriage return', t: 'Tab'
          };
          push(tok, map[n] || `Escaped literal '${n || '\\'}'`);
          i += 2;
          continue;
        }

        if (ch === '[') {
          let j = i + 1;
          let escaped = false;
          while (j < pattern.length) {
            const c = pattern[j];
            if (!escaped && c === ']') break;
            escaped = !escaped && c === '\\';
            if (c !== '\\') escaped = false;
            j++;
          }
          const tok = pattern.slice(i, Math.min(pattern.length, j + 1));
          push(tok, 'Character class: match one character from this set/range.');
          i = Math.min(pattern.length, j + 1);
          continue;
        }

        if (ch === '(') {
          const ahead = pattern.slice(i, i + 6);
          if (ahead.startsWith('(?:')) {
            push('(?:', 'Non-capturing group.');
            i += 3;
            continue;
          }
          if (ahead.startsWith('(?=')) { push('(?=', 'Positive lookahead.'); i += 3; continue; }
          if (ahead.startsWith('(?!')) { push('(?!', 'Negative lookahead.'); i += 3; continue; }
          if (ahead.startsWith('(?<=')) { push('(?<=', 'Positive lookbehind.'); i += 4; continue; }
          if (ahead.startsWith('(?<!')) { push('(?<!', 'Negative lookbehind.'); i += 4; continue; }
          if (ahead.startsWith('(?<')) {
            const end = pattern.indexOf('>', i + 3);
            if (end !== -1) {
              push(pattern.slice(i, end + 1), 'Named capturing group.');
              i = end + 1;
              continue;
            }
          }
          push('(', 'Capturing group start.');
          i++;
          continue;
        }

        if (ch === ')') { push(')', 'Group end.'); i++; continue; }
        if (ch === '^') { push('^', 'Start of line/input anchor.'); i++; continue; }
        if (ch === '$') { push('$', 'End of line/input anchor.'); i++; continue; }
        if (ch === '.') { push('.', 'Any character except line breaks (unless s flag).'); i++; continue; }
        if (ch === '|') { push('|', 'Alternation (OR).'); i++; continue; }

        if (ch === '*' || ch === '+' || ch === '?') {
          push(ch, ch === '*' ? '0 or more (greedy).' : ch === '+' ? '1 or more (greedy).' : '0 or 1 (optional, greedy).');
          i++;
          continue;
        }

        if (ch === '{') {
          const end = pattern.indexOf('}', i + 1);
          if (end !== -1) {
            const tok = pattern.slice(i, end + 1);
            push(tok, 'Quantifier: explicit repetition count/range.');
            i = end + 1;
            continue;
          }
        }

        push(ch, 'Literal character.');
        i++;
      }

      return out;
    }

    function renderExplanation(pattern) {
      const tokens = explainPattern(pattern).slice(0, 250);
      el.explain.innerHTML = tokens.map(t => `
        <div class="exp-item">
          <div class="tok">${escapeHtml(t.tok)}</div>
          <div>${escapeHtml(t.desc)}</div>
        </div>
      `).join('');
    }

    function updateStatus(ok, message, matchCount = null) {
      const bits = [];
      bits.push(`<span class="${ok ? 'ok' : 'err'}">${ok ? 'Pattern valid' : 'Pattern error'}</span>`);
      if (matchCount != null) bits.push(`<span>${matchCount} match${matchCount === 1 ? '' : 'es'}</span>`);
      if (message) bits.push(`<span class="muted">${escapeHtml(message)}</span>`);
      el.status.innerHTML = bits.join(' ');
    }

    function updateHash() {
      const p = new URLSearchParams();
      p.set('p', el.pattern.value);
      p.set('f', selectedFlags());
      p.set('t', el.testText.value);
      history.replaceState(null, '', '#' + p.toString());
    }

    function loadHash() {
      const raw = location.hash.startsWith('#') ? location.hash.slice(1) : '';
      if (!raw) {
        el.pattern.value = '(\\w+)';
        setFlags('g');
        el.testText.value = 'Try me: hello 123\\nEmail: jane@example.com';
        return;
      }
      const p = new URLSearchParams(raw);
      el.pattern.value = p.get('p') || '';
      setFlags(p.get('f') || '');
      el.testText.value = p.get('t') || '';
    }

    async function copyPermalink() {
      const url = location.href;
      try {
        await navigator.clipboard.writeText(url);
        updateStatus(true, 'Permalink copied to clipboard.');
      } catch {
        updateStatus(false, 'Clipboard failed. Copy URL from address bar.');
      }
    }

    function clearAll() {
      el.pattern.value = '';
      setFlags('');
      el.testText.value = '';
      updateAll();
      el.pattern.focus();
    }

    function updateAll() {
      const pattern = el.pattern.value;
      const flags = selectedFlags();
      const text = el.testText.value;

      el.errorBox.hidden = true;
      renderExplanation(pattern);

      try {
        const regex = buildRegex(pattern, flags, true);
        const matches = computeMatches(regex, text, flags);

        renderHighlighted(text, matches);
        renderMatchesTable(matches);
        updateStatus(true, '', matches.length);
      } catch (err) {
        const msg = err && err.message ? String(err.message) : 'Invalid pattern';
        const pos = getErrorPosition(msg);
        const caret = getCaretSnippet(pattern, pos);
        el.errorBox.hidden = false;
        el.errorBox.textContent = `${msg}${caret ? '\n\n' + caret : ''}`;

        el.highlight.textContent = text;
        el.legend.innerHTML = '<span class="muted">Fix pattern to highlight matches.</span>';
        el.matchesBody.innerHTML = `<tr><td colspan="4" class="muted">No results due to pattern error.</td></tr>`;
        updateStatus(false, msg);
      }

      updateHash();
    }

    function initTheme() {
      const stored = localStorage.getItem('regex-lab-theme');
      const dark = stored ? stored === 'dark' : true;
      document.body.classList.toggle('light', !dark);
      el.themeToggle.textContent = dark ? 'Light Mode' : 'Dark Mode';
    }

    function toggleTheme() {
      const isLight = document.body.classList.toggle('light');
      localStorage.setItem('regex-lab-theme', isLight ? 'light' : 'dark');
      el.themeToggle.textContent = isLight ? 'Dark Mode' : 'Light Mode';
    }

    function wireEvents() {
      el.pattern.addEventListener('input', updateAll);
      el.testText.addEventListener('input', updateAll);
      el.copyLink.addEventListener('click', copyPermalink);
      el.clearBtn.addEventListener('click', clearAll);
      el.themeToggle.addEventListener('click', toggleTheme);
      window.addEventListener('hashchange', () => {
        loadHash();
        updateAll();
      });
    }

    renderFlags();
    renderQuickTokens();
    initTheme();
    loadHash();
    wireEvents();
    updateAll();
  </script>
</body>
</html>
