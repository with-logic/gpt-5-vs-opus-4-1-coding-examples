<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kinetic Typography Studio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Playfair+Display:wght@400;700;900&family=Space+Grotesk:wght@300;400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <style>
    :root {
      --bg: #0c111d;
      --panel: #131b2c;
      --panel-2: #19243a;
      --text: #e8eefc;
      --muted: #9cb0d6;
      --line: #2a3858;
      --accent: #42e3b4;
      --accent-2: #5bc0ff;
      --danger: #ff5f6d;
      --safe: #6ee7a8;
      --font-ui: "Space Grotesk", "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      font-family: var(--font-ui);
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 90% -5%, #1f355f55, transparent),
        radial-gradient(1000px 600px at -10% 100%, #1d6f5d44, transparent),
        var(--bg);
      overflow: hidden;
    }

    .app {
      display: grid;
      grid-template-columns: 340px 1fr;
      height: 100%;
      gap: 12px;
      padding: 12px;
    }

    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--line);
      border-radius: 16px;
      overflow: auto;
      padding: 14px;
      scrollbar-width: thin;
    }

    .panel h1 {
      margin: 0 0 12px;
      font-size: 1.15rem;
      letter-spacing: 0.02em;
      font-weight: 700;
    }

    .group {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
      background: #10182a88;
    }

    .group h2 {
      margin: 0 0 8px;
      font-size: 0.84rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      font-weight: 700;
    }

    label { font-size: 0.82rem; color: var(--muted); display: block; margin-bottom: 5px; }
    input, select, button, textarea {
      width: 100%;
      background: #0c1424;
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 7px 9px;
      font-family: inherit;
      font-size: 0.88rem;
    }

    textarea { min-height: 72px; resize: vertical; }

    input[type="range"] { padding: 0; }
    input[type="checkbox"] { width: auto; transform: translateY(1px); }
    input[type="color"] { padding: 2px; height: 34px; }
    button {
      cursor: pointer;
      background: linear-gradient(135deg, #173154, #174e52);
      border-color: #2b557d;
      font-weight: 600;
    }
    button.secondary {
      background: linear-gradient(135deg, #2a2944, #2a304f);
      border-color: #4a4d78;
    }
    button.warn {
      background: linear-gradient(135deg, #54212a, #5b2d1f);
      border-color: #884439;
    }
    button:focus-visible, input:focus-visible, select:focus-visible, textarea:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px; }
    .inline { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
    .inline > * { flex: 1; }
    .inline.tight > *:first-child { flex: 0; }

    .main {
      min-width: 0;
      display: grid;
      grid-template-rows: 1fr 186px;
      gap: 12px;
    }

    .stage-wrap {
      position: relative;
      background: #0a0e17;
      border: 1px solid var(--line);
      border-radius: 16px;
      overflow: hidden;
      display: grid;
      place-items: center;
    }

    canvas#stage {
      max-width: 100%;
      max-height: 100%;
      touch-action: none;
      border-radius: 8px;
      background: #111;
      box-shadow: 0 10px 34px #00000077;
    }

    .status {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #0f1e2fdd;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 6px 9px;
      font-size: 0.75rem;
      color: #b6c4e7;
      backdrop-filter: blur(3px);
    }

    .timeline {
      background: linear-gradient(180deg, var(--panel), #111b2f);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px;
      overflow: hidden;
    }

    .timeline-top {
      display: grid;
      grid-template-columns: auto auto auto 1fr auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }

    .timebar-wrap { position: relative; height: 48px; }
    .timebar {
      appearance: none;
      width: 100%;
      margin: 16px 0;
      background: transparent;
      position: relative;
      z-index: 2;
    }
    .timebar::-webkit-slider-runnable-track { height: 4px; background: #273651; border-radius: 10px; }
    .timebar::-webkit-slider-thumb {
      appearance: none;
      margin-top: -6px;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0f1d2e;
    }
    .markers {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      pointer-events: none;
    }
    .marker {
      position: absolute;
      width: 2px;
      top: 10px;
      bottom: 14px;
      background: #6b7fa8;
      opacity: 0.7;
    }
    .marker.key { background: var(--accent); width: 3px; }
    .marker.beat { background: #ff8f42; opacity: 0.7; }
    .marker.bar { background: #ffd166; width: 2px; opacity: 0.9; }

    .chips { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 8px; }
    .chip {
      border: 1px solid #3b506f;
      border-radius: 999px;
      padding: 4px 9px;
      font-size: 0.75rem;
      background: #102039;
      cursor: pointer;
      user-select: none;
    }
    .chip.active { border-color: var(--accent); color: var(--accent); }

    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      background: #152843;
      border: 1px solid #38516f;
      border-bottom-width: 2px;
      padding: 2px 5px;
      border-radius: 5px;
      font-size: 0.72rem;
    }

    .small { font-size: 0.76rem; color: var(--muted); }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    @media (max-width: 1060px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto 1fr; overflow: auto; }
      .panel { max-height: 44vh; }
      .main { min-height: 64vh; }
    }

    @media (prefers-reduced-motion: reduce) {
      .status, .panel, .timeline { backdrop-filter: none !important; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="panel" aria-label="Control panel">
      <h1>Kinetic Typography Studio</h1>

      <section class="group">
        <h2>Text</h2>
        <label for="textInput">Content</label>
        <textarea id="textInput" aria-label="Text content">Kinetic\nTypography\nStudio</textarea>
        <div class="row">
          <div>
            <label for="fontFamily">Font</label>
            <select id="fontFamily" aria-label="Font picker">
              <option value="Space Grotesk">Space Grotesk</option>
              <option value="Bebas Neue">Bebas Neue</option>
              <option value="Playfair Display">Playfair Display</option>
              <option value="Georgia">Georgia</option>
              <option value="Times New Roman">Times New Roman</option>
              <option value="Arial">Arial</option>
              <option value="Verdana">Verdana</option>
              <option value="Trebuchet MS">Trebuchet MS</option>
              <option value="Courier New">Courier New</option>
            </select>
          </div>
          <div>
            <label for="fontSize">Size</label>
            <input id="fontSize" type="range" min="18" max="300" value="96" aria-label="Font size" />
          </div>
        </div>
        <div class="row3">
          <div>
            <label for="fontWeight">Weight</label>
            <input id="fontWeight" type="range" min="100" max="900" step="100" value="700" aria-label="Font weight" />
          </div>
          <div>
            <label for="italic"><span class="small">Italic</span></label>
            <div class="inline tight">
              <input id="italic" type="checkbox" aria-label="Italic toggle" />
            </div>
          </div>
          <div>
            <label for="tracking">Tracking</label>
            <input id="tracking" type="range" min="-10" max="40" step="0.2" value="0" aria-label="Tracking" />
          </div>
        </div>
      </section>

      <section class="group">
        <h2>Style</h2>
        <div class="row">
          <div>
            <label for="fillColor">Fill</label>
            <input id="fillColor" type="color" value="#ffffff" aria-label="Fill color" />
          </div>
          <div>
            <label for="strokeColor">Outline</label>
            <input id="strokeColor" type="color" value="#0e0f14" aria-label="Outline color" />
          </div>
        </div>
        <div class="row3">
          <div>
            <label for="strokeWidth">Outline px</label>
            <input id="strokeWidth" type="range" min="0" max="20" value="0" aria-label="Outline width" />
          </div>
          <div>
            <label for="shadowBlur">Shadow</label>
            <input id="shadowBlur" type="range" min="0" max="60" value="8" aria-label="Shadow blur" />
          </div>
          <div>
            <label for="shadowOpacity">Shadow Opacity</label>
            <input id="shadowOpacity" type="range" min="0" max="1" step="0.05" value="0.45" aria-label="Shadow opacity" />
          </div>
        </div>
        <div class="inline">
          <div>
            <label for="gradientMode">Gradient</label>
            <select id="gradientMode" aria-label="Gradient mode">
              <option value="none">None</option>
              <option value="linear">Linear</option>
              <option value="radial">Radial</option>
            </select>
          </div>
          <div>
            <label for="gradientA">A</label>
            <input id="gradientA" type="color" value="#7ef0ff" aria-label="Gradient color A" />
          </div>
          <div>
            <label for="gradientB">B</label>
            <input id="gradientB" type="color" value="#3c7bff" aria-label="Gradient color B" />
          </div>
        </div>
        <div class="inline tight">
          <input id="motionBlur" type="checkbox" aria-label="Motion blur toggle" />
          <label for="motionBlur" style="margin:0">Motion blur</label>
        </div>
      </section>

      <section class="group">
        <h2>Layout</h2>
        <div class="row3">
          <div>
            <label for="aspectPreset">Aspect</label>
            <select id="aspectPreset" aria-label="Aspect preset">
              <option value="16:9">16:9</option>
              <option value="9:16">9:16</option>
              <option value="1:1">1:1</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div>
            <label for="resW">Width</label>
            <input id="resW" type="number" value="1280" min="128" max="3840" aria-label="Resolution width" />
          </div>
          <div>
            <label for="resH">Height</label>
            <input id="resH" type="number" value="720" min="128" max="3840" aria-label="Resolution height" />
          </div>
        </div>
        <div class="row3">
          <div>
            <label for="margin">Margins</label>
            <input id="margin" type="range" min="0" max="200" value="48" aria-label="Safe margin" />
          </div>
          <div>
            <label for="gridSize">Grid px</label>
            <input id="gridSize" type="range" min="10" max="200" value="80" aria-label="Grid size" />
          </div>
          <div>
            <label for="bgColor">Background</label>
            <input id="bgColor" type="color" value="#10131f" aria-label="Background color" />
          </div>
        </div>
        <div class="inline tight">
          <input id="showGrid" type="checkbox" checked aria-label="Show grid" />
          <label for="showGrid" style="margin:0">Grid</label>
          <input id="showSafe" type="checkbox" checked aria-label="Show safe area" />
          <label for="showSafe" style="margin:0">Safe area</label>
        </div>
        <label for="bgImage">Background image</label>
        <input id="bgImage" type="file" accept="image/*" aria-label="Background image upload" />
      </section>

      <section class="group">
        <h2>Animation</h2>
        <div class="row3">
          <div>
            <label for="duration">Duration s</label>
            <input id="duration" type="number" value="5" min="0.5" max="60" step="0.1" aria-label="Animation duration" />
          </div>
          <div>
            <label for="fps">FPS</label>
            <input id="fps" type="number" value="30" min="12" max="120" step="1" aria-label="Frame rate" />
          </div>
          <div>
            <label for="stagger">Stagger ms</label>
            <input id="stagger" type="number" value="35" min="0" max="1000" step="5" aria-label="Glyph stagger" />
          </div>
        </div>

        <div class="row3">
          <div>
            <label for="glyphMode">Cascade mode</label>
            <select id="glyphMode" aria-label="Cascade mode">
              <option value="letter">Letter</option>
              <option value="word">Word</option>
              <option value="line">Line</option>
            </select>
          </div>
          <div>
            <label for="preset">Preset</label>
            <select id="preset" aria-label="Animation preset">
              <option value="none">None</option>
              <option value="typewriter">Typewriter</option>
              <option value="bounce">Bounce</option>
              <option value="liquid">Liquid</option>
              <option value="glitch">Glitch</option>
              <option value="fadeup">Fade-up</option>
              <option value="cascade">Cascade</option>
            </select>
          </div>
          <div>
            <label for="effectIntensity">Effect intensity</label>
            <input id="effectIntensity" type="range" min="0" max="2" step="0.05" value="1" aria-label="Effect intensity" />
          </div>
        </div>
        <div class="inline">
          <button id="applyPreset" aria-label="Apply preset">Apply preset</button>
          <button id="addKey" class="secondary" aria-label="Add keyframe">Add keyframe at playhead</button>
        </div>
      </section>

      <section class="group">
        <h2>Audio Reactive</h2>
        <label for="audioFile">Audio file</label>
        <input id="audioFile" type="file" accept="audio/*" aria-label="Audio file upload" />
        <div class="row3">
          <div>
            <label for="audioSensitivity">Sensitivity</label>
            <input id="audioSensitivity" type="range" min="0.8" max="2.2" step="0.05" value="1.25" aria-label="Beat detection sensitivity" />
          </div>
          <div>
            <label for="beatSnapMode">Snap target</label>
            <select id="beatSnapMode" aria-label="Snap mode">
              <option value="beat">Beats</option>
              <option value="bar">Bars</option>
            </select>
          </div>
          <div>
            <label for="audioReactive"><span class="small">Reactive</span></label>
            <div class="inline tight">
              <input id="audioReactive" type="checkbox" aria-label="Enable audio reactive mode" />
            </div>
          </div>
        </div>
        <div class="inline">
          <button id="detectBeats" class="secondary" aria-label="Detect beats">Detect beats</button>
          <button id="snapToBeats" class="secondary" aria-label="Snap keyframes to beats">Snap keyframes</button>
        </div>
        <div id="beatInfo" class="small">No audio loaded.</div>
      </section>

      <section class="group">
        <h2>Export</h2>
        <div class="row3">
          <div>
            <label for="exportType">Format</label>
            <select id="exportType" aria-label="Export format">
              <option value="webm">WebM</option>
              <option value="mp4">MP4*</option>
              <option value="gif">GIF</option>
              <option value="pngseq">PNG sequence ZIP</option>
            </select>
          </div>
          <div>
            <label for="exportFps">FPS</label>
            <input id="exportFps" type="number" min="10" max="120" value="30" aria-label="Export frame rate" />
          </div>
          <div>
            <label for="quality">Quality</label>
            <input id="quality" type="range" min="0.2" max="1" step="0.05" value="0.9" aria-label="Export quality" />
          </div>
        </div>
        <button id="exportBtn" aria-label="Export animation">Export</button>
        <div class="small">* MP4 depends on browser MediaRecorder codec support.</div>
      </section>

      <section class="group small" aria-label="Keyboard shortcuts">
        <h2>Shortcuts</h2>
        <div><span class="kbd">Space</span> Play/Pause</div>
        <div><span class="kbd">←</span>/<span class="kbd">→</span> Frame step</div>
        <div><span class="kbd">Ctrl/Cmd + K</span> Add keyframe</div>
        <div><span class="kbd">Ctrl/Cmd + E</span> Export</div>
      </section>
    </aside>

    <main class="main">
      <section class="stage-wrap" aria-label="Preview stage">
        <canvas id="stage" width="1280" height="720" aria-label="Animation canvas"></canvas>
        <div class="status" id="status">Idle</div>
      </section>

      <section class="timeline" aria-label="Timeline editor">
        <div class="timeline-top">
          <button id="playBtn" aria-label="Play or pause">Play</button>
          <button id="stopBtn" class="secondary" aria-label="Stop">Stop</button>
          <select id="activeProperty" aria-label="Animated property">
            <option value="x">Position X</option>
            <option value="y">Position Y</option>
            <option value="scale">Scale</option>
            <option value="rotation">Rotation</option>
            <option value="opacity">Opacity</option>
            <option value="tracking">Tracking</option>
            <option value="glyphOffset">Glyph offset</option>
          </select>
          <div class="chips" id="easingPresets" aria-label="Easing presets"></div>
          <button id="deleteKey" class="warn" aria-label="Delete nearest keyframe">Delete key</button>
        </div>

        <div class="row3">
          <div>
            <label for="keyValue">Key value</label>
            <input id="keyValue" type="number" step="0.1" aria-label="Keyframe value" />
          </div>
          <div>
            <label for="keyEase">Easing</label>
            <select id="keyEase" aria-label="Keyframe easing">
              <option value="linear">Linear</option>
              <option value="easeIn">Ease In</option>
              <option value="easeOut">Ease Out</option>
              <option value="easeInOut">Ease InOut</option>
              <option value="bounce">Bounce</option>
              <option value="steps">Steps</option>
              <option value="custom">Custom Bézier</option>
            </select>
          </div>
          <div>
            <label for="stepsCount">Steps</label>
            <input id="stepsCount" type="number" min="2" max="24" value="8" aria-label="Step count" />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="bezier1">Bézier P1 (x,y)</label>
            <input id="bezier1" value="0.25,0.1" aria-label="Bezier point one" />
          </div>
          <div>
            <label for="bezier2">Bézier P2 (x,y)</label>
            <input id="bezier2" value="0.25,1" aria-label="Bezier point two" />
          </div>
        </div>

        <div class="timebar-wrap">
          <input id="scrubber" class="timebar" type="range" min="0" max="5" value="0" step="0.001" aria-label="Timeline scrubber" />
          <div id="markers" class="markers" aria-hidden="true"></div>
        </div>
        <div class="small" id="timelineInfo">00:00 / 00:05</div>
      </section>
    </main>
  </div>

  <script>
    (() => {
      const $ = (id) => document.getElementById(id);
      const stage = $("stage");
      const ctx = stage.getContext("2d");
      const statusEl = $("status");
      const markersEl = $("markers");

      const reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      const easingFns = {
        linear: (t) => t,
        easeIn: (t) => t * t,
        easeOut: (t) => 1 - (1 - t) * (1 - t),
        easeInOut: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
        bounce: (t) => {
          const n1 = 7.5625, d1 = 2.75;
          if (t < 1 / d1) return n1 * t * t;
          if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
          if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
          return n1 * (t -= 2.625 / d1) * t + 0.984375;
        },
        steps: (t, steps = 8) => Math.floor(t * steps) / (steps - 1 || 1)
      };

      function cubicBezierAt(t, p1x, p1y, p2x, p2y) {
        const cx = 3 * p1x, bx = 3 * (p2x - p1x) - cx, ax = 1 - cx - bx;
        const cy = 3 * p1y, by = 3 * (p2y - p1y) - cy, ay = 1 - cy - by;
        const xAt = (u) => ((ax * u + bx) * u + cx) * u;
        const xDer = (u) => (3 * ax * u + 2 * bx) * u + cx;
        let u = t;
        for (let i = 0; i < 5; i++) {
          const x = xAt(u) - t;
          const d = xDer(u);
          if (Math.abs(d) < 1e-6) break;
          u -= x / d;
          u = Math.max(0, Math.min(1, u));
        }
        return ((ay * u + by) * u + cy) * u;
      }

      const state = {
        text: "Kinetic\nTypography\nStudio",
        duration: 5,
        fps: 30,
        t: 0,
        playing: false,
        lastTs: 0,
        activeProp: "x",
        selectedKeyIndex: -1,
        resolution: { w: 1280, h: 720 },
        style: {
          fontFamily: "Space Grotesk",
          fontSize: 96,
          fontWeight: 700,
          italic: false,
          fillColor: "#ffffff",
          strokeColor: "#0e0f14",
          strokeWidth: 0,
          shadowBlur: 8,
          shadowOpacity: 0.45,
          gradientMode: "none",
          gradientA: "#7ef0ff",
          gradientB: "#3c7bff",
          motionBlur: false,
          tracking: 0
        },
        layout: {
          margin: 48,
          showGrid: true,
          showSafe: true,
          gridSize: 80,
          bgColor: "#10131f",
          bgImage: null,
          bgImageObj: null,
          aspectPreset: "16:9"
        },
        anim: {
          preset: "none",
          intensity: 1,
          glyphMode: "letter",
          staggerMs: 35,
          keyframes: {
            x: [{ t: 0, v: 0, ease: "linear" }, { t: 5, v: 0, ease: "linear" }],
            y: [{ t: 0, v: 0, ease: "linear" }, { t: 5, v: 0, ease: "linear" }],
            scale: [{ t: 0, v: 1, ease: "linear" }, { t: 5, v: 1, ease: "linear" }],
            rotation: [{ t: 0, v: 0, ease: "linear" }, { t: 5, v: 0, ease: "linear" }],
            opacity: [{ t: 0, v: 1, ease: "linear" }, { t: 5, v: 1, ease: "linear" }],
            tracking: [{ t: 0, v: 0, ease: "linear" }, { t: 5, v: 0, ease: "linear" }],
            glyphOffset: [{ t: 0, v: 0, ease: "linear" }, { t: 5, v: 0, ease: "linear" }],
          }
        },
        audio: {
          file: null,
          url: null,
          beats: [],
          bars: [],
          bpm: 0,
          sourceBuffer: null,
          element: new Audio(),
          reactive: false,
          sensitivity: 1.25,
          level: 0,
          analyser: null,
          actx: null
        }
      };

      const easingPresetButtons = [
        ["linear", "Linear"],
        ["easeIn", "Ease In"],
        ["easeOut", "Ease Out"],
        ["easeInOut", "Ease InOut"],
        ["bounce", "Bounce"],
        ["custom", "Custom"]
      ];

      function initEasingChips() {
        const container = $("easingPresets");
        easingPresetButtons.forEach(([k, label]) => {
          const btn = document.createElement("button");
          btn.className = "chip";
          btn.type = "button";
          btn.textContent = label;
          btn.addEventListener("click", () => {
            $("keyEase").value = k;
            updateSelectedKey();
            syncChipActive();
          });
          btn.dataset.ease = k;
          container.appendChild(btn);
        });
        syncChipActive();
      }

      function syncChipActive() {
        const v = $("keyEase").value;
        [...$("easingPresets").children].forEach(c => c.classList.toggle("active", c.dataset.ease === v));
      }

      function formatTime(sec) {
        const mm = String(Math.floor(sec / 60)).padStart(2, "0");
        const ss = String(Math.floor(sec % 60)).padStart(2, "0");
        return `${mm}:${ss}`;
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function sortKeys(prop) {
        state.anim.keyframes[prop].sort((a, b) => a.t - b.t);
      }

      function interpKeyframes(prop, t) {
        const arr = state.anim.keyframes[prop];
        if (!arr.length) return 0;
        if (t <= arr[0].t) return arr[0].v;
        if (t >= arr[arr.length - 1].t) return arr[arr.length - 1].v;
        for (let i = 0; i < arr.length - 1; i++) {
          const a = arr[i], b = arr[i + 1];
          if (t >= a.t && t <= b.t) {
            const p = (t - a.t) / Math.max(1e-6, b.t - a.t);
            let e = p;
            if (a.ease === "custom") {
              const [p1x, p1y] = a.bez1 || [0.25, 0.1];
              const [p2x, p2y] = a.bez2 || [0.25, 1];
              e = cubicBezierAt(p, p1x, p1y, p2x, p2y);
            } else if (a.ease === "steps") {
              e = easingFns.steps(p, a.steps || 8);
            } else {
              e = (easingFns[a.ease] || easingFns.linear)(p);
            }
            return a.v + (b.v - a.v) * e;
          }
        }
        return arr[arr.length - 1].v;
      }

      function nearestKey(prop, t) {
        const arr = state.anim.keyframes[prop];
        let idx = -1, best = Infinity;
        arr.forEach((k, i) => {
          const d = Math.abs(k.t - t);
          if (d < best) { best = d; idx = i; }
        });
        return idx;
      }

      function parseBezier(text, fallback) {
        const p = text.split(",").map(s => Number(s.trim()));
        if (p.length !== 2 || p.some(n => Number.isNaN(n))) return fallback;
        return [clamp(p[0], 0, 1), clamp(p[1], 0, 1)];
      }

      function setStatus(msg) {
        statusEl.textContent = msg;
      }

      function splitUnits(text, mode) {
        if (mode === "word") {
          const lines = text.split("\n");
          return lines.flatMap((line, li) => line.split(/(\s+)/).map((w, wi) => ({ text: w, line: li, word: wi, isSpace: /^\s+$/.test(w) })));
        }
        if (mode === "line") return text.split("\n").map((line, li) => ({ text: line, line: li, isSpace: false }));
        return [...text].map((ch, i) => ({ text: ch, line: 0, index: i, isSpace: ch === " " }));
      }

      function drawGuides(w, h) {
        if (state.layout.showGrid) {
          ctx.save();
          ctx.strokeStyle = "#ffffff1a";
          ctx.lineWidth = 1;
          const g = Math.max(8, state.layout.gridSize);
          for (let x = g; x < w; x += g) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
          }
          for (let y = g; y < h; y += g) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
          }
          ctx.restore();
        }

        if (state.layout.showSafe) {
          const m = state.layout.margin;
          ctx.save();
          ctx.strokeStyle = "#6ee7a888";
          ctx.setLineDash([10, 8]);
          ctx.lineWidth = 2;
          ctx.strokeRect(m, m, w - 2 * m, h - 2 * m);
          ctx.restore();
        }
      }

      function getAudioEnergy(t) {
        const beats = state.audio.beats;
        if (!beats.length) return 0;
        const window = 0.08;
        let score = 0;
        for (let i = 0; i < beats.length; i++) {
          const d = Math.abs(beats[i] - t);
          if (d < window) score += 1 - d / window;
        }
        return clamp(score, 0, 1.2);
      }

      function drawFrame(time, renderCtx = ctx, canvas = stage, forExport = false) {
        const w = canvas.width, h = canvas.height;
        const x = interpKeyframes("x", time);
        const y = interpKeyframes("y", time);
        const s = interpKeyframes("scale", time);
        const r = interpKeyframes("rotation", time) * Math.PI / 180;
        const o = clamp(interpKeyframes("opacity", time), 0, 1);
        const tr = interpKeyframes("tracking", time) + state.style.tracking;
        const gOff = interpKeyframes("glyphOffset", time);

        renderCtx.save();
        renderCtx.clearRect(0, 0, w, h);

        if (state.layout.bgImageObj) {
          renderCtx.drawImage(state.layout.bgImageObj, 0, 0, w, h);
          renderCtx.fillStyle = `${state.layout.bgColor}55`;
          renderCtx.fillRect(0, 0, w, h);
        } else {
          renderCtx.fillStyle = state.layout.bgColor;
          renderCtx.fillRect(0, 0, w, h);
        }

        if (!forExport) drawGuides(w, h);

        const fontStyle = `${state.style.italic ? "italic" : "normal"} ${state.style.fontWeight} ${state.style.fontSize}px "${state.style.fontFamily}"`;
        renderCtx.font = fontStyle;
        renderCtx.textBaseline = "middle";
        renderCtx.textAlign = "left";

        let fillStyle = state.style.fillColor;
        if (state.style.gradientMode !== "none") {
          const grad = state.style.gradientMode === "linear"
            ? renderCtx.createLinearGradient(w * 0.2, h * 0.2, w * 0.8, h * 0.8)
            : renderCtx.createRadialGradient(w * 0.5, h * 0.5, 20, w * 0.5, h * 0.5, Math.max(w, h) * 0.6);
          grad.addColorStop(0, state.style.gradientA);
          grad.addColorStop(1, state.style.gradientB);
          fillStyle = grad;
        }

        const preset = state.anim.preset;
        const intensity = reducedMotion ? Math.min(0.25, state.anim.intensity) : state.anim.intensity;
        const units = splitUnits(state.text, state.anim.glyphMode);
        const stagger = state.anim.staggerMs / 1000;

        const lines = state.text.split("\n");
        const lineHeight = state.style.fontSize * 1.08;
        const startY = h * 0.5 - ((lines.length - 1) * lineHeight) / 2;

        renderCtx.globalAlpha = o;
        renderCtx.translate(w * 0.5 + x, h * 0.5 + y);
        renderCtx.rotate(r);
        renderCtx.scale(s, s);
        renderCtx.translate(-w * 0.5, -h * 0.5);

        if (state.style.motionBlur && !reducedMotion && !forExport) {
          renderCtx.fillStyle = "#0f122120";
          renderCtx.fillRect(0, 0, w, h);
        }

        let globalIdx = 0;
        const lineWidths = lines.map(line => measureTrackedWidth(line, tr, renderCtx));

        for (let li = 0; li < lines.length; li++) {
          const line = lines[li];
          let cx = w / 2 - lineWidths[li] / 2;
          const cy = startY + li * lineHeight;

          const chars = state.anim.glyphMode === "word" ? line.split(/(\s+)/) : [...line];
          for (let i = 0; i < chars.length; i++) {
            const txt = chars[i];
            const unitDelay = globalIdx * stagger;
            const localT = Math.max(0, time - unitDelay);
            let reveal = 1;
            let localY = 0;
            let localX = 0;
            let localR = 0;
            let localAlpha = 1;

            if (preset === "typewriter") {
              const progress = clamp((time / state.duration) * units.length, 0, units.length);
              reveal = globalIdx < progress ? 1 : 0;
            } else if (preset === "fadeup") {
              const p = clamp(localT / (state.duration * 0.35), 0, 1);
              const e = easingFns.easeOut(p);
              localY -= (1 - e) * (36 + gOff * 0.8);
              localAlpha = e;
            } else if (preset === "bounce") {
              localY += Math.sin(localT * 8 + globalIdx * 0.35) * (14 + gOff) * intensity;
            } else if (preset === "liquid") {
              localY += Math.sin(localT * 4.7 + globalIdx * 0.4) * (10 + gOff) * intensity;
              localX += Math.cos(localT * 3.8 + globalIdx * 0.25) * 4 * intensity;
              localR += Math.sin(localT * 2.5 + globalIdx * 0.2) * 0.09 * intensity;
            } else if (preset === "glitch") {
              const jitter = (Math.sin(localT * 58 + globalIdx * 13.1) + Math.sin(localT * 77 + globalIdx * 7.9)) * 0.5;
              localX += jitter * (6 + gOff) * intensity;
              localY += Math.sign(Math.sin(localT * 33 + globalIdx)) * 2 * intensity;
            } else if (preset === "cascade") {
              const p = clamp(localT / (state.duration * 0.25), 0, 1);
              const e = easingFns.easeOut(p);
              localY -= (1 - e) * (50 + gOff);
              localAlpha = e;
            }

            if (state.audio.reactive) {
              const e = getAudioEnergy(time);
              localY -= e * 20 * intensity;
              localR += e * 0.04;
              if (preset === "glitch") localX += (Math.random() - 0.5) * e * 20;
            }

            if (reveal > 0) {
              renderCtx.save();
              renderCtx.globalAlpha = o * localAlpha;
              renderCtx.translate(cx + localX, cy + localY);
              renderCtx.rotate(localR);

              renderCtx.shadowColor = `rgba(0,0,0,${state.style.shadowOpacity})`;
              renderCtx.shadowBlur = state.style.shadowBlur;
              renderCtx.fillStyle = fillStyle;
              if (state.style.strokeWidth > 0) {
                renderCtx.lineWidth = state.style.strokeWidth;
                renderCtx.strokeStyle = state.style.strokeColor;
                drawTrackedText(renderCtx, txt, 0, 0, tr, true, false);
              }
              drawTrackedText(renderCtx, txt, 0, 0, tr, false, true);

              if (preset === "glitch" && !reducedMotion) {
                renderCtx.globalCompositeOperation = "screen";
                renderCtx.fillStyle = "#ff2e5e88";
                drawTrackedText(renderCtx, txt, 1.2, 0, tr, false, true);
                renderCtx.fillStyle = "#1df2ff88";
                drawTrackedText(renderCtx, txt, -1.2, 0, tr, false, true);
                renderCtx.globalCompositeOperation = "source-over";
              }
              renderCtx.restore();
            }

            cx += measureTrackedWidth(txt, tr, renderCtx);
            globalIdx++;
          }
        }

        renderCtx.restore();
      }

      function drawTrackedText(c, text, x, y, tracking, stroke, fill) {
        let ox = x;
        for (const ch of text) {
          if (fill) c.fillText(ch, ox, y);
          if (stroke) c.strokeText(ch, ox, y);
          ox += c.measureText(ch).width + tracking;
        }
      }

      function measureTrackedWidth(text, tracking, c = ctx) {
        let w = 0;
        for (const ch of text) w += c.measureText(ch).width + tracking;
        return Math.max(0, w);
      }

      function updateTimelineInfo() {
        $("timelineInfo").textContent = `${formatTime(state.t)} / ${formatTime(state.duration)}`;
      }

      function updateMarkers() {
        markersEl.innerHTML = "";
        const createMarker = (t, cls) => {
          if (t < 0 || t > state.duration) return;
          const m = document.createElement("div");
          m.className = `marker ${cls}`;
          m.style.left = `${(t / state.duration) * 100}%`;
          markersEl.appendChild(m);
        };

        const arr = state.anim.keyframes[state.activeProp] || [];
        arr.forEach(k => createMarker(k.t, "key"));
        state.audio.beats.forEach(t => createMarker(t, "beat"));
        state.audio.bars.forEach(t => createMarker(t, "bar"));
      }

      function syncUIFromState() {
        $("textInput").value = state.text;
        $("duration").value = state.duration;
        $("fps").value = state.fps;
        $("scrubber").max = state.duration;
        $("scrubber").value = state.t;
        $("activeProperty").value = state.activeProp;

        $("fontFamily").value = state.style.fontFamily;
        $("fontSize").value = state.style.fontSize;
        $("fontWeight").value = state.style.fontWeight;
        $("italic").checked = state.style.italic;
        $("tracking").value = state.style.tracking;
        $("fillColor").value = state.style.fillColor;
        $("strokeColor").value = state.style.strokeColor;
        $("strokeWidth").value = state.style.strokeWidth;
        $("shadowBlur").value = state.style.shadowBlur;
        $("shadowOpacity").value = state.style.shadowOpacity;
        $("gradientMode").value = state.style.gradientMode;
        $("gradientA").value = state.style.gradientA;
        $("gradientB").value = state.style.gradientB;
        $("motionBlur").checked = state.style.motionBlur;

        $("margin").value = state.layout.margin;
        $("gridSize").value = state.layout.gridSize;
        $("showGrid").checked = state.layout.showGrid;
        $("showSafe").checked = state.layout.showSafe;
        $("bgColor").value = state.layout.bgColor;
        $("resW").value = state.resolution.w;
        $("resH").value = state.resolution.h;

        $("preset").value = state.anim.preset;
        $("effectIntensity").value = state.anim.intensity;
        $("stagger").value = state.anim.staggerMs;
        $("glyphMode").value = state.anim.glyphMode;

        $("audioReactive").checked = state.audio.reactive;
        $("audioSensitivity").value = state.audio.sensitivity;

        updateKeyUi();
        updateMarkers();
        updateTimelineInfo();
      }

      function updateKeyUi() {
        const arr = state.anim.keyframes[state.activeProp];
        if (!arr.length) {
          $("keyValue").value = 0;
          return;
        }
        state.selectedKeyIndex = nearestKey(state.activeProp, state.t);
        const key = arr[state.selectedKeyIndex];
        if (!key) return;
        $("keyValue").value = Number(key.v.toFixed(3));
        $("keyEase").value = key.ease || "linear";
        $("stepsCount").value = key.steps || 8;
        $("bezier1").value = (key.bez1 || [0.25, 0.1]).join(",");
        $("bezier2").value = (key.bez2 || [0.25, 1]).join(",");
        syncChipActive();
      }

      function addKeyframeAtCurrent() {
        const prop = state.activeProp;
        const arr = state.anim.keyframes[prop];
        const current = interpKeyframes(prop, state.t);
        const ease = $("keyEase").value;
        arr.push({
          t: Number(state.t.toFixed(3)),
          v: current,
          ease,
          steps: Number($("stepsCount").value) || 8,
          bez1: parseBezier($("bezier1").value, [0.25, 0.1]),
          bez2: parseBezier($("bezier2").value, [0.25, 1])
        });
        sortKeys(prop);
        state.selectedKeyIndex = nearestKey(prop, state.t);
        updateKeyUi();
        updateMarkers();
      }

      function updateSelectedKey() {
        const arr = state.anim.keyframes[state.activeProp];
        const idx = nearestKey(state.activeProp, state.t);
        if (idx < 0 || !arr[idx]) return;
        const k = arr[idx];
        k.v = Number($("keyValue").value);
        k.ease = $("keyEase").value;
        k.steps = Number($("stepsCount").value) || 8;
        k.bez1 = parseBezier($("bezier1").value, [0.25, 0.1]);
        k.bez2 = parseBezier($("bezier2").value, [0.25, 1]);
        updateMarkers();
      }

      function deleteNearestKey() {
        const prop = state.activeProp;
        const arr = state.anim.keyframes[prop];
        if (arr.length <= 2) {
          setStatus("Need at least 2 keys per property");
          return;
        }
        const idx = nearestKey(prop, state.t);
        arr.splice(idx, 1);
        updateKeyUi();
        updateMarkers();
      }

      function applyPreset(name) {
        state.anim.preset = name;
        const d = state.duration;
        const k = state.anim.keyframes;

        if (name === "typewriter") {
          k.opacity = [{ t: 0, v: 1, ease: "linear" }, { t: d, v: 1, ease: "linear" }];
          k.glyphOffset = [{ t: 0, v: 0, ease: "linear" }, { t: d, v: 0, ease: "linear" }];
        } else if (name === "bounce") {
          k.y = [{ t: 0, v: -8, ease: "easeOut" }, { t: d * 0.5, v: 0, ease: "bounce" }, { t: d, v: 0, ease: "linear" }];
          k.scale = [{ t: 0, v: 1, ease: "linear" }, { t: d * 0.2, v: 1.05, ease: "easeInOut" }, { t: d, v: 1, ease: "linear" }];
        } else if (name === "liquid") {
          k.rotation = [{ t: 0, v: -1, ease: "easeInOut" }, { t: d * 0.5, v: 1, ease: "easeInOut" }, { t: d, v: -1, ease: "easeInOut" }];
          k.glyphOffset = [{ t: 0, v: 8, ease: "linear" }, { t: d, v: 16, ease: "linear" }];
        } else if (name === "glitch") {
          k.x = [{ t: 0, v: 0, ease: "linear" }, { t: d, v: 0, ease: "linear" }];
          k.opacity = [{ t: 0, v: 0.96, ease: "steps", steps: 12 }, { t: d, v: 1, ease: "steps", steps: 12 }];
          k.glyphOffset = [{ t: 0, v: 9, ease: "linear" }, { t: d, v: 15, ease: "linear" }];
        } else if (name === "fadeup") {
          k.opacity = [{ t: 0, v: 0, ease: "easeOut" }, { t: d * 0.25, v: 1, ease: "easeOut" }, { t: d, v: 1, ease: "linear" }];
          k.y = [{ t: 0, v: 20, ease: "easeOut" }, { t: d * 0.4, v: 0, ease: "easeOut" }, { t: d, v: 0, ease: "linear" }];
        } else if (name === "cascade") {
          k.opacity = [{ t: 0, v: 0, ease: "easeIn" }, { t: d * 0.3, v: 1, ease: "easeOut" }, { t: d, v: 1, ease: "linear" }];
          k.glyphOffset = [{ t: 0, v: 20, ease: "easeOut" }, { t: d, v: 0, ease: "linear" }];
        }

        Object.keys(k).forEach(sortKeys);
        syncUIFromState();
      }

      async function loadBackground(file) {
        if (!file) return;
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          state.layout.bgImage = file;
          state.layout.bgImageObj = img;
          setStatus("Background loaded");
        };
        img.src = url;
      }

      function setResolution(w, h) {
        state.resolution.w = w;
        state.resolution.h = h;
        stage.width = w;
        stage.height = h;
      }

      function applyAspectPreset(v) {
        const base = Number($("resW").value) || 1280;
        if (v === "16:9") {
          $("resW").value = base;
          $("resH").value = Math.round(base * 9 / 16);
        }
        if (v === "9:16") {
          $("resW").value = Math.round(base * 9 / 16);
          $("resH").value = base;
        }
        if (v === "1:1") {
          $("resW").value = base;
          $("resH").value = base;
        }
        setResolution(Number($("resW").value), Number($("resH").value));
      }

      async function loadAudio(file) {
        if (!file) return;
        state.audio.file = file;
        if (state.audio.url) URL.revokeObjectURL(state.audio.url);
        state.audio.url = URL.createObjectURL(file);
        state.audio.element.src = state.audio.url;
        state.audio.element.preload = "auto";

        const actx = new (window.AudioContext || window.webkitAudioContext)();
        const arr = await file.arrayBuffer();
        const buffer = await actx.decodeAudioData(arr.slice(0));
        state.audio.sourceBuffer = buffer;
        state.audio.actx = actx;

        if (!state.audio.analyser) {
          const src = actx.createMediaElementSource(state.audio.element);
          const analyser = actx.createAnalyser();
          analyser.fftSize = 1024;
          src.connect(analyser);
          analyser.connect(actx.destination);
          state.audio.analyser = analyser;
        }

        $("beatInfo").textContent = `Audio loaded: ${file.name}`;
      }

      function detectBeats() {
        const buf = state.audio.sourceBuffer;
        if (!buf) {
          setStatus("Load audio first");
          return;
        }

        const ch = buf.getChannelData(0);
        const sampleRate = buf.sampleRate;
        const frame = 1024;
        const hop = 512;
        const energies = [];

        for (let i = 0; i + frame < ch.length; i += hop) {
          let e = 0;
          for (let j = 0; j < frame; j++) {
            const s = ch[i + j];
            e += s * s;
          }
          energies.push({
            t: i / sampleRate,
            e: e / frame
          });
        }

        const beats = [];
        const win = 36;
        const sensitivity = state.audio.sensitivity;

        for (let i = win; i < energies.length - win; i++) {
          let local = 0;
          for (let j = i - win; j < i; j++) local += energies[j].e;
          local /= win;
          const curr = energies[i].e;
          const isPeak = curr > local * sensitivity && curr > energies[i - 1].e && curr > energies[i + 1].e;
          if (isPeak) {
            const t = energies[i].t;
            if (!beats.length || t - beats[beats.length - 1] > 0.17) beats.push(t);
          }
        }

        state.audio.beats = beats;

        const intervals = [];
        for (let i = 1; i < beats.length; i++) intervals.push(beats[i] - beats[i - 1]);
        const med = intervals.length ? intervals.sort((a, b) => a - b)[Math.floor(intervals.length / 2)] : 0;
        state.audio.bpm = med > 0 ? Math.round(60 / med) : 0;

        state.audio.bars = beats.filter((_, i) => i % 4 === 0);

        $("beatInfo").textContent = beats.length
          ? `Detected ${beats.length} beats, BPM ~${state.audio.bpm}`
          : "No clear beats detected";

        updateMarkers();
        setStatus("Beat detection complete");
      }

      function snapKeyframesToRhythm() {
        const target = $("beatSnapMode").value === "bar" ? state.audio.bars : state.audio.beats;
        if (!target.length) {
          setStatus("No beats/bars available");
          return;
        }

        Object.keys(state.anim.keyframes).forEach(prop => {
          state.anim.keyframes[prop].forEach(k => {
            let best = target[0];
            let dist = Math.abs(k.t - best);
            for (const t of target) {
              const d = Math.abs(k.t - t);
              if (d < dist) { dist = d; best = t; }
            }
            k.t = clamp(Number(best.toFixed(3)), 0, state.duration);
          });
          sortKeys(prop);
        });

        updateMarkers();
        setStatus("Keyframes snapped");
      }

      function pollAudioLevel() {
        if (!state.audio.analyser) return;
        const arr = new Uint8Array(state.audio.analyser.frequencyBinCount);
        state.audio.analyser.getByteFrequencyData(arr);
        const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
        state.audio.level = avg / 255;
      }

      function tick(ts) {
        if (!state.lastTs) state.lastTs = ts;
        const dt = (ts - state.lastTs) / 1000;
        state.lastTs = ts;

        if (state.playing) {
          state.t += dt;
          if (state.t >= state.duration) {
            state.t = 0;
            if (state.audio.element && !state.audio.element.paused) {
              state.audio.element.currentTime = 0;
              state.audio.element.pause();
            }
          }
          $("scrubber").value = state.t;
        }

        pollAudioLevel();
        drawFrame(state.t);
        updateTimelineInfo();
        requestAnimationFrame(tick);
      }

      function playPause() {
        state.playing = !state.playing;
        $("playBtn").textContent = state.playing ? "Pause" : "Play";
        setStatus(state.playing ? "Playing" : "Paused");

        if (state.audio.file) {
          if (state.playing) {
            state.audio.element.currentTime = state.t;
            state.audio.element.play().catch(() => {});
            state.audio.actx && state.audio.actx.resume();
          } else {
            state.audio.element.pause();
          }
        }
      }

      function stopPlayback() {
        state.playing = false;
        state.t = 0;
        state.lastTs = 0;
        $("playBtn").textContent = "Play";
        $("scrubber").value = 0;
        if (state.audio.file) {
          state.audio.element.pause();
          state.audio.element.currentTime = 0;
        }
        setStatus("Stopped");
      }

      async function exportAnimation() {
        const type = $("exportType").value;
        const fps = Number($("exportFps").value) || 30;
        const quality = Number($("quality").value) || 0.9;
        const w = Number($("resW").value) || stage.width;
        const h = Number($("resH").value) || stage.height;
        const totalFrames = Math.max(1, Math.floor(state.duration * fps));

        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = w;
        exportCanvas.height = h;
        const exCtx = exportCanvas.getContext("2d");

        setStatus(`Exporting ${type.toUpperCase()}...`);

        if (type === "pngseq") {
          const zip = new JSZip();
          for (let i = 0; i < totalFrames; i++) {
            const t = i / fps;
            drawFrame(t, exCtx, exportCanvas, true);
            const blob = await new Promise(r => exportCanvas.toBlob(r, "image/png", 1));
            zip.file(`frame_${String(i).padStart(4, "0")}.png`, blob);
          }
          const out = await zip.generateAsync({ type: "blob" });
          saveAs(out, "kinetic_typography_png_sequence.zip");
          setStatus("PNG sequence exported");
          return;
        }

        if (type === "gif") {
          const gif = new GIF({
            workers: 2,
            quality: Math.round((1 - quality) * 20) + 1,
            workerScript: "https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js",
            width: w,
            height: h
          });
          for (let i = 0; i < totalFrames; i++) {
            const t = i / fps;
            drawFrame(t, exCtx, exportCanvas, true);
            gif.addFrame(exCtx, { copy: true, delay: 1000 / fps });
          }
          gif.on("finished", (blob) => {
            saveAs(blob, "kinetic_typography.gif");
            setStatus("GIF exported");
          });
          gif.render();
          return;
        }

        const stream = exportCanvas.captureStream(fps);
        const preferred = type === "mp4"
          ? ["video/mp4;codecs=avc1", "video/mp4", "video/webm;codecs=vp9", "video/webm"]
          : ["video/webm;codecs=vp9", "video/webm", "video/mp4"];

        const mime = preferred.find(m => MediaRecorder.isTypeSupported(m));
        if (!mime) {
          setStatus("No supported recorder codec");
          return;
        }

        const chunks = [];
        const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: Math.floor(4_000_000 * quality + 500_000) });
        rec.ondataavailable = (e) => e.data && chunks.push(e.data);

        const done = new Promise(resolve => rec.onstop = resolve);
        rec.start();

        for (let i = 0; i < totalFrames; i++) {
          const t = i / fps;
          drawFrame(t, exCtx, exportCanvas, true);
          await new Promise(r => setTimeout(r, 1000 / fps));
        }

        rec.stop();
        await done;

        const blob = new Blob(chunks, { type: mime });
        const ext = mime.includes("mp4") ? "mp4" : "webm";
        saveAs(blob, `kinetic_typography.${ext}`);
        setStatus(`${ext.toUpperCase()} exported`);
      }

      function bindUi() {
        const bind = (id, fn, evt = "input") => $(id).addEventListener(evt, fn);

        bind("textInput", (e) => state.text = e.target.value);
        bind("fontFamily", (e) => state.style.fontFamily = e.target.value, "change");
        bind("fontSize", (e) => state.style.fontSize = Number(e.target.value));
        bind("fontWeight", (e) => state.style.fontWeight = Number(e.target.value));
        bind("italic", (e) => state.style.italic = e.target.checked, "change");
        bind("tracking", (e) => state.style.tracking = Number(e.target.value));
        bind("fillColor", (e) => state.style.fillColor = e.target.value);
        bind("strokeColor", (e) => state.style.strokeColor = e.target.value);
        bind("strokeWidth", (e) => state.style.strokeWidth = Number(e.target.value));
        bind("shadowBlur", (e) => state.style.shadowBlur = Number(e.target.value));
        bind("shadowOpacity", (e) => state.style.shadowOpacity = Number(e.target.value));
        bind("gradientMode", (e) => state.style.gradientMode = e.target.value, "change");
        bind("gradientA", (e) => state.style.gradientA = e.target.value);
        bind("gradientB", (e) => state.style.gradientB = e.target.value);
        bind("motionBlur", (e) => state.style.motionBlur = e.target.checked, "change");

        bind("margin", (e) => state.layout.margin = Number(e.target.value));
        bind("gridSize", (e) => state.layout.gridSize = Number(e.target.value));
        bind("showGrid", (e) => state.layout.showGrid = e.target.checked, "change");
        bind("showSafe", (e) => state.layout.showSafe = e.target.checked, "change");
        bind("bgColor", (e) => state.layout.bgColor = e.target.value);
        bind("bgImage", (e) => loadBackground(e.target.files[0]), "change");

        bind("aspectPreset", (e) => applyAspectPreset(e.target.value), "change");
        bind("resW", () => setResolution(Number($("resW").value), Number($("resH").value)), "change");
        bind("resH", () => setResolution(Number($("resW").value), Number($("resH").value)), "change");

        bind("duration", (e) => {
          state.duration = Math.max(0.2, Number(e.target.value));
          $("scrubber").max = state.duration;
          ["x", "y", "scale", "rotation", "opacity", "tracking", "glyphOffset"].forEach(prop => {
            const arr = state.anim.keyframes[prop];
            if (arr.length) arr[arr.length - 1].t = state.duration;
          });
          state.t = clamp(state.t, 0, state.duration);
          updateMarkers();
        }, "change");
        bind("fps", (e) => state.fps = Number(e.target.value), "change");
        bind("stagger", (e) => state.anim.staggerMs = Number(e.target.value), "change");
        bind("glyphMode", (e) => state.anim.glyphMode = e.target.value, "change");
        bind("preset", (e) => state.anim.preset = e.target.value, "change");
        bind("effectIntensity", (e) => state.anim.intensity = Number(e.target.value));

        bind("applyPreset", () => applyPreset($("preset").value), "click");
        bind("addKey", addKeyframeAtCurrent, "click");

        bind("audioFile", async (e) => {
          await loadAudio(e.target.files[0]);
          setStatus("Audio loaded");
        }, "change");
        bind("audioSensitivity", (e) => state.audio.sensitivity = Number(e.target.value));
        bind("audioReactive", (e) => state.audio.reactive = e.target.checked, "change");
        bind("detectBeats", detectBeats, "click");
        bind("snapToBeats", snapKeyframesToRhythm, "click");

        bind("playBtn", playPause, "click");
        bind("stopBtn", stopPlayback, "click");

        bind("activeProperty", (e) => {
          state.activeProp = e.target.value;
          updateKeyUi();
          updateMarkers();
        }, "change");

        bind("scrubber", (e) => {
          state.t = Number(e.target.value);
          if (state.audio.file && !state.playing) state.audio.element.currentTime = state.t;
          updateKeyUi();
          updateTimelineInfo();
        });

        bind("keyValue", updateSelectedKey, "change");
        bind("keyEase", () => { updateSelectedKey(); syncChipActive(); }, "change");
        bind("stepsCount", updateSelectedKey, "change");
        bind("bezier1", updateSelectedKey, "change");
        bind("bezier2", updateSelectedKey, "change");
        bind("deleteKey", deleteNearestKey, "click");

        bind("exportBtn", exportAnimation, "click");

        stage.addEventListener("pointerdown", (e) => {
          stage.setPointerCapture(e.pointerId);
          const rect = stage.getBoundingClientRect();
          const sx = stage.width / rect.width;
          const sy = stage.height / rect.height;
          const startX = (e.clientX - rect.left) * sx;
          const startY = (e.clientY - rect.top) * sy;
          const baseX = interpKeyframes("x", state.t);
          const baseY = interpKeyframes("y", state.t);

          const move = (ev) => {
            const x = (ev.clientX - rect.left) * sx;
            const y = (ev.clientY - rect.top) * sy;
            const dx = x - startX;
            const dy = y - startY;
            const arrX = state.anim.keyframes.x;
            const arrY = state.anim.keyframes.y;
            const ix = nearestKey("x", state.t);
            const iy = nearestKey("y", state.t);
            if (arrX[ix]) arrX[ix].v = baseX + dx;
            if (arrY[iy]) arrY[iy].v = baseY + dy;
          };

          const up = () => {
            window.removeEventListener("pointermove", move);
            window.removeEventListener("pointerup", up);
            updateKeyUi();
          };

          window.addEventListener("pointermove", move);
          window.addEventListener("pointerup", up);
        });

        document.addEventListener("keydown", (e) => {
          const ctrl = e.ctrlKey || e.metaKey;
          if (e.code === "Space" && !["INPUT", "TEXTAREA", "SELECT"].includes(document.activeElement.tagName)) {
            e.preventDefault();
            playPause();
          }
          if (e.code === "ArrowRight") {
            e.preventDefault();
            state.t = clamp(state.t + 1 / state.fps, 0, state.duration);
            $("scrubber").value = state.t;
            updateKeyUi();
          }
          if (e.code === "ArrowLeft") {
            e.preventDefault();
            state.t = clamp(state.t - 1 / state.fps, 0, state.duration);
            $("scrubber").value = state.t;
            updateKeyUi();
          }
          if (ctrl && e.key.toLowerCase() === "k") {
            e.preventDefault();
            addKeyframeAtCurrent();
          }
          if (ctrl && e.key.toLowerCase() === "e") {
            e.preventDefault();
            exportAnimation();
          }
        });
      }

      function init() {
        initEasingChips();
        bindUi();
        syncUIFromState();
        requestAnimationFrame(tick);
      }

      init();
    })();
  </script>
</body>
</html>
