<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weather Theatre</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Fraunces:opsz,wght@9..144,400;9..144,700&family=DM+Sans:wght@400;500;700&display=swap');

    :root {
      --bg: #0f1724;
      --panel: rgba(9, 15, 27, 0.68);
      --border: rgba(255, 255, 255, 0.18);
      --text: #eef4ff;
      --muted: #9fb0c9;
      --gold: #efc26a;
      --rose: #d26a5d;
      --teal: #53b8ae;
      --shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'DM Sans', sans-serif;
      background:
        radial-gradient(1200px 650px at 12% -15%, rgba(83, 184, 174, 0.20), transparent 50%),
        radial-gradient(900px 600px at 100% 0%, rgba(210, 106, 93, 0.20), transparent 55%),
        linear-gradient(160deg, #0a101b 0%, #111d32 65%, #0d131f 100%);
      color: var(--text);
      display: flex;
      justify-content: center;
      align-items: center;
      padding: clamp(14px, 2.2vw, 30px);
    }

    .app-shell {
      width: min(1200px, 100%);
      background: var(--panel);
      border: 1px solid var(--border);
      backdrop-filter: blur(14px);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      padding: 18px clamp(18px, 2.4vw, 28px) 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .title h1 {
      margin: 0;
      font-family: 'Bebas Neue', sans-serif;
      font-weight: 400;
      letter-spacing: 0.04em;
      font-size: clamp(2rem, 4vw, 3rem);
      line-height: 0.88;
      color: #fff4df;
    }

    .title p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: clamp(0.9rem, 1.4vw, 1rem);
      max-width: 56ch;
    }

    .badge-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 999px;
      padding: 7px 12px;
      color: #ecf3ff;
      font-size: 0.82rem;
      background: rgba(255, 255, 255, 0.05);
      white-space: nowrap;
    }

    .theatre {
      position: relative;
      padding: 14px clamp(12px, 2vw, 20px) clamp(12px, 2vw, 20px);
    }

    canvas {
      width: 100%;
      height: min(56vh, 480px);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      display: block;
      background: #10192a;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12);
    }

    .subtitle {
      position: absolute;
      left: 30px;
      bottom: 34px;
      font-family: 'Fraunces', serif;
      font-size: clamp(1rem, 1.8vw, 1.3rem);
      color: #fff9e8;
      letter-spacing: 0.01em;
      text-shadow: 0 3px 16px rgba(0, 0, 0, 0.7);
      min-height: 1.5em;
      max-width: min(78%, 820px);
      pointer-events: none;
    }

    .subtitle::after {
      content: '';
      display: inline-block;
      width: 0.55ch;
      height: 1em;
      margin-left: 2px;
      background: rgba(255, 243, 216, 0.85);
      vertical-align: -0.1em;
      animation: blink 1s steps(1, end) infinite;
    }

    @keyframes blink { 50% { opacity: 0; } }

    .controls {
      display: grid;
      gap: 12px;
      padding: 0 clamp(12px, 2vw, 20px) clamp(16px, 2.2vw, 22px);
      grid-template-columns: 1.15fr 1.15fr 1fr;
    }

    .panel {
      background: rgba(6, 10, 19, 0.58);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 13px 14px;
    }

    .panel h3 {
      margin: 0 0 12px;
      font-size: 0.9rem;
      font-family: 'Bebas Neue', sans-serif;
      letter-spacing: 0.08em;
      font-weight: 400;
      color: #fbe7c2;
    }

    .slider-wrap { margin: 0 0 10px; }
    .slider-wrap:last-child { margin-bottom: 0; }

    .slider-line {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 0.88rem;
    }

    .slider-line strong { font-weight: 600; }
    .slider-line span { color: var(--muted); }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 9px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(239, 194, 106, 0.7), rgba(83, 184, 174, 0.5), rgba(210, 106, 93, 0.7));
      outline: none;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid #fff9e7;
      background: #1b3557;
      cursor: pointer;
      box-shadow: 0 1px 8px rgba(0, 0, 0, 0.45);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid #fff9e7;
      background: #1b3557;
      cursor: pointer;
      box-shadow: 0 1px 8px rgba(0, 0, 0, 0.45);
    }

    .toggle {
      display: inline-flex;
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 999px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .toggle button {
      border: 0;
      font: inherit;
      color: #dbe8fb;
      background: transparent;
      padding: 8px 12px;
      cursor: pointer;
      transition: 0.22s ease;
    }

    .toggle button.active {
      background: rgba(239, 194, 106, 0.22);
      color: #fff4da;
    }

    .mini {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 3px;
    }

    .mini .chip {
      font-size: 0.78rem;
      color: #d8e2f5;
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 999px;
      padding: 5px 9px;
      background: rgba(255, 255, 255, 0.04);
    }

    .forecast-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .forecast-item {
      border: 1px solid rgba(255, 255, 255, 0.13);
      border-radius: 10px;
      padding: 9px 8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      font-size: 0.8rem;
      line-height: 1.3;
      color: #d8e6fc;
    }

    .forecast-item b {
      display: block;
      color: #fff2d6;
      margin-bottom: 3px;
      font-size: 0.79rem;
    }

    .encore {
      margin-top: 10px;
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 9px;
      font: inherit;
      color: #fff3d9;
      background: linear-gradient(180deg, rgba(239, 194, 106, 0.24), rgba(239, 194, 106, 0.08));
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .encore:hover { transform: translateY(-1px); }

    @media (max-width: 960px) {
      .controls {
        grid-template-columns: 1fr;
      }
      .subtitle {
        left: 22px;
        bottom: 26px;
        max-width: 88%;
      }
      .forecast-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .top {
        flex-direction: column;
        align-items: flex-start;
      }
      .badge-row {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    const FORECAST = [
      { slot: 'Morning', icon: 'Mist', temp: 62, wind: 8, rain: 24, cloud: 50 },
      { slot: 'Noon', icon: 'Sunbreak', temp: 73, wind: 12, rain: 10, cloud: 28 },
      { slot: 'Evening', icon: 'Drizzle', temp: 66, wind: 15, rain: 58, cloud: 72 },
      { slot: 'Late', icon: 'Moonwash', temp: 59, wind: 9, rain: 18, cloud: 46 }
    ];

    const blend = (a, b, t) => Math.round(a + (b - a) * t);
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    function hexToRgb(hex) {
      const clean = hex.replace('#', '');
      const full = clean.length === 3 ? clean.split('').map(c => c + c).join('') : clean;
      const int = parseInt(full, 16);
      return [
        (int >> 16) & 255,
        (int >> 8) & 255,
        int & 255
      ];
    }

    function mixColors(colors, weights) {
      let r = 0, g = 0, b = 0;
      colors.forEach((hex, i) => {
        const [cr, cg, cb] = hexToRgb(hex);
        r += cr * weights[i];
        g += cg * weights[i];
        b += cb * weights[i];
      });
      return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function App() {
      const canvasRef = useRef(null);
      const frameRef = useRef(null);
      const startRef = useRef(performance.now());
      const mouseRef = useRef({ x: 0, y: 0, tx: 0, ty: 0 });

      const [cosy, setCosy] = useState(58);
      const [eerie, setEerie] = useState(26);
      const [heroic, setHeroic] = useState(44);
      const [timeMode, setTimeMode] = useState('matinee');
      const [subtitle, setSubtitle] = useState('');
      const [curtainStart, setCurtainStart] = useState(performance.now());

      const remix = useMemo(() => {
        const sum = cosy + eerie + heroic || 1;
        const c = cosy / sum;
        const e = eerie / sum;
        const h = heroic / sum;

        const meanRain = FORECAST.reduce((acc, f) => acc + f.rain, 0) / FORECAST.length;
        const meanWind = FORECAST.reduce((acc, f) => acc + f.wind, 0) / FORECAST.length;
        const meanCloud = FORECAST.reduce((acc, f) => acc + f.cloud, 0) / FORECAST.length;

        const skyTop = mixColors(['#f4c36e', '#1b273c', '#5c8fd8'], [c, e, h]);
        const skyBottom = mixColors(['#f9ddad', '#26415c', '#8bc6ec'], [c, e, h]);
        const haze = mixColors(['#f6b780', '#3a4f6f', '#f2d7a0'], [c, e, h]);

        const descriptor = c > e && c > h
          ? 'Warm lanterns cradle a gentle front'
          : e > c && e > h
          ? 'A spectral squall haunts the rafters'
          : 'A triumphant break in the clouds takes the stage';

        const detail = h > 0.4
          ? 'brass fanfare under charging winds'
          : e > 0.4
          ? 'whispers in rain-lit fog'
          : 'soft velvet skies and candlelight drizzle';

        return {
          weights: { c, e, h },
          skyTop,
          skyBottom,
          haze,
          meanRain,
          meanWind,
          meanCloud,
          descriptor,
          detail,
          rainDensity: clamp((meanRain / 100) * (0.3 + e * 1.15 + h * 0.32), 0.04, 0.95),
          cloudSpeed: 0.08 + meanWind * 0.009 + h * 0.22,
          spotlightIntensity: 0.28 + h * 0.5 + (timeMode === 'night' ? 0.14 : 0),
          fogLevel: clamp((meanCloud / 100) * (0.5 + e * 1.2), 0.06, 0.95),
          warmth: c,
          eeriness: e,
          heroism: h
        };
      }, [cosy, eerie, heroic, timeMode]);

      const sceneLine = `${remix.descriptor}, ${remix.detail}.`;

      useEffect(() => {
        let idx = 0;
        setSubtitle('');
        const timer = setInterval(() => {
          idx += 1;
          setSubtitle(sceneLine.slice(0, idx));
          if (idx >= sceneLine.length) clearInterval(timer);
        }, 28);
        return () => clearInterval(timer);
      }, [sceneLine]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        const onResize = () => {
          const rect = canvas.getBoundingClientRect();
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = Math.round(rect.width * dpr);
          canvas.height = Math.round(rect.height * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        };

        const onMove = (ev) => {
          const rect = canvas.getBoundingClientRect();
          mouseRef.current.tx = clamp((ev.clientX - rect.left) / rect.width, 0, 1);
          mouseRef.current.ty = clamp((ev.clientY - rect.top) / rect.height, 0, 1);
        };

        onResize();
        window.addEventListener('resize', onResize);
        window.addEventListener('pointermove', onMove, { passive: true });

        const draw = (t) => {
          const elapsed = (t - startRef.current) / 1000;
          const cw = canvas.clientWidth;
          const ch = canvas.clientHeight;
          const m = mouseRef.current;
          m.x += (m.tx - m.x) * 0.045;
          m.y += (m.ty - m.y) * 0.045;

          const nightFactor = timeMode === 'night' ? 1 : 0;

          const g = ctx.createLinearGradient(0, 0, 0, ch);
          g.addColorStop(0, remix.skyTop);
          g.addColorStop(0.75, remix.skyBottom);
          g.addColorStop(1, mixColors(['#f8d7a5', '#17263e', '#76a6d9'], [remix.warmth, remix.eeriness, remix.heroism]));
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, cw, ch);

          if (nightFactor > 0) {
            ctx.save();
            ctx.globalAlpha = 0.8;
            for (let i = 0; i < 70; i++) {
              const x = (i * 97 + 37) % cw;
              const y = (i * 53 + 23) % (ch * 0.55);
              const tw = 0.3 + ((Math.sin(elapsed * 1.7 + i) + 1) / 2);
              ctx.fillStyle = `rgba(255,248,220,${0.2 + tw * 0.55})`;
              ctx.fillRect(x, y, 2, 2);
            }
            ctx.restore();
          }

          const hazeGrad = ctx.createLinearGradient(0, ch * 0.35, 0, ch);
          hazeGrad.addColorStop(0, `rgba(${hexToRgb(remix.haze).join(',')},${0.08 + remix.fogLevel * 0.25})`);
          hazeGrad.addColorStop(1, `rgba(10,14,24,${0.42 + remix.fogLevel * 0.42})`);
          ctx.fillStyle = hazeGrad;
          ctx.fillRect(0, ch * 0.24, cw, ch);

          const parallax = (depth) => ((m.x - 0.5) * 2) * (12 * depth);

          const drawMountainBand = (baseY, amp, color, depth, seed) => {
            ctx.beginPath();
            ctx.moveTo(-40, ch);
            for (let x = -40; x <= cw + 40; x += 12) {
              const nx = x / cw;
              const y = baseY - Math.sin((nx * 6.4 + elapsed * remix.cloudSpeed * (0.08 + depth) + seed) * Math.PI) * amp
                      - Math.cos((nx * 10.3 + seed * 2.4) * Math.PI) * amp * 0.45;
              ctx.lineTo(x + parallax(depth), y);
            }
            ctx.lineTo(cw + 40, ch);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
          };

          drawMountainBand(ch * 0.67, 32, mixColors(['#e8b77d', '#27374f', '#6a8dbc'], [remix.warmth, remix.eeriness, remix.heroism]), 0.35, 0.3);
          drawMountainBand(ch * 0.74, 24, mixColors(['#c99667', '#1f2c3f', '#4d74a9'], [remix.warmth, remix.eeriness, remix.heroism]), 0.58, 1.2);
          drawMountainBand(ch * 0.83, 18, mixColors(['#9b6f4f', '#151f2f', '#2f4d77'], [remix.warmth, remix.eeriness, remix.heroism]), 0.88, 2.1);

          const cloudTone = mixColors(['#ffefcf', '#a4b2c9', '#dde7f6'], [remix.warmth, remix.eeriness, remix.heroism]);
          for (let i = 0; i < 7; i++) {
            const x = ((elapsed * remix.cloudSpeed * 38 + i * 190) % (cw + 320)) - 160;
            const y = ch * 0.2 + (i % 3) * 26 + Math.sin(elapsed * 0.5 + i * 2.1) * 5;
            const wobble = parallax(0.15 + i * 0.03);
            ctx.fillStyle = cloudTone.replace('rgb(', 'rgba(').replace(')', `,${0.12 + remix.fogLevel * 0.28})`);
            ctx.beginPath();
            ctx.ellipse(x + wobble, y, 70, 22, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 35 + wobble, y + 4, 48, 16, 0, 0, Math.PI * 2);
            ctx.fill();
          }

          if (remix.rainDensity > 0.1) {
            const drops = Math.floor(150 * remix.rainDensity);
            ctx.strokeStyle = `rgba(210, 230, 255, ${0.08 + remix.eeriness * 0.28})`;
            ctx.lineWidth = 1.2;
            for (let i = 0; i < drops; i++) {
              const rx = ((i * 43 + elapsed * 260 * (0.45 + remix.heroism * 0.6)) % (cw + 40)) - 20;
              const ry = (i * 67 + elapsed * 470) % (ch + 120) - 60;
              ctx.beginPath();
              ctx.moveTo(rx, ry);
              ctx.lineTo(rx - 4 - remix.eeriness * 3, ry + 10 + remix.heroism * 4);
              ctx.stroke();
            }
          }

          const stageY = ch * 0.83;
          const stageGrad = ctx.createLinearGradient(0, stageY - 30, 0, ch);
          stageGrad.addColorStop(0, mixColors(['#7d4d34', '#2f3847', '#3e4e6b'], [remix.warmth, remix.eeriness, remix.heroism]));
          stageGrad.addColorStop(1, '#100f16');
          ctx.fillStyle = stageGrad;
          ctx.fillRect(0, stageY - 14, cw, ch - stageY + 20);

          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          for (let i = 0; i < 18; i++) {
            const y = stageY + i * 5;
            ctx.fillRect(0, y, cw, 1);
          }

          const sweep = (phase, spread, color, alphaBase) => {
            const sx = cw * (0.1 + 0.8 * ((Math.sin(elapsed * 0.45 + phase) + 1) / 2));
            const sy = ch * 0.08;
            const ex = cw * (0.25 + 0.5 * ((Math.cos(elapsed * 0.38 + phase * 1.2) + 1) / 2));
            const ey = ch * 0.92;
            const grad = ctx.createLinearGradient(sx, sy, ex, ey);
            grad.addColorStop(0, `rgba(${color.join(',')},0)`);
            grad.addColorStop(0.35, `rgba(${color.join(',')},${alphaBase})`);
            grad.addColorStop(1, `rgba(${color.join(',')},0)`);

            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(sx - spread, sy);
            ctx.lineTo(sx + spread, sy);
            ctx.lineTo(ex + spread * 0.15, ey);
            ctx.lineTo(ex - spread * 0.15, ey);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          };

          const spotlightAlpha = remix.spotlightIntensity * (0.8 + 0.3 * nightFactor);
          sweep(0.2, 90, [255, 224, 166], spotlightAlpha * 0.45);
          sweep(2.2, 70, [178, 230, 255], spotlightAlpha * 0.3);
          if (remix.heroism > 0.34) {
            sweep(4.6, 65, [255, 242, 190], spotlightAlpha * 0.36);
          }

          const reveal = easeOutCubic(clamp((t - curtainStart) / 2200, 0, 1));
          const curtainGap = (cw * 0.52) * reveal;
          const curtainColor = mixColors(['#8f2b26', '#4d1f36', '#923f22'], [0.5, remix.eeriness, remix.heroism * 0.35 + remix.warmth * 0.25]);
          const curtainGradL = ctx.createLinearGradient(0, 0, cw / 2, 0);
          curtainGradL.addColorStop(0, curtainColor);
          curtainGradL.addColorStop(1, 'rgba(25,8,16,0.96)');
          const curtainGradR = ctx.createLinearGradient(cw / 2, 0, cw, 0);
          curtainGradR.addColorStop(0, 'rgba(25,8,16,0.96)');
          curtainGradR.addColorStop(1, curtainColor);

          ctx.save();
          ctx.fillStyle = curtainGradL;
          ctx.fillRect(-2 - curtainGap, 0, cw * 0.52, ch + 2);
          ctx.fillStyle = curtainGradR;
          ctx.fillRect(cw * 0.48 + curtainGap, 0, cw * 0.54 + 2, ch + 2);

          ctx.fillStyle = 'rgba(0,0,0,0.18)';
          for (let i = 0; i < 10; i++) {
            const stripeW = cw * 0.05;
            ctx.fillRect((i * stripeW) - curtainGap * 0.75, 0, stripeW * 0.4, ch);
            ctx.fillRect(cw - (i * stripeW) + curtainGap * 0.75, 0, stripeW * 0.4, ch);
          }

          ctx.fillStyle = 'rgba(90, 17, 18, 0.95)';
          const swagDrop = 14 + Math.sin(elapsed * 1.2) * 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(cw, 0);
          ctx.lineTo(cw, 24);
          for (let x = cw; x >= 0; x -= 32) {
            const y = 22 + Math.sin((x / cw) * Math.PI * 8 + elapsed * 0.5) * swagDrop;
            ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.restore();

          frameRef.current = requestAnimationFrame(draw);
        };

        frameRef.current = requestAnimationFrame(draw);

        return () => {
          cancelAnimationFrame(frameRef.current);
          window.removeEventListener('resize', onResize);
          window.removeEventListener('pointermove', onMove);
        };
      }, [remix, timeMode, curtainStart]);

      const dominant = useMemo(() => {
        const entries = [
          { k: 'Cosy', v: remix.weights.c },
          { k: 'Eerie', v: remix.weights.e },
          { k: 'Heroic', v: remix.weights.h }
        ].sort((a, b) => b.v - a.v);
        return entries[0].k;
      }, [remix]);

      return (
        <div className="app-shell">
          <div className="top">
            <div className="title">
              <h1>Weather Theatre</h1>
              <p>One forecast, three moods. Shift the sliders and restage the same sky as comfort drama, gothic omen, or cinematic triumph.</p>
            </div>
            <div className="badge-row">
              <span className="pill">Dominant Tone: {dominant}</span>
              <span className="pill">Rain Cue: {Math.round(remix.meanRain)}%</span>
              <span className="pill">Wind: {Math.round(remix.meanWind)} mph</span>
            </div>
          </div>

          <div className="theatre">
            <canvas ref={canvasRef} aria-label="Weather theatre stage canvas" />
            <div className="subtitle">{subtitle}</div>
          </div>

          <div className="controls">
            <div className="panel">
              <h3>Direction Board</h3>

              <div className="slider-wrap">
                <div className="slider-line"><strong>Cosy</strong><span>{cosy}</span></div>
                <input type="range" min="0" max="100" value={cosy} onChange={(e) => setCosy(Number(e.target.value))} />
              </div>

              <div className="slider-wrap">
                <div className="slider-line"><strong>Eerie</strong><span>{eerie}</span></div>
                <input type="range" min="0" max="100" value={eerie} onChange={(e) => setEerie(Number(e.target.value))} />
              </div>

              <div className="slider-wrap">
                <div className="slider-line"><strong>Heroic</strong><span>{heroic}</span></div>
                <input type="range" min="0" max="100" value={heroic} onChange={(e) => setHeroic(Number(e.target.value))} />
              </div>
            </div>

            <div className="panel">
              <h3>Lighting Call</h3>
              <div className="toggle">
                <button className={timeMode === 'matinee' ? 'active' : ''} onClick={() => setTimeMode('matinee')}>Matinee</button>
                <button className={timeMode === 'night' ? 'active' : ''} onClick={() => setTimeMode('night')}>Night</button>
              </div>

              <div className="mini">
                <span className="chip">Fog Layer: {Math.round(remix.fogLevel * 100)}%</span>
                <span className="chip">Spotlight: {Math.round(remix.spotlightIntensity * 100)}%</span>
                <span className="chip">Cloud Drift: {remix.cloudSpeed.toFixed(2)}x</span>
              </div>

              <button className="encore" onClick={() => setCurtainStart(performance.now())}>Encore Curtain Reveal</button>
            </div>

            <div className="panel">
              <h3>Mock Forecast</h3>
              <div className="forecast-grid">
                {FORECAST.map((f) => (
                  <div className="forecast-item" key={f.slot}>
                    <b>{f.slot} · {f.icon}</b>
                    {f.temp}°F<br />
                    Wind {f.wind} mph<br />
                    Rain {f.rain}%
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
