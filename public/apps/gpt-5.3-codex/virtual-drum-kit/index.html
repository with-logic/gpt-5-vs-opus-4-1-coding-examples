<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Virtual Drum Kit</title>
  <style>
    :root {
      --bg: #0b1016;
      --panel: #111923;
      --panel-2: #1a2533;
      --text: #e9f1ff;
      --muted: #9cb0c9;
      --accent: #ff6a3d;
      --accent-2: #35d6ff;
      --good: #38d987;
      --warn: #ff4d6d;
      --shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 15% -10%, rgba(53, 214, 255, 0.2), transparent 35%),
        radial-gradient(circle at 88% 8%, rgba(255, 106, 61, 0.17), transparent 40%),
        linear-gradient(180deg, #0b1016 0%, #090d13 100%);
      display: grid;
      place-items: center;
      padding: 18px;
    }

    .app {
      width: min(1100px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 20px;
      box-shadow: var(--shadow);
      overflow: hidden;
      backdrop-filter: blur(3px);
    }

    .top {
      padding: 20px 20px 16px;
      background:
        linear-gradient(90deg, rgba(255,106,61,0.12), transparent 40%),
        linear-gradient(270deg, rgba(53,214,255,0.12), transparent 40%),
        #0f1722;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }

    .title-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px 14px;
      justify-content: space-between;
    }

    h1 {
      margin: 0;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: clamp(1.2rem, 2.6vw, 1.95rem);
    }

    .subtitle {
      margin: 7px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 16px;
    }

    button {
      border: 0;
      border-radius: 12px;
      padding: 11px 16px;
      color: var(--text);
      background: var(--panel-2);
      font-size: 0.95rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      cursor: pointer;
      transition: transform 120ms ease, filter 120ms ease, background 150ms ease;
      min-height: 44px;
      box-shadow: inset 0 -2px 0 rgba(255,255,255,0.06), 0 5px 12px rgba(0,0,0,0.28);
    }

    button:hover { filter: brightness(1.08); }
    button:active { transform: translateY(1px) scale(0.99); }

    .btn-record { background: linear-gradient(180deg, #5e1b2d, #45111f); }
    .btn-record.active { background: linear-gradient(180deg, #a22644, #6f132e); box-shadow: 0 0 0 2px rgba(255,77,109,0.35) inset; }
    .btn-play { background: linear-gradient(180deg, #194f68, #0f3749); }
    .btn-stop { background: linear-gradient(180deg, #5a4b1f, #443712); }
    .btn-clear { background: linear-gradient(180deg, #3d3d3d, #2e2e2e); }

    .status {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      margin-top: 12px;
      font-size: 0.88rem;
      color: var(--muted);
    }

    .chip {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.09);
      border-radius: 999px;
      padding: 6px 10px;
    }

    .chip strong { color: var(--text); }

    .arena {
      position: relative;
      padding: 18px;
      background:
        radial-gradient(circle at 50% 0%, rgba(255,255,255,0.06), transparent 55%),
        linear-gradient(180deg, #0e151f, #0a1119);
    }

    .kit {
      display: grid;
      grid-template-columns: repeat(4, minmax(100px, 1fr));
      gap: 14px;
    }

    .pad {
      position: relative;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      min-height: clamp(88px, 13vw, 130px);
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,0.15), transparent 36%),
        linear-gradient(165deg, #1a2737 0%, #121c29 60%, #0f1722 100%);
      box-shadow: inset 0 -5px 10px rgba(0,0,0,0.38), 0 6px 16px rgba(0,0,0,0.34);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
      text-align: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: transform 100ms ease, box-shadow 110ms ease, border-color 150ms ease;
      cursor: pointer;
      padding: 8px;
    }

    .pad .key {
      font-size: clamp(1.2rem, 4vw, 1.85rem);
      font-weight: 900;
      letter-spacing: 0.08em;
      color: #fff;
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }

    .pad .name {
      font-size: clamp(0.72rem, 1.6vw, 0.86rem);
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #bed1ea;
      font-weight: 700;
    }

    .pad.active {
      transform: translateY(2px) scale(0.985);
      border-color: rgba(53, 214, 255, 0.9);
      box-shadow: 0 0 0 2px rgba(53,214,255,0.32) inset, 0 10px 24px rgba(0,0,0,0.35);
    }

    .pad.record-hit {
      border-color: rgba(255,106,61,0.95);
      box-shadow: 0 0 0 2px rgba(255,106,61,0.38) inset, 0 10px 24px rgba(0,0,0,0.35);
    }

    .footer-note {
      margin-top: 15px;
      color: var(--muted);
      font-size: 0.82rem;
      line-height: 1.45;
    }

    @media (max-width: 860px) {
      .kit {
        grid-template-columns: repeat(2, minmax(130px, 1fr));
      }

      .pad {
        min-height: clamp(102px, 18vw, 145px);
      }
    }

    @media (max-width: 430px) {
      .top, .arena { padding: 14px; }
      .controls { gap: 8px; }
      button { padding: 10px 12px; font-size: 0.88rem; }
      .pad .name { font-size: 0.72rem; }
    }
  </style>
</head>
<body>
  <main class="app" aria-label="Virtual Drum Kit application">
    <section class="top">
      <div class="title-row">
        <div>
          <h1>Virtual Drum Kit</h1>
          <p class="subtitle">Tap pads or use your keyboard to perform. Record your groove and play it back.</p>
        </div>
      </div>
      <div class="controls" role="group" aria-label="Recording controls">
        <button id="recordBtn" class="btn-record" type="button">Start Recording</button>
        <button id="playBtn" class="btn-play" type="button">Play Recording</button>
        <button id="stopBtn" class="btn-stop" type="button">Stop Playback</button>
        <button id="clearBtn" class="btn-clear" type="button">Clear Recording</button>
      </div>
      <div class="status" aria-live="polite">
        <span class="chip">State: <strong id="stateLabel">Idle</strong></span>
        <span class="chip">Recorded hits: <strong id="hitCount">0</strong></span>
        <span class="chip">Length: <strong id="recordLength">0.00s</strong></span>
      </div>
    </section>

    <section class="arena">
      <div id="kit" class="kit" role="grid" aria-label="Drum pads"></div>
      <p class="footer-note">
        Keyboard layout: A S D F G H J K. Audio starts on first tap/click due to browser autoplay policy.
      </p>
    </section>
  </main>

  <script>
    (function () {
      const pads = [
        { key: "A", code: "KeyA", name: "Kick", color: "#ff6a3d", sound: "kick" },
        { key: "S", code: "KeyS", name: "Snare", color: "#35d6ff", sound: "snare" },
        { key: "D", code: "KeyD", name: "Closed Hat", color: "#f4cf5d", sound: "hihat" },
        { key: "F", code: "KeyF", name: "Open Hat", color: "#86f58a", sound: "openhat" },
        { key: "G", code: "KeyG", name: "Low Tom", color: "#ff9e5b", sound: "tomLow" },
        { key: "H", code: "KeyH", name: "Mid Tom", color: "#68b4ff", sound: "tomMid" },
        { key: "J", code: "KeyJ", name: "Clap", color: "#f87ec8", sound: "clap" },
        { key: "K", code: "KeyK", name: "Crash", color: "#ffe07a", sound: "crash" }
      ];

      const kitEl = document.getElementById("kit");
      const recordBtn = document.getElementById("recordBtn");
      const playBtn = document.getElementById("playBtn");
      const stopBtn = document.getElementById("stopBtn");
      const clearBtn = document.getElementById("clearBtn");
      const stateLabel = document.getElementById("stateLabel");
      const hitCount = document.getElementById("hitCount");
      const recordLength = document.getElementById("recordLength");

      let audioCtx = null;
      let master = null;
      let isRecording = false;
      let isPlaying = false;
      let recordStartTime = 0;
      let recordedEvents = [];
      let recordDuration = 0;
      let activePlayTimers = [];

      function ensureAudio() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          master = audioCtx.createGain();
          master.gain.value = 0.92;
          master.connect(audioCtx.destination);
        }
        if (audioCtx.state === "suspended") audioCtx.resume();
      }

      function clamp(v, min, max) {
        return Math.min(max, Math.max(min, v));
      }

      function makeNoiseBuffer(duration = 0.22) {
        const length = Math.max(1, Math.floor(duration * audioCtx.sampleRate));
        const buffer = audioCtx.createBuffer(1, length, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        return buffer;
      }

      function makeFilteredNoise(type, frequency, q, start, attack, decay, gainValue) {
        const src = audioCtx.createBufferSource();
        src.buffer = makeNoiseBuffer(attack + decay + 0.05);

        const filter = audioCtx.createBiquadFilter();
        filter.type = type;
        filter.frequency.value = frequency;
        filter.Q.value = q;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.0001, start);
        gain.gain.linearRampToValueAtTime(gainValue, start + attack);
        gain.gain.exponentialRampToValueAtTime(0.0001, start + attack + decay);

        src.connect(filter);
        filter.connect(gain);
        gain.connect(master);

        src.start(start);
        src.stop(start + attack + decay + 0.03);
      }

      function makeTone(freqStart, freqEnd, start, duration, gainValue, type = "sine") {
        const osc = audioCtx.createOscillator();
        osc.type = type;
        osc.frequency.setValueAtTime(freqStart, start);
        osc.frequency.exponentialRampToValueAtTime(Math.max(35, freqEnd), start + duration);

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(gainValue, start);
        gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);

        osc.connect(gain);
        gain.connect(master);

        osc.start(start);
        osc.stop(start + duration + 0.02);
      }

      function playSound(sound) {
        ensureAudio();
        const t = audioCtx.currentTime;

        switch (sound) {
          case "kick": {
            makeTone(150, 40, t, 0.42, 0.95, "sine");
            makeTone(70, 42, t, 0.08, 0.22, "triangle");
            break;
          }
          case "snare": {
            makeFilteredNoise("highpass", 1400, 0.9, t, 0.002, 0.17, 0.58);
            makeTone(210, 130, t, 0.11, 0.33, "triangle");
            break;
          }
          case "hihat": {
            makeFilteredNoise("highpass", 7200, 0.7, t, 0.001, 0.07, 0.33);
            break;
          }
          case "openhat": {
            makeFilteredNoise("highpass", 6000, 0.6, t, 0.001, 0.32, 0.29);
            break;
          }
          case "tomLow": {
            makeTone(180, 74, t, 0.28, 0.58, "triangle");
            break;
          }
          case "tomMid": {
            makeTone(260, 120, t, 0.24, 0.52, "triangle");
            break;
          }
          case "clap": {
            makeFilteredNoise("bandpass", 1700, 0.75, t, 0.001, 0.08, 0.31);
            makeFilteredNoise("highpass", 1000, 0.45, t + 0.016, 0.001, 0.08, 0.25);
            makeFilteredNoise("highpass", 900, 0.4, t + 0.031, 0.001, 0.09, 0.2);
            break;
          }
          case "crash": {
            makeFilteredNoise("highpass", 2800, 0.65, t, 0.001, 0.6, 0.36);
            makeTone(420, 160, t, 0.35, 0.12, "sawtooth");
            break;
          }
        }
      }

      function flashPad(padEl, className = "active") {
        padEl.classList.add(className);
        setTimeout(() => padEl.classList.remove(className), className === "active" ? 100 : 130);
      }

      function triggerPadByCode(code, fromPlayback = false) {
        const pad = pads.find((p) => p.code === code);
        if (!pad) return;

        playSound(pad.sound);

        const padEl = document.querySelector(`[data-code="${code}"]`);
        if (padEl) {
          flashPad(padEl, "active");
          if (isRecording && !fromPlayback) flashPad(padEl, "record-hit");
        }

        if (isRecording && !fromPlayback) {
          const time = performance.now() - recordStartTime;
          recordedEvents.push({ code, time });
          recordDuration = Math.max(recordDuration, time);
          updateStats();
        }
      }

      function setStateLabel() {
        if (isPlaying) {
          stateLabel.textContent = "Playing";
          stateLabel.style.color = "var(--accent-2)";
          return;
        }
        if (isRecording) {
          stateLabel.textContent = "Recording";
          stateLabel.style.color = "var(--warn)";
          return;
        }
        stateLabel.textContent = "Idle";
        stateLabel.style.color = "var(--text)";
      }

      function updateStats() {
        hitCount.textContent = String(recordedEvents.length);
        recordLength.textContent = `${(recordDuration / 1000).toFixed(2)}s`;
      }

      function stopPlayback() {
        activePlayTimers.forEach((id) => clearTimeout(id));
        activePlayTimers = [];
        isPlaying = false;
        playBtn.disabled = false;
        stopBtn.disabled = true;
        setStateLabel();
      }

      function playback() {
        if (!recordedEvents.length) return;
        stopPlayback();
        isPlaying = true;
        playBtn.disabled = true;
        stopBtn.disabled = false;
        setStateLabel();

        const maxDelay = recordedEvents[recordedEvents.length - 1].time;

        recordedEvents.forEach((ev) => {
          const timer = setTimeout(() => triggerPadByCode(ev.code, true), ev.time);
          activePlayTimers.push(timer);
        });

        const endTimer = setTimeout(stopPlayback, maxDelay + 260);
        activePlayTimers.push(endTimer);
      }

      function toggleRecord() {
        if (isRecording) {
          isRecording = false;
          recordBtn.textContent = "Start Recording";
          recordBtn.classList.remove("active");
          recordDuration = recordedEvents.length ? recordedEvents[recordedEvents.length - 1].time : 0;
        } else {
          stopPlayback();
          isRecording = true;
          recordedEvents = [];
          recordDuration = 0;
          recordStartTime = performance.now();
          recordBtn.textContent = "Stop Recording";
          recordBtn.classList.add("active");
        }
        updateStats();
        setStateLabel();
      }

      function clearRecording() {
        stopPlayback();
        isRecording = false;
        recordedEvents = [];
        recordDuration = 0;
        recordBtn.textContent = "Start Recording";
        recordBtn.classList.remove("active");
        updateStats();
        setStateLabel();
      }

      function renderPads() {
        const frag = document.createDocumentFragment();

        pads.forEach((pad) => {
          const el = document.createElement("button");
          el.type = "button";
          el.className = "pad";
          el.dataset.code = pad.code;
          el.dataset.key = pad.key;
          el.setAttribute("role", "gridcell");
          el.setAttribute("aria-label", `${pad.name} pad, key ${pad.key}`);
          el.innerHTML = `<span class="key">${pad.key}</span><span class="name">${pad.name}</span>`;
          el.style.borderColor = "rgba(255,255,255,0.12)";
          el.style.boxShadow += `, inset 0 0 0 1px ${pad.color}33`;

          let suppressClickUntil = 0;
          const fire = () => triggerPadByCode(pad.code, false);
          el.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            suppressClickUntil = performance.now() + 350;
            fire();
          });
          el.addEventListener("click", () => {
            if (performance.now() < suppressClickUntil) return;
            fire();
          });

          frag.appendChild(el);
        });

        kitEl.appendChild(frag);
      }

      document.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        const code = e.code;
        if (!pads.some((p) => p.code === code)) return;
        e.preventDefault();
        triggerPadByCode(code, false);
      });

      recordBtn.addEventListener("click", toggleRecord);
      playBtn.addEventListener("click", playback);
      stopBtn.addEventListener("click", stopPlayback);
      clearBtn.addEventListener("click", clearRecording);

      stopBtn.disabled = true;
      renderPads();
      updateStats();
      setStateLabel();

      // Gentle idle pulse to add "studio hardware" liveliness.
      let pulse = 0;
      setInterval(() => {
        pulse += 0.05;
        const glow = 0.18 + (Math.sin(pulse) + 1) * 0.03;
        document.documentElement.style.setProperty("--ambient", glow.toFixed(3));
      }, 80);
    })();
  </script>
</body>
</html>
