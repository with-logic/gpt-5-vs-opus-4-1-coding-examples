<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cloud Painter</title>
  <style>
    :root {
      --sky-top: #94cfff;
      --sky-mid: #b7e7ff;
      --sky-bottom: #e6f8ff;
      --panel: rgba(255, 255, 255, 0.78);
      --panel-strong: rgba(255, 255, 255, 0.9);
      --ink: #38506d;
      --accent: #6db7ff;
      --accent-2: #ffb8d0;
      --shadow: rgba(72, 122, 166, 0.22);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Trebuchet MS", "Segoe UI", "Comic Sans MS", sans-serif;
      color: var(--ink);
      background: linear-gradient(180deg, var(--sky-top), var(--sky-bottom));
    }

    .app {
      position: relative;
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      padding: 14px;
    }

    .toolbar {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      width: min(980px, calc(100vw - 20px));
      padding: 12px 14px;
      border-radius: 22px;
      background: var(--panel);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.65);
      box-shadow: 0 8px 24px var(--shadow);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px 14px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 190px;
    }

    .logo {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 30%, #fff 0 28%, #ffe6a3 38%, #ffd77a 100%);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.7), 0 3px 9px rgba(255,190,77,0.45);
      animation: pulse 2.4s ease-in-out infinite;
    }

    .title {
      margin: 0;
      font-size: 1.28rem;
      letter-spacing: 0.5px;
    }

    .subtitle {
      margin: 0;
      font-size: 0.78rem;
      opacity: 0.86;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      flex: 1;
      justify-content: flex-end;
    }

    .group {
      background: var(--panel-strong);
      border: 1px solid rgba(255, 255, 255, 0.8);
      border-radius: 14px;
      padding: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: inset 0 0 0 1px rgba(168, 210, 255, 0.35);
    }

    .shape-btn, .action-btn {
      border: none;
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 700;
      font-size: 0.84rem;
      color: var(--ink);
      background: linear-gradient(180deg, #f9fdff, #e5f3ff);
      box-shadow: 0 2px 5px rgba(98, 145, 190, 0.22);
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.18s ease;
      user-select: none;
      touch-action: manipulation;
    }

    .shape-btn:hover, .action-btn:hover { transform: translateY(-1px); }
    .shape-btn:active, .action-btn:active { transform: translateY(1px) scale(0.98); }

    .shape-btn.active {
      background: linear-gradient(180deg, #bfe6ff, #93d0ff);
      box-shadow: 0 0 0 2px #ffffff, 0 5px 12px rgba(73, 145, 202, 0.3);
    }

    .action-btn.save {
      background: linear-gradient(180deg, #ffeaf3, #ffd5e8);
    }

    .action-btn.clear {
      background: linear-gradient(180deg, #fff7d9, #ffe9a6);
    }

    label {
      font-size: 0.76rem;
      font-weight: 700;
      white-space: nowrap;
      opacity: 0.88;
      margin-left: 2px;
    }

    .slider {
      appearance: none;
      width: 90px;
      height: 8px;
      border-radius: 999px;
      background: linear-gradient(90deg, #d5ebff, #b7dfff);
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid #fff;
      background: #7bbfff;
      box-shadow: 0 2px 6px rgba(53, 113, 163, 0.4);
      cursor: pointer;
    }

    #canvasWrap {
      width: min(1200px, 100%);
      height: min(780px, 100%);
      margin-top: 86px;
      border-radius: 24px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.55);
      box-shadow: 0 16px 36px rgba(70, 125, 170, 0.25);
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: none;
      touch-action: none;
    }

    .hint {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 8;
      background: rgba(255, 255, 255, 0.68);
      border-radius: 999px;
      padding: 7px 12px;
      font-weight: 700;
      font-size: 0.75rem;
      letter-spacing: 0.2px;
      border: 1px solid rgba(255,255,255,0.8);
      box-shadow: 0 4px 10px rgba(61, 119, 165, 0.2);
      pointer-events: none;
      animation: bob 2.8s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes bob {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(-4px); }
    }

    @media (max-width: 860px) {
      .toolbar { padding: 10px; }
      .title { font-size: 1.05rem; }
      .subtitle { display: none; }
      .controls { justify-content: flex-start; }
      .slider { width: 72px; }
      #canvasWrap { margin-top: 122px; }
      .shape-btn, .action-btn { padding: 7px 8px; font-size: 0.78rem; }
      .hint { font-size: 0.7rem; bottom: 10px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="toolbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1 class="title">Cloud Painter</h1>
          <p class="subtitle">Paint the sky with dreamy clouds</p>
        </div>
      </div>

      <div class="controls">
        <div class="group" id="shapeGroup" aria-label="Brush shapes">
          <button class="shape-btn active" data-shape="puff">Puff</button>
          <button class="shape-btn" data-shape="swirl">Swirl</button>
          <button class="shape-btn" data-shape="star">Star</button>
          <button class="shape-btn" data-shape="heart">Heart</button>
        </div>

        <div class="group">
          <label for="size">Size</label>
          <input class="slider" id="size" type="range" min="12" max="90" value="44" />
        </div>

        <div class="group">
          <label for="soft">Soft</label>
          <input class="slider" id="soft" type="range" min="25" max="100" value="85" />
        </div>

        <div class="group">
          <button class="action-btn clear" id="clearBtn">Clear</button>
          <button class="action-btn save" id="saveBtn">Save Image</button>
        </div>
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="scene" aria-label="Painting sky canvas"></canvas>
      <div class="hint">Click, drag, or tap to paint clouds ☁️</div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('scene');
      const wrap = document.getElementById('canvasWrap');
      const ctx = canvas.getContext('2d');

      const sizeEl = document.getElementById('size');
      const softEl = document.getElementById('soft');
      const clearBtn = document.getElementById('clearBtn');
      const saveBtn = document.getElementById('saveBtn');
      const shapeGroup = document.getElementById('shapeGroup');

      const state = {
        width: 0,
        height: 0,
        dpr: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
        pointer: { x: 0, y: 0, down: false, seen: false },
        currentShape: 'puff',
        stamps: [],
        planes: [],
        ambientClouds: [],
        lastDrawX: 0,
        lastDrawY: 0,
        lastFrame: performance.now(),
        drawCooldown: 0,
      };

      function resize() {
        const rect = wrap.getBoundingClientRect();
        state.width = Math.floor(rect.width);
        state.height = Math.floor(rect.height);
        canvas.width = Math.floor(state.width * state.dpr);
        canvas.height = Math.floor(state.height * state.dpr);
        ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
      }

      function rand(min, max) { return Math.random() * (max - min) + min; }

      function initScene() {
        state.stamps = [];
        state.ambientClouds = Array.from({ length: 14 }, () => ({
          x: rand(-120, state.width + 120),
          y: rand(30, state.height * 0.55),
          size: rand(24, 84),
          speed: rand(8, 24),
          alpha: rand(0.2, 0.45),
        }));

        state.planes = Array.from({ length: 4 }, (_, i) => spawnPlane(i * 0.25));
      }

      function spawnPlane(offset = 0) {
        const fromLeft = Math.random() > 0.35;
        const scale = rand(0.58, 1.05);
        const yBase = rand(60, state.height * 0.62);
        return {
          fromLeft,
          x: fromLeft ? rand(-state.width * 0.6, -80) - offset * state.width : rand(state.width + 80, state.width * 1.5) + offset * state.width,
          y: yBase,
          speed: rand(26, 54),
          scale,
          tilt: rand(-0.08, 0.08),
          bobSeed: rand(0, Math.PI * 2),
          hueShift: rand(-8, 8),
        };
      }

      function brushSize() { return Number(sizeEl.value); }
      function brushSoftness() { return Number(softEl.value) / 100; }

      function addStamp(x, y, power = 1) {
        const size = brushSize() * rand(0.82, 1.15) * power;
        state.stamps.push({
          x,
          y,
          baseX: x,
          size,
          shape: state.currentShape,
          alpha: (0.26 + brushSoftness() * 0.6) * rand(0.85, 1.15),
          drift: rand(3, 16),
          wobbleAmp: rand(1, 8),
          wobbleFreq: rand(0.4, 1.7),
          wobbleSeed: rand(0, Math.PI * 2),
          born: performance.now(),
        });

        if (state.stamps.length > 1800) {
          state.stamps.splice(0, state.stamps.length - 1800);
        }
      }

      function drawPuff(x, y, size, alpha) {
        ctx.save();
        ctx.globalAlpha = alpha;
        const puffs = 5;
        for (let i = 0; i < puffs; i++) {
          const angle = (Math.PI * 2 * i) / puffs + rand(-0.4, 0.4);
          const r = size * rand(0.16, 0.36);
          const px = x + Math.cos(angle) * size * rand(0.15, 0.38);
          const py = y + Math.sin(angle) * size * rand(0.08, 0.28);
          const g = ctx.createRadialGradient(px, py, r * 0.12, px, py, r);
          g.addColorStop(0, 'rgba(255,255,255,0.95)');
          g.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(px, py, r, 0, Math.PI * 2);
          ctx.fill();
        }
        const gMain = ctx.createRadialGradient(x, y, size * 0.15, x, y, size * 0.78);
        gMain.addColorStop(0, 'rgba(255,255,255,0.95)');
        gMain.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gMain;
        ctx.beginPath();
        ctx.ellipse(x, y, size * 0.7, size * 0.5, rand(-0.2, 0.2), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawSwirl(x, y, size, alpha) {
        ctx.save();
        ctx.globalAlpha = alpha * 0.9;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const spins = 2.9;
        const maxT = Math.PI * 2 * spins;
        ctx.strokeStyle = 'rgba(255,255,255,0.88)';
        ctx.lineWidth = Math.max(2, size * 0.12);
        ctx.beginPath();
        for (let t = 0; t <= maxT; t += 0.18) {
          const ratio = t / maxT;
          const radius = ratio * size * 0.58;
          const px = x + Math.cos(t) * radius;
          const py = y + Math.sin(t) * radius * 0.85;
          if (t === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();

        const glow = ctx.createRadialGradient(x, y, size * 0.1, x, y, size * 0.7);
        glow.addColorStop(0, 'rgba(255,255,255,0.7)');
        glow.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(x, y, size * 0.72, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawStar(x, y, size, alpha) {
        ctx.save();
        ctx.globalAlpha = alpha;
        const spikes = 5;
        const outer = size * 0.62;
        const inner = size * 0.26;
        let rot = -Math.PI / 2;
        const step = Math.PI / spikes;
        ctx.beginPath();
        for (let i = 0; i < spikes; i++) {
          const ox = x + Math.cos(rot) * outer;
          const oy = y + Math.sin(rot) * outer;
          ctx.lineTo(ox, oy);
          rot += step;
          const ix = x + Math.cos(rot) * inner;
          const iy = y + Math.sin(rot) * inner;
          ctx.lineTo(ix, iy);
          rot += step;
        }
        ctx.closePath();
        const g = ctx.createRadialGradient(x, y, size * 0.08, x, y, size * 0.85);
        g.addColorStop(0, 'rgba(255,255,255,0.92)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();
      }

      function drawHeart(x, y, size, alpha) {
        ctx.save();
        ctx.globalAlpha = alpha * 0.95;
        const s = size * 0.5;
        ctx.beginPath();
        ctx.moveTo(x, y + s * 0.54);
        ctx.bezierCurveTo(x - s * 1.05, y - s * 0.2, x - s * 0.66, y - s * 1.05, x, y - s * 0.3);
        ctx.bezierCurveTo(x + s * 0.66, y - s * 1.05, x + s * 1.05, y - s * 0.2, x, y + s * 0.54);
        const g = ctx.createRadialGradient(x, y - s * 0.1, s * 0.1, x, y, s * 1.2);
        g.addColorStop(0, 'rgba(255,255,255,0.95)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();
      }

      function drawCloudShape(shape, x, y, size, alpha) {
        if (shape === 'swirl') drawSwirl(x, y, size, alpha);
        else if (shape === 'star') drawStar(x, y, size, alpha);
        else if (shape === 'heart') drawHeart(x, y, size, alpha);
        else drawPuff(x, y, size, alpha);
      }

      function drawBackground(t) {
        const grad = ctx.createLinearGradient(0, 0, 0, state.height);
        grad.addColorStop(0, '#8fcfff');
        grad.addColorStop(0.56, '#bde9ff');
        grad.addColorStop(1, '#eaf9ff');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, state.width, state.height);

        const sunX = state.width * 0.86;
        const sunY = state.height * 0.16;
        const pulse = (Math.sin(t * 0.0014) + 1) * 0.5;

        const sunGlow = ctx.createRadialGradient(sunX, sunY, 20, sunX, sunY, 140 + pulse * 25);
        sunGlow.addColorStop(0, 'rgba(255, 244, 179, 0.95)');
        sunGlow.addColorStop(1, 'rgba(255, 244, 179, 0)');
        ctx.fillStyle = sunGlow;
        ctx.beginPath();
        ctx.arc(sunX, sunY, 170, 0, Math.PI * 2);
        ctx.fill();

        const horizon = ctx.createLinearGradient(0, state.height * 0.72, 0, state.height);
        horizon.addColorStop(0, 'rgba(255,255,255,0)');
        horizon.addColorStop(1, 'rgba(255,255,255,0.55)');
        ctx.fillStyle = horizon;
        ctx.fillRect(0, state.height * 0.62, state.width, state.height * 0.4);
      }

      function drawAmbientCloud(c) {
        const yScale = 0.74;
        const baseAlpha = c.alpha;
        const r = c.size;

        ctx.save();
        for (let i = 0; i < 3; i++) {
          const cx = c.x + (i - 1) * r * 0.45;
          const cy = c.y + Math.abs(i - 1) * r * 0.08;
          const gr = ctx.createRadialGradient(cx, cy, r * 0.2, cx, cy, r);
          gr.addColorStop(0, `rgba(255,255,255,${baseAlpha})`);
          gr.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = gr;
          ctx.beginPath();
          ctx.ellipse(cx, cy, r * (0.65 - i * 0.07), r * yScale * (0.74 - i * 0.05), 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawPlane(p, t) {
        const bob = Math.sin(t * 0.0012 + p.bobSeed) * 5;
        const x = p.x;
        const y = p.y + bob;

        ctx.save();
        ctx.translate(x, y);
        const dir = p.fromLeft ? 1 : -1;
        ctx.scale(dir, 1);
        ctx.rotate(p.tilt + Math.sin(t * 0.001 + p.bobSeed) * 0.03);

        const s = 26 * p.scale;

        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 1.6;
        ctx.beginPath();
        ctx.moveTo(-s * 2.2, 0);
        ctx.lineTo(-s * 3.7, -s * 0.25);
        ctx.stroke();

        ctx.fillStyle = `hsl(${205 + p.hueShift} 85% 73%)`;
        ctx.beginPath();
        ctx.moveTo(-s * 0.5, -s * 0.24);
        ctx.lineTo(s * 1.05, 0);
        ctx.lineTo(-s * 0.5, s * 0.24);
        ctx.lineTo(-s * 0.72, s * 0.06);
        ctx.lineTo(-s * 0.72, -s * 0.06);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#f4fbff';
        ctx.beginPath();
        ctx.ellipse(-s * 0.18, 0, s * 0.86, s * 0.24, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#86cbff';
        ctx.beginPath();
        ctx.ellipse(s * 0.26, 0, s * 0.28, s * 0.14, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#7ebcf5';
        ctx.beginPath();
        ctx.moveTo(-s * 0.16, -s * 0.06);
        ctx.lineTo(-s * 0.64, -s * 0.62);
        ctx.lineTo(-s * 0.2, -s * 0.18);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(-s * 0.1, s * 0.08);
        ctx.lineTo(-s * 0.76, s * 0.58);
        ctx.lineTo(-s * 0.22, s * 0.18);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawPointerCursor() {
        if (!state.pointer.seen) return;
        const s = brushSize() * 0.5;
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.strokeStyle = 'rgba(69, 122, 171, 0.85)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(state.pointer.x, state.pointer.y, s, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.beginPath();
        ctx.arc(state.pointer.x, state.pointer.y, s, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function animate(now) {
        const dt = Math.min(0.033, (now - state.lastFrame) / 1000);
        state.lastFrame = now;

        drawBackground(now);

        for (const c of state.ambientClouds) {
          c.x += c.speed * dt;
          if (c.x > state.width + c.size * 1.2) {
            c.x = -c.size * 1.2;
            c.y = rand(30, state.height * 0.58);
            c.size = rand(24, 84);
            c.alpha = rand(0.2, 0.46);
            c.speed = rand(8, 24);
          }
          drawAmbientCloud(c);
        }

        for (const stamp of state.stamps) {
          stamp.baseX += stamp.drift * dt;
          if (stamp.baseX > state.width + stamp.size) stamp.baseX = -stamp.size;
          const age = (now - stamp.born) * 0.001;
          const yOffset = Math.sin(age * stamp.wobbleFreq + stamp.wobbleSeed) * stamp.wobbleAmp;
          drawCloudShape(stamp.shape, stamp.baseX, stamp.y + yOffset, stamp.size, stamp.alpha);
        }

        for (let i = 0; i < state.planes.length; i++) {
          const p = state.planes[i];
          const dir = p.fromLeft ? 1 : -1;
          p.x += dir * p.speed * dt;
          const offLeft = p.x < -220;
          const offRight = p.x > state.width + 220;
          if ((p.fromLeft && offRight) || (!p.fromLeft && offLeft)) {
            state.planes[i] = spawnPlane();
          } else {
            drawPlane(p, now);
          }
        }

        if (state.pointer.down) {
          state.drawCooldown -= dt;
          if (state.drawCooldown <= 0) {
            const dx = state.pointer.x - state.lastDrawX;
            const dy = state.pointer.y - state.lastDrawY;
            const dist = Math.hypot(dx, dy);
            const step = Math.max(8, brushSize() * 0.26);
            const count = Math.max(1, Math.floor(dist / step));
            for (let i = 1; i <= count; i++) {
              const t = i / count;
              addStamp(state.lastDrawX + dx * t, state.lastDrawY + dy * t, rand(0.9, 1.05));
            }
            state.lastDrawX = state.pointer.x;
            state.lastDrawY = state.pointer.y;
            state.drawCooldown = 0.014;
          }
        }

        drawPointerCursor();

        requestAnimationFrame(animate);
      }

      function handlePointer(e) {
        const rect = canvas.getBoundingClientRect();
        state.pointer.x = Math.max(0, Math.min(state.width, e.clientX - rect.left));
        state.pointer.y = Math.max(0, Math.min(state.height, e.clientY - rect.top));
        state.pointer.seen = true;
      }

      canvas.addEventListener('pointerdown', (e) => {
        handlePointer(e);
        state.pointer.down = true;
        state.lastDrawX = state.pointer.x;
        state.lastDrawY = state.pointer.y;
        addStamp(state.pointer.x, state.pointer.y, 1.1);
        canvas.setPointerCapture(e.pointerId);
      });

      canvas.addEventListener('pointermove', (e) => {
        handlePointer(e);
      });

      canvas.addEventListener('pointerup', () => {
        state.pointer.down = false;
      });
      canvas.addEventListener('pointercancel', () => {
        state.pointer.down = false;
      });
      canvas.addEventListener('pointerleave', () => {
        if (!state.pointer.down) state.pointer.seen = false;
      });

      shapeGroup.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-shape]');
        if (!btn) return;
        state.currentShape = btn.dataset.shape;
        for (const el of shapeGroup.querySelectorAll('.shape-btn')) {
          el.classList.toggle('active', el === btn);
        }
      });

      clearBtn.addEventListener('click', () => {
        state.stamps = [];
      });

      saveBtn.addEventListener('click', () => {
        const temp = document.createElement('a');
        temp.download = `cloud-painter-${new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-')}.png`;
        temp.href = canvas.toDataURL('image/png');
        temp.click();
      });

      window.addEventListener('resize', () => {
        resize();
        initScene();
      });

      resize();
      initScene();
      requestAnimationFrame((t) => {
        state.lastFrame = t;
        animate(t);
      });
    })();
  </script>
</body>
</html>
