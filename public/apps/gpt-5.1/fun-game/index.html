<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Fun Game</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <style>
      :root {
        color-scheme: dark light;
        --bg-gradient-start: #1b0044;
        --bg-gradient-end: #150e33;
        --accent-pink: #ff4f9a;
        --accent-yellow: #ffd644;
        --accent-cyan: #3cf2ff;
        --accent-green: #54ff9f;
        --danger-red: #ff4b5c;
        --text-main: #fdf9ff;
        --text-soft: #c9c5ff;
        --panel-bg: rgba(9, 6, 25, 0.92);
        --panel-border: rgba(255, 255, 255, 0.12);
        --shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.45);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html,
      body {
        height: 100%;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: radial-gradient(circle at top, #3b1c93 0%, #040010 55%)
          fixed;
        color: var(--text-main);
        display: flex;
        align-items: stretch;
        justify-content: center;
        padding: 16px;
      }

      .game-shell {
        margin: auto;
        width: 100%;
        max-width: 1040px;
        background: linear-gradient(
            145deg,
            rgba(255, 255, 255, 0.04),
            rgba(20, 8, 70, 0.9)
          );
        border-radius: 24px;
        border: 1px solid var(--panel-border);
        box-shadow: var(--shadow-soft);
        padding: 18px 18px 20px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        backdrop-filter: blur(18px);
      }

      .game-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .title-block {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .title-icon {
        width: 40px;
        height: 40px;
        border-radius: 16px;
        background: conic-gradient(
          from 210deg,
          #ff4f9a,
          #ffd644,
          #3cf2ff,
          #54ff9f,
          #ff4f9a
        );
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 18px rgba(255, 79, 154, 0.7);
      }

      .title-icon-inner {
        width: 60%;
        height: 60%;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 20%, #fff, #ffe083);
        position: relative;
      }

      .title-icon-inner::before,
      .title-icon-inner::after {
        content: "";
        position: absolute;
        top: 32%;
        width: 18%;
        height: 18%;
        border-radius: 50%;
        background: #1e0039;
      }

      .title-icon-inner::before {
        left: 22%;
      }

      .title-icon-inner::after {
        right: 22%;
      }

      .title-text-main {
        font-size: 1.5rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        font-weight: 800;
        color: var(--accent-yellow);
        text-shadow: 0 0 14px rgba(255, 213, 83, 0.9);
        line-height: 1.1;
      }

      .title-sub {
        font-size: 0.85rem;
        color: var(--text-soft);
      }

      .title-text {
        display: flex;
        flex-direction: column;
      }

      .scoreboard {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .pill {
        border-radius: 999px;
        padding: 6px 12px 6px 10px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: radial-gradient(
          circle at 0 0,
          rgba(255, 215, 128, 0.25),
          rgba(9, 5, 40, 0.95)
        );
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.35);
        font-size: 0.85rem;
        white-space: nowrap;
      }

      .pill-label {
        opacity: 0.8;
      }

      .pill-value {
        font-weight: 700;
        letter-spacing: 0.04em;
      }

      .pill.highlight {
        background: radial-gradient(
          circle at 10% 0,
          rgba(255, 79, 154, 0.6),
          rgba(7, 8, 36, 0.98)
        );
        border-color: rgba(255, 173, 224, 0.6);
      }

      .pill.speed {
        background: radial-gradient(
          circle at 10% 0,
          rgba(60, 242, 255, 0.6),
          rgba(7, 8, 36, 0.98)
        );
        border-color: rgba(142, 245, 255, 0.6);
      }

      .pill-status-dot {
        width: 7px;
        height: 7px;
        border-radius: 999px;
        background: var(--accent-green);
        box-shadow: 0 0 10px rgba(84, 255, 159, 0.9);
      }

      .pill-status-dot.paused {
        background: #ffb84f;
        box-shadow: 0 0 9px rgba(255, 184, 79, 0.9);
      }

      .pill-status-dot.over {
        background: var(--danger-red);
        box-shadow: 0 0 9px rgba(255, 75, 92, 0.9);
      }

      .retry-chip {
        border-radius: 999px;
        padding: 5px 11px;
        background: radial-gradient(
          circle at 0 0,
          rgba(255, 255, 255, 0.24),
          rgba(11, 16, 45, 0.98)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        display: inline-flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        font-size: 0.82rem;
        user-select: none;
        transition: transform 0.12s ease-out, box-shadow 0.12s ease-out,
          background 0.12s ease-out;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
      }

      .retry-chip:hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.43);
      }

      .retry-chip-icon {
        width: 16px;
        height: 16px;
        border-radius: 999px;
        background: radial-gradient(circle at 30% 20%, #fff, #ffd644);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
      }

      .game-wrapper {
        position: relative;
        border-radius: 20px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: radial-gradient(circle at 10% -10%, #4522a0, #070318);
        box-shadow: 0 22px 40px rgba(0, 0, 0, 0.65);
        touch-action: none;
      }

      .game-wrapper.shake {
        animation: shake 0.32s cubic-bezier(0.36, 0.07, 0.19, 0.97);
      }

      @keyframes shake {
        10%,
        90% {
          transform: translate3d(-2px, 0, 0);
        }
        20%,
        80% {
          transform: translate3d(4px, 0, 0);
        }
        30%,
        50%,
        70% {
          transform: translate3d(-6px, 0, 0);
        }
        40%,
        60% {
          transform: translate3d(6px, 0, 0);
        }
      }

      #gameCanvas {
        display: block;
        width: 100%;
        max-height: min(70vh, 600px);
        background: transparent;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }

      .overlay-inner {
        pointer-events: auto;
        max-width: 420px;
        width: min(90%, 420px);
        padding: 18px 18px 16px;
        border-radius: 18px;
        background: radial-gradient(
            circle at top,
            rgba(255, 255, 255, 0.24),
            rgba(6, 3, 23, 0.96)
          ),
          linear-gradient(
            135deg,
            rgba(255, 79, 154, 0.6),
            rgba(60, 242, 255, 0.2)
          );
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 0 18px 45px rgba(0, 0, 0, 0.75);
        text-align: center;
      }

      .overlay.hidden {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.18s ease-out;
      }

      .overlay:not(.hidden) {
        opacity: 1;
        transition: opacity 0.24s ease-out;
      }

      .overlay-title {
        font-size: 1.4rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-weight: 800;
        color: var(--accent-yellow);
        text-shadow: 0 0 14px rgba(255, 197, 90, 0.9);
        margin-bottom: 6px;
      }

      .overlay-subtitle {
        font-size: 0.9rem;
        color: var(--text-main);
        opacity: 0.9;
        margin-bottom: 10px;
      }

      .overlay-scores {
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-bottom: 10px;
        flex-wrap: wrap;
        font-size: 0.85rem;
      }

      .overlay-score-box {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.55);
        background: rgba(9, 5, 40, 0.78);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.6);
      }

      .overlay-cta {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 8px;
      }

      .primary-btn {
        border: none;
        outline: none;
        cursor: pointer;
        border-radius: 999px;
        padding: 9px 20px;
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        background: linear-gradient(120deg, #ff4f9a, #ffd644);
        color: #18052e;
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.65);
        transition: transform 0.12s ease-out, box-shadow 0.12s ease-out,
          filter 0.12s ease-out;
      }

      .primary-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.84);
        filter: brightness(1.08);
      }

      .primary-btn:active {
        transform: translateY(0px) scale(0.98);
        box-shadow: 0 12px 22px rgba(0, 0, 0, 0.7);
      }

      .hint-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 6px;
        font-size: 0.8rem;
        color: var(--text-soft);
      }

      .kbd {
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.5);
        padding: 2px 7px;
        background: rgba(0, 0, 0, 0.4);
        font-size: 0.78rem;
        display: inline-flex;
        align-items: center;
        gap: 2px;
      }

      .touch-badge {
        border-radius: 10px;
        padding: 2px 10px;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: rgba(0, 0, 0, 0.45);
        font-size: 0.78rem;
      }

      .game-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 4px;
        font-size: 0.78rem;
        color: var(--text-soft);
        gap: 6px;
        flex-wrap: wrap;
      }

      .footer-tip {
        opacity: 0.8;
      }

      .footer-keys {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }

      .badge-pill {
        border-radius: 999px;
        padding: 2px 9px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(4, 2, 19, 0.9);
      }

      .badge-pill strong {
        color: var(--accent-cyan);
      }

      @keyframes scoreFlash {
        0% {
          transform: scale(1);
          text-shadow: 0 0 0 rgba(255, 214, 68, 0.7);
        }
        40% {
          transform: scale(1.2);
          text-shadow: 0 0 18px rgba(255, 214, 68, 1);
        }
        100% {
          transform: scale(1);
          text-shadow: 0 0 0 rgba(255, 214, 68, 0.7);
        }
      }

      .score-flash {
        animation: scoreFlash 0.55s ease-out;
      }

      @media (max-width: 640px) {
        .game-shell {
          padding: 12px 10px 14px;
          border-radius: 18px;
        }

        .game-header {
          flex-direction: column;
          align-items: stretch;
        }

        .scoreboard {
          justify-content: space-between;
        }

        .title-text-main {
          font-size: 1.2rem;
        }

        .overlay-inner {
          padding: 16px 12px 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-shell" aria-label="Fun Game runner">
      <header class="game-header">
        <div class="title-block">
          <div class="title-icon" aria-hidden="true">
            <div class="title-icon-inner"></div>
          </div>
          <div class="title-text">
            <div class="title-text-main">Fun Game</div>
            <div class="title-sub">Jump the sillies, chase the rainbow score.</div>
          </div>
        </div>
        <div class="scoreboard" aria-label="Scoreboard">
          <div class="pill">
            <div
              id="statusDot"
              class="pill-status-dot paused"
              aria-hidden="true"
            ></div>
            <span class="pill-label">Status</span>
            <span id="statusLabel" class="pill-value">Ready</span>
          </div>
          <div class="pill">
            <span class="pill-label">Score</span>
            <span id="scoreLabel" class="pill-value">0</span>
          </div>
          <div class="pill highlight" id="highScorePill">
            <span class="pill-label">High&nbsp;Score</span>
            <span id="highScoreLabel" class="pill-value">0</span>
          </div>
          <div class="pill speed">
            <span class="pill-label">Speed</span>
            <span id="speedLabel" class="pill-value">1.0x</span>
          </div>
          <button
            id="retryChip"
            class="retry-chip"
            type="button"
            aria-label="Retry game"
          >
            <div class="retry-chip-icon">↻</div>
            <span>Retry</span>
          </button>
        </div>
      </header>

      <div class="game-wrapper" id="gameWrapper">
        <canvas
          id="gameCanvas"
          role="img"
          aria-label="Cartoon runner dodging obstacles"
        ></canvas>

        <div class="overlay" id="overlay">
          <div class="overlay-inner" id="overlayInner">
            <div class="overlay-title" id="overlayTitle">Fun Game</div>
            <div class="overlay-subtitle" id="overlaySubtitle">
              Jump over wobbly obstacles, stay on your tiny planet as long as you can.
            </div>
            <div class="overlay-scores">
              <div class="overlay-score-box">
                <span>Last score: </span
                ><strong id="overlayLastScore">0</strong>
              </div>
              <div class="overlay-score-box">
                <span>Best: </span><strong id="overlayBestScore">0</strong>
              </div>
            </div>
            <div class="overlay-cta">
              <button id="primaryButton" class="primary-btn" type="button">
                Tap / Space to play
              </button>
              <div class="hint-row">
                <div>
                  <span class="kbd"><span>Space</span></span>
                  <span>or</span>
                  <span class="kbd"><span>↑</span></span>
                  <span>to jump</span>
                </div>
                <div class="touch-badge">Tap or click anywhere</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <footer class="game-footer">
        <div class="footer-tip">
          Survive longer, speed up, unlock ridiculously high scores.
        </div>
        <div class="footer-keys">
          <span class="badge-pill">
            Avoid obstacles, <strong>double-jump</strong> if needed.
          </span>
          <span class="badge-pill">
            Funny sounds on jumps, bumps, and wins.
          </span>
        </div>
      </footer>
    </div>

    <script>
      (function () {
        const canvas = document.getElementById("gameCanvas");
        const wrapper = document.getElementById("gameWrapper");
        const overlay = document.getElementById("overlay");
        const overlayTitle = document.getElementById("overlayTitle");
        const overlaySubtitle = document.getElementById("overlaySubtitle");
        const overlayLastScore = document.getElementById("overlayLastScore");
        const overlayBestScore = document.getElementById("overlayBestScore");
        const primaryButton = document.getElementById("primaryButton");
        const scoreLabel = document.getElementById("scoreLabel");
        const highScoreLabel = document.getElementById("highScoreLabel");
        const speedLabel = document.getElementById("speedLabel");
        const highScorePill = document.getElementById("highScorePill");
        const statusDot = document.getElementById("statusDot");
        const statusLabel = document.getElementById("statusLabel");
        const retryChip = document.getElementById("retryChip");

        const GAME_WIDTH = 960;
        const GAME_HEIGHT = 540;
        const GROUND_HEIGHT = 120;
        const HERO_WIDTH = 64;
        const HERO_HEIGHT = 80;
        const GRAVITY = 2100;
        const JUMP_VELOCITY = -1050;
        const DOUBLE_JUMP_VELOCITY = -900;
        const BASE_SPEED = 360;
        const SPEED_ACCEL = 26;
        const MAX_SPEED = 980;

        let ctx;
        let hero;
        let obstacles;
        let particles;
        let lastTimestamp = 0;
        let elapsed = 0;
        let spawnTimer = 0;
        let score = 0;
        let highScore = 0;
        let gameState = "ready";
        let cameraX = 0;
        let audioCtx = null;
        let audioUnlocked = false;

        function initCanvas() {
          const dpr = window.devicePixelRatio || 1;
          canvas.width = GAME_WIDTH * dpr;
          canvas.height = GAME_HEIGHT * dpr;
          ctx = canvas.getContext("2d");
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function createHero() {
          const groundY = GAME_HEIGHT - GROUND_HEIGHT;
          return {
            x: 150,
            y: groundY - HERO_HEIGHT,
            width: HERO_WIDTH,
            height: HERO_HEIGHT,
            vy: 0,
            onGround: true,
            jumpsUsed: 0,
            blinkTimer: 0,
            runCycle: 0,
            squash: 0,
          };
        }

        function resetGameState() {
          hero = createHero();
          obstacles = [];
          particles = [];
          lastTimestamp = 0;
          elapsed = 0;
          spawnTimer = 0;
          score = 0;
          cameraX = 0;
          updateScoreLabels();
        }

        function getHighScoreFromStorage() {
          try {
            const saved = localStorage.getItem("fun-game-highscore");
            const value = saved ? Number(saved) : 0;
            if (Number.isFinite(value) && value >= 0) {
              return value;
            }
          } catch (e) {
          }
          return 0;
        }

        function saveHighScore() {
          try {
            localStorage.setItem("fun-game-highscore", String(highScore));
          } catch (e) {
          }
        }

        function unlockAudio() {
          if (audioUnlocked) return;
          if (!audioCtx) {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return;
            audioCtx = new AC();
          }
          if (audioCtx.state === "suspended") {
            audioCtx.resume();
          }
          audioUnlocked = true;
        }

        function playSound(kind) {
          unlockAudio();
          if (!audioCtx || audioCtx.state !== "running") return;

          const now = audioCtx.currentTime;

          function blip(opts) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const frequencyStart = opts.start || 440;
            const frequencyEnd = opts.end || frequencyStart;
            const duration = opts.duration || 0.12;
            const volume = opts.volume || 0.3;
            osc.type = opts.type || "square";
            osc.frequency.setValueAtTime(frequencyStart, now);
            if (frequencyEnd !== frequencyStart) {
              osc.frequency.exponentialRampToValueAtTime(
                frequencyEnd,
                now + duration
              );
            }
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(
              0.001,
              now + duration + 0.02
            );
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + duration + 0.05);
          }

          if (kind === "jump1") {
            blip({
              start: 650,
              end: 1180,
              duration: 0.15,
              volume: 0.26,
              type: "square",
            });
          } else if (kind === "jump2") {
            blip({
              start: 480,
              end: 920,
              duration: 0.18,
              volume: 0.25,
              type: "triangle",
            });
          } else if (kind === "hit") {
            blip({
              start: 220,
              end: 80,
              duration: 0.22,
              volume: 0.32,
              type: "sawtooth",
            });
            setTimeout(function () {
              blip({
                start: 120,
                end: 220,
                duration: 0.16,
                volume: 0.18,
                type: "square",
              });
            }, 60);
          } else if (kind === "start") {
            blip({
              start: 420,
              end: 880,
              duration: 0.25,
              volume: 0.28,
              type: "triangle",
            });
          } else if (kind === "record") {
            blip({
              start: 660,
              end: 1320,
              duration: 0.2,
              volume: 0.26,
              type: "square",
            });
            setTimeout(function () {
              blip({
                start: 990,
                end: 1480,
                duration: 0.18,
                volume: 0.26,
                type: "square",
              });
            }, 110);
          }
        }

        function worldSpeed() {
          const s = BASE_SPEED + elapsed * SPEED_ACCEL;
          return s > MAX_SPEED ? MAX_SPEED : s;
        }

        function updateScoreLabels() {
          scoreLabel.textContent = Math.floor(score).toString();
          highScoreLabel.textContent = Math.floor(highScore).toString();
          const speedMultiplier =
            Math.round((worldSpeed() / BASE_SPEED) * 10) / 10;
          speedLabel.textContent = speedMultiplier.toFixed(1) + "x";
        }

        function setGameStatus(label, mode) {
          statusLabel.textContent = label;
          statusDot.classList.remove("paused", "over");
          if (mode === "paused") {
            statusDot.classList.add("paused");
          } else if (mode === "over") {
            statusDot.classList.add("over");
          }
        }

        function showOverlay(mode) {
          overlay.classList.remove("hidden");
          if (mode === "ready") {
            overlayTitle.textContent = "Fun Game";
            overlaySubtitle.textContent =
              "Jump over neon marshmallows, double-jump when things get silly.";
            overlayLastScore.textContent = "0";
            overlayBestScore.textContent = Math.floor(highScore).toString();
            primaryButton.textContent = "Tap / Space to play";
          } else if (mode === "over") {
            overlayTitle.textContent = "Ouch!";
            overlaySubtitle.textContent =
              "You bonked into a marshmallow. Shake it off and try again.";
            overlayLastScore.textContent = Math.floor(score).toString();
            overlayBestScore.textContent = Math.floor(highScore).toString();
            primaryButton.textContent = "Retry run";
          }
        }

        function hideOverlay() {
          overlay.classList.add("hidden");
        }

        function spawnObstacle() {
          const lane = Math.random();
          const baseHeight = 40 + Math.random() * 50;
          const type = lane < 0.3 ? "tall" : lane < 0.6 ? "double" : "wide";
          const width =
            type === "tall"
              ? 55 + Math.random() * 20
              : type === "double"
              ? 36
              : 80 + Math.random() * 30;
          const groundY = GAME_HEIGHT - GROUND_HEIGHT;
          const height =
            type === "tall" ? baseHeight + 40 : type === "double" ? baseHeight : baseHeight;
          const y = groundY - height;

          obstacles.push({
            x: GAME_WIDTH + 60,
            y: y,
            width: width,
            height: height,
            wobbleOffset: Math.random() * Math.PI * 2,
            type: type,
            passed: false,
          });
        }

        function addDustBurst(x, y, count, dir) {
          for (let i = 0; i < count; i++) {
            const speed = 120 + Math.random() * 200;
            const angle =
              dir === "up"
                ? -Math.PI / 2 + (Math.random() - 0.5) * 0.9
                : Math.PI + (Math.random() - 0.5) * 0.8;
            particles.push({
              x: x,
              y: y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              radius: 3 + Math.random() * 4,
              life: 0.5 + Math.random() * 0.3,
              age: 0,
            });
          }
        }

        function heroJump() {
          if (gameState !== "running") return;
          if (hero.jumpsUsed === 0 && hero.onGround) {
            hero.vy = JUMP_VELOCITY;
            hero.onGround = false;
            hero.jumpsUsed = 1;
            hero.squash = -0.22;
            addDustBurst(
              hero.x + hero.width * 0.35,
              hero.y + hero.height,
              10,
              "up"
            );
            playSound("jump1");
          } else if (hero.jumpsUsed === 1) {
            hero.vy = DOUBLE_JUMP_VELOCITY;
            hero.jumpsUsed = 2;
            hero.squash = -0.28;
            addDustBurst(
              hero.x + hero.width * 0.4,
              hero.y + hero.height * 0.4,
              10,
              "up"
            );
            playSound("jump2");
          }
        }

        function startRun() {
          if (gameState === "running") return;
          if (gameState === "ready") {
            resetGameState();
          }
          gameState = "running";
          hideOverlay();
          setGameStatus("Running", "");
          playSound("start");
        }

        function endRun() {
          if (gameState !== "running") return;
          gameState = "over";
          setGameStatus("Game over", "over");
          wrapper.classList.remove("shake");
          void wrapper.offsetWidth;
          wrapper.classList.add("shake");

          const previousHigh = highScore;
          if (score > highScore) {
            highScore = score;
            saveHighScore();
            highScorePill.classList.add("score-flash");
            setTimeout(function () {
              highScorePill.classList.remove("score-flash");
            }, 600);
            playSound("record");
          } else {
            playSound("hit");
          }
          updateScoreLabels();
          showOverlay("over");

          requestAnimationFrame(function () {
            wrapper.classList.remove("shake");
          });
        }

        function resetFromGameOver() {
          resetGameState();
          gameState = "ready";
          showOverlay("ready");
          setGameStatus("Ready", "paused");
        }

        function rectsOverlap(a, b) {
          return !(
            a.x + a.width < b.x ||
            a.x > b.x + b.width ||
            a.y + a.height < b.y ||
            a.y > b.y + b.height
          );
        }

        function lerp(a, b, t) {
          return a + (b - a) * t;
        }

        function drawRoundedRect(x, y, w, h, r) {
          const radius = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + w - radius, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
          ctx.lineTo(x + w, y + h - radius);
          ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
          ctx.lineTo(x + radius, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
        }

        function drawBackground() {
          const w = GAME_WIDTH;
          const h = GAME_HEIGHT;
          const groundY = h - GROUND_HEIGHT;

          const grd = ctx.createLinearGradient(0, 0, 0, h);
          grd.addColorStop(0, "#3b1c93");
          grd.addColorStop(0.3, "#20175a");
          grd.addColorStop(1, "#07061c");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, w, h);

          const sunX = lerp(
            w * 0.2,
            w * 0.8,
            0.5 + Math.sin(elapsed * 0.2) * 0.2
          );
          const sunY = h * 0.22;
          const sunR = 60;
          const radial = ctx.createRadialGradient(
            sunX,
            sunY,
            5,
            sunX,
            sunY,
            sunR
          );
          radial.addColorStop(0, "rgba(255, 255, 255, 0.98)");
          radial.addColorStop(0.4, "rgba(255, 236, 162, 0.98)");
          radial.addColorStop(1, "rgba(255, 145, 204, 0)");
          ctx.fillStyle = radial;
          ctx.beginPath();
          ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
          ctx.fill();

          ctx.save();
          ctx.globalAlpha = 0.6;
          ctx.strokeStyle = "rgba(255,255,255,0.12)";
          ctx.lineWidth = 1;
          for (let i = 0; i < 40; i++) {
            const twinkleX =
              ((i * 71 + cameraX * 0.4) % (w + 100)) - 50;
            const twinkleY = 40 + ((i * 53) % (groundY - 80));
            const size = 1 + ((i * 13) % 2);
            ctx.beginPath();
            ctx.moveTo(twinkleX - size, twinkleY);
            ctx.lineTo(twinkleX + size, twinkleY);
            ctx.moveTo(twinkleX, twinkleY - size);
            ctx.lineTo(twinkleX, twinkleY + size);
            ctx.stroke();
          }
          ctx.restore();

          function drawHills(color, amp, freq, speedFactor, offsetY) {
            ctx.fillStyle = color;
            ctx.beginPath();
            const scroll = (cameraX * speedFactor) % w;
            const startX = -scroll - w;
            ctx.moveTo(startX, groundY + 100);
            for (let x = startX; x <= startX + w * 3; x += 8) {
              const nx = x / w;
              const y =
                groundY +
                offsetY -
                Math.sin(nx * freq * Math.PI * 2) * amp;
              ctx.lineTo(x, y);
            }
            ctx.lineTo(startX + w * 3, groundY + 100);
            ctx.closePath();
            ctx.fill();
          }

          drawHills("#28154f", 40, 0.9, 0.2, -40);
          drawHills("#321869", 55, 1.1, 0.35, -26);
          drawHills("#43238a", 65, 1.6, 0.5, -10);

          const planetGrad = ctx.createLinearGradient(
            0,
            groundY - 30,
            0,
            h
          );
          planetGrad.addColorStop(0, "#281729");
          planetGrad.addColorStop(0.5, "#161328");
          planetGrad.addColorStop(1, "#05010a");
          ctx.fillStyle = planetGrad;
          ctx.fillRect(0, groundY - 12, w, h - groundY + 40);

          const stripeWidth = 90;
          const stripeOffset = (cameraX * 0.9) % stripeWidth;
          ctx.save();
          ctx.beginPath();
          ctx.rect(0, groundY - 8, w, h - groundY + 30);
          ctx.clip();
          for (let x = -stripeWidth * 2; x < w + stripeWidth * 2; x += stripeWidth) {
            const stripeX = x - stripeOffset;
            const grad = ctx.createLinearGradient(
              stripeX,
              groundY,
              stripeX + stripeWidth,
              groundY
            );
            grad.addColorStop(0, "rgba(255,79,154,0.85)");
            grad.addColorStop(0.5, "rgba(255,214,68,0.9)");
            grad.addColorStop(1, "rgba(60,242,255,0.85)");
            ctx.fillStyle = grad;
            ctx.fillRect(
              stripeX,
              groundY - 8,
              stripeWidth * 0.6,
              10
            );
          }
          ctx.restore();
        }

        function drawHero() {
          const baseX = hero.x;
          const baseY = hero.y;
          const squashScaleY = 1 + hero.squash * 0.6;
          const squashScaleX = 1 - hero.squash * 0.35;
          const centerX = baseX + hero.width / 2;
          const centerY = baseY + hero.height / 2;

          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.scale(squashScaleX, squashScaleY);
          ctx.translate(-centerX, -centerY);

          const t = hero.runCycle;
          const bounce =
            hero.onGround && gameState === "running"
              ? Math.sin(t * 12) * 4
              : 0;

          const bodyX = baseX + 10;
          const bodyY = baseY + 20 + bounce;
          const bodyW = hero.width - 20;
          const bodyH = hero.height - 30;

          const bodyGrad = ctx.createLinearGradient(
            bodyX,
            bodyY,
            bodyX,
            bodyY + bodyH
          );
          bodyGrad.addColorStop(0, "#ff4f9a");
          bodyGrad.addColorStop(0.5, "#ff9a62");
          bodyGrad.addColorStop(1, "#ffd644");
          drawRoundedRect(bodyX, bodyY, bodyW, bodyH, 18);
          ctx.fillStyle = bodyGrad;
          ctx.fill();

          ctx.fillStyle = "rgba(255,255,255,0.16)";
          drawRoundedRect(bodyX, bodyY + 6, bodyW * 0.5, 18, 12);
          ctx.fill();

          const headR = 22;
          const headX = baseX + hero.width / 2;
          const headY = baseY + 14 + bounce;
          const headGrad = ctx.createRadialGradient(
            headX - 6,
            headY - 8,
            4,
            headX,
            headY,
            headR
          );
          headGrad.addColorStop(0, "#fff8d9");
          headGrad.addColorStop(1, "#ffd27c");
          ctx.fillStyle = headGrad;
          ctx.beginPath();
          ctx.arc(headX, headY, headR, 0, Math.PI * 2);
          ctx.fill();

          const eyeOffsetY = -4;
          const eyeOffsetX = 8;
          const blink =
            Math.abs(Math.sin(hero.blinkTimer * 9.2)) > 0.94
              ? 0.2
              : 1;
          ctx.fillStyle = "#22052a";
          function drawEye(dx) {
            ctx.beginPath();
            ctx.ellipse(
              headX + dx,
              headY + eyeOffsetY,
              3.4,
              4.6 * blink,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(
              headX + dx - 0.8,
              headY + eyeOffsetY - 1.4,
              1.3,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.fillStyle = "#22052a";
          }
          drawEye(-eyeOffsetX);
          drawEye(eyeOffsetX);

          ctx.strokeStyle = "#22052a";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(headX - 6, headY + 6);
          ctx.quadraticCurveTo(
            headX,
            headY + 11,
            headX + 8,
            headY + 6
          );
          ctx.stroke();

          const hairColor = "#ff7bd8";
          ctx.fillStyle = hairColor;
          ctx.beginPath();
          ctx.moveTo(headX - headR, headY - 6);
          ctx.quadraticCurveTo(
            headX - 6,
            headY - headR - 8,
            headX + 2,
            headY - 8
          );
          ctx.quadraticCurveTo(
            headX + 12,
            headY - headR + 4,
            headX + headR - 3,
            headY - 2
          );
          ctx.lineTo(headX + headR - 3, headY - headR + 8);
          ctx.quadraticCurveTo(
            headX,
            headY - headR - 6,
            headX - headR,
            headY - 3
          );
          ctx.closePath();
          ctx.fill();

          const tLeg = hero.runCycle * 14;
          const legSwing = hero.onGround
            ? Math.sin(tLeg) * 11
            : 4;

          function drawLeg(side) {
            const base = {
              x: baseX + (side < 0 ? 16 : hero.width - 16),
              y: baseY + hero.height - 12,
            };
            const knee = {
              x: base.x + legSwing * (side < 0 ? -0.16 : 0.16),
              y: base.y + 16 + legSwing * 0.1,
            };
            const foot = {
              x: base.x + legSwing * (side < 0 ? -0.4 : 0.4),
              y: base.y + 32,
            };
            ctx.strokeStyle = "#2af7ff";
            ctx.lineWidth = 5;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(base.x, base.y);
            ctx.lineTo(knee.x, knee.y);
            ctx.lineTo(foot.x, foot.y);
            ctx.stroke();

            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.ellipse(
              foot.x,
              foot.y + 4,
              9,
              5,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.fillStyle = "#ff4f9a";
            ctx.beginPath();
            ctx.ellipse(
              foot.x,
              foot.y + 4,
              9,
              5,
              0,
              0,
              Math.PI * 2
            );
            ctx.globalAlpha *= 0.7;
            ctx.fill();
            ctx.globalAlpha /= 0.7;
          }
          drawLeg(-1);
          drawLeg(1);

          const armSwing = hero.onGround
            ? Math.sin(tLeg + Math.PI) * 9
            : 5;
          function drawArm(side) {
            const base = {
              x: bodyX + (side < 0 ? 2 : bodyW - 2),
              y: bodyY + 18,
            };
            const elbow = {
              x: base.x + armSwing * 0.3 * (side < 0 ? -1 : 1),
              y: base.y + 14,
            };
            const hand = {
              x: base.x + armSwing * 0.6 * (side < 0 ? -1 : 1),
              y: base.y + 30,
            };
            ctx.strokeStyle = "#ffd27c";
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(base.x, base.y);
            ctx.lineTo(elbow.x, elbow.y);
            ctx.lineTo(hand.x, hand.y);
            ctx.stroke();

            ctx.fillStyle = "#ffd27c";
            ctx.beginPath();
            ctx.arc(hand.x, hand.y + 1, 5, 0, Math.PI * 2);
            ctx.fill();
          }
          drawArm(-1);
          drawArm(1);

          ctx.restore();
        }

        function drawObstacle(obstacle) {
          const { x, y, width, height, wobbleOffset, type } = obstacle;
          const t = elapsed * 6 + wobbleOffset;
          const wobble = Math.sin(t) * 4;

          const cx = x + width / 2;
          const cy = y + height / 2;
          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate((wobble * Math.PI) / 720);
          ctx.translate(-cx, -cy);

          let grad = ctx.createLinearGradient(
            x,
            y,
            x,
            y + height
          );
          if (type === "tall") {
            grad.addColorStop(0, "#3cf2ff");
            grad.addColorStop(1, "#2474ff");
          } else if (type === "double") {
            grad.addColorStop(0, "#ff9a62");
            grad.addColorStop(1, "#ff4f9a");
          } else {
            grad.addColorStop(0, "#54ff9f");
            grad.addColorStop(1, "#15c776");
          }
          drawRoundedRect(x, y, width, height, 16);
          ctx.fillStyle = grad;
          ctx.fill();

          const faceY = y + height * 0.35;
          const faceCenterX = x + width / 2;
          const eyeSpacing = Math.min(10, width * 0.18);
          const blink =
            Math.abs(Math.sin(t * 1.7)) > 0.85
              ? 0.2
              : 1;
          ctx.fillStyle = "#120222";
          function drawObstacleEye(dx) {
            ctx.beginPath();
            ctx.ellipse(
              faceCenterX + dx,
              faceY,
              3,
              4 * blink,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
          drawObstacleEye(-eyeSpacing);
          drawObstacleEye(eyeSpacing);

          ctx.beginPath();
          ctx.moveTo(faceCenterX - 6, faceY + 10);
          ctx.quadraticCurveTo(
            faceCenterX,
            faceY + 15 + Math.sin(t) * 2,
            faceCenterX + 6,
            faceY + 10
          );
          ctx.strokeStyle = "#120222";
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.restore();
        }

        function drawParticles(dt) {
          ctx.save();
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.age += dt;
            if (p.age >= p.life) {
              particles.splice(i, 1);
              continue;
            }
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += GRAVITY * 0.3 * dt;
            const t = p.age / p.life;
            const alpha = 1 - t;
            ctx.globalAlpha = alpha * 0.8;
            ctx.fillStyle = t < 0.4 ? "#ffd644" : "#ff9a62";
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * (1 - t * 0.4), 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        function update(delta) {
          const dt = Math.min(delta, 0.05);
          if (gameState === "running") {
            const speed = worldSpeed();
            elapsed += dt;
            cameraX += speed * dt;

            hero.vy += GRAVITY * dt;
            hero.y += hero.vy * dt;
            const groundY = GAME_HEIGHT - GROUND_HEIGHT;
            if (hero.y + hero.height >= groundY) {
              if (!hero.onGround) {
                addDustBurst(
                  hero.x + hero.width * 0.5,
                  groundY,
                  9,
                  "up"
                );
              }
              hero.y = groundY - hero.height;
              hero.vy = 0;
              hero.onGround = true;
              hero.jumpsUsed = 0;
            } else {
              hero.onGround = false;
            }

            hero.runCycle += dt * (2 + speed / 160);
            hero.blinkTimer += dt;
            hero.squash = lerp(hero.squash, 0, 0.18);

            spawnTimer -= dt;
            const spawnInterval =
              1.05 - Math.min(0.7, elapsed * 0.04);
            if (spawnTimer <= 0) {
              spawnObstacle();
              spawnTimer = spawnInterval + Math.random() * 0.4;
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
              const ob = obstacles[i];
              ob.x -= speed * dt;

              if (!ob.passed && ob.x + ob.width < hero.x) {
                ob.passed = true;
                score += 5;
                scoreLabel.classList.add("score-flash");
                setTimeout(function () {
                  scoreLabel.classList.remove("score-flash");
                }, 420);
              }

              if (ob.x + ob.width < -80) {
                obstacles.splice(i, 1);
              }
            }

            const heroBounds = {
              x: hero.x + 10,
              y: hero.y + 10,
              width: hero.width - 22,
              height: hero.height - 18,
            };
            for (let i = 0; i < obstacles.length; i++) {
              const ob = obstacles[i];
              const obBounds = {
                x: ob.x + 4,
                y: ob.y + 4,
                width: ob.width - 8,
                height: ob.height - 6,
              };
              if (rectsOverlap(heroBounds, obBounds)) {
                endRun();
                break;
              }
            }

            score += dt * (8 + speed / 50);
            updateScoreLabels();
          }

          drawBackground();
          drawHero();
          for (let i = 0; i < obstacles.length; i++) {
            drawObstacle(obstacles[i]);
          }
          drawParticles(dt);
        }

        function gameLoop(timestamp) {
          if (!lastTimestamp) {
            lastTimestamp = timestamp;
          }
          const delta = (timestamp - lastTimestamp) / 1000;
          lastTimestamp = timestamp;
          update(delta);
          requestAnimationFrame(gameLoop);
        }

        function onPrimaryAction() {
          unlockAudio();
          if (gameState === "ready") {
            startRun();
          } else if (gameState === "running") {
            heroJump();
          } else if (gameState === "over") {
            resetFromGameOver();
            setTimeout(function () {
              startRun();
            }, 60);
          }
        }

        function onRetryChip() {
          unlockAudio();
          if (gameState === "running") {
            endRun();
          }
          resetFromGameOver();
        }

        function onKeyDown(e) {
          if (
            e.code === "Space" ||
            e.code === "ArrowUp" ||
            e.code === "KeyW"
          ) {
            e.preventDefault();
            unlockAudio();
            if (gameState === "ready") {
              startRun();
              setTimeout(heroJump, 30);
            } else if (gameState === "running") {
              heroJump();
            } else if (gameState === "over") {
              resetFromGameOver();
              setTimeout(function () {
                startRun();
                setTimeout(heroJump, 30);
              }, 40);
            }
          } else if (e.code === "KeyR") {
            e.preventDefault();
            onRetryChip();
          }
        }

        function onPointerDown(e) {
          e.preventDefault();
          onPrimaryAction();
        }

        function init() {
          initCanvas();
          highScore = getHighScoreFromStorage();
          resetGameState();
          gameState = "ready";
          showOverlay("ready");
          setGameStatus("Ready", "paused");
          updateScoreLabels();

          primaryButton.addEventListener("click", onPrimaryAction);
          retryChip.addEventListener("click", onRetryChip);
          window.addEventListener("keydown", onKeyDown);
          wrapper.addEventListener("pointerdown", onPointerDown);

          requestAnimationFrame(gameLoop);
        }

        if (document.readyState === "complete" || document.readyState === "interactive") {
          init();
        } else {
          document.addEventListener("DOMContentLoaded", init);
        }
      })();
    </script>
  </body>
</html>

