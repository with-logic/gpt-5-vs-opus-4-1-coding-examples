<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Asteroid Outrider</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #1b2940, #050811 55%, #000000);
        color: #f4f7ff;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
          "Segoe UI", sans-serif;
      }

      body {
        display: flex;
        align-items: stretch;
        justify-content: stretch;
      }

      #gameCanvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        background: transparent;
      }

      #overlay {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 18px 22px;
        pointer-events: none;
      }

      .top-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        text-shadow: 0 0 6px rgba(0, 0, 0, 0.85);
        mix-blend-mode: screen;
      }

      .title {
        font-weight: 800;
        letter-spacing: 0.16em;
        font-size: clamp(17px, 2.6vw, 22px);
        text-transform: uppercase;
        color: #9ddcff;
      }

      .title span.accent {
        color: #ff9df2;
      }

      .badges {
        display: flex;
        gap: 8px;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.15em;
      }

      .badge {
        border-radius: 999px;
        padding: 2px 10px;
        border: 1px solid rgba(158, 220, 255, 0.4);
        background: linear-gradient(
          120deg,
          rgba(7, 18, 39, 0.9),
          rgba(12, 35, 68, 0.6)
        );
        backdrop-filter: blur(10px);
        box-shadow: 0 0 12px rgba(18, 180, 255, 0.35);
      }

      .stats {
        display: flex;
        align-items: center;
        gap: 14px;
        font-size: 13px;
      }

      .stat-label {
        opacity: 0.75;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      .stat-value {
        font-variant-numeric: tabular-nums;
        font-weight: 600;
      }

      #score {
        color: #ffe58a;
      }

      #best {
        color: #9dffcf;
      }

      #lives {
        color: #ff9da3;
      }

      .bottom-bar {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 16px;
        font-size: 12px;
        color: rgba(244, 247, 255, 0.88);
        text-shadow: 0 0 7px rgba(0, 0, 0, 0.9);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 12px;
        max-width: 70vw;
      }

      .controls span {
        opacity: 0.85;
      }

      .key {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 18px;
        padding: 1px 5px;
        margin: 0 2px;
        border-radius: 4px;
        border: 1px solid rgba(230, 238, 255, 0.55);
        background: rgba(8, 10, 24, 0.8);
        box-shadow: 0 0 0 1px rgba(8, 155, 255, 0.3),
          0 0 8px rgba(0, 0, 0, 0.9);
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.14em;
      }

      #statusLine {
        font-size: 12px;
        opacity: 0.9;
        letter-spacing: 0.14em;
        text-transform: uppercase;
      }

      #centerMessage {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        font-family: inherit;
        text-align: center;
        text-transform: uppercase;
        text-shadow: 0 0 12px rgba(0, 0, 0, 0.95);
        letter-spacing: 0.25em;
        font-weight: 800;
        color: #f6f7ff;
        font-size: clamp(20px, 2.8vw, 32px);
        padding-bottom: 30px;
        transition: opacity 0.25s ease-out, transform 0.25s ease-out;
      }

      #centerMessage.hidden {
        opacity: 0;
        transform: translateY(12px);
      }

      #centerMessage small {
        display: block;
        margin-top: 14px;
        font-size: 11px;
        letter-spacing: 0.22em;
        color: #c7d3ff;
      }

      .float-tip {
        position: absolute;
        left: 50%;
        bottom: 15%;
        transform: translateX(-50%);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.16em;
        opacity: 0.84;
        text-shadow: 0 0 8px rgba(0, 0, 0, 0.95);
      }

      .float-tip span {
        color: #9ddcff;
      }

      @media (max-width: 640px) {
        #overlay {
          padding: 10px 10px 16px;
        }
        .top-bar {
          align-items: flex-start;
          flex-direction: column;
          gap: 10px;
        }
        .stats {
          gap: 10px;
        }
        .bottom-bar {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }
        .controls {
          max-width: 100%;
        }
        #centerMessage {
          padding: 0 22px 40px;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="overlay">
      <div class="top-bar">
        <div class="title">
          ASTEROID <span class="accent">OUTRIDER</span>
          <div class="badges">
            <div class="badge">Rogue Sector: Epsilon Rift</div>
            <div class="badge">Solo Patrol Prototype</div>
          </div>
        </div>
        <div class="stats">
          <div>
            <div class="stat-label">Score</div>
            <div id="score" class="stat-value">0</div>
          </div>
          <div>
            <div class="stat-label">Best Run</div>
            <div id="best" class="stat-value">0</div>
          </div>
          <div>
            <div class="stat-label">Lives</div>
            <div id="lives" class="stat-value">3</div>
          </div>
        </div>
      </div>
      <div class="bottom-bar">
        <div class="controls">
          <span
            ><span class="key">W</span>/<span class="key">↑</span> Thrust</span
          >
          <span
            ><span class="key">A</span>/<span class="key">D</span> or
            <span class="key">←</span>/<span class="key">→</span> Rotate</span
          >
          <span><span class="key">Space</span> Fire cannons</span>
          <span><span class="key">Shift</span> Boost</span>
          <span><span class="key">P</span> Pause</span>
          <span><span class="key">R</span> Retry after death</span>
        </div>
        <div>
          <div id="statusLine">Press <span class="key">Enter</span> to launch</div>
        </div>
      </div>
      <div id="centerMessage">
        Patrol Briefing<br />
        <small>Enter the Rift &mdash; Survive, Hunt, Adapt</small>
      </div>
      <div class="float-tip">
        Tip: Aim slightly ahead of targets to land hits.
      </div>
    </div>

    <script>
      (function () {
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const scoreEl = document.getElementById("score");
        const bestEl = document.getElementById("best");
        const livesEl = document.getElementById("lives");
        const statusLine = document.getElementById("statusLine");
        const centerMessage = document.getElementById("centerMessage");

        function resizeCanvas() {
          const dpr = window.devicePixelRatio || 1;
          const rect = canvas.getBoundingClientRect();
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();

        const TAU = Math.PI * 2;

        const GAME_STATE = {
          state: "splash", // 'splash' | 'playing' | 'dead' | 'paused'
          lastTime: performance.now(),
          stars: [],
          asteroids: [],
          enemies: [],
          bullets: [],
          particles: [],
          player: null,
          width: () => canvas.clientWidth || window.innerWidth,
          height: () => canvas.clientHeight || window.innerHeight,
          score: 0,
          bestScore: 0,
          lives: 3,
          difficultyTimer: 0,
          asteroidSpawnTimer: 0,
          enemySpawnTimer: 0,
          keys: Object.create(null),
          inputLocked: false,
          screenFlash: 0,
          cameraShake: 0,
        };

        function randRange(min, max) {
          return Math.random() * (max - min) + min;
        }

        function clamp(v, min, max) {
          return v < min ? min : v > max ? max : v;
        }

        function wrapPosition(e, w, h, margin) {
          if (e.x < -margin) e.x += w + margin * 2;
          if (e.x > w + margin) e.x -= w + margin * 2;
          if (e.y < -margin) e.y += h + margin * 2;
          if (e.y > h + margin) e.y -= h + margin * 2;
        }

        function distanceSq(ax, ay, bx, by) {
          const dx = ax - bx;
          const dy = ay - by;
          return dx * dx + dy * dy;
        }

        function playTone(freq, duration, type, volume) {
          try {
            const AudioContext =
              window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            if (!playTone.ctx) {
              playTone.ctx = new AudioContext();
            }
            const ctxA = playTone.ctx;
            const osc = ctxA.createOscillator();
            const gain = ctxA.createGain();
            osc.type = type || "triangle";
            osc.frequency.value = freq;
            gain.gain.value = volume ?? 0.12;
            const now = ctxA.currentTime;
            gain.gain.setValueAtTime(gain.gain.value, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            osc.connect(gain).connect(ctxA.destination);
            osc.start(now);
            osc.stop(now + duration + 0.02);
          } catch (e) {
            // audio is cosmetic; ignore errors
          }
        }

        class Particle {
          constructor(x, y, vx, vy, life, color, size) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.life = life;
            this.maxLife = life;
            this.color = color;
            this.size = size;
          }
          update(dt) {
            this.life -= dt;
            this.x += this.vx * dt;
            this.y += this.vy * dt;
          }
          draw(ctx) {
            const t = clamp(this.life / this.maxLife, 0, 1);
            ctx.save();
            ctx.globalAlpha = t;
            const r = this.size * (0.6 + 0.4 * t);
            const grd = ctx.createRadialGradient(
              this.x,
              this.y,
              0,
              this.x,
              this.y,
              r
            );
            grd.addColorStop(0, this.color);
            grd.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(this.x, this.y, r, 0, TAU);
            ctx.fill();
            ctx.restore();
          }
        }

        class Bullet {
          constructor(x, y, angle, speed, owner, color) {
            const spread = randRange(-0.02, 0.02);
            const a = angle + spread;
            this.x = x;
            this.y = y;
            this.vx = Math.cos(a) * speed;
            this.vy = Math.sin(a) * speed;
            this.life = 1.5;
            this.radius = 3;
            this.owner = owner; // 'player' | 'enemy'
            this.color = color || "#fffbd1";
          }
          update(dt) {
            this.life -= dt;
            this.x += this.vx * dt;
            this.y += this.vy * dt;
          }
          draw(ctx) {
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.x - this.vx * 0.01, this.y - this.vy * 0.01);
            ctx.lineTo(this.x + this.vx * 0.02, this.y + this.vy * 0.02);
            ctx.stroke();
            ctx.restore();
          }
        }

        class Asteroid {
          constructor(x, y, size) {
            this.x = x;
            this.y = y;
            this.size = size; // 3 large, 2 medium, 1 small
            const baseSpeed = size === 3 ? 40 : size === 2 ? 70 : 95;
            const a = randRange(0, TAU);
            const mag = randRange(baseSpeed * 0.8, baseSpeed * 1.3);
            this.vx = Math.cos(a) * mag;
            this.vy = Math.sin(a) * mag;
            this.angle = randRange(0, TAU);
            this.spin = randRange(-0.6, 0.6);
            const baseRadius = size === 3 ? 48 : size === 2 ? 30 : 20;
            this.radius = baseRadius * randRange(0.9, 1.1);
            this.points = [];
            const verts = 9 + Math.floor(Math.random() * 4);
            for (let i = 0; i < verts; i++) {
              const t = (i / verts) * TAU;
              const r = this.radius * randRange(0.7, 1.05);
              this.points.push({ angle: t, radius: r });
            }
          }
          update(dt, w, h) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.angle += this.spin * dt;
            wrapPosition(this, w, h, 60);
          }
          draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.strokeStyle = "rgba(192,205,230,0.92)";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < this.points.length; i++) {
              const p = this.points[i];
              const x = Math.cos(p.angle) * p.radius;
              const y = Math.sin(p.angle) * p.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
          }
        }

        class Ship {
          constructor(x, y, isPlayer) {
            this.x = x;
            this.y = y;
            this.angle = -Math.PI / 2;
            this.vx = 0;
            this.vy = 0;
            this.radius = 18;
            this.isPlayer = isPlayer;
            this.thrustPower = isPlayer ? 220 : 170;
            this.turnSpeed = isPlayer ? 3.5 : 2.4;
            this.drag = 0.9;
            this.shootCooldown = 0;
            this.invuln = 1.3;
            this.boostEnergy = 1;
            this.boosting = false;
            this.ai = null;
            if (!isPlayer) {
              this.radius = 20;
              this.turnSpeed = 2.8;
              this.boostEnergy = 1;
              this.ai = {
                fireCooldown: randRange(0.5, 1.4),
                changeDirTimer: 0,
                preferredDistance: randRange(220, 340),
                strafeDir: Math.random() < 0.5 ? -1 : 1,
              };
            }
          }

          update(dt, state) {
            const w = state.width();
            const h = state.height();
            if (this.shootCooldown > 0) this.shootCooldown -= dt;
            if (this.invuln > 0) this.invuln -= dt;

            if (this.isPlayer) {
              this.updatePlayer(dt, state);
            } else {
              this.updateAI(dt, state);
            }

            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vx *= 1 - (1 - this.drag) * dt * 4;
            this.vy *= 1 - (1 - this.drag) * dt * 4;
            wrapPosition(this, w, h, 40);
          }

          updatePlayer(dt, state) {
            const keys = state.keys;
            let turning = 0;
            if (keys["ArrowLeft"] || keys["KeyA"]) turning -= 1;
            if (keys["ArrowRight"] || keys["KeyD"]) turning += 1;
            this.angle += turning * this.turnSpeed * dt;

            const thrust =
              keys["ArrowUp"] || keys["KeyW"]
                ? 1
                : keys["ArrowDown"] || keys["KeyS"]
                ? -0.5
                : 0;

            const boosting =
              (keys["ShiftLeft"] || keys["ShiftRight"]) && this.boostEnergy > 0;
            this.boosting = boosting && thrust > 0;
            const thrustMult = this.boosting ? 1.9 : 1;
            const power = this.thrustPower * thrustMult * thrust;
            if (thrust !== 0) {
              this.vx += Math.cos(this.angle) * power * dt;
              this.vy += Math.sin(this.angle) * power * dt;
            }

            if (this.boosting) {
              this.boostEnergy -= dt * 0.65;
            } else {
              this.boostEnergy += dt * 0.35;
            }
            this.boostEnergy = clamp(this.boostEnergy, 0, 1);

            const maxSpeed = this.boosting ? 420 : 290;
            const speed = Math.hypot(this.vx, this.vy);
            if (speed > maxSpeed) {
              const k = maxSpeed / speed;
              this.vx *= k;
              this.vy *= k;
            }

            if (keys["Space"]) {
              this.tryShoot(state);
            }
          }

          updateAI(dt, state) {
            const player = state.player;
            if (!player) return;
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            let targetAngle = Math.atan2(dy, dx);
            let diff = ((targetAngle - this.angle + Math.PI) % TAU) - Math.PI;
            const maxTurn = this.turnSpeed * dt;
            diff = clamp(diff, -maxTurn, maxTurn);
            this.angle += diff;

            const dist = Math.hypot(dx, dy);
            const ai = this.ai;
            if (!ai) return;

            ai.changeDirTimer -= dt;
            if (ai.changeDirTimer <= 0) {
              ai.changeDirTimer = randRange(0.7, 1.8);
              ai.strafeDir = Math.random() < 0.5 ? -1 : 1;
              ai.preferredDistance = randRange(220, 360);
            }

            let thrustSign = 0;
            if (dist > ai.preferredDistance + 40) thrustSign = 1;
            else if (dist < ai.preferredDistance - 50) thrustSign = -0.4;

            const strafeAngle =
              this.angle + ai.strafeDir * (Math.PI / 2) * 0.55;
            const thrustPower = this.thrustPower * thrustSign;
            this.vx += Math.cos(this.angle) * thrustPower * dt;
            this.vy += Math.sin(this.angle) * thrustPower * dt;
            this.vx += Math.cos(strafeAngle) * this.thrustPower * 0.3 * dt;
            this.vy += Math.sin(strafeAngle) * this.thrustPower * 0.3 * dt;

            ai.fireCooldown -= dt;
            const facingAccuracy = Math.abs(
              ((Math.atan2(dy, dy && dx) - this.angle + Math.PI) % TAU) - Math.PI
            );
            const angleToPlayer = Math.atan2(dy, dx);
            const aimDiff =
              ((angleToPlayer - this.angle + Math.PI) % TAU) - Math.PI;
            const canFire =
              ai.fireCooldown <= 0 &&
              Math.abs(aimDiff) < 0.22 &&
              dist < 650 &&
              dist > 90;
            if (canFire) {
              this.tryShoot(state, true);
              ai.fireCooldown = randRange(0.6, 1.6);
            }

            const maxSpeed = 310;
            const speed = Math.hypot(this.vx, this.vy);
            if (speed > maxSpeed) {
              const k = maxSpeed / speed;
              this.vx *= k;
              this.vy *= k;
            }
          }

          tryShoot(state, isEnemy) {
            if (this.shootCooldown > 0) return;
            this.shootCooldown = isEnemy ? 0.7 : 0.2;
            const muzzleDist = this.radius + 6;
            const x = this.x + Math.cos(this.angle) * muzzleDist;
            const y = this.y + Math.sin(this.angle) * muzzleDist;
            const speed = isEnemy ? 380 : 520;
            const color = isEnemy ? "#ff767a" : "#fffbd1";
            const bullet = new Bullet(
              x,
              y,
              this.angle,
              speed,
              isEnemy ? "enemy" : "player",
              color
            );
            state.bullets.push(bullet);
            const toneFreq = isEnemy ? 340 : 540;
            playTone(toneFreq, 0.07, "square", isEnemy ? 0.07 : 0.11);
          }

          draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle + Math.PI / 2);
            const shipColor = this.isPlayer
              ? "#9ddcff"
              : "#ff9df2";
            const coreColor = this.isPlayer ? "#ffffff" : "#ffe0ff";
            const glowColor = this.isPlayer ? "#2cf0ff" : "#ff58c0";

            if (this.invuln > 0) {
              const t = this.invuln * 12;
              const flicker = (Math.sin(t) + 1) * 0.5;
              ctx.globalAlpha = 0.3 + flicker * 0.6;
            }

            ctx.lineJoin = "round";
            ctx.lineCap = "round";

            ctx.save();
            ctx.globalAlpha *= 0.9;
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 4.5;
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(14, 14);
            ctx.lineTo(0, 8);
            ctx.lineTo(-14, 14);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();

            ctx.strokeStyle = shipColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(12, 13);
            ctx.lineTo(0, 5);
            ctx.lineTo(-12, 13);
            ctx.closePath();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, -16);
            ctx.lineTo(7, 6);
            ctx.lineTo(0, 1);
            ctx.lineTo(-7, 6);
            ctx.closePath();
            ctx.strokeStyle = coreColor;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, 5);
            ctx.lineTo(7, 15);
            ctx.moveTo(0, 5);
            ctx.lineTo(-7, 15);
            ctx.strokeStyle = "rgba(197,210,255,0.8)";
            ctx.lineWidth = 1.3;
            ctx.stroke();

            if (this.boosting && this.isPlayer) {
              const flick = 0.9 + Math.random() * 0.4;
              const plumeLength = 16 + this.boostEnergy * 18 * flick;
              ctx.save();
              ctx.translate(0, 16);
              ctx.beginPath();
              ctx.moveTo(-6, 0);
              ctx.lineTo(0, plumeLength);
              ctx.lineTo(6, 0);
              ctx.closePath();
              const grd = ctx.createLinearGradient(
                0,
                0,
                0,
                plumeLength
              );
              grd.addColorStop(0, "rgba(255,255,255,0.9)");
              grd.addColorStop(0.4, "rgba(147,233,255,0.9)");
              grd.addColorStop(1, "rgba(0,0,0,0)");
              ctx.fillStyle = grd;
              ctx.fill();
              ctx.restore();
            }

            ctx.restore();
          }
        }

        function spawnStars() {
          GAME_STATE.stars.length = 0;
          const w = GAME_STATE.width();
          const h = GAME_STATE.height();
          const count = Math.floor((w * h) / 9000);
          for (let i = 0; i < count; i++) {
            GAME_STATE.stars.push({
              x: Math.random() * w,
              y: Math.random() * h,
              depth: Math.random() * 0.7 + 0.3,
              radius: Math.random() * 1.5 + 0.4,
              twinkle: Math.random() * TAU,
            });
          }
        }

        spawnStars();

        function resetRun(fullReset) {
          const s = GAME_STATE;
          if (fullReset) {
            s.score = 0;
            s.lives = 3;
            s.asteroids.length = 0;
            s.enemies.length = 0;
            s.bullets.length = 0;
            s.particles.length = 0;
            s.difficultyTimer = 0;
            s.asteroidSpawnTimer = 1.2;
            s.enemySpawnTimer = 4.5;
          }
          const w = s.width();
          const h = s.height();
          s.player = new Ship(w / 2, h / 2, true);
          s.screenFlash = 0;
          s.cameraShake = 0;
          updateHUD();
        }

        function updateHUD() {
          scoreEl.textContent = Math.floor(GAME_STATE.score);
          bestEl.textContent = Math.floor(GAME_STATE.bestScore);
          livesEl.textContent = GAME_STATE.lives;
        }

        function spawnAsteroid() {
          const w = GAME_STATE.width();
          const h = GAME_STATE.height();
          const edge = Math.floor(Math.random() * 4);
          let x, y;
          const margin = 40;
          if (edge === 0) {
            x = Math.random() * w;
            y = -margin;
          } else if (edge === 1) {
            x = w + margin;
            y = Math.random() * h;
          } else if (edge === 2) {
            x = Math.random() * w;
            y = h + margin;
          } else {
            x = -margin;
            y = Math.random() * h;
          }
          const sizeRoll = Math.random();
          const size = sizeRoll < 0.5 ? 3 : sizeRoll < 0.85 ? 2 : 1;
          GAME_STATE.asteroids.push(new Asteroid(x, y, size));
        }

        function spawnEnemy() {
          const w = GAME_STATE.width();
          const h = GAME_STATE.height();
          const edge = Math.floor(Math.random() * 4);
          const margin = 70;
          let x, y;
          if (edge === 0) {
            x = Math.random() * w;
            y = -margin;
          } else if (edge === 1) {
            x = w + margin;
            y = Math.random() * h;
          } else if (edge === 2) {
            x = Math.random() * w;
            y = h + margin;
          } else {
            x = -margin;
            y = Math.random() * h;
          }
          const enemy = new Ship(x, y, false);
          enemy.angle = Math.atan2(
            GAME_STATE.height() / 2 - y,
            GAME_STATE.width() / 2 - x
          );
          GAME_STATE.enemies.push(enemy);
        }

        function explodeAt(x, y, colorMain, colorSecondary, count, power) {
          const s = GAME_STATE;
          for (let i = 0; i < count; i++) {
            const a = randRange(0, TAU);
            const speed = randRange(power * 0.4, power);
            const vx = Math.cos(a) * speed;
            const vy = Math.sin(a) * speed;
            const life = randRange(0.3, 0.8);
            const color =
              Math.random() < 0.5 ? colorMain : colorSecondary || colorMain;
            s.particles.push(
              new Particle(
                x,
                y,
                vx,
                vy,
                life,
                color,
                randRange(6, 16)
              )
            );
          }
          s.cameraShake = Math.min(s.cameraShake + power * 0.004, 18);
          s.screenFlash = Math.min(s.screenFlash + power * 0.0015, 0.22);
        }

        function handleCollisions(dt) {
          const s = GAME_STATE;
          const w = s.width();
          const h = s.height();
          const player = s.player;
          const bullets = s.bullets;
          const asteroids = s.asteroids;
          const enemies = s.enemies;

          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            if (b.life <= 0) {
              bullets.splice(i, 1);
              continue;
            }
            const bx = b.x;
            const by = b.y;

            for (let j = asteroids.length - 1; j >= 0; j--) {
              const a = asteroids[j];
              const rr = (a.radius + b.radius) * (a.radius + b.radius);
              if (distanceSq(bx, by, a.x, a.y) < rr) {
                bullets.splice(i, 1);
                const size = a.size;
                asteroids.splice(j, 1);
                explodeAt(a.x, a.y, "#ffea9a", "#ff9a52", 12 + size * 4, 260);
                const scoreGain = size === 3 ? 60 : size === 2 ? 90 : 130;
                s.score += scoreGain;
                s.bestScore = Math.max(s.bestScore, s.score);
                updateHUD();
                const toneBase = 280 + size * 90;
                playTone(toneBase, 0.09, "sawtooth", 0.15);

                if (size > 1) {
                  const childSize = size - 1;
                  const childCount = 2;
                  for (let n = 0; n < childCount; n++) {
                    const child = new Asteroid(a.x, a.y, childSize);
                    child.vx += randRange(-40, 40);
                    child.vy += randRange(-40, 40);
                    asteroids.push(child);
                  }
                }
                break;
              }
            }

            if (b.owner === "player") {
              for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                const rr = (e.radius + b.radius) * (e.radius + b.radius);
                if (distanceSq(bx, by, e.x, e.y) < rr) {
                  bullets.splice(i, 1);
                  enemies.splice(j, 1);
                  explodeAt(
                    e.x,
                    e.y,
                    "#ff9df2",
                    "#ffd0ff",
                    22,
                    320
                  );
                  s.score += 260;
                  s.bestScore = Math.max(s.bestScore, s.score);
                  updateHUD();
                  playTone(620, 0.11, "square", 0.14);
                  break;
                }
              }
            }
          }

          if (player && s.state === "playing") {
            for (let i = bullets.length - 1; i >= 0; i--) {
              const b = bullets[i];
              if (b.owner === "enemy" && player.invuln <= 0) {
                const rr = (player.radius + b.radius) * (player.radius + b.radius);
                if (distanceSq(player.x, player.y, b.x, b.y) < rr) {
                  bullets.splice(i, 1);
                  damagePlayerAt(player.x, player.y);
                  break;
                }
              }
            }

            if (player.invuln <= 0) {
              for (let i = asteroids.length - 1; i >= 0; i--) {
                const a = asteroids[i];
                const rr = (player.radius + a.radius) * (player.radius + a.radius);
                if (distanceSq(player.x, player.y, a.x, a.y) < rr) {
                  asteroids.splice(i, 1);
                  explodeAt(
                    a.x,
                    a.y,
                    "#ffea9a",
                    "#ff9a52",
                    12 + a.size * 4,
                    280
                  );
                  damagePlayerAt(player.x, player.y);
                  break;
                }
              }

              for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const rr =
                  (player.radius + e.radius) * (player.radius + e.radius);
                if (distanceSq(player.x, player.y, e.x, e.y) < rr) {
                  enemies.splice(i, 1);
                  explodeAt(e.x, e.y, "#ff9df2", "#ffd0ff", 20, 320);
                  damagePlayerAt(player.x, player.y);
                  break;
                }
              }
            }
          }
        }

        function damagePlayerAt(x, y) {
          const s = GAME_STATE;
          explodeAt(x, y, "#9ddcff", "#ffffff", 25, 360);
          playTone(180, 0.22, "sawtooth", 0.18);
          s.lives -= 1;
          s.cameraShake = 24;
          s.screenFlash = 0.3;
          if (s.lives <= 0) {
            s.state = "dead";
            s.inputLocked = false;
            centerMessage.classList.remove("hidden");
            centerMessage.innerHTML =
              "PATROL LOST<br /><small>Press R to Launch Again</small>";
            statusLine.textContent = "You were shredded in the Rift.";
          } else {
            resetRun(false);
            statusLine.textContent = "Hull breach! You were forced to respawn.";
          }
          updateHUD();
        }

        function updateGame(dt) {
          const s = GAME_STATE;
          const w = s.width();
          const h = s.height();

          s.difficultyTimer += dt;
          const diffLevel = 1 + s.difficultyTimer * 0.23;

          s.asteroidSpawnTimer -= dt;
          if (s.asteroidSpawnTimer <= 0) {
            spawnAsteroid();
            s.asteroidSpawnTimer = clamp(1.7 - diffLevel * 0.12, 0.4, 1.7);
          }

          s.enemySpawnTimer -= dt;
          if (s.enemySpawnTimer <= 0) {
            spawnEnemy();
            s.enemySpawnTimer = clamp(6.5 - diffLevel * 0.35, 2.1, 7.0);
          }

          const baseScoreRate = 18;
          s.score += baseScoreRate * dt;
          s.bestScore = Math.max(s.bestScore, s.score);

          if (s.player && s.player.boosting) {
            s.score += baseScoreRate * dt * 0.8;
          }

          for (const star of s.stars) {
            const speed = 10 + star.depth * 40;
            star.y += speed * dt;
            if (star.y > h) {
              star.y = -2;
              star.x = Math.random() * w;
            }
            star.twinkle += dt * (0.8 + star.depth * 1.2);
          }

          if (s.player) {
            s.player.update(dt, s);
          }

          for (const a of s.asteroids) {
            a.update(dt, w, h);
          }
          for (const e of s.enemies) {
            e.update(dt, s);
          }
          for (const b of s.bullets) {
            b.update(dt);
          }
          for (const p of s.particles) {
            p.update(dt);
          }

          s.bullets = s.bullets.filter((b) => b.life > 0);
          s.particles = s.particles.filter((p) => p.life > 0);

          handleCollisions(dt);
          updateHUD();

          if (s.screenFlash > 0) {
            s.screenFlash = Math.max(0, s.screenFlash - dt * 0.8);
          }
          if (s.cameraShake > 0) {
            s.cameraShake = Math.max(0, s.cameraShake - dt * 18);
          }
        }

        function render() {
          const s = GAME_STATE;
          const w = s.width();
          const h = s.height();
          ctx.clearRect(0, 0, w, h);

          ctx.save();
          const grad = ctx.createRadialGradient(
            w * 0.5,
            h * 0.2,
            0,
            w * 0.5,
            h * 0.2,
            Math.max(w, h) * 0.9
          );
          grad.addColorStop(0, "rgba(40,81,135,0.55)");
          grad.addColorStop(0.35, "rgba(15,23,42,0.8)");
          grad.addColorStop(1, "rgba(0,0,0,1)");
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, w, h);
          ctx.restore();

          ctx.save();
          ctx.globalCompositeOperation = "screen";
          for (const star of s.stars) {
            const tw = (Math.sin(star.twinkle) + 1) * 0.5;
            ctx.globalAlpha = 0.3 + tw * 0.7 * star.depth;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, TAU);
            ctx.fillStyle = star.depth > 0.7 ? "#e8f3ff" : "#8fb6ff";
            ctx.fill();
          }
          ctx.restore();

          let offsetX = 0;
          let offsetY = 0;
          if (s.cameraShake > 0) {
            offsetX = randRange(-1, 1) * s.cameraShake;
            offsetY = randRange(-1, 1) * s.cameraShake;
          }
          ctx.save();
          ctx.translate(offsetX, offsetY);

          for (const a of s.asteroids) {
            a.draw(ctx);
          }
          for (const e of s.enemies) {
            e.draw(ctx);
          }
          if (s.player) {
            s.player.draw(ctx);
          }
          for (const b of s.bullets) {
            b.draw(ctx);
          }
          for (const p of s.particles) {
            p.draw(ctx);
          }
          ctx.restore();

          if (s.screenFlash > 0) {
            ctx.save();
            ctx.globalAlpha = s.screenFlash;
            ctx.fillStyle = "rgba(255,255,255,0.9)";
            ctx.fillRect(0, 0, w, h);
            ctx.restore();
          }
        }

        function gameLoop(timestamp) {
          const s = GAME_STATE;
          let dt = (timestamp - s.lastTime) / 1000;
          if (!Number.isFinite(dt) || dt <= 0) dt = 0.016;
          dt = Math.min(dt, 0.04);
          s.lastTime = timestamp;

          if (s.state === "playing") {
            updateGame(dt);
          } else {
            for (const star of s.stars) {
              const w = s.width();
              const h = s.height();
              const speed = 12 + star.depth * 30;
              star.y += speed * dt;
              if (star.y > h) {
                star.y = -2;
                star.x = Math.random() * w;
              }
              star.twinkle += dt * (0.8 + star.depth * 1.2);
            }
          }

          render();
          requestAnimationFrame(gameLoop);
        }

        function startGameFromSplash() {
          const s = GAME_STATE;
          s.state = "playing";
          s.score = 0;
          s.lives = 3;
          s.difficultyTimer = 0;
          s.asteroidSpawnTimer = 0.7;
          s.enemySpawnTimer = 4.0;
          s.asteroids.length = 0;
          s.enemies.length = 0;
          s.bullets.length = 0;
          s.particles.length = 0;
          resetRun(true);
          centerMessage.classList.add("hidden");
          statusLine.textContent = "Stay alive. Thin the field. Hunt smart.";
          playTone(520, 0.18, "triangle", 0.12);
        }

        function togglePause() {
          const s = GAME_STATE;
          if (s.state === "playing") {
            s.state = "paused";
            centerMessage.classList.remove("hidden");
            centerMessage.innerHTML =
              "PAUSED<br /><small>Press P to Resume Patrol</small>";
            statusLine.textContent = "Autopilot engaged; systems on standby.";
          } else if (s.state === "paused") {
            s.state = "playing";
            centerMessage.classList.add("hidden");
            statusLine.textContent = "Back in the Rift. Eyes up.";
          }
        }

        window.addEventListener(
          "keydown",
          (e) => {
            if (
              ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(
                e.code
              )
            ) {
              e.preventDefault();
            }
            GAME_STATE.keys[e.code] = true;

            if (e.code === "Enter") {
              if (GAME_STATE.state === "splash") {
                startGameFromSplash();
              }
            }

            if (e.code === "KeyP") {
              if (GAME_STATE.state === "playing" || GAME_STATE.state === "paused") {
                togglePause();
              }
            }

            if (e.code === "KeyR") {
              if (GAME_STATE.state === "dead") {
                startGameFromSplash();
              }
            }
          },
          { passive: false }
        );

        window.addEventListener("keyup", (e) => {
          GAME_STATE.keys[e.code] = false;
        });

        resetRun(true);
        requestAnimationFrame(gameLoop);
      })();
    </script>
  </body>
</html>

