<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Escape the Maze</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="Escape the Maze - a fast, elegant browser game where you race through a freshly generated maze with arrow keys, chasing the optimal path."
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #020617;
        --bg-elevated: #020617;
        --panel: rgba(15, 23, 42, 0.96);
        --accent: #38bdf8;
        --accent-soft: rgba(56, 189, 248, 0.15);
        --accent-strong: #0ea5e9;
        --accent-2: #8b5cf6;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --danger: #f97373;
        --success: #4ade80;
        --border-subtle: rgba(148, 163, 184, 0.3);
        --maze-wall: #020617;
        --maze-path: #020617;
        --maze-bg: radial-gradient(circle at 0 0, #1d283a 0, #020617 55%);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: radial-gradient(circle at top, #0b1120 0, #020617 55%);
        color: var(--text);
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont,
          'Segoe UI', sans-serif;
        -webkit-font-smoothing: antialiased;
      }

      body {
        display: flex;
        align-items: stretch;
        justify-content: center;
      }

      .app-shell {
        display: flex;
        flex-direction: column;
        width: 100%;
        max-width: 1040px;
        margin: 16px;
        padding: 16px;
        border-radius: 18px;
        background:
          radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), transparent 60%),
          radial-gradient(circle at bottom right, rgba(139, 92, 246, 0.1), transparent 55%),
          linear-gradient(135deg, #020617, #020617);
        box-shadow:
          0 28px 80px rgba(15, 23, 42, 0.85),
          0 0 0 1px rgba(148, 163, 184, 0.2);
      }

      header.app-header {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
        justify-content: space-between;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.3);
        margin-bottom: 12px;
      }

      .title-block {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .app-logo {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        background:
          conic-gradient(from 160deg, #0ea5e9, #22c55e, #a855f7, #0ea5e9);
        position: relative;
        box-shadow:
          0 0 0 1px rgba(15, 23, 42, 0.9),
          0 12px 30px rgba(15, 23, 42, 0.9);
        overflow: hidden;
      }

      .app-logo::after {
        content: '';
        position: absolute;
        inset: 3px;
        border-radius: 10px;
        background:
          radial-gradient(circle at 30% 20%, rgba(248, 250, 252, 0.28), transparent 55%),
          radial-gradient(circle at 80% 80%, rgba(56, 189, 248, 0.3), transparent 55%),
          rgba(15, 23, 42, 0.9);
        box-shadow:
          0 0 0 1px rgba(148, 163, 184, 0.35),
          inset 0 0 0 1px rgba(15, 23, 42, 0.9);
      }

      .app-logo-maze {
        position: absolute;
        inset: 4px;
        border-radius: 9px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(4, 1fr);
        gap: 1px;
        padding: 1px;
      }

      .app-logo-cell {
        border-radius: 1px;
        background-color: rgba(15, 23, 42, 0.85);
      }

      .app-logo-cell.wall {
        background: linear-gradient(145deg, #020617, #020617);
      }

      .app-logo-cell.path {
        background: linear-gradient(145deg, rgba(56, 189, 248, 0.9), rgba(129, 140, 248, 0.8));
      }

      h1.app-title {
        font-size: 1.5rem;
        font-weight: 600;
        letter-spacing: 0.04em;
        display: flex;
        align-items: center;
        gap: 0.35rem;
      }

      .app-title span.sub {
        font-size: 0.85rem;
        font-weight: 400;
        color: var(--muted);
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .app-tag {
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.15), rgba(129, 140, 248, 0.12));
        color: var(--accent);
        border: 1px solid rgba(56, 189, 248, 0.45);
      }

      .header-right {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 8px;
      }

      .header-subtitle {
        font-size: 0.8rem;
        color: var(--muted);
        max-width: 260px;
        text-align: right;
      }

      .shortcut-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 8px;
        border-radius: 999px;
        background-color: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 10px 25px rgba(15, 23, 42, 0.85);
      }

      .keycap {
        min-width: 16px;
        height: 16px;
        border-radius: 4px;
        padding: 0 4px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        font-weight: 500;
        background: radial-gradient(circle at top, #111827, #020617);
        border: 1px solid rgba(148, 163, 184, 0.5);
        box-shadow:
          0 2px 0 rgba(15, 23, 42, 0.95),
          0 0 0 1px rgba(15, 23, 42, 0.9);
      }

      .keycap.arrow {
        font-size: 8px;
      }

      .layout {
        display: grid;
        grid-template-columns: minmax(0, 3fr) minmax(0, 2.25fr);
        gap: 16px;
        align-items: stretch;
      }

      .card {
        border-radius: 18px;
        padding: 14px;
        background: linear-gradient(
          145deg,
          rgba(15, 23, 42, 0.92),
          rgba(15, 23, 42, 0.96)
        );
        border: 1px solid rgba(148, 163, 184, 0.32);
        box-shadow:
          0 20px 55px rgba(15, 23, 42, 0.95),
          inset 0 0 0 1px rgba(15, 23, 42, 0.95);
      }

      .card.main {
        position: relative;
        overflow: hidden;
      }

      .card.main::before {
        content: '';
        position: absolute;
        inset: -40%;
        background:
          radial-gradient(circle at 10% 0%, rgba(56, 189, 248, 0.07), transparent 50%),
          radial-gradient(circle at 80% 110%, rgba(129, 140, 248, 0.08), transparent 60%);
        opacity: 0.95;
        pointer-events: none;
      }

      .card.main-inner {
        position: relative;
        z-index: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .maze-shell {
        position: relative;
        border-radius: 16px;
        padding: 10px;
        background:
          radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.16), transparent 55%),
          radial-gradient(circle at 100% 100%, rgba(129, 140, 248, 0.24), transparent 60%),
          radial-gradient(circle at 50% 50%, #020617, #020617);
        box-shadow:
          inset 0 0 0 1px rgba(15, 23, 42, 0.95),
          0 10px 30px rgba(15, 23, 42, 0.95);
      }

      .maze-shell::after {
        content: '';
        position: absolute;
        inset: 10px;
        border-radius: 14px;
        border: 1px dashed rgba(30, 64, 175, 0.6);
        pointer-events: none;
        opacity: 0.55;
      }

      .maze-canvas-wrap {
        position: relative;
      }

      #mazeCanvas {
        display: block;
        width: 100%;
        height: auto;
        border-radius: 10px;
        background: radial-gradient(circle at center, #020617 0, #020617 50%);
        box-shadow:
          0 0 0 1px rgba(15, 23, 42, 0.95),
          0 26px 60px rgba(15, 23, 42, 0.9);
        cursor: grab;
      }

      #mazeCanvas:active {
        cursor: grabbing;
      }

      .maze-overlay-label {
        position: absolute;
        top: 10px;
        left: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        background-color: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.5);
        font-size: 10px;
        letter-spacing: 0.14em;
        text-transform: uppercase;
        color: var(--muted);
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }

      .maze-overlay-label span.dot {
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: radial-gradient(circle at 30% 30%, #22c55e, #16a34a);
        box-shadow: 0 0 0 6px rgba(34, 197, 94, 0.1);
      }

      .maze-overlay-label span.blink {
        position: relative;
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: radial-gradient(circle at 30% 30%, #f97316, #fb923c);
        animation: ping 1.4s infinite;
      }

      @keyframes ping {
        0% {
          transform: scale(0.85);
          opacity: 1;
        }
        70% {
          transform: scale(1.5);
          opacity: 0;
        }
        100% {
          transform: scale(0.85);
          opacity: 0;
        }
      }

      .maze-status-chip {
        position: absolute;
        right: 12px;
        top: 10px;
        display: flex;
        gap: 6px;
        align-items: center;
      }

      .maze-status-chip span {
        padding: 2px 8px;
        border-radius: 999px;
        background-color: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.5);
        font-size: 10px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .maze-status-chip span.mode {
        border-color: rgba(56, 189, 248, 0.7);
        color: var(--accent);
        background: linear-gradient(
          135deg,
          rgba(56, 189, 248, 0.12),
          rgba(129, 140, 248, 0.12)
        );
      }

      .hud-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
        align-items: center;
        justify-content: space-between;
      }

      .hud-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .pill-metric {
        min-width: 92px;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background-color: rgba(15, 23, 42, 0.9);
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 6px;
        font-size: 11px;
      }

      .pill-metric .label {
        color: var(--muted);
      }

      .pill-metric .value {
        font-variant-numeric: tabular-nums;
        font-weight: 500;
      }

      .pill-metric .value.highlight {
        color: var(--accent);
      }

      .pill-metric .value.good {
        color: var(--success);
      }

      .pill-metric .value.bad {
        color: #facc15;
      }

      .pill-metric .tiny {
        font-size: 9px;
        color: var(--muted);
        margin-left: 4px;
      }

      .controls-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 6px;
      }

      button.btn {
        position: relative;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.45);
        background: radial-gradient(circle at 30% 0%, rgba(56, 189, 248, 0.35), transparent 60%),
          linear-gradient(135deg, #0f172a, #020617);
        color: var(--text);
        padding: 6px 14px;
        font-size: 0.8rem;
        font-weight: 500;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        outline: none;
        box-shadow:
          0 14px 30px rgba(15, 23, 42, 0.9),
          0 0 0 1px rgba(15, 23, 42, 0.9),
          inset 0 0 0 1px rgba(15, 23, 42, 1);
        transition:
          transform 0.08s ease-out,
          box-shadow 0.08s ease-out,
          border-color 0.12s ease-out,
          background 0.16s ease-out;
      }

      button.btn:hover {
        transform: translateY(-1px);
        border-color: rgba(56, 189, 248, 0.85);
        box-shadow:
          0 18px 36px rgba(15, 23, 42, 0.95),
          0 0 0 1px rgba(15, 23, 42, 0.98),
          0 0 18px rgba(56, 189, 248, 0.3);
      }

      button.btn:active {
        transform: translateY(1px) scale(0.995);
        box-shadow:
          0 8px 18px rgba(15, 23, 42, 0.98),
          0 0 0 1px rgba(15, 23, 42, 0.98);
      }

      button.btn.secondary {
        background: linear-gradient(135deg, #020617, #020617);
        border-color: rgba(148, 163, 184, 0.55);
        color: var(--muted);
      }

      .btn .icon {
        font-size: 11px;
        opacity: 0.8;
      }

      .btn .shortcut {
        font-size: 10px;
        color: var(--muted);
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        border-radius: 999px;
        background-color: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(56, 189, 248, 0.6);
        font-size: 10px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: var(--accent);
      }

      .panel-right-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
      }

      .panel-right-header h2 {
        font-size: 0.95rem;
        margin: 0;
        font-weight: 500;
      }

      .panel-right-header .sub {
        font-size: 0.75rem;
        color: var(--muted);
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        margin-top: 8px;
      }

      .metric-card {
        padding: 8px 9px;
        border-radius: 12px;
        background: radial-gradient(circle at 0 0, rgba(15, 23, 42, 0.98), #020617);
        border: 1px solid rgba(148, 163, 184, 0.4);
        font-size: 11px;
      }

      .metric-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 4px;
        color: var(--muted);
      }

      .metric-card-value {
        font-size: 1rem;
        font-weight: 500;
        font-variant-numeric: tabular-nums;
      }

      .metric-card-value.good {
        color: var(--success);
      }

      .metric-card-value.bad {
        color: #facc15;
      }

      .metric-card-footer {
        font-size: 9px;
        color: var(--muted);
        margin-top: 2px;
      }

      .difficulty-row {
        margin-top: 10px;
        padding-top: 6px;
        border-top: 1px dashed rgba(55, 65, 81, 0.9);
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: space-between;
      }

      .difficulty-label {
        font-size: 0.8rem;
        color: var(--muted);
      }

      .difficulty-toggle {
        display: inline-flex;
        gap: 4px;
        padding: 2px;
        border-radius: 999px;
        background-color: rgba(15, 23, 42, 1);
        border: 1px solid rgba(75, 85, 99, 0.9);
      }

      .difficulty-toggle button {
        border: none;
        outline: none;
        border-radius: 999px;
        font-size: 10px;
        padding: 3px 8px;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .difficulty-toggle button.active {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.18), rgba(139, 92, 246, 0.18));
        color: var(--accent);
        box-shadow:
          0 0 0 1px rgba(56, 189, 248, 0.4),
          0 10px 22px rgba(15, 23, 42, 0.98);
      }

      .legend-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
        padding-top: 8px;
        border-top: 1px dashed rgba(55, 65, 81, 0.9);
        font-size: 11px;
        color: var(--muted);
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .legend-swatch {
        width: 14px;
        height: 14px;
        border-radius: 5px;
        border: 1px solid rgba(148, 163, 184, 0.7);
        box-shadow: 0 6px 14px rgba(15, 23, 42, 0.95);
      }

      .legend-swatch.player {
        background: radial-gradient(circle at 30% 30%, #22d3ee, #0ea5e9);
      }

      .legend-swatch.goal {
        background: radial-gradient(circle at 30% 30%, #22c55e, #16a34a);
      }

      .legend-swatch.wall {
        background: linear-gradient(135deg, #020617, #020617);
      }

      .helper-text {
        font-size: 11px;
        color: var(--muted);
        margin-top: 8px;
      }

      .helper-text strong {
        color: var(--accent-strong);
        font-weight: 500;
      }

      .toast {
        margin-top: 10px;
        padding: 7px 9px;
        border-radius: 10px;
        background: linear-gradient(
          135deg,
          rgba(34, 197, 94, 0.18),
          rgba(56, 189, 248, 0.1)
        );
        border: 1px solid rgba(34, 197, 94, 0.5);
        font-size: 11px;
        color: #bbf7d0;
        display: none;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .toast.visible {
        display: flex;
      }

      .toast span.label {
        text-transform: uppercase;
        letter-spacing: 0.09em;
        font-size: 10px;
        color: rgba(220, 252, 231, 0.9);
      }

      .toast span.msg {
        font-weight: 500;
      }

      .toast span.meta {
        font-size: 10px;
        color: rgba(209, 250, 229, 0.8);
      }

      .overlay-win {
        pointer-events: none;
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .overlay-win-inner {
        opacity: 0;
        transform: translateY(6px) scale(0.97);
        transition:
          opacity 0.18s ease-out,
          transform 0.18s ease-out;
        pointer-events: auto;
      }

      .overlay-win.visible .overlay-win-inner {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      .overlay-card {
        min-width: 260px;
        max-width: 360px;
        padding: 12px 14px;
        border-radius: 16px;
        background:
          radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.4), transparent 60%),
          radial-gradient(circle at 100% 100%, rgba(34, 197, 94, 0.4), transparent 60%),
          rgba(15, 23, 42, 0.98);
        border: 1px solid rgba(148, 163, 184, 0.85);
        box-shadow:
          0 26px 65px rgba(15, 23, 42, 1),
          0 0 0 1px rgba(15, 23, 42, 0.98);
      }

      .overlay-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
      }

      .overlay-card-header h3 {
        margin: 0;
        font-size: 1rem;
        display: flex;
        align-items: baseline;
        gap: 6px;
      }

      .overlay-card-header h3 span.tag {
        font-size: 10px;
        border-radius: 999px;
        padding: 2px 7px;
        border: 1px solid rgba(34, 197, 94, 0.7);
        color: #bbf7d0;
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      .overlay-card-body {
        font-size: 11px;
        color: var(--muted);
      }

      .overlay-card-body strong {
        color: var(--text);
        font-weight: 500;
      }

      .overlay-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 6px;
        margin: 8px 0 4px;
      }

      .overlay-metric {
        padding: 6px 6px;
        border-radius: 10px;
        background-color: rgba(15, 23, 42, 0.98);
        border: 1px solid rgba(148, 163, 184, 0.55);
        text-align: center;
      }

      .overlay-metric .label {
        font-size: 9px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      .overlay-metric .value {
        margin-top: 2px;
        font-variant-numeric: tabular-nums;
        font-weight: 500;
      }

      .overlay-metric .value.good {
        color: var(--success);
      }

      .overlay-metric .value.bad {
        color: #facc15;
      }

      .overlay-footer {
        margin-top: 6px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .overlay-footer-note {
        font-size: 10px;
        color: var(--muted);
      }

      .overlay-footer button.btn {
        padding: 5px 10px;
        font-size: 10px;
      }

      footer.app-footer {
        margin-top: 14px;
        font-size: 10px;
        color: var(--muted);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .footer-left {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .footer-dot {
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: radial-gradient(circle at 30% 30%, #22c55e, #16a34a);
        box-shadow: 0 0 10px rgba(22, 163, 74, 0.9);
      }

      .footer-hotkeys {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .footer-hotkeys span {
        opacity: 0.85;
      }

      @media (max-width: 900px) {
        .layout {
          grid-template-columns: minmax(0, 1.1fr);
        }
      }

      @media (max-width: 640px) {
        .app-shell {
          margin: 10px;
          padding: 12px;
        }

        header.app-header {
          align-items: flex-start;
        }

        .header-right {
          align-items: flex-start;
        }

        .header-subtitle {
          max-width: none;
          text-align: left;
        }
      }
    </style>
  </head>
  <body>
    <main class="app-shell" id="appRoot">
      <header class="app-header">
        <div class="title-block">
          <div class="app-logo" aria-hidden="true">
            <div class="app-logo-maze">
              <div class="app-logo-cell wall"></div>
              <div class="app-logo-cell wall"></div>
              <div class="app-logo-cell path"></div>
              <div class="app-logo-cell wall"></div>
              <div class="app-logo-cell path"></div>
              <div class="app-logo-cell path"></div>
              <div class="app-logo-cell path"></div>
              <div class="app-logo-cell wall"></div>
              <div class="app-logo-cell wall"></div>
              <div class="app-logo-cell wall"></div>
              <div class="app-logo-cell path"></div>
              <div class="app-logo-cell wall"></div>
              <div class="app-logo-cell path"></div>
              <div class="app-logo-cell wall"></div>
              <div class="app-logo-cell path"></div>
              <div class="app-logo-cell path"></div>
            </div>
          </div>
          <div>
            <h1 class="app-title">
              Escape the Maze
              <span class="sub">Precision Speedrun Edition</span>
            </h1>
            <span class="app-tag">Randomized · Keyboard-Driven · Score-Chasing</span>
          </div>
        </div>
        <div class="header-right">
          <div class="header-subtitle">
            Use the arrow keys to sprint through a freshly generated maze. Hug the <strong>shortest path</strong> for a perfect bonus.
          </div>
          <div class="shortcut-pill" aria-hidden="true">
            <span class="keycap arrow">↑</span>
            <span class="keycap arrow">↓</span>
            <span class="keycap arrow">←</span>
            <span class="keycap arrow">→</span>
            <span style="font-size: 10px; color: var(--muted); margin-left: 4px"
              >to navigate &middot; <strong style="color: var(--accent)">R</strong> to replay</span
            >
          </div>
        </div>
      </header>

      <section class="layout">
        <section class="card main" aria-label="Maze gameplay area">
          <div class="card.main-inner">
            <div class="maze-shell" id="mazeShell" tabindex="0" aria-label="Interactive maze">
              <div class="maze-canvas-wrap">
                <canvas id="mazeCanvas" width="640" height="640"></canvas>
                <div class="maze-overlay-label">
                  <span class="dot"></span>
                  LIVE RUN
                  <span class="blink"></span>
                </div>
                <div class="maze-status-chip">
                  <span id="difficultyBadge" class="mode">MEDIUM GRID</span>
                </div>
                <div class="overlay-win" id="winOverlay" aria-live="polite" aria-atomic="true">
                  <div class="overlay-win-inner">
                    <div class="overlay-card">
                      <div class="overlay-card-header">
                        <h3>
                          Escaped!
                          <span class="tag" id="winTag">Clean exit</span>
                        </h3>
                        <span style="font-size: 0.75rem; color: var(--muted)">Maze cleared</span>
                      </div>
                      <div class="overlay-card-body" id="winSummary">
                        You reached the exit. Time to compare your route against the optimal line through the maze.
                      </div>
                      <div class="overlay-grid">
                        <div class="overlay-metric">
                          <div class="label">Time</div>
                          <div class="value" id="winTimeValue">0.00s</div>
                        </div>
                        <div class="overlay-metric">
                          <div class="label">Moves</div>
                          <div class="value" id="winMovesValue">0</div>
                        </div>
                        <div class="overlay-metric">
                          <div class="label">Optimal</div>
                          <div class="value" id="winOptimalValue">0</div>
                        </div>
                      </div>
                      <div class="overlay-footer">
                        <div class="overlay-footer-note" id="winFooterNote">
                          Tip: Shave off dead-ends to chase the perfect route.
                        </div>
                        <div style="display: inline-flex; gap: 6px">
                          <button class="btn secondary" id="btnReplaySame">
                            <span class="icon">↻</span>
                            Same Maze
                          </button>
                          <button class="btn" id="btnReplayNew">
                            <span class="icon">✨</span>
                            New Maze
                          </button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="hud-row" aria-hidden="true">
                <div class="hud-group">
                  <div class="pill-metric">
                    <span class="label">Time</span>
                    <span class="value highlight" id="hudTime">0.00s</span>
                  </div>
                  <div class="pill-metric">
                    <span class="label">Moves</span>
                    <span class="value" id="hudMoves">0</span>
                  </div>
                  <div class="pill-metric">
                    <span class="label">Optimal</span>
                    <span class="value" id="hudOptimal">0</span>
                  </div>
                  <div class="pill-metric">
                    <span class="label">Efficiency</span>
                    <span class="value" id="hudEfficiency">100%</span>
                  </div>
                </div>
                <div class="hud-group">
                  <button class="btn" id="btnReplay">
                    <span class="icon">↻</span>
                    Replay
                    <span class="shortcut">R</span>
                  </button>
                  <button class="btn secondary" id="btnFocus">
                    <span class="icon">⌨</span>
                    Focus controls
                  </button>
                </div>
              </div>
            </div>
          </div>
        </section>

        <aside class="card" aria-label="Run stats and controls">
          <div class="panel-right-header">
            <div>
              <h2>Run Breakdown</h2>
              <div class="sub">Chase the perfect route through each maze.</div>
            </div>
            <span class="badge">
              <span style="width: 6px; height: 6px; border-radius: 999px; background: radial-gradient(circle at 30% 30%, #22c55e, #16a34a); box-shadow: 0 0 10px rgba(34,197,94,0.9);"></span>
              Shortest Path Bonus
            </span>
          </div>

          <div class="metrics-grid">
            <div class="metric-card">
              <div class="metric-card-header">
                <span>Current Run</span>
                <span id="metricStatusBadge" style="font-size: 10px; color: var(--muted)">In progress</span>
              </div>
              <div class="metric-card-value" id="metricCurrentTime">0.00s</div>
              <div class="metric-card-footer">
                Time is live from your <strong>first</strong> step until you touch the exit tile.
              </div>
            </div>

            <div class="metric-card">
              <div class="metric-card-header">
                <span>Best Run</span>
                <span style="font-size: 10px; color: var(--muted)">This session</span>
              </div>
              <div class="metric-card-value good" id="metricBestTime">—</div>
              <div class="metric-card-footer" id="metricBestLabel">
                Escape a maze to record a baseline time.
              </div>
            </div>

            <div class="metric-card">
              <div class="metric-card-header">
                <span>Path Quality</span>
                <span id="metricQualityBadge" style="font-size: 10px; color: var(--muted)">Waiting</span>
              </div>
              <div class="metric-card-value" id="metricQuality">—</div>
              <div class="metric-card-footer" id="metricQualityLabel">
                Finish a maze to see how closely your route matched the optimal path.
              </div>
            </div>

            <div class="metric-card">
              <div class="metric-card-header">
                <span>Shortest Path</span>
                <span style="font-size: 10px; color: var(--muted)">Moves</span>
              </div>
              <div class="metric-card-value" id="metricOptimal">0</div>
              <div class="metric-card-footer">
                The minimum number of steps from the entrance to the exit in this exact maze layout.
              </div>
            </div>
          </div>

          <div class="difficulty-row">
            <div class="difficulty-label">
              Difficulty
              <span style="color: var(--muted); font-size: 10px">
                (grid size &amp; twistiness)
              </span>
            </div>
            <div class="difficulty-toggle" role="radiogroup" aria-label="Maze difficulty">
              <button type="button" data-size="small" aria-checked="false" role="radio">
                Calm
              </button>
              <button
                type="button"
                data-size="medium"
                aria-checked="true"
                role="radio"
                class="active"
              >
                Focused
              </button>
              <button type="button" data-size="large" aria-checked="false" role="radio">
                Intense
              </button>
            </div>
          </div>

          <div class="legend-row" aria-hidden="true">
            <div class="legend-item">
              <span class="legend-swatch player"></span>
              <span>Player</span>
            </div>
            <div class="legend-item">
              <span class="legend-swatch goal"></span>
              <span>Exit</span>
            </div>
            <div class="legend-item">
              <span class="legend-swatch wall"></span>
              <span>Wall</span>
            </div>
          </div>

          <div class="helper-text">
            - Use the <strong>arrow keys</strong> to move one tile at a time.<br />
            - Timer starts on your <strong>first movement</strong>.<br />
            - Reach the glowing exit tile using as few moves as possible.<br />
            - Finishing with <strong>exactly</strong> the optimal number of moves grants a
            <strong>Shortest Path Bonus</strong> and marks the run as <strong>perfect</strong>.
          </div>

          <div class="toast" id="toast">
            <div>
              <span class="label" id="toastLabel">Bonus</span>
              <span class="msg" id="toastMsg">Shortest path achieved!</span>
            </div>
            <span class="meta" id="toastMeta">0 extra steps</span>
          </div>
        </aside>
      </section>

      <footer class="app-footer">
        <div class="footer-left">
          <span class="footer-dot" aria-hidden="true"></span>
          <span>Keyboard-first maze racing. Press any arrow key to begin.</span>
        </div>
        <div class="footer-hotkeys" aria-hidden="true">
          <span class="keycap arrow">↑</span>
          <span class="keycap arrow">↓</span>
          <span class="keycap arrow">←</span>
          <span class="keycap arrow">→</span>
          <span style="font-size: 10px; color: var(--muted)">move</span>
          <span style="font-size: 14px; color: rgba(148,163,184,0.5)">·</span>
          <span class="keycap">R</span>
          <span style="font-size: 10px; color: var(--muted)">replay</span>
        </div>
      </footer>
    </main>

    <script>
      (function () {
        const canvas = document.getElementById('mazeCanvas');
        const mazeShell = document.getElementById('mazeShell');
        const winOverlay = document.getElementById('winOverlay');
        const winTag = document.getElementById('winTag');
        const winSummary = document.getElementById('winSummary');
        const winTimeValue = document.getElementById('winTimeValue');
        const winMovesValue = document.getElementById('winMovesValue');
        const winOptimalValue = document.getElementById('winOptimalValue');
        const winFooterNote = document.getElementById('winFooterNote');
        const btnReplaySame = document.getElementById('btnReplaySame');
        const btnReplayNew = document.getElementById('btnReplayNew');
        const difficultyBadge = document.getElementById('difficultyBadge');

        const hudTime = document.getElementById('hudTime');
        const hudMoves = document.getElementById('hudMoves');
        const hudOptimal = document.getElementById('hudOptimal');
        const hudEfficiency = document.getElementById('hudEfficiency');
        const btnReplay = document.getElementById('btnReplay');
        const btnFocus = document.getElementById('btnFocus');

        const metricStatusBadge = document.getElementById('metricStatusBadge');
        const metricCurrentTime = document.getElementById('metricCurrentTime');
        const metricBestTime = document.getElementById('metricBestTime');
        const metricBestLabel = document.getElementById('metricBestLabel');
        const metricQuality = document.getElementById('metricQuality');
        const metricQualityBadge = document.getElementById('metricQualityBadge');
        const metricQualityLabel = document.getElementById('metricQualityLabel');
        const metricOptimal = document.getElementById('metricOptimal');

        const toast = document.getElementById('toast');
        const toastLabel = document.getElementById('toastLabel');
        const toastMsg = document.getElementById('toastMsg');
        const toastMeta = document.getElementById('toastMeta');

        const difficultyButtons = Array.from(
          document.querySelectorAll('.difficulty-toggle button')
        );

        const ctx = canvas.getContext('2d');

        const difficulties = {
          small: { size: 19, label: 'CALM GRID' },
          medium: { size: 27, label: 'MEDIUM GRID' },
          large: { size: 35, label: 'INTENSE GRID' }
        };

        let currentDifficulty = 'medium';

        let grid = null;
        let gridSize = difficulties[currentDifficulty].size;
        let cellSize = 20;
        let player = { x: 1, y: 1 };
        let goal = { x: 0, y: 0 };
        let optimalSteps = 0;
        let moves = 0;

        let timerStarted = false;
        let timerActive = false;
        let startTime = 0;
        let elapsedMs = 0;
        let bestTimeMs = null;
        let animationFrameId = null;

        let hasWon = false;
        let lastMazeSeed = null;
        let lastMazeGrid = null;
        let lastMazeGoal = null;
        let lastMazeOptimal = null;

        function randomSeed() {
          return Math.floor(Math.random() * 1e9);
        }

        function createPRNG(seed) {
          let s = seed >>> 0;
          return function () {
            s = (s + 0x6d2b79f5) | 0;
            let t = Math.imul(s ^ (s >>> 15), 1 | s);
            t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        }

        function resizeCanvas() {
          const shellRect = mazeShell.getBoundingClientRect();
          const maxSize = Math.min(shellRect.width - 20, window.innerHeight - 220, 720);
          const size = Math.max(320, maxSize);
          const scale = window.devicePixelRatio || 1;

          // Snap cell size to integer for crisp walls.
          const baseCell = Math.floor((size * scale) / gridSize);
          const finalCellSize = Math.max(8 * scale, baseCell);
          const width = finalCellSize * gridSize;
          const height = finalCellSize * gridSize;

          canvas.width = width;
          canvas.height = height;
          canvas.style.width = width / scale + 'px';
          canvas.style.height = height / scale + 'px';
          cellSize = finalCellSize;

          drawMaze();
        }

        function makeMaze(size, seed) {
          const rng = createPRNG(seed);
          const width = size;
          const height = size;
          const grid = Array.from({ length: height }, () => Array(width).fill(1));

          function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
              const j = Math.floor(rng() * (i + 1));
              const tmp = arr[i];
              arr[i] = arr[j];
              arr[j] = tmp;
            }
          }

          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1]
          ];

          const stack = [];
          const startX = 1;
          const startY = 1;
          grid[startY][startX] = 0;
          stack.push([startX, startY]);

          while (stack.length) {
            const [cx, cy] = stack[stack.length - 1];
            const options = [];
            const dirOrder = dirs.slice();
            shuffle(dirOrder);

            for (const [dx, dy] of dirOrder) {
              const nx = cx + dx * 2;
              const ny = cy + dy * 2;
              if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1) {
                if (grid[ny][nx] === 1) {
                  options.push([dx, dy]);
                }
              }
            }

            if (!options.length) {
              stack.pop();
              continue;
            }

            const [dx, dy] = options[0];
            const mx = cx + dx;
            const my = cy + dy;
            const nx = cx + dx * 2;
            const ny = cy + dy * 2;
            grid[my][mx] = 0;
            grid[ny][nx] = 0;
            stack.push([nx, ny]);
          }

          // Choose farthest reachable cell on last row as goal for better runs.
          const start = { x: 1, y: 1 };
          let goal = { x: width - 2, y: height - 2 };
          let bestDistance = -1;

          // BFS to compute distances from start.
          const dist = Array.from({ length: height }, () => Array(width).fill(Infinity));
          const queue = [];
          dist[start.y][start.x] = 0;
          queue.push([start.x, start.y]);

          while (queue.length) {
            const [x, y] = queue.shift();
            const d = dist[y][x];
            for (const [dx, dy] of dirs) {
              const nx = x + dx;
              const ny = y + dy;
              if (
                nx > 0 &&
                nx < width - 1 &&
                ny > 0 &&
                ny < height - 1 &&
                grid[ny][nx] === 0 &&
                dist[ny][nx] === Infinity
              ) {
                dist[ny][nx] = d + 1;
                queue.push([nx, ny]);
              }
            }
          }

          for (let x = 1; x < width - 1; x++) {
            const y = height - 2;
            if (grid[y][x] === 0 && dist[y][x] !== Infinity && dist[y][x] > bestDistance) {
              bestDistance = dist[y][x];
              goal = { x, y };
            }
          }

          if (bestDistance <= 0 || bestDistance === Infinity) {
            goal = { x: width - 2, y: height - 2 };
          }

          return { grid, start, goal };
        }

        function computeShortestPath(grid, start, goal) {
          const height = grid.length;
          const width = grid[0].length;
          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1]
          ];
          const dist = Array.from({ length: height }, () => Array(width).fill(Infinity));
          const queue = [];
          dist[start.y][start.x] = 0;
          queue.push([start.x, start.y]);

          while (queue.length) {
            const [x, y] = queue.shift();
            const d = dist[y][x];
            if (x === goal.x && y === goal.y) {
              return d;
            }
            for (const [dx, dy] of dirs) {
              const nx = x + dx;
              const ny = y + dy;
              if (
                nx >= 0 &&
                nx < width &&
                ny >= 0 &&
                ny < height &&
                grid[ny][nx] === 0 &&
                dist[ny][nx] === Infinity
              ) {
                dist[ny][nx] = d + 1;
                queue.push([nx, ny]);
              }
            }
          }
          return Infinity;
        }

        function drawMaze() {
          if (!grid) return;

          const width = grid[0].length;
          const height = grid.length;

          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const gradient = ctx.createRadialGradient(
            canvas.width * 0.18,
            canvas.height * 0.1,
            canvas.width * 0.1,
            canvas.width * 0.5,
            canvas.height * 0.9,
            canvas.width * 0.9
          );
          gradient.addColorStop(0, '#020617');
          gradient.addColorStop(0.6, '#020617');
          gradient.addColorStop(1, '#020617');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const wallColor = '#020617';
          const wallBorder = 'rgba(15,23,42,0.9)';
          const pathGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
          pathGradient.addColorStop(0, '#0f172a');
          pathGradient.addColorStop(1, '#020617');

          ctx.fillStyle = pathGradient;
          ctx.fillRect(
            cellSize,
            cellSize,
            canvas.width - cellSize * 2,
            canvas.height - cellSize * 2
          );

          ctx.strokeStyle = 'rgba(15,23,42,0.9)';
          ctx.lineWidth = Math.max(1, cellSize * 0.18);
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              if (grid[y][x] === 1) {
                const px = x * cellSize;
                const py = y * cellSize;
                ctx.fillStyle = wallColor;
                ctx.fillRect(px, py, cellSize, cellSize);
              }
            }
          }

          ctx.strokeStyle = wallBorder;
          ctx.strokeRect(
            cellSize * 0.5,
            cellSize * 0.5,
            canvas.width - cellSize,
            canvas.height - cellSize
          );

          drawGoalTile();
          drawPlayer();

          ctx.restore();
        }

        function drawPlayer() {
          const px = player.x * cellSize + cellSize / 2;
          const py = player.y * cellSize + cellSize / 2;
          const radius = (cellSize * 0.38);

          const gradient = ctx.createRadialGradient(
            px - radius * 0.4,
            py - radius * 0.4,
            radius * 0.3,
            px,
            py,
            radius
          );
          gradient.addColorStop(0, '#22d3ee');
          gradient.addColorStop(1, '#0ea5e9');

          ctx.save();
          ctx.shadowColor = 'rgba(56,189,248,0.7)';
          ctx.shadowBlur = radius * 0.9;
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(px, py, radius, 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowColor = 'rgba(15,23,42,1)';
          ctx.shadowBlur = radius * 0.5;
          ctx.fillStyle = 'rgba(15,23,42,0.9)';
          ctx.beginPath();
          ctx.arc(px, py - radius * 0.3, radius * 0.4, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }

        function drawGoalTile() {
          const gx = goal.x * cellSize;
          const gy = goal.y * cellSize;
          const padding = cellSize * 0.18;
          const x = gx + padding;
          const y = gy + padding;
          const w = cellSize - padding * 2;
          const h = cellSize - padding * 2;

          const gradient = ctx.createLinearGradient(x, y, x + w, y + h);
          gradient.addColorStop(0, '#22c55e');
          gradient.addColorStop(1, '#4ade80');

          ctx.save();
          ctx.shadowColor = 'rgba(74,222,128,0.7)';
          ctx.shadowBlur = cellSize * 0.8;
          ctx.fillStyle = 'rgba(21, 128, 61, 0.6)';
          ctx.fillRect(x - 2, y - 2, w + 4, h + 4);

          ctx.fillStyle = gradient;
          const radius = cellSize * 0.2;
          roundedRect(ctx, x, y, w, h, radius);

          ctx.lineWidth = Math.max(1, cellSize * 0.12);
          ctx.strokeStyle = 'rgba(250, 250, 250, 0.4)';
          ctx.stroke();

          ctx.restore();
        }

        function roundedRect(ctx, x, y, width, height, radius) {
          const r = Math.min(radius, width / 2, height / 2);
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.lineTo(x + width - r, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + r);
          ctx.lineTo(x + width, y + height - r);
          ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
          ctx.lineTo(x + r, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - r);
          ctx.lineTo(x, y + r);
          ctx.quadraticCurveTo(x, y, x + r, y);
          ctx.closePath();
          ctx.fill();
        }

        function formatTime(ms) {
          return (ms / 1000).toFixed(2) + 's';
        }

        function updateHUD() {
          hudTime.textContent = formatTime(elapsedMs);
          hudMoves.textContent = String(moves);
          hudOptimal.textContent = String(optimalSteps);
          const eff =
            optimalSteps > 0 ? Math.max(0, Math.min(100, Math.round((optimalSteps / Math.max(moves, optimalSteps)) * 100))) : 100;
          hudEfficiency.textContent = eff + '%';

          metricCurrentTime.textContent = formatTime(elapsedMs);
          metricOptimal.textContent = String(optimalSteps);

          if (bestTimeMs == null) {
            metricBestTime.textContent = '—';
            metricBestTime.classList.remove('good', 'bad');
            metricBestLabel.textContent = 'Escape a maze to record a baseline time.';
          } else {
            metricBestTime.textContent = formatTime(bestTimeMs);
            metricBestTime.classList.add('good');
            metricBestLabel.textContent = 'Best escape time across all mazes this session.';
          }
        }

        function hideWinOverlay() {
          winOverlay.classList.remove('visible');
        }

        function showWinOverlay(summary) {
          winOverlay.classList.add('visible');
          winSummary.innerHTML = summary;
        }

        function resetTimer() {
          timerStarted = false;
          timerActive = false;
          elapsedMs = 0;
          startTime = 0;
          metricStatusBadge.textContent = 'Ready';
        }

        function startTimerIfNeeded() {
          if (!timerStarted) {
            timerStarted = true;
            timerActive = true;
            startTime = performance.now();
            metricStatusBadge.textContent = 'In progress';
            scheduleTick();
          }
        }

        function scheduleTick() {
          if (animationFrameId != null) return;
          animationFrameId = requestAnimationFrame(tick);
        }

        function tick() {
          animationFrameId = null;
          if (timerActive) {
            elapsedMs = performance.now() - startTime;
          }
          updateHUD();
          if (timerActive) {
            scheduleTick();
          }
        }

        function stopTimerAndFinalizeWin() {
          if (!timerStarted || !timerActive) return;
          timerActive = false;
          elapsedMs = performance.now() - startTime;
          updateHUD();
        }

        function computeQualityLabel(extraMoves, ratio) {
          if (extraMoves === 0) return 'Perfect shortest path. Immaculate routing.';
          if (ratio <= 1.05) return 'Ultra-tight. Your route is nearly indistinguishable from optimal.';
          if (ratio <= 1.15) return 'Strong pathing. A bit of trimming and you can reach perfection.';
          if (ratio <= 1.3)
            return 'Good escape with some exploratory detours. Great target for optimization.';
          return 'You survived the maze. Now try hugging the main corridor to tighten things up.';
        }

        function showToast(label, msg, meta) {
          toastLabel.textContent = label;
          toastMsg.textContent = msg;
          toastMeta.textContent = meta || '';
          toast.classList.add('visible');
          clearTimeout(showToast._timeout);
          showToast._timeout = setTimeout(() => {
            toast.classList.remove('visible');
          }, 4600);
        }

        function clearToast() {
          toast.classList.remove('visible');
        }

        function updateDifficultyUI() {
          difficultyButtons.forEach((btn) => {
            const size = btn.getAttribute('data-size');
            const isActive = size === currentDifficulty;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-checked', String(isActive));
          });
          difficultyBadge.textContent = difficulties[currentDifficulty].label;
        }

        function initMaze({ reuseLast } = { reuseLast: false }) {
          clearToast();
          hideWinOverlay();
          hasWon = false;
          moves = 0;
          resetTimer();

          gridSize = difficulties[currentDifficulty].size;

          if (reuseLast && lastMazeGrid && lastMazeGoal && lastMazeGrid.length === gridSize) {
            grid = lastMazeGrid.map((row) => row.slice());
            player = { x: 1, y: 1 };
            goal = { x: lastMazeGoal.x, y: lastMazeGoal.y };
            optimalSteps = lastMazeOptimal || computeShortestPath(grid, player, goal);
          } else {
            lastMazeSeed = randomSeed();
            const { grid: mazeGrid, start, goal: mazeGoal } = makeMaze(
              gridSize,
              lastMazeSeed
            );
            grid = mazeGrid;
            player = { x: start.x, y: start.y };
            goal = { x: mazeGoal.x, y: mazeGoal.y };
            optimalSteps = computeShortestPath(grid, player, goal);
            lastMazeGrid = grid.map((row) => row.slice());
            lastMazeGoal = { x: goal.x, y: goal.y };
            lastMazeOptimal = optimalSteps;
          }

          metricQuality.textContent = '—';
          metricQualityBadge.textContent = 'Waiting';
          metricQualityLabel.textContent =
            'Finish a maze to see how closely your route matched the optimal path.';

          resizeCanvas();
          updateHUD();
        }

        function movePlayer(dx, dy) {
          if (!grid || hasWon) return;

          const newX = player.x + dx;
          const newY = player.y + dy;

          if (
            newX < 0 ||
            newY < 0 ||
            newX >= grid[0].length ||
            newY >= grid.length ||
            grid[newY][newX] === 1
          ) {
            subtleBumpFeedback();
            return;
          }

          startTimerIfNeeded();

          player.x = newX;
          player.y = newY;
          moves += 1;
          drawMaze();
          updateHUD();

          if (player.x === goal.x && player.y === goal.y && !hasWon) {
            hasWon = true;
            stopTimerAndFinalizeWin();
            handleWin();
          }
        }

        function subtleBumpFeedback() {
          if (!canvas.animate) return;
          canvas.animate(
            [
              { transform: 'translateX(0px)' },
              { transform: 'translateX(-1.5px)' },
              { transform: 'translateX(1.5px)' },
              { transform: 'translateX(0px)' }
            ],
            { duration: 90, iterations: 1 }
          );
        }

        function handleWin() {
          metricStatusBadge.textContent = 'Completed';
          const time = elapsedMs;

          if (bestTimeMs == null || time < bestTimeMs) {
            bestTimeMs = time;
          }

          const extraMoves = Math.max(0, moves - optimalSteps);
          const ratio = optimalSteps > 0 ? moves / optimalSteps : 1;
          const qualityPct =
            optimalSteps > 0 ? Math.max(0, Math.min(100, Math.round((optimalSteps / moves) * 100))) : 100;

          const isPerfect = extraMoves === 0 && optimalSteps > 0;

          winTimeValue.textContent = formatTime(time);
          winMovesValue.textContent = String(moves);
          winOptimalValue.textContent = String(optimalSteps);

          const qualityLabel = computeQualityLabel(extraMoves, ratio);
          metricQuality.textContent = qualityPct + '%';
          metricQualityLabel.textContent = qualityLabel;

          if (isPerfect) {
            winTag.textContent = 'Perfect route';
            winFooterNote.textContent =
              'You matched the exact shortest path. Try a harder grid next.';
            metricQualityBadge.textContent = 'Perfect';
            metricQualityBadge.style.color = '#4ade80';
            metricQualityBadge.style.fontWeight = '500';
            showToast(
              'Shortest Path',
              'Flawless routing! You matched the optimal path.',
              'Bonus unlocked · 0 extra steps'
            );
          } else if (ratio <= 1.1) {
            winTag.textContent = 'Tight line';
            winFooterNote.textContent =
              'You were extremely close to the shortest route. Tiny tweaks could make this perfect.';
            metricQualityBadge.textContent = 'Excellent';
            metricQualityBadge.style.color = '#22c55e';
            metricQualityBadge.style.fontWeight = '500';
            showToast(
              'Near Perfect',
              'Super clean pathing.',
              extraMoves + ' extra steps vs. optimal'
            );
          } else if (ratio <= 1.4) {
            winTag.textContent = 'Exploratory';
            winFooterNote.textContent =
              'Escaped with a few detours. Re-run to see how much you can compress the path.';
            metricQualityBadge.textContent = 'Solid';
            metricQualityBadge.style.color = '#eab308';
            metricQualityBadge.style.fontWeight = '500';
            showToast(
              'Good Run',
              'You escaped with room to optimize.',
              extraMoves + ' extra steps vs. optimal'
            );
          } else {
            winTag.textContent = 'Survivor';
            winFooterNote.textContent =
              'You found a way out. Next run, try to follow the main corridor and avoid dead-ends.';
            metricQualityBadge.textContent = 'Messy';
            metricQualityBadge.style.color = '#f97316';
            metricQualityBadge.style.fontWeight = '500';
            showToast(
              'Escaped',
              'You beat the maze – now chase a cleaner path.',
              extraMoves + ' extra steps vs. optimal'
            );
          }

          let summary;
          if (isPerfect) {
            summary =
              'You traced the <strong>exact shortest path</strong> from the entrance to the exit. Every single move counted and none were wasted.';
          } else if (ratio <= 1.1) {
            summary =
              'You finished only <strong>' +
              extraMoves +
              ' move' +
              (extraMoves === 1 ? '' : 's') +
              '</strong> above the theoretical minimum. With a little practice this maze could be a perfect run.';
          } else {
            summary =
              'You escaped in <strong>' +
              formatTime(time) +
              '</strong> using <strong>' +
              moves +
              ' moves</strong>. The maze can be solved in <strong>' +
              optimalSteps +
              ' moves</strong>, so there is plenty of room to tighten your route.';
          }

          showWinOverlay(summary);
          updateHUD();
        }

        function handleKeydown(e) {
          const key = e.key;
          if (
            key === 'ArrowUp' ||
            key === 'ArrowDown' ||
            key === 'ArrowLeft' ||
            key === 'ArrowRight' ||
            key === 'r' ||
            key === 'R'
          ) {
            e.preventDefault();
          }

          if (key === 'ArrowUp') movePlayer(0, -1);
          else if (key === 'ArrowDown') movePlayer(0, 1);
          else if (key === 'ArrowLeft') movePlayer(-1, 0);
          else if (key === 'ArrowRight') movePlayer(1, 0);
          else if (key === 'r' || key === 'R') {
            initMaze({ reuseLast: false });
          }
        }

        function initEvents() {
          window.addEventListener('keydown', handleKeydown);

          btnReplay.addEventListener('click', function () {
            initMaze({ reuseLast: false });
            mazeShell.focus();
          });

          btnFocus.addEventListener('click', function () {
            mazeShell.focus();
            subtleFocusHighlight();
          });

          btnReplaySame.addEventListener('click', function () {
            initMaze({ reuseLast: true });
            mazeShell.focus();
          });

          btnReplayNew.addEventListener('click', function () {
            initMaze({ reuseLast: false });
            mazeShell.focus();
          });

          difficultyButtons.forEach((btn) => {
            btn.addEventListener('click', () => {
              const size = btn.getAttribute('data-size');
              if (size === currentDifficulty) return;
              currentDifficulty = size;
              updateDifficultyUI();
              initMaze({ reuseLast: false });
              mazeShell.focus();
            });
          });

          window.addEventListener('resize', function () {
            resizeCanvas();
          });

          mazeShell.addEventListener('click', function () {
            mazeShell.focus();
            subtleFocusHighlight();
          });
        }

        function subtleFocusHighlight() {
          if (!mazeShell.animate) return;
          mazeShell.animate(
            [
              { boxShadow: '0 0 0 0 rgba(56,189,248,0)', borderColor: 'rgba(148,163,184,0.32)' },
              {
                boxShadow: '0 0 0 2px rgba(56,189,248,0.7)',
                borderColor: 'rgba(56,189,248,0.8)'
              },
              { boxShadow: '0 0 0 0 rgba(56,189,248,0)', borderColor: 'rgba(148,163,184,0.32)' }
            ],
            {
              duration: 420,
              easing: 'ease-out'
            }
          );
        }

        function init() {
          updateDifficultyUI();
          initMaze({ reuseLast: false });
          initEvents();
          setTimeout(function () {
            mazeShell.focus();
          }, 200);
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', init);
        } else {
          init();
        }
      })();
    </script>
  </body>
</html>

