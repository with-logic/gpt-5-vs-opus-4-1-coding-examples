<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape the Maze</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #282c34;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 { margin-bottom: 10px; }

        .info-panel {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 8px;
        }

        canvas {
            background-color: #fff;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .controls {
            margin-top: 20px;
        }

        button {
            background: #61dafb;
            color: #282c34;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #4fa8d1;
        }

        .modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal-content {
            background: #20232a;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #61dafb;
        }

    </style>
</head>
<body>

    <h1>Escape the Maze</h1>
    
    <div class="info-panel">
        <div>Time: <span id="timer">0.0</span>s</div>
        <div>Steps: <span id="steps">0</span></div>
    </div>

    <canvas id="mazeCanvas"></canvas>

    <div class="controls">
        <button onclick="initGame()">New Maze</button>
    </div>

    <div id="winModal" class="modal">
        <div class="modal-content">
            <h2 style="color: #61dafb;">Escaped!</h2>
            <p>Time: <span id="finalTime"></span>s</p>
            <p>Steps: <span id="finalSteps"></span></p>
            <p id="bonusMsg"></p>
            <button onclick="document.getElementById('winModal').style.display='none'; initGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const timerEl = document.getElementById('timer');
        const stepsEl = document.getElementById('steps');

        // Config
        const cols = 21;
        const rows = 21;
        const cellSize = 25;
        const width = cols * cellSize;
        const height = rows * cellSize;
        canvas.width = width;
        canvas.height = height;

        // State
        let maze = [];
        let player = { x: 1, y: 1 };
        let end = { x: cols - 2, y: rows - 2 };
        let startTime;
        let timerInterval;
        let stepCount = 0;
        let gameActive = false;
        let minSteps = 0;

        // Init
        function initGame() {
            // Reset
            gameActive = true;
            stepCount = 0;
            stepsEl.textContent = 0;
            timerEl.textContent = "0.0";
            player = { x: 1, y: 1 };
            
            generateMaze();
            calculateShortestPath();
            
            draw();
            
            clearInterval(timerInterval);
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const delta = (Date.now() - startTime) / 1000;
                timerEl.textContent = delta.toFixed(1);
            }, 100);
        }

        // Recursive Backtracker
        function generateMaze() {
            // Initialize Grid: 1 = Wall, 0 = Path
            maze = [];
            for (let y = 0; y < rows; y++) {
                let row = [];
                for (let x = 0; x < cols; x++) {
                    row.push(1); // All walls
                }
                maze.push(row);
            }

            const stack = [];
            let current = { x: 1, y: 1 };
            maze[1][1] = 0;
            stack.push(current);

            while (stack.length > 0) {
                current = stack[stack.length - 1];
                const neighbors = getUnvisitedNeighbors(current.x, current.y);

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    // Remove wall between current and next
                    const wallX = (current.x + next.x) / 2;
                    const wallY = (current.y + next.y) / 2;
                    maze[wallY][wallX] = 0;
                    maze[next.y][next.x] = 0;
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }

            // Ensure end is reachable (it should be with this algo)
            maze[rows - 2][cols - 2] = 0;
            end = { x: cols - 2, y: rows - 2 };
        }

        function getUnvisitedNeighbors(x, y) {
            const neighbors = [];
            const directions = [
                { dx: 0, dy: -2 }, // N
                { dx: 0, dy: 2 },  // S
                { dx: 2, dy: 0 },  // E
                { dx: -2, dy: 0 }  // W
            ];

            for (let d of directions) {
                const nx = x + d.dx;
                const ny = y + d.dy;
                if (nx > 0 && nx < cols - 1 && ny > 0 && ny < rows - 1 && maze[ny][nx] === 1) {
                    neighbors.push({ x: nx, y: ny });
                }
            }
            return neighbors;
        }

        // BFS for shortest path
        function calculateShortestPath() {
            const q = [{ x: 1, y: 1, d: 0 }];
            const visited = new Set();
            visited.add("1,1");
            
            while (q.length > 0) {
                const curr = q.shift();
                if (curr.x === end.x && curr.y === end.y) {
                    minSteps = curr.d;
                    return;
                }
                
                const dirs = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
                for (let d of dirs) {
                    const nx = curr.x + d.x;
                    const ny = curr.y + d.y;
                    if (maze[ny][nx] === 0 && !visited.has(`${nx},${ny}`)) {
                        visited.add(`${nx},${ny}`);
                        q.push({ x: nx, y: ny, d: curr.d + 1 });
                    }
                }
            }
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#282c34';
            ctx.fillRect(0, 0, width, height);

            // Draw Maze
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#61dafb'; // Wall color
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    } else {
                        ctx.fillStyle = '#20232a'; // Floor
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw End
            ctx.fillStyle = '#4cd964';
            ctx.fillRect(end.x * cellSize + 5, end.y * cellSize + 5, cellSize - 10, cellSize - 10);

            // Draw Player
            ctx.fillStyle = '#ff3b30';
            ctx.beginPath();
            ctx.arc(
                player.x * cellSize + cellSize / 2, 
                player.y * cellSize + cellSize / 2, 
                cellSize / 2 - 4, 0, Math.PI * 2
            );
            ctx.fill();
        }

        function move(dx, dy) {
            if (!gameActive) return;

            const nx = player.x + dx;
            const ny = player.y + dy;

            if (maze[ny][nx] === 0) {
                player.x = nx;
                player.y = ny;
                stepCount++;
                stepsEl.textContent = stepCount;
                draw();

                if (player.x === end.x && player.y === end.y) {
                    win();
                }
            }
        }

        function win() {
            gameActive = false;
            clearInterval(timerInterval);
            const finalTime = timerEl.textContent;
            
            document.getElementById('finalTime').textContent = finalTime;
            document.getElementById('finalSteps').textContent = stepCount;
            
            const bonusMsg = document.getElementById('bonusMsg');
            if (stepCount <= minSteps + 2) {
                bonusMsg.textContent = "ðŸ† Perfect Path Bonus! (Optimal was " + minSteps + ")";
                bonusMsg.style.color = "#ffd700";
            } else {
                bonusMsg.textContent = `Optimal path was ${minSteps} steps.`;
                bonusMsg.style.color = "#ccc";
            }

            document.getElementById('winModal').style.display = 'flex';
        }

        // Controls
        window.addEventListener('keydown', e => {
            switch(e.key) {
                case 'ArrowUp': move(0, -1); break;
                case 'ArrowDown': move(0, 1); break;
                case 'ArrowLeft': move(-1, 0); break;
                case 'ArrowRight': move(1, 0); break;
            }
        });

        initGame();

    </script>
</body>
</html>
