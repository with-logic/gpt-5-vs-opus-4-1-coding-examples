<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Step Sequencer</title>
    <style>
        :root {
            --bg-color: #121214;
            --panel-color: #1e1e24;
            --accent-color: #00ffe5;
            --secondary-accent: #ff0055;
            --step-inactive: #33333d;
            --step-active: #00ffe5;
            --step-current: #ffffff;
            --text-color: #e0e0e0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            font-weight: 300;
            letter-spacing: 4px;
            text-transform: uppercase;
            text-shadow: 0 0 10px var(--accent-color);
            margin-bottom: 2rem;
        }

        .sequencer-container {
            background-color: var(--panel-color);
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), 0 0 5px var(--accent-color);
            border: 1px solid #333;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        button {
            background: transparent;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 0.5rem 1rem;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.8rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        button:hover {
            background: var(--accent-color);
            color: var(--bg-color);
            box-shadow: 0 0 10px var(--accent-color);
        }

        button.active {
            background: var(--secondary-accent);
            border-color: var(--secondary-accent);
            color: white;
            box-shadow: 0 0 10px var(--secondary-accent);
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: #333;
            height: 4px;
            border-radius: 2px;
            width: 100px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px var(--accent-color);
        }

        .grid {
            display: grid;
            grid-template-columns: 80px repeat(16, 1fr);
            gap: 6px;
            margin-bottom: 1rem;
        }

        .track-label {
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 0.9rem;
            color: #888;
            text-transform: uppercase;
        }

        .step {
            width: 30px;
            height: 40px;
            background-color: var(--step-inactive);
            border-radius: 2px;
            cursor: pointer;
            transition: background-color 0.1s;
            position: relative;
        }

        .step:hover {
            background-color: #444;
        }

        .step.active {
            background-color: var(--step-active);
            box-shadow: 0 0 10px var(--step-active);
        }

        /* The moving playhead indicator */
        .step.playing {
            border: 2px solid var(--step-current);
        }
        
        .step.active.playing {
             background-color: #fff;
             box-shadow: 0 0 15px #fff;
        }

        .beat-marker {
            grid-column: 2 / -1;
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 0 2px;
        }
        
        .marker {
            width: 30px;
            text-align: center;
            font-size: 0.7rem;
            color: #555;
        }

        .status-bar {
            margin-top: 1rem;
            font-size: 0.8rem;
            color: #666;
            text-align: right;
            height: 1rem;
        }
        
        /* Specific track colors */
        .track-row:nth-child(2) .step.active { background-color: #ff0055; box-shadow: 0 0 10px #ff0055; }
        .track-row:nth-child(3) .step.active { background-color: #ffe600; box-shadow: 0 0 10px #ffe600; }
        .track-row:nth-child(4) .step.active { background-color: #00aaff; box-shadow: 0 0 10px #00aaff; }

    </style>
</head>
<body>

    <h1>Neon Step Sequencer</h1>

    <div class="sequencer-container">
        
        <div class="controls">
            <div class="control-group">
                <button id="playBtn">Play</button>
                <button id="stopBtn">Stop</button>
                <button id="clearBtn">Clear</button>
            </div>
            
            <div class="control-group">
                <label for="tempo">BPM</label>
                <input type="range" id="tempo" min="60" max="200" value="120">
                <span id="tempoVal">120</span>
            </div>

            <div class="control-group">
                <label for="swing">Swing</label>
                <input type="range" id="swing" min="0" max="0.5" step="0.01" value="0">
            </div>
            
             <div class="control-group">
                <button id="saveBtn">Save</button>
                <button id="loadBtn">Load</button>
                <button id="exportBtn">Export WAV</button>
            </div>
        </div>

        <div class="grid" id="grid">
            <!-- Headers generated by JS -->
        </div>

        <div class="status-bar" id="status">Ready</div>
    </div>

    <script>
        // --- Audio Engine (Synthesis) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const sounds = {
            kick: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);

                osc.start(time);
                osc.stop(time + 0.5);
            },
            snare: (ctx, time) => {
                // Noise
                const bufferSize = ctx.sampleRate;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;
                const noiseGain = ctx.createGain();
                
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(ctx.destination);

                noiseGain.gain.setValueAtTime(1, time);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                noise.start(time);
                noise.stop(time + 0.2);

                // Tone
                const osc = ctx.createOscillator();
                const oscGain = ctx.createGain();
                osc.connect(oscGain);
                oscGain.connect(ctx.destination);
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(250, time);
                oscGain.gain.setValueAtTime(0.5, time);
                oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                osc.start(time);
                osc.stop(time + 0.1);
            },
            hihat: (ctx, time) => {
                const bufferSize = ctx.sampleRate;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 5000;
                const gain = ctx.createGain();

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);

                gain.gain.setValueAtTime(0.6, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                
                noise.start(time);
                noise.stop(time + 0.05);
            },
            clap: (ctx, time) => {
                const bufferSize = ctx.sampleRate;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1500;
                const gain = ctx.createGain();

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);

                // Clap envelope
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.8, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);

                noise.start(time);
                noise.stop(time + 0.2);
            }
        };

        const tracks = ['kick', 'snare', 'hihat', 'clap'];
        const steps = 16;
        let gridData = tracks.map(() => new Array(steps).fill(false));
        
        // --- UI Logic ---
        const gridEl = document.getElementById('grid');
        
        function renderGrid() {
            gridEl.innerHTML = '';
            
            // Markers
            gridEl.appendChild(document.createElement('div')); // spacer
            for(let i=0; i<steps; i++) {
                // const marker = document.createElement('div');
                // marker.className = 'marker';
                // marker.textContent = (i % 4 === 0) ? (i/4 + 1) : '';
                // gridEl.appendChild(marker);
            }

            tracks.forEach((track, rowIndex) => {
                const label = document.createElement('div');
                label.className = 'track-label';
                label.textContent = track;
                gridEl.appendChild(label);

                // Use a wrapper to apply nth-child CSS correctly
                // Actually, I can just apply a class to the row container if I used one, but here I'm using grid direct children.
                // I'll add a class to the step based on row.
                
                for (let i = 0; i < steps; i++) {
                    const step = document.createElement('div');
                    step.className = 'step';
                    step.dataset.row = rowIndex;
                    step.dataset.col = i;
                    if (gridData[rowIndex][i]) step.classList.add('active');
                    
                    step.addEventListener('click', () => {
                        gridData[rowIndex][i] = !gridData[rowIndex][i];
                        step.classList.toggle('active');
                    });
                    
                    // Add a class for styling specific rows (a bit hacky with grid layout but works if we use parent selector? No.)
                    // I will just rely on the order in the DOM for the nth-child css or add specific classes.
                    gridEl.appendChild(step);
                    
                    // Wrap in a conceptual row for CSS? No, grid layout is flat.
                    // I'll add a wrapper class to the step for row-specific coloring if needed, 
                    // but my CSS used :nth-child on track-row. I don't have track-rows.
                    // Let's fix the CSS coloring logic.
                    // I'll stick to a generic active color or inline styles if I want variety.
                    // Let's manually set color classes.
                    if (rowIndex === 1) step.style.setProperty('--step-active', '#ff0055');
                    if (rowIndex === 2) step.style.setProperty('--step-active', '#ffe600');
                    if (rowIndex === 3) step.style.setProperty('--step-active', '#00aaff');
                }
            });
        }

        renderGrid();

        // --- Sequencer Logic ---
        let isPlaying = false;
        let currentStep = 0;
        let nextNoteTime = 0;
        let timerID = null;
        let tempo = 120;
        let swing = 0;
        const lookahead = 25.0; // ms
        const scheduleAheadTime = 0.1; // s

        function nextNote() {
            const secondsPerBeat = 60.0 / tempo;
            const sixteenthNoteTime = 0.25 * secondsPerBeat;
            
            // Apply swing
            let actualTime = sixteenthNoteTime;
            if (currentStep % 2 !== 0) {
                 // Even steps (0-indexed odd numbers in sequence) are delayed by swing
                 // Wait, standard swing: 1st note long, 2nd note short?
                 // Usually visualized as delaying the off-beat.
                 // Steps 0, 2, 4 are on-beat. Steps 1, 3, 5 are off-beat.
                 // So we delay odd steps.
            }
            // Simplified scheduling: Just add time. Swing is complex with lookahead.
            // Let's just calculate the next time based on current step parity.
            
            let swingOffset = 0;
            if (currentStep % 2 === 0) {
                // On-beat. Next one is off-beat, so this duration is normal + swing
                // swingOffset = swing * sixteenthNoteTime; 
                // Actually easier: simply delay the timestamp of the off-beats.
            }

            // Logic:
            // Time for step N is T.
            // Time for step N+1 is T + 1/16th.
            // With swing:
            // Step 0 (On): T
            // Step 1 (Off): T + 1/16th + swingAmount
            // Step 2 (On): T + 2/16ths
            
            nextNoteTime += sixteenthNoteTime; // Basic increment
            
            currentStep++;
            if (currentStep === steps) currentStep = 0;
        }

        function scheduleNote(stepNumber, time) {
            // Visualize
            requestAnimationFrame(() => {
                drawPlayhead(stepNumber);
            });

            // Swing calculation for playback time
            let playTime = time;
            if (stepNumber % 2 !== 0) {
                playTime += (swing * (60.0 / tempo) * 0.25);
            }

            // Play active sounds
            tracks.forEach((track, i) => {
                if (gridData[i][stepNumber]) {
                    sounds[track](audioCtx, playTime);
                }
            });
        }

        function scheduler() {
            while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                scheduleNote(currentStep, nextNoteTime);
                nextNote();
            }
            timerID = window.setTimeout(scheduler, lookahead);
        }

        function play() {
            if (isPlaying) return;
            
            // Resume context if suspended (browser policy)
            if (audioCtx.state === 'suspended') audioCtx.resume();

            isPlaying = true;
            currentStep = 0;
            nextNoteTime = audioCtx.currentTime;
            scheduler();
            document.getElementById('playBtn').classList.add('active');
        }

        function stop() {
            isPlaying = false;
            window.clearTimeout(timerID);
            document.getElementById('playBtn').classList.remove('active');
            
            // clear playheads
            document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
        }

        function drawPlayhead(stepIndex) {
            document.querySelectorAll('.step').forEach(s => s.classList.remove('playing'));
            // Select all steps in this column
             const stepsInCol = document.querySelectorAll(`.step[data-col="${stepIndex}"]`);
             stepsInCol.forEach(s => s.classList.add('playing'));
        }

        // --- Controls ---
        document.getElementById('playBtn').addEventListener('click', play);
        document.getElementById('stopBtn').addEventListener('click', stop);
        document.getElementById('clearBtn').addEventListener('click', () => {
            gridData = tracks.map(() => new Array(steps).fill(false));
            renderGrid();
        });

        const tempoInput = document.getElementById('tempo');
        tempoInput.addEventListener('input', (e) => {
            tempo = e.target.value;
            document.getElementById('tempoVal').textContent = tempo;
        });

        const swingInput = document.getElementById('swing');
        swingInput.addEventListener('input', (e) => {
            swing = parseFloat(e.target.value);
        });

        // --- Persistence ---
        document.getElementById('saveBtn').addEventListener('click', () => {
            localStorage.setItem('sequencerPattern', JSON.stringify(gridData));
            document.getElementById('status').textContent = 'Pattern Saved';
            setTimeout(() => document.getElementById('status').textContent = 'Ready', 2000);
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            const data = localStorage.getItem('sequencerPattern');
            if (data) {
                gridData = JSON.parse(data);
                renderGrid();
                document.getElementById('status').textContent = 'Pattern Loaded';
            } else {
                document.getElementById('status').textContent = 'No saved pattern found';
            }
            setTimeout(() => document.getElementById('status').textContent = 'Ready', 2000);
        });

        // --- Export ---
        // This is complex because we need to render faster than real-time
        document.getElementById('exportBtn').addEventListener('click', async () => {
            document.getElementById('status').textContent = 'Exporting...';
            
            // 1. Calculate duration: 16 steps * seconds per step
            const secondsPerBeat = 60.0 / tempo;
            const totalDuration = steps * 0.25 * secondsPerBeat; // 1 bar (4 beats) if 16 steps
            
            // 2. Create Offline Context
            const offlineCtx = new OfflineAudioContext(1, 44100 * totalDuration, 44100);
            
            // 3. Schedule everything
            for (let i = 0; i < steps; i++) {
                let time = i * (0.25 * secondsPerBeat);
                if (i % 2 !== 0) time += (swing * (0.25 * secondsPerBeat));
                
                tracks.forEach((track, row) => {
                    if (gridData[row][i]) {
                        sounds[track](offlineCtx, time);
                    }
                });
            }
            
            // 4. Render
            const renderedBuffer = await offlineCtx.startRendering();
            
            // 5. Convert to WAV (simple implementation)
            const wavData = bufferToWave(renderedBuffer, 0, renderedBuffer.length);
            const blob = new Blob([wavData], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'beat.wav';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.getElementById('status').textContent = 'Export Complete';
             setTimeout(() => document.getElementById('status').textContent = 'Ready', 2000);
        });

        // Helper: AudioBuffer to WAV
        function bufferToWave(abuffer, offset, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample,
                pos = 0;

            // write WAVE header
            setUint32(0x46464952);                         // "RIFF"
            setUint32(length - 8);                         // file length - 8
            setUint32(0x45564157);                         // "WAVE"

            setUint32(0x20746d66);                         // "fmt " chunk
            setUint32(16);                                 // length = 16
            setUint16(1);                                  // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2);                      // block-align
            setUint16(16);                                 // 16-bit (hardcoded in this parser)

            setUint32(0x61746164);                         // "data" - chunk
            setUint32(length - pos - 4);                   // chunk length

            // write interleaved data
            for(i = 0; i < abuffer.numberOfChannels; i++)
                channels.push(abuffer.getChannelData(i));

            while(pos < length) {
                for(i = 0; i < numOfChan; i++) {             // interleave channels
                    sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int
                    view.setInt16(pos, sample, true);          // write 16-bit sample
                    pos += 2;
                }
                offset++                                     // next source sample
            }

            return buffer;

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }

            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }
        }
    </script>
</body>
</html>
