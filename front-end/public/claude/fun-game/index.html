<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fun Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 400% 400%;
            animation: gradientShift 10s ease infinite;
            overflow: hidden;
            height: 100vh;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .parallax-bg {
            position: absolute;
            width: 200%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="10" cy="10" r="2" fill="%23ffffff40"/><circle cx="30" cy="25" r="1.5" fill="%23ffffff30"/><circle cx="70" cy="15" r="1" fill="%23ffffff50"/><circle cx="90" cy="35" r="2.5" fill="%23ffffff20"/></svg>') repeat;
            animation: parallaxMove 20s linear infinite;
            z-index: 1;
        }

        @keyframes parallaxMove {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .game-area {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .player {
            position: absolute;
            bottom: 20px;
            left: 50px;
            width: 50px;
            height: 50px;
            background: #ff6b6b;
            border-radius: 50% 50% 0 0;
            border: 3px solid #fff;
            transition: bottom 0.3s ease;
            z-index: 10;
        }

        .player::before {
            content: '';
            position: absolute;
            top: 15px;
            left: 15px;
            width: 8px;
            height: 8px;
            background: #fff;
            border-radius: 50%;
        }

        .player::after {
            content: '';
            position: absolute;
            top: 15px;
            right: 15px;
            width: 8px;
            height: 8px;
            background: #fff;
            border-radius: 50%;
        }

        .player.jumping {
            bottom: 120px;
        }

        .obstacle {
            position: absolute;
            bottom: 20px;
            right: -50px;
            width: 30px;
            height: 60px;
            background: #e74c3c;
            border-radius: 5px;
            border: 2px solid #fff;
            animation: moveObstacle 3s linear infinite;
            z-index: 5;
        }

        .obstacle::before {
            content: '!';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
        }

        @keyframes moveObstacle {
            0% { right: -50px; }
            100% { right: 100vw; }
        }

        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .high-score {
            font-size: 16px;
            opacity: 0.8;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 200;
            display: none;
        }

        .game-over h2 {
            color: #e74c3c;
            margin-bottom: 20px;
            font-size: 32px;
        }

        .game-over p {
            color: #333;
            margin-bottom: 20px;
            font-size: 18px;
        }

        .retry-btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .retry-btn:hover {
            transform: scale(1.1);
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            color: #333;
            font-size: 14px;
            max-width: 200px;
        }

        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50px;
            animation: floatCloud 15s linear infinite;
        }

        .cloud1 {
            width: 80px;
            height: 40px;
            top: 10%;
            right: -80px;
            animation-duration: 20s;
        }

        .cloud2 {
            width: 60px;
            height: 30px;
            top: 25%;
            right: -60px;
            animation-duration: 25s;
            animation-delay: -5s;
        }

        @keyframes floatCloud {
            0% { right: -80px; }
            100% { right: 100vw; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="parallax-bg"></div>
        <div class="cloud cloud1"></div>
        <div class="cloud cloud2"></div>
        
        <div class="game-area">
            <div class="player" id="player"></div>
        </div>

        <div class="ui">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="high-score">High Score: <span id="highScore">0</span></div>
        </div>

        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Your Score: <span id="finalScore">0</span></p>
            <p>High Score: <span id="finalHighScore">0</span></p>
            <button class="retry-btn" onclick="restartGame()">Try Again!</button>
        </div>

        <div class="instructions">
            <strong>How to Play:</strong><br>
            Press SPACEBAR or click to jump over obstacles!<br>
            Survive as long as possible!
        </div>
    </div>

    <script>
        class FunGame {
            constructor() {
                this.player = document.getElementById('player');
                this.gameArea = document.querySelector('.game-area');
                this.scoreElement = document.getElementById('score');
                this.highScoreElement = document.getElementById('highScore');
                this.gameOverDiv = document.getElementById('gameOver');
                
                this.isGameRunning = true;
                this.isJumping = false;
                this.score = 0;
                this.highScore = localStorage.getItem('funGameHighScore') || 0;
                this.obstacleSpeed = 3000;
                this.spawnRate = 2000;
                this.lastObstacleSpawn = 0;
                
                this.obstacles = [];
                
                this.highScoreElement.textContent = this.highScore;
                
                this.bindEvents();
                this.gameLoop();
                this.spawnObstacles();
                
                this.playSound('start');
            }

            bindEvents() {
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.jump();
                    }
                });

                document.addEventListener('click', () => {
                    this.jump();
                });

                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.jump();
                });
            }

            jump() {
                if (!this.isGameRunning || this.isJumping) return;
                
                this.isJumping = true;
                this.player.classList.add('jumping');
                this.playSound('jump');
                
                setTimeout(() => {
                    this.player.classList.remove('jumping');
                    setTimeout(() => {
                        this.isJumping = false;
                    }, 100);
                }, 400);
            }

            spawnObstacle() {
                const obstacle = document.createElement('div');
                obstacle.className = 'obstacle';
                obstacle.style.animationDuration = `${this.obstacleSpeed}ms`;
                this.gameArea.appendChild(obstacle);
                this.obstacles.push(obstacle);

                setTimeout(() => {
                    if (obstacle.parentNode) {
                        obstacle.remove();
                        this.obstacles = this.obstacles.filter(obs => obs !== obstacle);
                    }
                }, this.obstacleSpeed + 100);
            }

            spawnObstacles() {
                if (!this.isGameRunning) return;
                
                this.spawnObstacle();
                
                // Increase difficulty over time
                this.obstacleSpeed = Math.max(1500, this.obstacleSpeed - 50);
                this.spawnRate = Math.max(1000, this.spawnRate - 20);
                
                setTimeout(() => this.spawnObstacles(), this.spawnRate);
            }

            checkCollisions() {
                const playerRect = this.player.getBoundingClientRect();
                
                this.obstacles.forEach(obstacle => {
                    const obstacleRect = obstacle.getBoundingClientRect();
                    
                    if (playerRect.left < obstacleRect.right &&
                        playerRect.right > obstacleRect.left &&
                        playerRect.bottom > obstacleRect.top &&
                        playerRect.top < obstacleRect.bottom) {
                        this.gameOver();
                    }
                });
            }

            updateScore() {
                this.score += 1;
                this.scoreElement.textContent = this.score;
                
                if (this.score % 100 === 0) {
                    this.playSound('milestone');
                }
            }

            gameLoop() {
                if (!this.isGameRunning) return;
                
                this.checkCollisions();
                this.updateScore();
                
                requestAnimationFrame(() => this.gameLoop());
            }

            gameOver() {
                this.isGameRunning = false;
                this.playSound('gameOver');
                
                // Clear obstacles
                this.obstacles.forEach(obstacle => {
                    if (obstacle.parentNode) obstacle.remove();
                });
                this.obstacles = [];
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('funGameHighScore', this.highScore);
                    this.playSound('newRecord');
                }
                
                // Show game over screen
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalHighScore').textContent = this.highScore;
                this.gameOverDiv.style.display = 'block';
            }

            playSound(type) {
                // Create audio context for sound effects
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                let frequency, duration, type_wave;
                
                switch(type) {
                    case 'jump':
                        frequency = 400;
                        duration = 0.2;
                        type_wave = 'sine';
                        break;
                    case 'gameOver':
                        frequency = 200;
                        duration = 0.5;
                        type_wave = 'sawtooth';
                        break;
                    case 'milestone':
                        frequency = 800;
                        duration = 0.3;
                        type_wave = 'square';
                        break;
                    case 'newRecord':
                        frequency = 600;
                        duration = 0.8;
                        type_wave = 'sine';
                        break;
                    case 'start':
                        frequency = 500;
                        duration = 0.3;
                        type_wave = 'triangle';
                        break;
                    default:
                        return;
                }
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type_wave;
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            }
        }

        let game;

        function startGame() {
            game = new FunGame();
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            
            // Clear any remaining obstacles
            document.querySelectorAll('.obstacle').forEach(obs => obs.remove());
            
            startGame();
        }

        // Start the game when page loads
        startGame();
    </script>
</body>
</html>