<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Step Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            padding: 20px;
            overflow-x: auto;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #00ffff;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff; }
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .control-group {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #88ffff;
        }
        
        input[type="range"] {
            width: 100px;
            background: transparent;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: #333;
            height: 4px;
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            background: #00ffff;
            border: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            cursor: pointer;
            -webkit-appearance: none;
            box-shadow: 0 0 10px #00ffff;
        }
        
        button {
            background: linear-gradient(45deg, #001133, #003366);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            background: linear-gradient(45deg, #003366, #006699);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        button.playing {
            background: linear-gradient(45deg, #660000, #cc0000);
            border-color: #ff4444;
            color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }
        
        .sequencer {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #00ffff;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(15px);
        }
        
        .track {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .track-label {
            width: 120px;
            font-weight: bold;
            text-align: right;
            margin-right: 20px;
            color: #88ffff;
        }
        
        .steps {
            display: flex;
            gap: 5px;
            flex: 1;
        }
        
        .step {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #003366;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .step:hover {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .step.active {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            border-color: #ffffff;
        }
        
        .step.current {
            animation: pulse 0.3s ease-in-out;
            border-color: #ffff00;
            box-shadow: 0 0 25px rgba(255, 255, 0, 0.8);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .pattern-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .bpm-display {
            font-size: 1.2em;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .export-section {
            text-align: center;
            margin-top: 20px;
        }
        
        #waveform {
            width: 100%;
            height: 100px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 10px;
            margin-top: 10px;
        }
        
        .beat-indicator {
            text-align: center;
            font-size: 2em;
            margin-bottom: 20px;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ FUTURISTIC STEP SEQUENCER üéµ</h1>
        
        <div class="beat-indicator" id="beatIndicator">1</div>
        
        <div class="controls">
            <div class="control-group">
                <label for="bpmSlider">Tempo (BPM)</label>
                <input type="range" id="bpmSlider" min="60" max="200" value="120">
                <div class="bpm-display" id="bpmDisplay">120 BPM</div>
            </div>
            
            <div class="control-group">
                <label for="swingSlider">Swing</label>
                <input type="range" id="swingSlider" min="0" max="100" value="0">
                <div class="bpm-display" id="swingDisplay">0%</div>
            </div>
            
            <div class="control-group">
                <label for="volumeSlider">Master Volume</label>
                <input type="range" id="volumeSlider" min="0" max="100" value="70">
                <div class="bpm-display" id="volumeDisplay">70%</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="playBtn">‚ñ∂ PLAY</button>
            <button id="stopBtn">‚èπ STOP</button>
            <button id="clearBtn">üóë CLEAR ALL</button>
        </div>
        
        <div class="sequencer" id="sequencer">
            <!-- Tracks will be generated here -->
        </div>
        
        <div class="pattern-controls">
            <button id="saveBtn">üíæ SAVE PATTERN</button>
            <button id="loadBtn">üìÅ LOAD PATTERN</button>
            <button id="randomBtn">üé≤ RANDOM</button>
            <button id="exportBtn">üì§ EXPORT WAV</button>
        </div>
        
        <div class="export-section">
            <canvas id="waveform"></canvas>
        </div>
    </div>

    <script>
        class StepSequencer {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.currentStep = 0;
                this.bpm = 120;
                this.swing = 0;
                this.volume = 0.7;
                this.steps = 16;
                this.intervalId = null;
                
                // Track patterns - each track has 16 steps
                this.tracks = {
                    kick: { name: 'KICK DRUM', pattern: new Array(16).fill(false), sound: null },
                    snare: { name: 'SNARE', pattern: new Array(16).fill(false), sound: null },
                    hihat: { name: 'HI-HAT', pattern: new Array(16).fill(false), sound: null },
                    openhat: { name: 'OPEN HAT', pattern: new Array(16).fill(false), sound: null },
                    crash: { name: 'CRASH', pattern: new Array(16).fill(false), sound: null },
                    ride: { name: 'RIDE', pattern: new Array(16).fill(false), sound: null }
                };
                
                this.init();
            }
            
            async init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    await this.createSounds();
                    this.setupUI();
                    this.setupEventListeners();
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                    alert('Audio initialization failed. Please ensure your browser supports Web Audio API.');
                }
            }
            
            async createSounds() {
                // Create synthetic drum sounds
                this.tracks.kick.sound = this.createKickDrum();
                this.tracks.snare.sound = this.createSnareDrum();
                this.tracks.hihat.sound = this.createHiHat();
                this.tracks.openhat.sound = this.createOpenHat();
                this.tracks.crash.sound = this.createCrash();
                this.tracks.ride.sound = this.createRide();
            }
            
            createKickDrum() {
                return (time = 0) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    osc.frequency.setValueAtTime(60, time);
                    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1000, time);
                    filter.frequency.exponentialRampToValueAtTime(1, time + 0.5);
                    
                    gain.gain.setValueAtTime(this.volume, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start(time);
                    osc.stop(time + 0.5);
                };
            }
            
            createSnareDrum() {
                return (time = 0) => {
                    const noise = this.audioContext.createBufferSource();
                    const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.2, this.audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    
                    for (let i = 0; i < output.length; i++) {
                        output[i] = (Math.random() * 2 - 1) * 0.3;
                    }
                    
                    noise.buffer = noiseBuffer;
                    
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    filter.type = 'highpass';
                    filter.frequency.setValueAtTime(1000, time);
                    
                    gain.gain.setValueAtTime(this.volume * 0.8, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    noise.start(time);
                    noise.stop(time + 0.2);
                };
            }
            
            createHiHat() {
                return (time = 0) => {
                    const noise = this.audioContext.createBufferSource();
                    const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.1, this.audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    
                    for (let i = 0; i < output.length; i++) {
                        output[i] = (Math.random() * 2 - 1) * 0.1;
                    }
                    
                    noise.buffer = noiseBuffer;
                    
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    filter.type = 'highpass';
                    filter.frequency.setValueAtTime(8000, time);
                    
                    gain.gain.setValueAtTime(this.volume * 0.5, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    noise.start(time);
                    noise.stop(time + 0.1);
                };
            }
            
            createOpenHat() {
                return (time = 0) => {
                    const noise = this.audioContext.createBufferSource();
                    const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.3, this.audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    
                    for (let i = 0; i < output.length; i++) {
                        output[i] = (Math.random() * 2 - 1) * 0.2;
                    }
                    
                    noise.buffer = noiseBuffer;
                    
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    filter.type = 'highpass';
                    filter.frequency.setValueAtTime(6000, time);
                    
                    gain.gain.setValueAtTime(this.volume * 0.6, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    noise.start(time);
                    noise.stop(time + 0.3);
                };
            }
            
            createCrash() {
                return (time = 0) => {
                    const noise = this.audioContext.createBufferSource();
                    const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 2, this.audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    
                    for (let i = 0; i < output.length; i++) {
                        output[i] = (Math.random() * 2 - 1) * 0.3;
                    }
                    
                    noise.buffer = noiseBuffer;
                    
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(3000, time);
                    
                    gain.gain.setValueAtTime(this.volume * 0.7, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 2);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    noise.start(time);
                    noise.stop(time + 2);
                };
            }
            
            createRide() {
                return (time = 0) => {
                    const osc1 = this.audioContext.createOscillator();
                    const osc2 = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    osc1.frequency.setValueAtTime(800, time);
                    osc2.frequency.setValueAtTime(1200, time);
                    
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(2000, time);
                    
                    gain.gain.setValueAtTime(this.volume * 0.4, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.8);
                    
                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc1.start(time);
                    osc2.start(time);
                    osc1.stop(time + 0.8);
                    osc2.stop(time + 0.8);
                };
            }
            
            setupUI() {
                const sequencer = document.getElementById('sequencer');
                sequencer.innerHTML = '';
                
                Object.keys(this.tracks).forEach(trackKey => {
                    const track = this.tracks[trackKey];
                    const trackElement = document.createElement('div');
                    trackElement.className = 'track';
                    
                    const label = document.createElement('div');
                    label.className = 'track-label';
                    label.textContent = track.name;
                    trackElement.appendChild(label);
                    
                    const stepsContainer = document.createElement('div');
                    stepsContainer.className = 'steps';
                    
                    for (let i = 0; i < this.steps; i++) {
                        const step = document.createElement('div');
                        step.className = 'step';
                        step.textContent = i + 1;
                        step.dataset.track = trackKey;
                        step.dataset.step = i;
                        
                        step.addEventListener('click', () => {
                            track.pattern[i] = !track.pattern[i];
                            step.classList.toggle('active', track.pattern[i]);
                        });
                        
                        stepsContainer.appendChild(step);
                    }
                    
                    trackElement.appendChild(stepsContainer);
                    sequencer.appendChild(trackElement);
                });
            }
            
            setupEventListeners() {
                const playBtn = document.getElementById('playBtn');
                const stopBtn = document.getElementById('stopBtn');
                const clearBtn = document.getElementById('clearBtn');
                const bpmSlider = document.getElementById('bpmSlider');
                const swingSlider = document.getElementById('swingSlider');
                const volumeSlider = document.getElementById('volumeSlider');
                const saveBtn = document.getElementById('saveBtn');
                const loadBtn = document.getElementById('loadBtn');
                const randomBtn = document.getElementById('randomBtn');
                const exportBtn = document.getElementById('exportBtn');
                
                playBtn.addEventListener('click', () => this.play());
                stopBtn.addEventListener('click', () => this.stop());
                clearBtn.addEventListener('click', () => this.clear());
                
                bpmSlider.addEventListener('input', (e) => {
                    this.bpm = parseInt(e.target.value);
                    document.getElementById('bpmDisplay').textContent = `${this.bpm} BPM`;
                    if (this.isPlaying) {
                        this.stop();
                        this.play();
                    }
                });
                
                swingSlider.addEventListener('input', (e) => {
                    this.swing = parseInt(e.target.value);
                    document.getElementById('swingDisplay').textContent = `${this.swing}%`;
                });
                
                volumeSlider.addEventListener('input', (e) => {
                    this.volume = parseInt(e.target.value) / 100;
                    document.getElementById('volumeDisplay').textContent = `${e.target.value}%`;
                });
                
                saveBtn.addEventListener('click', () => this.savePattern());
                loadBtn.addEventListener('click', () => this.loadPattern());
                randomBtn.addEventListener('click', () => this.randomPattern());
                exportBtn.addEventListener('click', () => this.exportWAV());
            }
            
            play() {
                if (!this.audioContext) return;
                
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                this.isPlaying = true;
                document.getElementById('playBtn').classList.add('playing');
                document.getElementById('playBtn').textContent = '‚è∏ PAUSE';
                
                const stepDuration = (60 / this.bpm / 4) * 1000; // 16th notes
                
                this.intervalId = setInterval(() => {
                    this.playStep();
                    this.updateUI();
                    this.currentStep = (this.currentStep + 1) % this.steps;
                }, stepDuration);
            }
            
            stop() {
                this.isPlaying = false;
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
                
                this.currentStep = 0;
                document.getElementById('playBtn').classList.remove('playing');
                document.getElementById('playBtn').textContent = '‚ñ∂ PLAY';
                
                // Clear current step highlighting
                document.querySelectorAll('.step.current').forEach(step => {
                    step.classList.remove('current');
                });
                
                document.getElementById('beatIndicator').textContent = '1';
            }
            
            playStep() {
                const currentTime = this.audioContext.currentTime;
                let swingDelay = 0;
                
                // Apply swing to off-beats (odd steps)
                if (this.currentStep % 2 === 1) {
                    swingDelay = (this.swing / 100) * 0.1;
                }
                
                Object.keys(this.tracks).forEach(trackKey => {
                    const track = this.tracks[trackKey];
                    if (track.pattern[this.currentStep]) {
                        setTimeout(() => {
                            track.sound(currentTime + swingDelay);
                        }, swingDelay * 1000);
                    }
                });
            }
            
            updateUI() {
                // Update current step highlighting
                document.querySelectorAll('.step.current').forEach(step => {
                    step.classList.remove('current');
                });
                
                document.querySelectorAll(`[data-step="${this.currentStep}"]`).forEach(step => {
                    step.classList.add('current');
                });
                
                // Update beat indicator
                const beat = Math.floor(this.currentStep / 4) + 1;
                document.getElementById('beatIndicator').textContent = beat;
            }
            
            clear() {
                Object.keys(this.tracks).forEach(trackKey => {
                    this.tracks[trackKey].pattern.fill(false);
                });
                
                document.querySelectorAll('.step.active').forEach(step => {
                    step.classList.remove('active');
                });
            }
            
            savePattern() {
                const patternData = {
                    tracks: this.tracks,
                    bpm: this.bpm,
                    swing: this.swing
                };
                
                const blob = new Blob([JSON.stringify(patternData)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sequencer-pattern.json';
                a.click();
                URL.revokeObjectURL(url);
            }
            
            loadPattern() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const patternData = JSON.parse(e.target.result);
                                
                                Object.keys(patternData.tracks).forEach(trackKey => {
                                    if (this.tracks[trackKey]) {
                                        this.tracks[trackKey].pattern = patternData.tracks[trackKey].pattern;
                                    }
                                });
                                
                                this.bpm = patternData.bpm || 120;
                                this.swing = patternData.swing || 0;
                                
                                // Update UI
                                document.getElementById('bpmSlider').value = this.bpm;
                                document.getElementById('swingSlider').value = this.swing;
                                document.getElementById('bpmDisplay').textContent = `${this.bpm} BPM`;
                                document.getElementById('swingDisplay').textContent = `${this.swing}%`;
                                
                                this.setupUI();
                                this.updatePatternDisplay();
                            } catch (error) {
                                alert('Error loading pattern file');
                            }
                        };
                        reader.readAsText(file);
                    }
                });
                
                input.click();
            }
            
            updatePatternDisplay() {
                Object.keys(this.tracks).forEach(trackKey => {
                    const track = this.tracks[trackKey];
                    track.pattern.forEach((active, stepIndex) => {
                        const stepElement = document.querySelector(`[data-track="${trackKey}"][data-step="${stepIndex}"]`);
                        if (stepElement) {
                            stepElement.classList.toggle('active', active);
                        }
                    });
                });
            }
            
            randomPattern() {
                Object.keys(this.tracks).forEach(trackKey => {
                    const track = this.tracks[trackKey];
                    for (let i = 0; i < this.steps; i++) {
                        track.pattern[i] = Math.random() > 0.7; // 30% chance for each step
                    }
                });
                
                this.updatePatternDisplay();
            }
            
            exportWAV() {
                // This is a simplified WAV export - creates a short buffer with the pattern
                const sampleRate = this.audioContext.sampleRate;
                const patternDuration = (60 / this.bpm) * 4; // 4 beats
                const bufferLength = sampleRate * patternDuration;
                const buffer = this.audioContext.createBuffer(1, bufferLength, sampleRate);
                const data = buffer.getChannelData(0);
                
                // This would need more complex implementation for real WAV export
                alert('WAV export feature would require additional audio processing libraries. Pattern saved as JSON instead.');
                this.savePattern();
            }
        }
        
        // Initialize the sequencer when the page loads
        window.addEventListener('load', () => {
            const sequencer = new StepSequencer();
        });
        
        // Handle audio context suspension (Chrome autoplay policy)
        document.addEventListener('click', async () => {
            if (window.sequencer && window.sequencer.audioContext && window.sequencer.audioContext.state === 'suspended') {
                await window.sequencer.audioContext.resume();
            }
        }, { once: true });
    </script>
</body>
</html>