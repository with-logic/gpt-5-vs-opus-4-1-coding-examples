<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Step Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
            color: #00ff88;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            width: 100%;
        }
        h1 {
            text-align: center;
            font-size: 2.5rem;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            margin-bottom: 30px;
            letter-spacing: 4px;
        }
        .controls {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        .control-row {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
        }
        input[type="range"] {
            width: 150px;
            accent-color: #00ff88;
        }
        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: #0a0a0a;
            border: 2px solid #00ff88;
            border-radius: 5px;
            color: #00ff88;
            font-family: 'Courier New', monospace;
        }
        button {
            background: #00ff88;
            color: #0a0a0a;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }
        button:hover {
            background: #00cc6d;
            box-shadow: 0 0 15px #00ff88;
        }
        button.active {
            background: #ff0055;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 15px #ff0055; }
            50% { box-shadow: 0 0 30px #ff0055; }
        }
        .sequencer {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        .track {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .track-label {
            width: 100px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
        }
        .steps {
            display: flex;
            gap: 5px;
            flex: 1;
        }
        .step {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .step:hover {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 10px #00ff88;
        }
        .step.active {
            background: #00ff88;
            box-shadow: 0 0 15px #00ff88;
        }
        .step.playing {
            border-color: #ff0055;
            box-shadow: 0 0 20px #ff0055;
        }
        .step.quarter {
            border-color: #ffaa00;
        }
        .pattern-manager {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .value-display {
            display: inline-block;
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #ffaa00;
        }
        @media (max-width: 768px) {
            .step {
                width: 30px;
                height: 30px;
            }
            .track-label {
                width: 80px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>â—ˆ AUDIO SEQUENCER â—ˆ</h1>

        <div class="controls">
            <div class="control-row">
                <button id="playBtn" onclick="togglePlay()">â–¶ PLAY</button>
                <button onclick="clearAll()">âŒ« CLEAR</button>

                <div class="control-group">
                    <label for="tempo">BPM:</label>
                    <input type="range" id="tempo" min="60" max="200" value="120" oninput="updateTempo()">
                    <span class="value-display" id="tempoValue">120</span>
                </div>

                <div class="control-group">
                    <label for="swing">SWING:</label>
                    <input type="range" id="swing" min="0" max="100" value="0" oninput="updateSwing()">
                    <span class="value-display" id="swingValue">0%</span>
                </div>
            </div>

            <div class="control-row pattern-manager">
                <button onclick="savePattern()">ðŸ’¾ SAVE</button>
                <button onclick="loadPattern()">ðŸ“‚ LOAD</button>
                <button onclick="exportWAV()">â¬‡ EXPORT WAV</button>
                <button onclick="randomize()">ðŸŽ² RANDOM</button>
            </div>
        </div>

        <div class="sequencer">
            <div id="tracks"></div>
        </div>
    </div>

    <script>
        // Audio Context Setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Drum sounds configuration
        const drums = [
            { name: 'Kick', freq: 60, type: 'sine', decay: 0.5 },
            { name: 'Snare', freq: 200, type: 'triangle', decay: 0.2 },
            { name: 'Hi-Hat', freq: 800, type: 'square', decay: 0.1 },
            { name: 'Clap', freq: 1000, type: 'sawtooth', decay: 0.15 }
        ];

        // Sequencer state
        let tempo = 120;
        let swing = 0;
        let isPlaying = false;
        let currentStep = 0;
        let intervalId = null;
        let pattern = drums.map(() => Array(16).fill(false));

        // Initialize sequencer UI
        function init() {
            const tracksContainer = document.getElementById('tracks');

            drums.forEach((drum, trackIndex) => {
                const track = document.createElement('div');
                track.className = 'track';

                const label = document.createElement('div');
                label.className = 'track-label';
                label.textContent = drum.name;
                track.appendChild(label);

                const steps = document.createElement('div');
                steps.className = 'steps';

                for (let i = 0; i < 16; i++) {
                    const step = document.createElement('div');
                    step.className = 'step';
                    if (i % 4 === 0) step.classList.add('quarter');
                    step.dataset.track = trackIndex;
                    step.dataset.step = i;
                    step.onclick = () => toggleStep(trackIndex, i);
                    steps.appendChild(step);
                }

                track.appendChild(steps);
                tracksContainer.appendChild(track);
            });
        }

        // Toggle step
        function toggleStep(track, step) {
            pattern[track][step] = !pattern[track][step];
            updateUI();
        }

        // Update UI
        function updateUI() {
            const allSteps = document.querySelectorAll('.step');
            allSteps.forEach(step => {
                const track = parseInt(step.dataset.track);
                const stepNum = parseInt(step.dataset.step);

                if (pattern[track][stepNum]) {
                    step.classList.add('active');
                } else {
                    step.classList.remove('active');
                }

                if (stepNum === currentStep && isPlaying) {
                    step.classList.add('playing');
                } else {
                    step.classList.remove('playing');
                }
            });
        }

        // Play/Stop
        function togglePlay() {
            isPlaying = !isPlaying;
            const btn = document.getElementById('playBtn');

            if (isPlaying) {
                btn.textContent = 'â¸ PAUSE';
                btn.classList.add('active');
                startSequencer();
            } else {
                btn.textContent = 'â–¶ PLAY';
                btn.classList.remove('active');
                stopSequencer();
            }
        }

        // Start sequencer
        function startSequencer() {
            const stepTime = (60 / tempo / 4) * 1000; // 16th notes
            currentStep = 0;

            intervalId = setInterval(() => {
                playStep(currentStep);
                currentStep = (currentStep + 1) % 16;
                updateUI();
            }, stepTime);
        }

        // Stop sequencer
        function stopSequencer() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            currentStep = 0;
            updateUI();
        }

        // Play step
        function playStep(step) {
            pattern.forEach((track, trackIndex) => {
                if (track[step]) {
                    playDrumSound(drums[trackIndex]);
                }
            });
        }

        // Play drum sound using Web Audio API
        function playDrumSound(drum) {
            const now = audioContext.currentTime;

            // Oscillator for tone
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.type = drum.type;
            osc.frequency.setValueAtTime(drum.freq, now);

            // Pitch envelope for kick
            if (drum.name === 'Kick') {
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            }

            // Amplitude envelope
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + drum.decay);

            // Noise for snare/hi-hat
            if (drum.name === 'Snare' || drum.name === 'Hi-Hat' || drum.name === 'Clap') {
                const noise = createNoiseBuffer();
                const noiseSource = audioContext.createBufferSource();
                const noiseGain = audioContext.createGain();
                const noiseFilter = audioContext.createBiquadFilter();

                noiseSource.buffer = noise;
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = drum.name === 'Hi-Hat' ? 5000 : 1000;

                noiseGain.gain.setValueAtTime(0.2, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + drum.decay);

                noiseSource.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                noiseSource.start(now);
                noiseSource.stop(now + drum.decay);
            }

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.start(now);
            osc.stop(now + drum.decay);
        }

        // Create noise buffer
        function createNoiseBuffer() {
            const bufferSize = audioContext.sampleRate * 0.2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            return buffer;
        }

        // Clear all
        function clearAll() {
            pattern = drums.map(() => Array(16).fill(false));
            updateUI();
        }

        // Randomize
        function randomize() {
            pattern = drums.map(() => Array(16).fill(false).map(() => Math.random() > 0.7));
            updateUI();
        }

        // Update tempo
        function updateTempo() {
            tempo = parseInt(document.getElementById('tempo').value);
            document.getElementById('tempoValue').textContent = tempo;

            if (isPlaying) {
                stopSequencer();
                isPlaying = true;
                startSequencer();
            }
        }

        // Update swing
        function updateSwing() {
            swing = parseInt(document.getElementById('swing').value);
            document.getElementById('swingValue').textContent = swing + '%';
        }

        // Save pattern
        function savePattern() {
            const data = JSON.stringify({ pattern, tempo, swing });
            localStorage.setItem('sequencerPattern', data);
            alert('Pattern saved!');
        }

        // Load pattern
        function loadPattern() {
            const data = localStorage.getItem('sequencerPattern');
            if (data) {
                const loaded = JSON.parse(data);
                pattern = loaded.pattern;
                tempo = loaded.tempo;
                swing = loaded.swing;

                document.getElementById('tempo').value = tempo;
                document.getElementById('swing').value = swing;
                updateTempo();
                updateSwing();
                updateUI();
                alert('Pattern loaded!');
            } else {
                alert('No saved pattern found!');
            }
        }

        // Export to WAV (simplified version - renders pattern once)
        function exportWAV() {
            if (isPlaying) {
                togglePlay();
            }

            alert('Rendering pattern to WAV...');

            // Create offline context for rendering
            const duration = (60 / tempo) * 4; // 1 bar
            const offlineContext = new OfflineAudioContext(2, audioContext.sampleRate * duration, audioContext.sampleRate);
            const stepTime = duration / 16;

            // Schedule all sounds
            pattern.forEach((track, trackIndex) => {
                track.forEach((active, step) => {
                    if (active) {
                        const startTime = step * stepTime;
                        const drum = drums[trackIndex];

                        const osc = offlineContext.createOscillator();
                        const gain = offlineContext.createGain();

                        osc.type = drum.type;
                        osc.frequency.setValueAtTime(drum.freq, startTime);

                        if (drum.name === 'Kick') {
                            osc.frequency.exponentialRampToValueAtTime(40, startTime + 0.1);
                        }

                        gain.gain.setValueAtTime(0.3, startTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, startTime + drum.decay);

                        osc.connect(gain);
                        gain.connect(offlineContext.destination);

                        osc.start(startTime);
                        osc.stop(startTime + drum.decay);
                    }
                });
            });

            // Render and download
            offlineContext.startRendering().then(buffer => {
                const wav = encodeWAV(buffer);
                const blob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'sequence.wav';
                a.click();

                alert('WAV exported successfully!');
            });
        }

        // Encode WAV file
        function encodeWAV(buffer) {
            const length = buffer.length * buffer.numberOfChannels * 2;
            const arrayBuffer = new ArrayBuffer(44 + length);
            const view = new DataView(arrayBuffer);
            const channels = [];
            let offset = 0;

            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + length, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, buffer.numberOfChannels, true);
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * buffer.numberOfChannels * 2, true);
            view.setUint16(32, buffer.numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, length, true);

            // Write audio data
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, channels[channel][i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return arrayBuffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Initialize
        init();
        updateUI();
    </script>
</body>
</html>